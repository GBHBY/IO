Wed Feb 17 00:26:40 CST 2021
1: 1:[TOC]
2: 2:
3: 3:<!-- Generics -->
4: 4:
5: 5:# 第二十章 泛型
6: 6:
7: 7:> 普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。
8: 8:
9: 9:多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。除了 `final` 类（或只提供私有构造函数的类）任何类型都可被扩展，所以大部分时候这种灵活性是自带的。
10: 10:
11: 11:拘泥于单一的继承体系太过局限，因为只有继承体系中的对象才能适用基类作为参数的方法中。如果方法以接口而不是类作为参数，限制就宽松多了，只要实现了接口就可以。这给予调用方一种选项，通过调整现有的类来实现接口，满足方法参数要求。接口可以突破继承体系的限制。
12: 12:
13: 13:即便是接口也还是有诸多限制。一旦指定了接口，它就要求你的代码必须使用特定的接口。而我们希望编写更通用的代码，能够适用“非特定的类型”，而不是一个具体的接口或类。
14: 14:
15: 15:这就是泛型的概念，是 Java 5 的重大变化之一。泛型实现了*参数化类型*，这样你编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。随后你会发现 Java 中泛型的实现并没有那么“泛”，你可能会质疑“泛型”这个词是否合适用来描述这一功能。
16: 16:
17: 17:如果你从未接触过参数化类型机制，你会发现泛型对 Java 语言确实是个很有益的补充。在你实例化一个类型参数时，编译器会负责转型并确保类型的正确性。这是一大进步。
18: 18:
19: 19:然而，如果你了解其他语言（例如 C++ ）的参数化机制，你会发现，Java 泛型并不能满足所有的预期。使用别人创建好的泛型相对容易，但是创建自己的泛型时，就会遇到很多意料之外的麻烦。
20: 20:
21: 21:这并不是说 Java 泛型毫无用处。在很多情况下，它可以使代码更直接更优雅。不过，如果你见识过那种实现了更纯粹的泛型的编程语言，那么，Java 可能会令你失望。本章会介绍 Java 泛型的优点与局限。我会解释 Java 的泛型是如何发展成现在这样的，希望能够帮助你更有效地使用这个特性。[^1]
22: 22:
23: 23:### 与 C++ 的比较
24: 24:
25: 25:Java 的设计者曾说过，这门语言的灵感主要来自 C++ 。尽管如此，学习 Java 时基本不用参考 C++ 。
26: 26:
27: 27:但是，Java 中的泛型需要与 C++ 进行对比，理由有两个：首先，理解 C++ *模板*（泛型的主要灵感来源，包括基本语法）的某些特性，有助于理解泛型的基础理念。同时，非常重要的一点是，你可以了解 Java 泛型的局限是什么，以及为什么会有这些局限。最终的目标是明确 Java 泛型的边界，让你成为一个程序高手。只有知道了某个技术不能做什么，你才能更好地做到所能做的（部分原因是，不必浪费时间在死胡同里）。
28: 28:
29: 29:第二个原因是，在 Java 社区中，大家普遍对 C++ 模板有一种误解，而这种误解可能会令你在理解泛型的意图时产生偏差。
30: 30:
31: 31:因此，本章中会介绍少量 C++ 模板的例子，仅当它们确实可以加深理解时才会引入。
32: 32:
33: 33:<!-- Simple Generics -->
34: 34:
35: 35:## 简单泛型
36: 36:
37: 37:促成泛型出现的最主要的动机之一是为了创建*集合类*，参见 [集合](book/12-Collections.md) 章节。集合用于存放要使用到的对象。数组也是如此，不过集合比数组更加灵活，功能更丰富。几乎所有程序在运行过程中都会涉及到一组对象，因此集合是可复用性最高的类库之一。
38: 38:
39: 39:我们先看一个只能持有单个对象的类。这个类可以明确指定其持有的对象的类型：
40: 40:
41: 41:```java
42: 42:// generics/Holder1.java
43: 43:
44: 44:class Automobile {}
45: 45:
46: 46:public class Holder1 {
47: 47:    private Automobile a;
48: 48:    public Holder1(Automobile a) { this.a = a; }
49: 49:    Automobile get() { return a; }
50: 50:}
51: 51:```
52: 52:
53: 53:这个类的可复用性不高，它无法持有其他类型的对象。我们可不希望为碰到的每个类型都编写一个新的类。
54: 54:
55: 55:在 Java 5 之前，我们可以让这个类直接持有 `Object` 类型的对象：
56: 56:
57: 57:```java
58: 58:// generics/ObjectHolder.java
59: 59:
60: 60:public class ObjectHolder {
61: 61:    private Object a;
62: 62:    public ObjectHolder(Object a) { this.a = a; }
63: 63:    public void set(Object a) { this.a = a; }
64: 64:    public Object get() { return a; }
65: 65:    
66: 66:    public static void main(String[] args) {
67: 67:        ObjectHolder h2 = new ObjectHolder(new Automobile());
68: 68:        Automobile a = (Automobile)h2.get();
69: 69:        h2.set("Not an Automobile");
70: 70:        String s = (String)h2.get();
71: 71:        h2.set(1); // 自动装箱为 Integer
72: 72:        Integer x = (Integer)h2.get();
73: 73:    }
74: 74:}
75: 75:```
76: 76:
77: 77:现在，`ObjectHolder` 可以持有任何类型的对象，在上面的示例中，一个 `ObjectHolder` 先后持有了三种不同类型的对象。
78: 78:
79: 79:一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。
80: 80:
81: 81:因此，与其使用 `Object` ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用*类型参数*，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，`T` 就是类型参数：
82: 82:
83: 83:```java
84: 84:// generics/GenericHolder.java
85: 85:
86: 86:public class GenericHolder<T> {
87: 87:    private T a;
88: 88:    public GenericHolder() {}
89: 89:    public void set(T a) { this.a = a; }
90: 90:    public T get() { return a; }
91: 91:    
92: 92:    public static void main(String[] args) {
93: 93:        GenericHolder<Automobile> h3 = new GenericHolder<Automobile>();
94: 94:        h3.set(new Automobile()); // 此处有类型校验
95: 95:        Automobile a = h3.get();  // 无需类型转换
96: 96:        //- h3.set("Not an Automobile"); // 报错
97: 97:        //- h3.set(1);  // 报错
98: 98:    }
99: 99:}
100: 100:```
101: 101:
102: 102:创建 `GenericHolder` 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 `main()` 中那样使用。然后，你就只能在 `GenericHolder` 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当你调用 `get()` 取值时，直接就是正确的类型。
103: 103:
104: 104:这就是 Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。
105: 105:
106: 106:你可能注意到 `h3` 的定义非常繁复。在 `=` 左边有 `GenericHolder<Automobile>`, 右边又重复了一次。在 Java 5 中，这种写法被解释成“必要的”，但在 Java 7 中设计者修正了这个问题（新的简写语法随后成为备受欢迎的特性）。以下是简写的例子：
107: 107:
108: 108:```java
109: 109:// generics/Diamond.java
110: 110:
111: 111:class Bob {}
112: 112:
113: 113:public class Diamond<T> {
114: 114:    public static void main(String[] args) {
115: 115:        GenericHolder<Bob> h3 = new GenericHolder<>();
116: 116:        h3.set(new Bob());
117: 117:    }
118: 118:}
119: 119:```
120: 120:
121: 121:注意，在 `h3` 的定义处，`=` 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。在本书剩余部分都会使用这种语法。
122: 122:
123: 123:一般来说，你可以认为泛型和其他类型差不多，只不过它们碰巧有类型参数罢了。在使用泛型时，你只需要指定它们的名称和类型参数列表即可。
124: 124:
125: 125:### 一个元组类库
126: 126:
127: 127:有时一个方法需要能返回多个对象。而 **return** 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得了编译时的类型安全。
128: 128:
129: 129:这个概念称为*元组*，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 *数据传输对象* 或 *信使* ）。
130: 130:
131: 131:通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组：
132: 132:
133: 133:```java
134: 134:// onjava/Tuple2.java
135: 135:package onjava;
136: 136:
137: 137:public class Tuple2<A, B> {
138: 138:    public final A a1;
139: 139:    public final B a2;
140: 140:    public Tuple2(A a, B b) { a1 = a; a2 = b; }
141: 141:    public String rep() { return a1 + ", " + a2; }
142: 142:  
143: 143:    @Override
144: 144:    public String toString() {
145: 145:        return "(" + rep() + ")";
146: 146:    }
147: 147:}
148: 148:```
149: 149:
150: 150:构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。
151: 151:
152: 152:初次阅读上面的代码时，你可能认为这违反了 Java 编程的封装原则。`a1` 和 `a2` 应该声明为 **private**，然后提供 `getFirst()` 和 `getSecond()` 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取 `a1` 和 `a2` 然后对它们执行任何操作，但无法对 `a1` 和 `a2` 重新赋值。例子中的 `final` 可以实现同样的效果，并且更为简洁明了。
153: 153:
154: 154:另一种设计思路是允许元组的用户给 `a1` 和 `a2` 重新赋值。然而，采用上例中的形式无疑更加安全，如果用户想存储不同的元素，就会强制他们创建新的 `Tuple2` 对象。
155: 155:
156: 156:我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了：
157: 157:
158: 158:```java
159: 159:// onjava/Tuple3.java
160: 160:package onjava;
161: 161:
162: 162:public class Tuple3<A, B, C> extends Tuple2<A, B> {
163: 163:    public final C a3;
164: 164:    public Tuple3(A a, B b, C c) {
165: 165:        super(a, b);
166: 166:        a3 = c;
167: 167:    }
168: 168:    
169: 169:    @Override
170: 170:    public String rep() {
171: 171:        return super.rep() + ", " + a3;
172: 172:    }
173: 173:}
174: 174:
175: 175:// onjava/Tuple4.java
176: 176:package onjava;
177: 177:
178: 178:public class Tuple4<A, B, C, D>
179: 179:  extends Tuple3<A, B, C> {
180: 180:    public final D a4;
181: 181:    public Tuple4(A a, B b, C c, D d) {
182: 182:        super(a, b, c);
183: 183:        a4 = d;
184: 184:    }
185: 185:    
186: 186:    @Override
187: 187:    public String rep() {
188: 188:        return super.rep() + ", " + a4;
189: 189:    }
190: 190:}
191: 191:
192: 192:// onjava/Tuple5.java
193: 193:package onjava;
194: 194:
195: 195:public class Tuple5<A, B, C, D, E>
196: 196:  extends Tuple4<A, B, C, D> {
197: 197:    public final E a5;
198: 198:    public Tuple5(A a, B b, C c, D d, E e) {
199: 199:        super(a, b, c, d);
200: 200:        a5 = e;
201: 201:    }
202: 202:    
203: 203:    @Override
204: 204:    public String rep() {
205: 205:        return super.rep() + ", " + a5;
206: 206:    }
207: 207:}
208: 208:```
209: 209:
210: 210:演示需要，再定义两个类：
211: 211:
212: 212:```java
213: 213:// generics/Amphibian.java
214: 214:public class Amphibian {}
215: 215:
216: 216:// generics/Vehicle.java
217: 217:public class Vehicle {}
218: 218:```
219: 219:
220: 220:使用元组时，你只需要定义一个长度适合的元组，将其作为返回值即可。注意下面例子中方法的返回类型：
221: 221:
222: 222:```java
223: 223:// generics/TupleTest.java
224: 224:import onjava.*;
225: 225:
226: 226:public class TupleTest {
227: 227:    static Tuple2<String, Integer> f() {
228: 228:        // 47 自动装箱为 Integer
229: 229:        return new Tuple2<>("hi", 47);
230: 230:    }
231: 231:  
232: 232:    static Tuple3<Amphibian, String, Integer> g() {
233: 233:        return new Tuple3<>(new Amphibian(), "hi", 47);
234: 234:    }
235: 235:  
236: 236:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
237: 237:        return new Tuple4<>(new Vehicle(), new Amphibian(), "hi", 47);
238: 238:    }
239: 239:  
240: 240:    static Tuple5<Vehicle, Amphibian, String, Integer, Double> k() {
241: 241:        return new Tuple5<>(new Vehicle(), new Amphibian(), "hi", 47, 11.1);
242: 242:    }
243: 243:  
244: 244:    public static void main(String[] args) {
245: 245:        Tuple2<String, Integer> ttsi = f();
246: 246:        System.out.println(ttsi);
247: 247:        // ttsi.a1 = "there"; // 编译错误，因为 final 不能重新赋值
248: 248:        System.out.println(g());
249: 249:        System.out.println(h());
250: 250:        System.out.println(k());
251: 251:    }
252: 252:}
253: 253:
254: 254:/* 输出：
255: 255: (hi, 47)
256: 256: (Amphibian@1540e19d, hi, 47)
257: 257: (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47)
258: 258: (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1)
259: 259: */
260: 260:```
261: 261:
262: 262:有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。
263: 263:
264: 264:通过 `ttsi.a1 = "there"` 语句的报错，我们可以看出，**final** 声明确实可以确保 **public** 字段在对象被构造出来之后就不能重新赋值了。
265: 265:
266: 266:在上面的程序中，`new` 表达式有些啰嗦。本章稍后会介绍，如何利用 *泛型方法* 简化它们。
267: 267:
268: 268:### 一个堆栈类
269: 269:
270: 270:接下来我们看一个稍微复杂一点的例子：堆栈。在 [集合](book/12-Collections.md) 一章中，我们用 `LinkedList` 实现了 `onjava.Stack` 类。在那个例子中，`LinkedList` 本身已经具备了创建堆栈所需的方法。`Stack` 是通过两个泛型类 `Stack<T>` 和 `LinkedList<T>` 的组合来创建。我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。
271: 271:
272: 272:这次我们不用 `LinkedList` 来实现自己的内部链式存储机制。
273: 273:
274: 274:```java
275: 275:// generics/LinkedStack.java
276: 276:// 用链式结构实现的堆栈
277: 277:
278: 278:public class LinkedStack<T> {
279: 279:    private static class Node<U> {
280: 280:        U item;
281: 281:        Node<U> next;
282: 282:    
283: 283:        Node() { item = null; next = null; }
284: 284:        
285: 285:        Node(U item, Node<U> next) {
286: 286:            this.item = item;
287: 287:            this.next = next;
288: 288:        }
289: 289:    
290: 290:        boolean end() {
291: 291:            return item == null && next == null;
292: 292:        }
293: 293:    }
294: 294:  
295: 295:    private Node<T> top = new Node<>();  // 栈顶
296: 296:  
297: 297:    public void push(T item) {
298: 298:        top = new Node<>(item, top);
299: 299:    }
300: 300:  
301: 301:    public T pop() {
302: 302:        T result = top.item;
303: 303:        if (!top.end()) {
304: 304:            top = top.next;
305: 305:        }
306: 306:        return result;
307: 307:    }
308: 308:  
309: 309:    public static void main(String[] args) {
310: 310:        LinkedStack<String> lss = new LinkedStack<>();
311: 311:        for (String s : "Phasers on stun!".split(" ")) {
312: 312:            lss.push(s);
313: 313:        }
314: 314:        String s;
315: 315:        while ((s = lss.pop()) != null) {
316: 316:            System.out.println(s);
317: 317:        }
318: 318:    }
319: 319:}
320: 320:```
321: 321:
322: 322:输出结果：
323: 323:
324: 324:```java
325: 325:stun!
326: 326:on
327: 327:Phasers
328: 328:```
329: 329:
330: 330:内部类 `Node` 也是一个泛型，它拥有自己的类型参数。
331: 331:
332: 332:这个例子使用了一个 *末端标识* (end sentinel) 来判断栈何时为空。这个末端标识是在构造 `LinkedStack` 时创建的。然后，每次调用 `push()` 就会创建一个 `Node<T>` 对象，并将其链接到前一个 `Node<T>` 对象。当你调用 `pop()` 方法时，总是返回 `top.item`，然后丢弃当前 `top` 所指向的 `Node<T>`，并将 `top` 指向下一个 `Node<T>`，除非到达末端标识，这时就不能再移动 `top` 了。如果已经到达末端，程序还继续调用 `pop()` 方法，它只能得到 `null`，说明栈已经空了。
333: 333:
334: 334:### RandomList
335: 335:
336: 336:作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 `select()` 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型：
337: 337:
338: 338:```java
339: 339:// generics/RandomList.java
340: 340:import java.util.*;
341: 341:import java.util.stream.*;
342: 342:
343: 343:public class RandomList<T> extends ArrayList<T> {
344: 344:    private Random rand = new Random(47);
345: 345:  
346: 346:    public T select() {
347: 347:        return get(rand.nextInt(size()));
348: 348:    }
349: 349:  
350: 350:    public static void main(String[] args) {
351: 351:        RandomList<String> rs = new RandomList<>();
352: 352:        Arrays.stream("The quick brown fox jumped over the lazy brown dog".split(" ")).forEach(rs::add);
353: 353:        IntStream.range(0, 11).forEach(i -> 
354: 354:            System.out.print(rs.select() + " "));
355: 355:    }
356: 356:}
357: 357:```
358: 358:
359: 359:输出结果：
360: 360:
361: 361:```java
362: 362:brown over fox quick quick dog brown The brown lazy brown
363: 363:```
364: 364:
365: 365:`RandomList` 继承了 `ArrayList` 的所有方法。本例中只添加了 `select()` 这个方法。
366: 366:
367: 367:<!-- Generic Interfaces -->
368: 368:
369: 369:## 泛型接口
370: 370:
371: 371:泛型也可以应用于接口。例如 *生成器*，这是一种专门负责创建对象的类。实际上，这是 *工厂方法* 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。
372: 372:
373: 373:一般而言，一个生成器只定义一个方法，用于创建对象。例如 `java.util.function` 类库中的 `Supplier` 就是一个生成器，调用其 `get()` 获取对象。`get()` 是泛型方法，返回值为类型参数 `T`。
374: 374:
375: 375:为了演示 `Supplier`，我们需要定义几个类。下面是个咖啡相关的继承体系：
376: 376:
377: 377:```java
378: 378:// generics/coffee/Coffee.java
379: 379:package generics.coffee;
380: 380:
381: 381:public class Coffee {
382: 382:    private static long counter = 0;
383: 383:    private final long id = counter++;
384: 384:  
385: 385:    @Override
386: 386:    public String toString() {
387: 387:        return getClass().getSimpleName() + " " + id;
388: 388:    }
389: 389:}
390: 390:
391: 391:
392: 392:// generics/coffee/Latte.java
393: 393:package generics.coffee;
394: 394:public class Latte extends Coffee {}
395: 395:
396: 396:
397: 397:// generics/coffee/Mocha.java
398: 398:package generics.coffee;
399: 399:public class Mocha extends Coffee {}
400: 400:
401: 401:
402: 402:// generics/coffee/Cappuccino.java
403: 403:package generics.coffee;
404: 404:public class Cappuccino extends Coffee {}
405: 405:
406: 406:
407: 407:// generics/coffee/Americano.java
408: 408:package generics.coffee;
409: 409:public class Americano extends Coffee {}
410: 410:
411: 411:
412: 412:// generics/coffee/Breve.java
413: 413:package generics.coffee;
414: 414:public class Breve extends Coffee {}
415: 415:```
416: 416:
417: 417:现在，我们可以编写一个类，实现 `Supplier<Coffee>` 接口，它能够随机生成不同类型的 `Coffee` 对象：
418: 418:
419: 419:```java
420: 420:// generics/coffee/CoffeeSupplier.java
421: 421:// {java generics.coffee.CoffeeSupplier}
422: 422:package generics.coffee;
423: 423:import java.util.*;
424: 424:import java.util.function.*;
425: 425:import java.util.stream.*;
426: 426:
427: 427:public class CoffeeSupplier
428: 428:implements Supplier<Coffee>, Iterable<Coffee> {
429: 429:    private Class<?>[] types = { Latte.class, Mocha.class, 
430: 430:        Cappuccino.class, Americano.class, Breve.class };
431: 431:    private static Random rand = new Random(47);
432: 432:  
433: 433:    public CoffeeSupplier() {}
434: 434:    // For iteration:
435: 435:    private int size = 0;
436: 436:    public CoffeeSupplier(int sz) { size = sz; }
437: 437:  
438: 438:    @Override
439: 439:    public Coffee get() {
440: 440:        try {
441: 441:            return (Coffee) types[rand.nextInt(types.length)].newInstance();
442: 442:        } catch (InstantiationException | IllegalAccessException e) {
443: 443:            throw new RuntimeException(e);
444: 444:        }
445: 445:    }
446: 446:  
447: 447:    class CoffeeIterator implements Iterator<Coffee> {
448: 448:        int count = size;
449: 449:        @Override
450: 450:        public boolean hasNext() { return count > 0; }
451: 451:        @Override
452: 452:        public Coffee next() {
453: 453:            count--;
454: 454:            return CoffeeSupplier.this.get();
455: 455:        }
456: 456:        @Override
457: 457:        public void remove() {
458: 458:            throw new UnsupportedOperationException();
459: 459:        }
460: 460:    }
461: 461:  
462: 462:    @Override
463: 463:    public Iterator<Coffee> iterator() {
464: 464:        return new CoffeeIterator();
465: 465:    }
466: 466:  
467: 467:    public static void main(String[] args) {
468: 468:        Stream.generate(new CoffeeSupplier())
469: 469:              .limit(5)
470: 470:              .forEach(System.out::println);
471: 471:        for (Coffee c : new CoffeeSupplier(5)) {
472: 472:            System.out.println(c);
473: 473:        }
474: 474:    }
475: 475:}
476: 476:```
477: 477:
478: 478:输出结果：
479: 479:
480: 480:```java
481: 481:Americano 0
482: 482:Latte 1
483: 483:Americano 2
484: 484:Mocha 3
485: 485:Mocha 4
486: 486:Breve 5
487: 487:Americano 6
488: 488:Latte 7
489: 489:Cappuccino 8
490: 490:Cappuccino 9
491: 491:```
492: 492:
493: 493:参数化的 `Supplier` 接口确保 `get()` 返回值是参数的类型。`CoffeeSupplier` 同时还实现了 `Iterable` 接口，所以能用于 *for-in* 语句。不过，它还需要知道何时终止循环，这正是第二个构造函数的作用。
494: 494:
495: 495:下面是另一个实现 `Supplier<T>` 接口的例子，它负责生成 Fibonacci 数列：
496: 496:
497: 497:```java
498: 498:// generics/Fibonacci.java
499: 499:// Generate a Fibonacci sequence
500: 500:import java.util.function.*;
501: 501:import java.util.stream.*;
502: 502:
503: 503:public class Fibonacci implements Supplier<Integer> {
504: 504:    private int count = 0;
505: 505:    @Override
506: 506:    public Integer get() { return fib(count++); }
507: 507:  
508: 508:    private int fib(int n) {
509: 509:        if(n < 2) return 1;
510: 510:        return fib(n-2) + fib(n-1);
511: 511:    }
512: 512:  
513: 513:    public static void main(String[] args) {
514: 514:        Stream.generate(new Fibonacci())
515: 515:              .limit(18)
516: 516:              .map(n -> n + " ")
517: 517:              .forEach(System.out::print);
518: 518:    }
519: 519:}
520: 520:```
521: 521:
522: 522:输出结果：
523: 523:
524: 524:```java
525: 525:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
526: 526:```
527: 527:
528: 528:虽然我们在 `Fibonacci` 类的里里外外使用的都是 `int` 类型，但是其参数类型却是 `Integer`。这个例子引出了 Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备自动装箱和拆箱的功能，可以很方便地在基本类型和相应的包装类之间进行转换。通过这个例子中 `Fibonacci` 类对 `int` 的使用，我们已经看到了这种效果。
529: 529:
530: 530:如果还想更进一步，编写一个实现了 `Iterable` 的 `Fibnoacci` 生成器。我们的一个选择是重写这个类，令其实现 `Iterable` 接口。不过，你并不是总能拥有源代码的控制权，并且，除非必须这么做，否则，我们也不愿意重写一个类。而且我们还有另一种选择，就是创建一个 *适配器* (Adapter) 来实现所需的接口，我们在前面介绍过这个设计模式。
531: 531:
532: 532:有多种方法可以实现适配器。例如，可以通过继承来创建适配器类：
533: 533:
534: 534:```java
535: 535:// generics/IterableFibonacci.java
536: 536:// Adapt the Fibonacci class to make it Iterable
537: 537:import java.util.*;
538: 538:
539: 539:public class IterableFibonacci
540: 540:extends Fibonacci implements Iterable<Integer> {
541: 541:    private int n;
542: 542:    public IterableFibonacci(int count) { n = count; }
543: 543:  
544: 544:    @Override
545: 545:    public Iterator<Integer> iterator() {
546: 546:        return new Iterator<Integer>() {
547: 547:            @Override
548: 548:            public boolean hasNext() { return n > 0; }
549: 549:            @Override
550: 550:            public Integer next() {
551: 551:                n--;
552: 552:                return IterableFibonacci.this.get();
553: 553:            }
554: 554:            @Override
555: 555:            public void remove() { // Not implemented
556: 556:                throw new UnsupportedOperationException();
557: 557:            }
558: 558:        };
559: 559:    }
560: 560:  
561: 561:    public static void main(String[] args) {
562: 562:        for(int i : new IterableFibonacci(18))
563: 563:            System.out.print(i + " ");
564: 564:    }
565: 565:}
566: 566:```
567: 567:
568: 568:输出结果：
569: 569:
570: 570:```java
571: 571:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
572: 572:```
573: 573:
574: 574:在 *for-in* 语句中使用 `IterableFibonacci`，必须在构造函数中提供一个边界值，这样 `hasNext()` 才知道何时返回 **false**，结束循环。
575: 575:
576: 576:<!-- Generic Methods -->
577: 577:
578: 578:## 泛型方法
579: 579:
580: 580:到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。
581: 581:
582: 582:泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。
583: 583:
584: 584:如果方法是 **static** 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型类型参数，则它必须是泛型方法。
585: 585:
586: 586:要定义泛型方法，请将泛型参数列表放置在返回值之前，如下所示：
587: 587:
588: 588:```java
589: 589:// generics/GenericMethods.java
590: 590:
591: 591:public class GenericMethods {
592: 592:    public <T> void f(T x) {
593: 593:        System.out.println(x.getClass().getName());
594: 594:    }
595: 595:
596: 596:    public static void main(String[] args) {
597: 597:        GenericMethods gm = new GenericMethods();
598: 598:        gm.f("");
599: 599:        gm.f(1);
600: 600:        gm.f(1.0);
601: 601:        gm.f(1.0F);
602: 602:        gm.f('c');
603: 603:        gm.f(gm);
604: 604:    }
605: 605:}
606: 606:/* Output:
607: 607:java.lang.String
608: 608:java.lang.Integer
609: 609:java.lang.Double
610: 610:java.lang.Float
611: 611:java.lang.Character
612: 612:GenericMethods
613: 613:*/
614: 614:```
615: 615:
616: 616:尽管可以同时对类及其方法进行参数化，但这里未将 **GenericMethods** 类参数化。只有方法 `f()` 具有类型参数，该参数由方法返回类型之前的参数列表指示。
617: 617:
618: 618:对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 *类型参数推断*。因此，对 `f()` 的调用看起来像普通的方法调用，并且 `f()` 看起来像被重载了无数次一样。它甚至会接受 **GenericMethods** 类型的参数。
619: 619:
620: 620:如果使用基本类型调用 `f()` ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。
621: 621:
622: 622:<!-- Varargs and Generic Methods -->
623: 623:
624: 624:### 变长参数和泛型方法
625: 625:
626: 626:泛型方法和变长参数列表可以很好地共存：
627: 627:
628: 628:```java
629: 629:// generics/GenericVarargs.java
630: 630:
631: 631:import java.util.ArrayList;
632: 632:import java.util.List;
633: 633:
634: 634:public class GenericVarargs {
635: 635:    @SafeVarargs
636: 636:    public static <T> List<T> makeList(T... args) {
637: 637:        List<T> result = new ArrayList<>();
638: 638:        for (T item : args)
639: 639:            result.add(item);
640: 640:        return result;
641: 641:    }
642: 642:
643: 643:    public static void main(String[] args) {
644: 644:        List<String> ls = makeList("A");
645: 645:        System.out.println(ls);
646: 646:        ls = makeList("A", "B", "C");
647: 647:        System.out.println(ls);
648: 648:        ls = makeList(
649: 649:                "ABCDEFFHIJKLMNOPQRSTUVWXYZ".split(""));
650: 650:        System.out.println(ls);
651: 651:    }
652: 652:}
653: 653:/* Output:
654: 654:[A]
655: 655:[A, B, C]
656: 656:[A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R,
657: 657:S, T, U, V, W, X, Y, Z]
658: 658:*/
659: 659:```
660: 660:
661: 661:此处显示的 `makeList()` 方法产生的功能与标准库的 `java.util.Arrays.asList()` 方法相同。
662: 662:
663: 663:`@SafeVarargs` 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。
664: 664:
665: 665:<!-- A General-Purpose Supplier -->
666: 666:
667: 667:### 一个泛型的 Supplier
668: 668:
669: 669:这是一个为任意具有无参构造方法的类生成 **Supplier** 的类。为了减少键入，它还包括一个用于生成 **BasicSupplier** 的泛型方法：
670: 670:
671: 671:```java
672: 672:// onjava/BasicSupplier.java
673: 673:// Supplier from a class with a no-arg constructor
674: 674:package onjava;
675: 675:
676: 676:import java.util.function.Supplier;
677: 677:
678: 678:public class BasicSupplier<T> implements Supplier<T> {
679: 679:    private Class<T> type;
680: 680:
681: 681:    public BasicSupplier(Class<T> type) {
682: 682:        this.type = type;
683: 683:    }
684: 684:
685: 685:    @Override
686: 686:    public T get() {
687: 687:        try {
688: 688:            // Assumes type is a public class:
689: 689:            return type.newInstance();
690: 690:        } catch (InstantiationException |
691: 691:                IllegalAccessException e) {
692: 692:            throw new RuntimeException(e);
693: 693:        }
694: 694:    }
695: 695:
696: 696:    // Produce a default Supplier from a type token:
697: 697:    public static <T> Supplier<T> create(Class<T> type) {
698: 698:        return new BasicSupplier<>(type);
699: 699:    }
700: 700:}
701: 701:```
702: 702:
703: 703:此类提供了产生以下对象的基本实现：
704: 704:
705: 705:1. 是 **public** 的。 因为 **BasicSupplier** 在单独的包中，所以相关的类必须具有 **public** 权限，而不仅仅是包级访问权限。
706: 706:
707: 707:2. 具有无参构造方法。要创建一个这样的 **BasicSupplier** 对象，请调用 `create()` 方法，并将要生成类型的类型令牌传递给它。通用的 `create()` 方法提供了 `BasicSupplier.create(MyType.class)` 这种较简洁的语法来代替较笨拙的 `new BasicSupplier <MyType>(MyType.class)`。
708: 708:
709: 709:例如，这是一个具有无参构造方法的简单类：
710: 710:
711: 711:```java
712: 712:// generics/CountedObject.java
713: 713:
714: 714:public class CountedObject {
715: 715:    private static long counter = 0;
716: 716:    private final long id = counter++;
717: 717:
718: 718:    public long id() {
719: 719:        return id;
720: 720:    }
721: 721:
722: 722:    @Override
723: 723:    public String toString() {
724: 724:        return "CountedObject " + id;
725: 725:    }
726: 726:}
727: 727:```
728: 728:
729: 729:**CountedObject** 类可以跟踪自身创建了多少个实例，并通过 `toString()` 报告这些实例的数量。 **BasicSupplier** 可以轻松地为 **CountedObject** 创建 **Supplier**：
730: 730:
731: 731:```java
732: 732:  // generics/BasicSupplierDemo.java
733: 733:
734: 734:import onjava.BasicSupplier;
735: 735:
736: 736:import java.util.stream.Stream;
737: 737:
738: 738:public class BasicSupplierDemo {
739: 739:    public static void main(String[] args) {
740: 740:        Stream.generate(
741: 741:                BasicSupplier.create(CountedObject.class))
742: 742:                .limit(5)
743: 743:                .forEach(System.out::println);
744: 744:    }
745: 745:}
746: 746:/* Output:
747: 747:CountedObject 0
748: 748:CountedObject 1
749: 749:CountedObject 2
750: 750:CountedObject 3
751: 751:CountedObject 4
752: 752:*/
753: 753:```
754: 754:
755: 755:泛型方法减少了产生 **Supplier** 对象所需的代码量。 Java 泛型强制传递 **Class** 对象，以便在 `create()` 方法中将其用于类型推断。
756: 756:
757: 757:<!-- Simplifying Tuple Use -->
758: 758:
759: 759:### 简化元组的使用
760: 760:
761: 761:使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库。在这里，我们使用重载的静态方法创建元组：
762: 762:
763: 763:```java
764: 764:// onjava/Tuple.java
765: 765:// Tuple library using type argument inference
766: 766:package onjava;
767: 767:
768: 768:public class Tuple {
769: 769:    public static <A, B> Tuple2<A, B> tuple(A a, B b) {
770: 770:        return new Tuple2<>(a, b);
771: 771:    }
772: 772:
773: 773:    public static <A, B, C> Tuple3<A, B, C>
774: 774:    tuple(A a, B b, C c) {
775: 775:        return new Tuple3<>(a, b, c);
776: 776:    }
777: 777:
778: 778:    public static <A, B, C, D> Tuple4<A, B, C, D>
779: 779:    tuple(A a, B b, C c, D d) {
780: 780:        return new Tuple4<>(a, b, c, d);
781: 781:    }
782: 782:
783: 783:    public static <A, B, C, D, E>
784: 784:    Tuple5<A, B, C, D, E> tuple(A a, B b, C c, D d, E e) {
785: 785:        return new Tuple5<>(a, b, c, d, e);
786: 786:    }
787: 787:}
788: 788:```
789: 789:
790: 790:我们修改 **TupleTest.java** 来测试 **Tuple.java** :
791: 791:
792: 792:```java
793: 793:// generics/TupleTest2.java
794: 794:
795: 795:import onjava.Tuple2;
796: 796:import onjava.Tuple3;
797: 797:import onjava.Tuple4;
798: 798:import onjava.Tuple5;
799: 799:
800: 800:import static onjava.Tuple.tuple;
801: 801:
802: 802:public class TupleTest2 {
803: 803:    static Tuple2<String, Integer> f() {
804: 804:        return tuple("hi", 47);
805: 805:    }
806: 806:
807: 807:    static Tuple2 f2() {
808: 808:        return tuple("hi", 47);
809: 809:    }
810: 810:
811: 811:    static Tuple3<Amphibian, String, Integer> g() {
812: 812:        return tuple(new Amphibian(), "hi", 47);
813: 813:    }
814: 814:
815: 815:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
816: 816:        return tuple(
817: 817:                new Vehicle(), new Amphibian(), "hi", 47);
818: 818:    }
819: 819:
820: 820:    static Tuple5<Vehicle, Amphibian,
821: 821:            String, Integer, Double> k() {
822: 822:        return tuple(new Vehicle(), new Amphibian(),
823: 823:                "hi", 47, 11.1);
824: 824:    }
825: 825:
826: 826:    public static void main(String[] args) {
827: 827:        Tuple2<String, Integer> ttsi = f();
828: 828:        System.out.println(ttsi);
829: 829:        System.out.println(f2());
830: 830:        System.out.println(g());
831: 831:        System.out.println(h());
832: 832:        System.out.println(k());
833: 833:    }
834: 834:}
835: 835:/* Output:
836: 836:(hi, 47)
837: 837:(hi, 47)
838: 838:(Amphibian@14ae5a5, hi, 47)
839: 839:(Vehicle@135fbaa4, Amphibian@45ee12a7, hi, 47)
840: 840:(Vehicle@4b67cf4d, Amphibian@7ea987ac, hi, 47, 11.1)
841: 841:*/
842: 842:```
843: 843:
844: 844:请注意，`f()` 返回一个参数化的 **Tuple2** 对象，而 `f2()` 返回一个未参数化的 **Tuple2** 对象。编译器不会在这里警告 `f2()` ，因为返回值未以参数化方式使用。从某种意义上说，它被“向上转型”为一个未参数化的 **Tuple2** 。 但是，如果尝试将 `f2()` 的结果放入到参数化的 **Tuple2** 中，则编译器将发出警告。
845: 845:
846: 846:<!-- A Set Utility -->
847: 847:
848: 848:### 一个 Set 工具
849: 849:
850: 850:对于泛型方法的另一个示例，请考虑由 **Set** 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法：
851: 851:
852: 852:```java
853: 853:// onjava/Sets.java
854: 854:
855: 855:package onjava;
856: 856:
857: 857:import java.util.HashSet;
858: 858:import java.util.Set;
859: 859:
860: 860:public class Sets {
861: 861:    public static <T> Set<T> union(Set<T> a, Set<T> b) {
862: 862:        Set<T> result = new HashSet<>(a);
863: 863:        result.addAll(b);
864: 864:        return result;
865: 865:    }
866: 866:
867: 867:    public static <T>
868: 868:    Set<T> intersection(Set<T> a, Set<T> b) {
869: 869:        Set<T> result = new HashSet<>(a);
870: 870:        result.retainAll(b);
871: 871:        return result;
872: 872:    }
873: 873:
874: 874:    // Subtract subset from superset:
875: 875:    public static <T> Set<T>
876: 876:    difference(Set<T> superset, Set<T> subset) {
877: 877:        Set<T> result = new HashSet<>(superset);
878: 878:        result.removeAll(subset);
879: 879:        return result;
880: 880:    }
881: 881:
882: 882:    // Reflexive--everything not in the intersection:
883: 883:    public static <T> Set<T> complement(Set<T> a, Set<T> b) {
884: 884:        return difference(union(a, b), intersection(a, b));
885: 885:    }
886: 886:}
887: 887:```
888: 888:
889: 889:前三个方法通过将第一个参数的引用复制到新的 **HashSet** 对象中来复制第一个参数，因此不会直接修改参数集合。因此，返回值是一个新的 **Set** 对象。
890: 890:
891: 891:这四种方法代表数学集合操作： `union()` 返回一个包含两个参数并集的 **Set** ， `intersection()` 返回一个包含两个参数集合交集的 **Set** ， `difference()` 从 **superset** 中减去 **subset** 的元素 ，而 `complement()` 返回所有不在交集中的元素的 **Set**。作为显示这些方法效果的简单示例的一部分，下面是一个包含不同水彩名称的 **enum** ：
892: 892:
893: 893:```java
894: 894:// generics/watercolors/Watercolors.java
895: 895:
896: 896:package watercolors;
897: 897:
898: 898:public enum Watercolors {
899: 899:    ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW,
900: 900:    ORANGE, BRILLIANT_RED, CRIMSON, MAGENTA,
901: 901:    ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE,
902: 902:    PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE,
903: 903:    PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN,
904: 904:    YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
905: 905:    BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK
906: 906:}
907: 907:```
908: 908:
909: 909:为了方便起见（不必全限定所有名称），将其静态导入到以下示例中。本示例使用 **EnumSet** 轻松从 **enum** 中创建 **Set** 。（可以在[第二十二章 枚举](book/22-Enumerations.md)一章中了解有关 **EnumSet** 的更多信息。）在这里，静态方法 `EnumSet.range()` 要求提供所要在结果 **Set** 中创建的元素范围的第一个和最后一个元素：
910: 910:
911: 911:```java
912: 912:// generics/WatercolorSets.java
913: 913:
914: 914:import watercolors.*;
915: 915:
916: 916:import java.util.EnumSet;
917: 917:import java.util.Set;
918: 918:
919: 919:import static watercolors.Watercolors.*;
920: 920:import static onjava.Sets.*;
921: 921:
922: 922:public class WatercolorSets {
923: 923:    public static void main(String[] args) {
924: 924:        Set<Watercolors> set1 =
925: 925:                EnumSet.range(BRILLIANT_RED, VIRIDIAN_HUE);
926: 926:        Set<Watercolors> set2 =
927: 927:                EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER);
928: 928:        System.out.println("set1: " + set1);
929: 929:        System.out.println("set2: " + set2);
930: 930:        System.out.println(
931: 931:                "union(set1, set2): " + union(set1, set2));
932: 932:        Set<Watercolors> subset = intersection(set1, set2);
933: 933:        System.out.println(
934: 934:                "intersection(set1, set2): " + subset);
935: 935:        System.out.println("difference(set1, subset): " +
936: 936:                difference(set1, subset));
937: 937:        System.out.println("difference(set2, subset): " +
938: 938:                difference(set2, subset));
939: 939:        System.out.println("complement(set1, set2): " +
940: 940:                complement(set1, set2));
941: 941:    }
942: 942:}
943: 943:/* Output:
944: 944:set1: [BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER,
945: 945:VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
946: 946:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE]
947: 947:set2: [CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
948: 948:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE,
949: 949:SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
950: 950:BURNT_UMBER]
951: 951:union(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
952: 952:YELLOW_OCHRE, MAGENTA, SAP_GREEN, CERULEAN_BLUE_HUE,
953: 953:ULTRAMARINE, VIRIDIAN_HUE, VIOLET, RAW_UMBER,
954: 954:ROSE_MADDER, PERMANENT_GREEN, BURNT_UMBER,
955: 955:PHTHALO_BLUE, CRIMSON, COBALT_BLUE_HUE]
956: 956:intersection(set1, set2): [PERMANENT_GREEN,
957: 957:CERULEAN_BLUE_HUE, ULTRAMARINE, VIRIDIAN_HUE,
958: 958:PHTHALO_BLUE, COBALT_BLUE_HUE]
959: 959:difference(set1, subset): [BRILLIANT_RED, MAGENTA,
960: 960:VIOLET, CRIMSON, ROSE_MADDER]
961: 961:difference(set2, subset): [BURNT_SIENNA, YELLOW_OCHRE,
962: 962:BURNT_UMBER, SAP_GREEN, RAW_UMBER]
963: 963:complement(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
964: 964:YELLOW_OCHRE, MAGENTA, SAP_GREEN, VIOLET, RAW_UMBER,
965: 965:ROSE_MADDER, BURNT_UMBER, CRIMSON]
966: 966:*/
967: 967:```
968: 968:
969: 969:接下来的例子使用 `Sets.difference()` 方法来展示 **java.util** 包中各种 **Collection** 和 **Map** 类之间的方法差异：
970: 970:
971: 971:```java
972: 972:// onjava/CollectionMethodDifferences.java
973: 973:// {java onjava.CollectionMethodDifferences}
974: 974:
975: 975:package onjava;
976: 976:
977: 977:import java.lang.reflect.Method;
978: 978:import java.util.*;
979: 979:import java.util.stream.Collectors;
980: 980:
981: 981:public class CollectionMethodDifferences {
982: 982:    static Set<String> methodSet(Class<?> type) {
983: 983:        return Arrays.stream(type.getMethods())
984: 984:                .map(Method::getName)
985: 985:                .collect(Collectors.toCollection(TreeSet::new));
986: 986:    }
987: 987:
988: 988:    static void interfaces(Class<?> type) {
989: 989:        System.out.print("Interfaces in " +
990: 990:                type.getSimpleName() + ": ");
991: 991:        System.out.println(
992: 992:                Arrays.stream(type.getInterfaces())
993: 993:                        .map(Class::getSimpleName)
994: 994:                        .collect(Collectors.toList()));
995: 995:    }
996: 996:
997: 997:    static Set<String> object = methodSet(Object.class);
998: 998:
999: 999:    static {
1000: 1000:        object.add("clone");
1001: 1001:    }
1002: 1002:
1003: 1003:    static void
1004: 1004:    difference(Class<?> superset, Class<?> subset) {
1005: 1005:        System.out.print(superset.getSimpleName() +
1006: 1006:                " extends " + subset.getSimpleName() +
1007: 1007:                ", adds: ");
1008: 1008:        Set<String> comp = Sets.difference(
1009: 1009:                methodSet(superset), methodSet(subset));
1010: 1010:        comp.removeAll(object); // Ignore 'Object' methods
1011: 1011:        System.out.println(comp);
1012: 1012:        interfaces(superset);
1013: 1013:    }
1014: 1014:
1015: 1015:    public static void main(String[] args) {
1016: 1016:        System.out.println("Collection: " +
1017: 1017:                methodSet(Collection.class));
1018: 1018:        interfaces(Collection.class);
1019: 1019:        difference(Set.class, Collection.class);
1020: 1020:        difference(HashSet.class, Set.class);
1021: 1021:        difference(LinkedHashSet.class, HashSet.class);
1022: 1022:        difference(TreeSet.class, Set.class);
1023: 1023:        difference(List.class, Collection.class);
1024: 1024:        difference(ArrayList.class, List.class);
1025: 1025:        difference(LinkedList.class, List.class);
1026: 1026:        difference(Queue.class, Collection.class);
1027: 1027:        difference(PriorityQueue.class, Queue.class);
1028: 1028:        System.out.println("Map: " + methodSet(Map.class));
1029: 1029:        difference(HashMap.class, Map.class);
1030: 1030:        difference(LinkedHashMap.class, HashMap.class);
1031: 1031:        difference(SortedMap.class, Map.class);
1032: 1032:        difference(TreeMap.class, Map.class);
1033: 1033:    }
1034: 1034:}
1035: 1035:/* Output:
1036: 1036:Collection: [add, addAll, clear, contains, containsAll,
1037: 1037:equals, forEach, hashCode, isEmpty, iterator,
1038: 1038:parallelStream, remove, removeAll, removeIf, retainAll,
1039: 1039:size, spliterator, stream, toArray]
1040: 1040:Interfaces in Collection: [Iterable]
1041: 1041:Set extends Collection, adds: []
1042: 1042:Interfaces in Set: [Collection]
1043: 1043:HashSet extends Set, adds: []
1044: 1044:Interfaces in HashSet: [Set, Cloneable, Serializable]
1045: 1045:LinkedHashSet extends HashSet, adds: []
1046: 1046:Interfaces in LinkedHashSet: [Set, Cloneable,
1047: 1047:Serializable]
1048: 1048:TreeSet extends Set, adds: [headSet,
1049: 1049:descendingIterator, descendingSet, pollLast, subSet,
1050: 1050:floor, tailSet, ceiling, last, lower, comparator,
1051: 1051:pollFirst, first, higher]
1052: 1052:Interfaces in TreeSet: [NavigableSet, Cloneable,
1053: 1053:Serializable]
1054: 1054:List extends Collection, adds: [replaceAll, get,
1055: 1055:indexOf, subList, set, sort, lastIndexOf, listIterator]
1056: 1056:Interfaces in List: [Collection]
1057: 1057:ArrayList extends List, adds: [trimToSize,
1058: 1058:ensureCapacity]
1059: 1059:Interfaces in ArrayList: [List, RandomAccess,
1060: 1060:Cloneable, Serializable]
1061: 1061:LinkedList extends List, adds: [offerFirst, poll,
1062: 1062:getLast, offer, getFirst, removeFirst, element,
1063: 1063:removeLastOccurrence, peekFirst, peekLast, push,
1064: 1064:pollFirst, removeFirstOccurrence, descendingIterator,
1065: 1065:pollLast, removeLast, pop, addLast, peek, offerLast,
1066: 1066:addFirst]
1067: 1067:Interfaces in LinkedList: [List, Deque, Cloneable,
1068: 1068:Serializable]
1069: 1069:Queue extends Collection, adds: [poll, peek, offer,
1070: 1070:element]
1071: 1071:Interfaces in Queue: [Collection]
1072: 1072:PriorityQueue extends Queue, adds: [comparator]
1073: 1073:Interfaces in PriorityQueue: [Serializable]
1074: 1074:Map: [clear, compute, computeIfAbsent,
1075: 1075:computeIfPresent, containsKey, containsValue, entrySet,
1076: 1076:equals, forEach, get, getOrDefault, hashCode, isEmpty,
1077: 1077:keySet, merge, put, putAll, putIfAbsent, remove,
1078: 1078:replace, replaceAll, size, values]
1079: 1079:HashMap extends Map, adds: []
1080: 1080:Interfaces in HashMap: [Map, Cloneable, Serializable]
1081: 1081:LinkedHashMap extends HashMap, adds: []
1082: 1082:Interfaces in LinkedHashMap: [Map]
1083: 1083:SortedMap extends Map, adds: [lastKey, subMap,
1084: 1084:comparator, firstKey, headMap, tailMap]
1085: 1085:Interfaces in SortedMap: [Map]
1086: 1086:TreeMap extends Map, adds: [descendingKeySet,
1087: 1087:navigableKeySet, higherEntry, higherKey, floorKey,
1088: 1088:subMap, ceilingKey, pollLastEntry, firstKey, lowerKey,
1089: 1089:headMap, tailMap, lowerEntry, ceilingEntry,
1090: 1090:descendingMap, pollFirstEntry, lastKey, firstEntry,
1091: 1091:floorEntry, comparator, lastEntry]
1092: 1092:Interfaces in TreeMap: [NavigableMap, Cloneable,
1093: 1093:Serializable]
1094: 1094:*/
1095: 1095:```
1096: 1096:
1097: 1097:在第十二章 [集合的本章小结](book/12-Collections.md#本章小结) 部分将会用到这里的输出结果。
1098: 1098:
1099: 1099:<!-- Building Complex Models -->
1100: 1100:
1101: 1101:## 构建复杂模型
1102: 1102:
1103: 1103:泛型的一个重要好处是能够简单安全地创建复杂模型。例如，我们可以轻松地创建一个元组列表：
1104: 1104:
1105: 1105:```java
1106: 1106:// generics/TupleList.java
1107: 1107:// Combining generic types to make complex generic types
1108: 1108:
1109: 1109:import onjava.Tuple4;
1110: 1110:
1111: 1111:import java.util.ArrayList;
1112: 1112:
1113: 1113:public class TupleList<A, B, C, D>
1114: 1114:        extends ArrayList<Tuple4<A, B, C, D>> {
1115: 1115:    public static void main(String[] args) {
1116: 1116:        TupleList<Vehicle, Amphibian, String, Integer> tl =
1117: 1117:                new TupleList<>();
1118: 1118:        tl.add(TupleTest2.h());
1119: 1119:        tl.add(TupleTest2.h());
1120: 1120:        tl.forEach(System.out::println);
1121: 1121:    }
1122: 1122:}
1123: 1123:/* Output:
1124: 1124:(Vehicle@7cca494b, Amphibian@7ba4f24f, hi, 47)
1125: 1125:(Vehicle@3b9a45b3, Amphibian@7699a589, hi, 47)
1126: 1126:*/
1127: 1127:```
1128: 1128:
1129: 1129:这将产生一个功能强大的数据结构，而无需太多代码。
1130: 1130:
1131: 1131:下面是第二个例子。每个类都是组成块，总体包含很多个块。在这里，该模型是一个具有过道，货架和产品的零售商店：
1132: 1132:
1133: 1133:```java
1134: 1134:// generics/Store.java
1135: 1135:// Building a complex model using generic collections
1136: 1136:
1137: 1137:import onjava.Suppliers;
1138: 1138:
1139: 1139:import java.util.ArrayList;
1140: 1140:import java.util.Random;
1141: 1141:import java.util.function.Supplier;
1142: 1142:
1143: 1143:class Product {
1144: 1144:    private final int id;
1145: 1145:    private String description;
1146: 1146:    private double price;
1147: 1147:
1148: 1148:    Product(int idNumber, String descr, double price) {
1149: 1149:        id = idNumber;
1150: 1150:        description = descr;
1151: 1151:        this.price = price;
1152: 1152:        System.out.println(toString());
1153: 1153:    }
1154: 1154:
1155: 1155:    @Override
1156: 1156:    public String toString() {
1157: 1157:        return id + ": " + description +
1158: 1158:                ", price: $" + price;
1159: 1159:    }
1160: 1160:
1161: 1161:    public void priceChange(double change) {
1162: 1162:        price += change;
1163: 1163:    }
1164: 1164:
1165: 1165:    public static Supplier<Product> generator =
1166: 1166:            new Supplier<Product>() {
1167: 1167:                private Random rand = new Random(47);
1168: 1168:
1169: 1169:                @Override
1170: 1170:                public Product get() {
1171: 1171:                    return new Product(rand.nextInt(1000), "Test",
1172: 1172:                            Math.round(
1173: 1173:                                    rand.nextDouble() * 1000.0) + 0.99);
1174: 1174:                }
1175: 1175:            };
1176: 1176:}
1177: 1177:
1178: 1178:class Shelf extends ArrayList<Product> {
1179: 1179:    Shelf(int nProducts) {
1180: 1180:        Suppliers.fill(this, Product.generator, nProducts);
1181: 1181:    }
1182: 1182:}
1183: 1183:
1184: 1184:class Aisle extends ArrayList<Shelf> {
1185: 1185:    Aisle(int nShelves, int nProducts) {
1186: 1186:        for (int i = 0; i < nShelves; i++)
1187: 1187:            add(new Shelf(nProducts));
1188: 1188:    }
1189: 1189:}
1190: 1190:
1191: 1191:class CheckoutStand {
1192: 1192:}
1193: 1193:
1194: 1194:class Office {
1195: 1195:}
1196: 1196:
1197: 1197:public class Store extends ArrayList<Aisle> {
1198: 1198:    private ArrayList<CheckoutStand> checkouts =
1199: 1199:            new ArrayList<>();
1200: 1200:    private Office office = new Office();
1201: 1201:
1202: 1202:    public Store(
1203: 1203:            int nAisles, int nShelves, int nProducts) {
1204: 1204:        for (int i = 0; i < nAisles; i++)
1205: 1205:            add(new Aisle(nShelves, nProducts));
1206: 1206:    }
1207: 1207:
1208: 1208:    @Override
1209: 1209:    public String toString() {
1210: 1210:        StringBuilder result = new StringBuilder();
1211: 1211:        for (Aisle a : this)
1212: 1212:            for (Shelf s : a)
1213: 1213:                for (Product p : s) {
1214: 1214:                    result.append(p);
1215: 1215:                    result.append("\n");
1216: 1216:                }
1217: 1217:        return result.toString();
1218: 1218:    }
1219: 1219:
1220: 1220:    public static void main(String[] args) {
1221: 1221:        System.out.println(new Store(5, 4, 3));
1222: 1222:    }
1223: 1223:}
1224: 1224:/* Output: (First 8 Lines)
1225: 1225:258: Test, price: $400.99
1226: 1226:861: Test, price: $160.99
1227: 1227:868: Test, price: $417.99
1228: 1228:207: Test, price: $268.99
1229: 1229:551: Test, price: $114.99
1230: 1230:278: Test, price: $804.99
1231: 1231:520: Test, price: $554.99
1232: 1232:140: Test, price: $530.99
1233: 1233:                  ...
1234: 1234:*/
1235: 1235:```
1236: 1236:
1237: 1237:`Store.toString()` 显示了结果：尽管有复杂的层次结构，但多层的集合仍然是类型安全的和可管理的。令人印象深刻的是，组装这样的模型并不需要耗费过多精力。
1238: 1238:
1239: 1239:**Shelf** 使用 `Suppliers.fill()` 这个实用程序，该实用程序接受 **Collection** （第一个参数），并使用 **Supplier** （第二个参数），以元素的数量为 **n** （第三个参数）来填充它。 **Suppliers** 类将会在本章末尾定义，其中的方法都是在执行某种填充操作，并在本章的其他示例中使用。
1240: 1240:
1241: 1241:<!-- The Mystery of Erasure -->
1242: 1242:
1243: 1243:## 泛型擦除
1244: 1244:
1245: 1245:当你开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的。例如，尽管可以说  `ArrayList.class`，但不能说成 `ArrayList<Integer>.class`。考虑下面的情况：
1246: 1246:
1247: 1247:```java
1248: 1248:// generics/ErasedTypeEquivalence.java
1249: 1249:
1250: 1250:import java.util.*;
1251: 1251:
1252: 1252:public class ErasedTypeEquivalence {
1253: 1253:    
1254: 1254:    public static void main(String[] args) {
1255: 1255:        Class c1 = new ArrayList<String>().getClass();
1256: 1256:        Class c2 = new ArrayList<Integer>().getClass();
1257: 1257:        System.out.println(c1 == c2);
1258: 1258:    }
1259: 1259:    
1260: 1260:}
1261: 1261:/* Output:
1262: 1262:true
1263: 1263:*/
1264: 1264:```
1265: 1265:
1266: 1266:`ArrayList<String>` 和 `ArrayList<Integer>` 应该是不同的类型。不同的类型会有不同的行为。例如，如果尝试向 `ArrayList<String>` 中放入一个 `Integer`，所得到的行为（失败）和向 `ArrayList<Integer>` 中放入一个 `Integer` 所得到的行为（成功）完全不同。然而上面的程序认为它们是相同的类型。
1267: 1267:
1268: 1268:下面的例子是对该谜题的补充：
1269: 1269:
1270: 1270:```java
1271: 1271:// generics/LostInformation.java
1272: 1272:
1273: 1273:import java.util.*;
1274: 1274:
1275: 1275:class Frob {}
1276: 1276:class Fnorkle {}
1277: 1277:class Quark<Q> {}
1278: 1278:
1279: 1279:class Particle<POSITION, MOMENTUM> {}
1280: 1280:
1281: 1281:public class LostInformation {
1282: 1282:
1283: 1283:    public static void main(String[] args) {
1284: 1284:        List<Frob> list = new ArrayList<>();
1285: 1285:        Map<Frob, Fnorkle> map = new HashMap<>();
1286: 1286:        Quark<Fnorkle> quark = new Quark<>();
1287: 1287:        Particle<Long, Double> p = new Particle<>();
1288: 1288:        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));
1289: 1289:        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));
1290: 1290:        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));
1291: 1291:        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));
1292: 1292:    }
1293: 1293:
1294: 1294:}
1295: 1295:/* Output:
1296: 1296:[E]
1297: 1297:[K,V]
1298: 1298:[Q]
1299: 1299:[POSITION,MOMENTUM]
1300: 1300:*/
1301: 1301:```
1302: 1302:
1303: 1303:根据 JDK 文档，**Class.getTypeParameters()** “返回一个 **TypeVariable** 对象数组，表示泛型声明中声明的类型参数...” 这暗示你可以发现这些参数类型。但是正如上例中输出所示，你只能看到用作参数占位符的标识符，这并非有用的信息。
1304: 1304:
1305: 1305:残酷的现实是：
1306: 1306:
1307: 1307:在泛型代码内部，无法获取任何有关泛型参数类型的信息。
1308: 1308:
1309: 1309:因此，你可以知道如类型参数标识符和泛型边界这些信息，但无法得知实际的类型参数从而用来创建特定的实例。如果你曾是 C++ 程序员，那么这个事实会让你很沮丧，在使用 Java 泛型工作时，它是必须处理的最基本的问题。
1310: 1310:
1311: 1311:Java 泛型是使用擦除实现的。这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此，`List<String>` 和 `List<Integer>` 在运行时实际上是相同的类型。它们都被擦除成原生类型 `List`。
1312: 1312:
1313: 1313:理解擦除并知道如何处理它，是你在学习 Java 泛型时面临的最大障碍之一。这也是本节将要探讨的内容。
1314: 1314:
1315: 1315:### C++ 的方式
1316: 1316:
1317: 1317:下面是使用模版的 C++ 示例。你会看到类型参数的语法十分相似，因为 Java 是受 C++ 启发的：
1318: 1318:
1319: 1319:```c++
1320: 1320:// generics/Templates.cpp
1321: 1321:
1322: 1322:#include <iostream>
1323: 1323:using namespace std;
1324: 1324:
1325: 1325:template<class T> class Manipulator {
1326: 1326:    T obj;
1327: 1327:public:
1328: 1328:    Manipulator(T x) { obj = x; }
1329: 1329:    void manipulate() { obj.f(); }
1330: 1330:};
1331: 1331:
1332: 1332:class HasF {
1333: 1333:public:
1334: 1334:    void f() { cout << "HasF::f()" << endl; }
1335: 1335:};
1336: 1336:
1337: 1337:int main() {
1338: 1338:    HasF hf;
1339: 1339:    Manipulator<HasF> manipulator(hf);
1340: 1340:    manipulator.manipulate();
1341: 1341:}
1342: 1342:/* Output:
1343: 1343:HasF::f()
1344: 1344:*/
1345: 1345:```
1346: 1346:
1347: 1347:**Manipulator** 类存储了一个 **T** 类型的对象。`manipulate()` 方法会调用 **obj** 上的 `f()` 方法。它是如何知道类型参数 **T** 中存在 `f()` 方法的呢？C++ 编译器会在你实例化模版时进行检查，所以在 `Manipulator<HasF>` 实例化的那一刻，它看到 **HasF** 中含有一个方法 `f()`。如果情况并非如此，你就会得到一个编译期错误，保持类型安全。
1348: 1348:
1349: 1349:用 C++ 编写这种代码很简单，因为当模版被实例化时，模版代码就知道模版参数的类型。Java 泛型就不同了。下面是 **HasF** 的 Java 版本：
1350: 1350:
1351: 1351:```java
1352: 1352:// generics/HasF.java
1353: 1353:
1354: 1354:public class HasF {
1355: 1355:    public void f() {
1356: 1356:        System.out.println("HasF.f()");
1357: 1357:    }
1358: 1358:}
1359: 1359:```
1360: 1360:
1361: 1361:如果我们将示例的其余代码用 Java 实现，就不会通过编译：
1362: 1362:
1363: 1363:```java
1364: 1364:// generics/Manipulation.java
1365: 1365:// {WillNotCompile}
1366: 1366:
1367: 1367:class Manipulator<T> {
1368: 1368:    private T obj;
1369: 1369:    
1370: 1370:    Manipulator(T x) {
1371: 1371:        obj = x;
1372: 1372:    }
1373: 1373:    
1374: 1374:    // Error: cannot find symbol: method f():
1375: 1375:    public void manipulate() {
1376: 1376:        obj.f();
1377: 1377:    }
1378: 1378:}
1379: 1379:
1380: 1380:public class Manipulation {
1381: 1381:	public static void main(String[] args) {
1382: 1382:        HasF hf = new HasF();
1383: 1383:        Manipulator<HasF> manipulator = new Manipulator<>(hf);
1384: 1384:        manipulator.manipulate();
1385: 1385:    }
1386: 1386:}
1387: 1387:```
1388: 1388:
1389: 1389:因为擦除，Java 编译器无法将 `manipulate()` 方法必须能调用 **obj** 的 `f()` 方法这一需求映射到 HasF 具有 `f()` 方法这个事实上。为了调用 `f()`，我们必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。这里重用了 **extends** 关键字。由于有了边界，下面的代码就能通过编译：
1390: 1390:
1391: 1391:```java
1392: 1392:public class Manipulator2<T extends HasF> {
1393: 1393:    private T obj;
1394: 1394:
1395: 1395:    Manipulator2(T x) {
1396: 1396:        obj = x;
1397: 1397:    }
1398: 1398:
1399: 1399:    public void manipulate() {
1400: 1400:        obj.f();
1401: 1401:    }
1402: 1402:}
1403: 1403:```
1404: 1404:
1405: 1405:边界 `<T extends HasF>` 声明 T 必须是 HasF 类型或其子类。如果情况确实如此，就可以安全地在 **obj** 上调用 `f()` 方法。
1406: 1406:
1407: 1407:我们说泛型类型参数会擦除到它的第一个边界（可能有多个边界，稍后你将看到）。我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的示例，**T** 擦除到了 **HasF**，就像在类的声明中用 **HasF** 替换了 **T** 一样。
1408: 1408:
1409: 1409:你可能正确地观察到了泛型在 **Manipulator2.java** 中没有贡献任何事。你可以很轻松地自己去执行擦除，生成没有泛型的类：
1410: 1410:
1411: 1411:```java
1412: 1412:// generics/Manipulator3.java
1413: 1413:
1414: 1414:class Manipulator3 {
1415: 1415:    private HasF obj;
1416: 1416:    
1417: 1417:    Manipulator3(HasF x) {
1418: 1418:        obj = x;
1419: 1419:    }
1420: 1420:    
1421: 1421:    public void manipulate() {
1422: 1422:        obj.f();
1423: 1423:    }
1424: 1424:}
1425: 1425:```
1426: 1426:
1427: 1427:这提出了很重要的一点：泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用。因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换更加复杂。但是，不能因此认为使用 `<T extends HasF>` 形式就是有缺陷的。例如，如果某个类有一个返回 **T** 的方法，那么泛型就有所帮助，因为它们之后将返回确切的类型：
1428: 1428:
1429: 1429:```java
1430: 1430:// generics/ReturnGenericType.java
1431: 1431:
1432: 1432:public class ReturnGenericType<T extends HasF> {
1433: 1433:    private T obj;
1434: 1434:    
1435: 1435:    ReturnGenericType(T x) {
1436: 1436:        obj = x;
1437: 1437:    }
1438: 1438:    
1439: 1439:    public T get() {
1440: 1440:        return obj;
1441: 1441:    }
1442: 1442:}
1443: 1443:```
1444: 1444:
1445: 1445:你必须查看所有的代码，从而确定代码是否复杂到必须使用泛型的程度。
1446: 1446:
1447: 1447:我们将在本章稍后看到有关边界的更多细节。
1448: 1448:
1449: 1449:### 迁移兼容性
1450: 1450:
1451: 1451:为了减少潜在的关于擦除的困惑，你必须清楚地认识到这不是一个语言特性。它是 Java 实现泛型的一种妥协，因为泛型不是 Java 语言出现时就有的，所以就有了这种妥协。它会使你痛苦，因此你需要尽早习惯它并了解为什么它会这样。
1452: 1452:
1453: 1453:如果 Java 1.0 就含有泛型的话，那么这个特性就不会使用擦除来实现——它会使用具体化，保持参数类型为第一类实体，因此你就能在类型参数上执行基于类型的语言操作和反射操作。本章稍后你会看到，擦除减少了泛型的泛化性。泛型在 Java 中仍然是有用的，只是不如它们本来设想的那么有用，而原因就是擦除。
1454: 1454:
1455: 1455:在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文使用泛型类型。泛型类型只有在静态类型检测期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如， `List<T>` 这样的类型注解会被擦除为 **List**，普通的类型变量在未指定边界的情况下会被擦除为 **Object**。
1456: 1456:
1457: 1457:擦除的核心动机是你可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称为“迁移兼容性”。在理想情况下，所有事物将在指定的某天被泛化。在现实中，即使程序员只编写泛型代码，他们也必须处理 Java 5 之前编写的非泛型类库。这些类库的作者可能从没想过要泛化他们的代码，或许他们可能刚刚开始接触泛型。
1458: 1458:
1459: 1459:因此 Java 泛型不仅必须支持向后兼容性——现有的代码和类文件仍然合法，继续保持之前的含义——而且还必须支持迁移兼容性，使得类库能按照它们自己的步调变为泛型，当某个类库变为泛型时，不会破坏依赖于它的代码和应用。在确定了这个目标后，Java 设计者们和从事此问题相关工作的各个团队决策认为擦除是唯一可行的解决方案。擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。
1460: 1460:
1461: 1461:例如，假设一个应用使用了两个类库 **X** 和 **Y**，**Y** 使用了类库 **Z**。随着 Java 5 的出现，这个应用和这些类库的创建者最终可能希望迁移到泛型上。但是当进行迁移时，它们有着不同的动机和限制。为了实现迁移兼容性，每个类库与应用必须与其他所有的部分是否使用泛型无关。因此，它们不能探测其他类库是否使用了泛型。因此，某个特定的类库使用了泛型这样的证据必须被”擦除“。
1462: 1462:
1463: 1463:如果没有某种类型的迁移途径，所有已经构建了很长时间的类库就需要与希望迁移到 Java 泛型上的开发者们说再见了。类库毫无争议是编程语言的一部分，对生产效率有着极大的影响，所以这种代码无法接受。擦除是否是最佳的或唯一的迁移途径，还待时间来证明。
1464: 1464:
1465: 1465:### 擦除的问题
1466: 1466:
1467: 1467:因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。擦除允许你继续使用现有的非泛型客户端代码，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会骤然破坏所有现有的代码。
1468: 1468:
1469: 1469:擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作中，例如转型、**instanceof** 操作和 **new** 表达式。因为所有关于参数的类型信息都丢失了，当你在编写泛型代码时，必须时刻提醒自己，你只是看起来拥有有关参数的类型信息而已。
1470: 1470:
1471: 1471:考虑如下的代码段：
1472: 1472:
1473: 1473:```java
1474: 1474:class Foo<T> {
1475: 1475:    T var;
1476: 1476:}
1477: 1477:```
1478: 1478:
1479: 1479:看上去当你创建一个 **Foo** 实例时：
1480: 1480:
1481: 1481:```java
1482: 1482:Foo<Cat> f = new Foo<>();
1483: 1483:```
1484: 1484:
1485: 1485:**class** **Foo** 中的代码应该知道现在工作于 **Cat** 之上。泛型语法也在强烈暗示整个类中所有 T 出现的地方都被替换，就像在 C++ 中一样。但是事实并非如此，当你在编写这个类的代码时，必须提醒自己：“不，这只是一个 **Object**“。
1486: 1486:
1487: 1487:另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管你可能希望这样：
1488: 1488:
1489: 1489:```java
1490: 1490:// generics/ErasureAndInheritance.java
1491: 1491:
1492: 1492:class GenericBase<T> {
1493: 1493:    private T element;
1494: 1494:    
1495: 1495:    public void set(T arg) {
1496: 1496:        element = arg;
1497: 1497:    }
1498: 1498:    
1499: 1499:    public T get() {
1500: 1500:        return element;
1501: 1501:    }
1502: 1502:}
1503: 1503:
1504: 1504:class Derived1<T> extends GenericBase<T> {}
1505: 1505:
1506: 1506:class Derived2 extends GenericBase {} // No warning
1507: 1507:
1508: 1508:// class Derived3 extends GenericBase<?> {}
1509: 1509:// Strange error:
1510: 1510:// unexpected type
1511: 1511:// required: class or interface without bounds
1512: 1512:public class ErasureAndInteritance {
1513: 1513:    @SuppressWarnings("unchecked")
1514: 1514:    public static void main(String[] args) {
1515: 1515:        Derived2 d2 = new Derived2();
1516: 1516:        Object obj = d2.get();
1517: 1517:        d2.set(obj); // Warning here!
1518: 1518:    }
1519: 1519:}
1520: 1520:```
1521: 1521:
1522: 1522:**Derived2** 继承自 **GenericBase**，但是没有任何类型参数，编译器没有发出任何警告。直到调用 `set()` 方法时才出现警告。
1523: 1523:
1524: 1524:为了关闭警告，Java 提供了一个注解，我们可以在列表中看到它：
1525: 1525:
1526: 1526:```java
1527: 1527:@SuppressWarnings("unchecked")
1528: 1528:```
1529: 1529:
1530: 1530:这个注解放置在产生警告的方法上，而不是整个类上。当你要关闭警告时，最好尽可能地“聚焦”，这样就不会因为过于宽泛地关闭警告，而导致意外地遮蔽掉真正的问题。
1531: 1531:
1532: 1532:可以推断，**Derived3** 产生的错误意味着编译器期望得到一个原生基类。
1533: 1533:
1534: 1534:当你希望将类型参数不仅仅当作 Object 处理时，就需要付出额外努力来管理边界，并且与在 C++、Ada 和 Eiffel 这样的语言中获得参数化类型相比，你需要付出多得多的努力来获得少得多的回报。这并不是说，对于大多数的编程问题而言，这些语言通常都会比 Java 更得心应手，只是说它们的参数化类型机制相比 Java 更灵活、更强大。
1535: 1535:
1536: 1536:### 边界处的动作
1537: 1537:
1538: 1538:因为擦除，我发现了泛型最令人困惑的方面是可以表示没有任何意义的事物。例如：
1539: 1539:
1540: 1540:```java
1541: 1541:// generics/ArrayMaker.java
1542: 1542:
1543: 1543:import java.lang.reflect.*;
1544: 1544:import java.util.*;
1545: 1545:
1546: 1546:public class ArrayMaker<T> {
1547: 1547:    private Class<T> kind;
1548: 1548:
1549: 1549:    public ArrayMaker(Class<T> kind) {
1550: 1550:        this.kind = kind;
1551: 1551:    }
1552: 1552:
1553: 1553:    @SuppressWarnings("unchecked")
1554: 1554:    T[] create(int size) {
1555: 1555:        return (T[]) Array.newInstance(kind, size);
1556: 1556:    }
1557: 1557:
1558: 1558:    public static void main(String[] args) {
1559: 1559:        ArrayMaker<String> stringMaker = new ArrayMaker<>(String.class);
1560: 1560:        String[] stringArray = stringMaker.create(9);
1561: 1561:        System.out.println(Arrays.toString(stringArray));
1562: 1562:    }
1563: 1563:}
1564: 1564:/* Output
1565: 1565:[null,null,null,null,null,null,null,null,null]
1566: 1566:*/
1567: 1567:```
1568: 1568:
1569: 1569:即使 **kind** 被存储为 `Class<T>`，擦除也意味着它实际被存储为没有任何参数的 **Class**。因此，当你在使用它时，例如创建数组，`Array.newInstance()` 实际上并未拥有 **kind** 所蕴含的类型信息。所以它不会产生具体的结果，因而必须转型，这会产生一条令你无法满意的警告。
1570: 1570:
1571: 1571:注意，对于在泛型中创建数组，使用 `Array.newInstance()` 是推荐的方式。
1572: 1572:
1573: 1573:如果我们创建一个集合而不是数组，情况就不同了：
1574: 1574:
1575: 1575:```java
1576: 1576:// generics/ListMaker.java
1577: 1577:
1578: 1578:import java.util.*;
1579: 1579:
1580: 1580:public class ListMaker<T> {
1581: 1581:    List<T> create() {
1582: 1582:        return new ArrayList<>();
1583: 1583:    }
1584: 1584:    
1585: 1585:    public static void main(String[] args) {
1586: 1586:        ListMaker<String> stringMaker = new ListMaker<>();
1587: 1587:        List<String> stringList = stringMaker.create();
1588: 1588:    }
1589: 1589:}
1590: 1590:```
1591: 1591:
1592: 1592:编译器不会给出任何警告，尽管我们知道（从擦除中）在 `create()` 内部的 `new ArrayList<>()` 中的 `<T>` 被移除了——在运行时，类内部没有任何 `<T>`，因此这看起来毫无意义。但是如果你遵从这种思路，并将这个表达式改为 `new ArrayList()`，编译器就会发出警告。
1593: 1593:
1594: 1594:本例中这么做真的毫无意义吗？如果在创建 **List** 的同时向其中放入一些对象呢，像这样：
1595: 1595:
1596: 1596:```java
1597: 1597:// generics/FilledList.java
1598: 1598:
1599: 1599:import java.util.*;
1600: 1600:import java.util.function.*;
1601: 1601:import onjava.*;
1602: 1602:
1603: 1603:public class FilledList<T> extends ArrayList<T> {
1604: 1604:    FilledList(Supplier<T> gen, int size) {
1605: 1605:        Suppliers.fill(this, gen, size);
1606: 1606:    }
1607: 1607:    
1608: 1608:    public FilledList(T t, int size) {
1609: 1609:        for (int i = 0; i < size; i++) {
1610: 1610:            this.add(t);
1611: 1611:        }
1612: 1612:    }
1613: 1613:    
1614: 1614:    public static void main(String[] args) {
1615: 1615:        List<String> list = new FilledList<>("Hello", 4);
1616: 1616:        System.out.println(list);
1617: 1617:        // Supplier version:
1618: 1618:        List<Integer> ilist = new FilledList<>(() -> 47, 4);
1619: 1619:        System.out.println(ilist);
1620: 1620:    }
1621: 1621:}
1622: 1622:/* Output:
1623: 1623:[Hello,Hello,Hello,Hello]
1624: 1624:[47,47,47,47]
1625: 1625:*/
1626: 1626:```
1627: 1627:
1628: 1628:即使编译器无法得知 `add()` 中的 **T** 的任何信息，但它仍可以在编译期确保你放入 **FilledList** 中的对象是 **T** 类型。因此，即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。
1629: 1629:
1630: 1630:因为擦除移除了方法体中的类型信息，所以在运行时的问题就是*边界*：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。
1631: 1631:
1632: 1632:考虑如下这段非泛型示例：
1633: 1633:
1634: 1634:```java
1635: 1635:// generics/SimpleHolder.java
1636: 1636:
1637: 1637:public class SimpleHolder {
1638: 1638:    private Object obj;
1639: 1639:    
1640: 1640:    public void set(Object obj) {
1641: 1641:        this.obj = obj;
1642: 1642:    }
1643: 1643:    
1644: 1644:    public Object get() {
1645: 1645:        return obj;
1646: 1646:    }
1647: 1647:    
1648: 1648:    public static void main(String[] args) {
1649: 1649:        SimpleHolder holder = new SimpleHolder();
1650: 1650:        holder.set("Item");
1651: 1651:        String s = (String) holder.get();
1652: 1652:    }
1653: 1653:}
1654: 1654:```
1655: 1655:
1656: 1656:如果用 **javap -c SimpleHolder** 反编译这个类，会得到如下内容（经过编辑）：
1657: 1657:
1658: 1658:```java
1659: 1659:public void set(java.lang.Object);
1660: 1660:   0: aload_0
1661: 1661:   1: aload_1
1662: 1662:   2: putfield #2; // Field obj:Object;
1663: 1663:   5: return
1664: 1664:    
1665: 1665:public java.lang.Object get();
1666: 1666:   0: aload_0
1667: 1667:   1: getfield #2; // Field obj:Object;
1668: 1668:   4: areturn
1669: 1669:    
1670: 1670:public static void main(java.lang.String[]);
1671: 1671:   0: new #3; // class SimpleHolder
1672: 1672:   3: dup
1673: 1673:   4: invokespecial #4; // Method "<init>":()V
1674: 1674:   7: astore_1
1675: 1675:   8: aload_1
1676: 1676:   9: ldc #5; // String Item
1677: 1677:   11: invokevirtual #6; // Method set:(Object;)V
1678: 1678:   14: aload_1
1679: 1679:   15: invokevirtual #7; // Method get:()Object;
1680: 1680:   18: checkcast #8; // class java/lang/String
1681: 1681:   21: astore_2
1682: 1682:   22: return
1683: 1683:```
1684: 1684:
1685: 1685:`set()` 和 `get()` 方法存储和产生值，转型在调用 `get()` 时接受检查。
1686: 1686:
1687: 1687:现在将泛型融入上例代码中：
1688: 1688:
1689: 1689:```java
1690: 1690:// generics/GenericHolder2.java
1691: 1691:
1692: 1692:public class GenericHolder2<T> {
1693: 1693:    private T obj;
1694: 1694:
1695: 1695:    public void set(T obj) {
1696: 1696:        this.obj = obj;
1697: 1697:    }
1698: 1698:
1699: 1699:    public T get() {
1700: 1700:        return obj;
1701: 1701:    }
1702: 1702:
1703: 1703:    public static void main(String[] args) {
1704: 1704:        GenericHolder2<String> holder =  new GenericHolder2<>();
1705: 1705:        holder.set("Item");
1706: 1706:        String s = holder.get();
1707: 1707:    }
1708: 1708:}
1709: 1709:```
1710: 1710:
1711: 1711:从 `get()` 返回后的转型消失了，但是我们还知道传递给 `set()` 的值在编译期会被检查。下面是相关的字节码：
1712: 1712:
1713: 1713:```java
1714: 1714:public void set(java.lang.Object);
1715: 1715:   0: aload_0
1716: 1716:   1: aload_1
1717: 1717:   2: putfield #2; // Field obj:Object;
1718: 1718:   5: return
1719: 1719:       
1720: 1720:public java.lang.Object get();
1721: 1721:   0: aload_0
1722: 1722:   1: getfield #2; // Field obj:Object;
1723: 1723:   4: areturn
1724: 1724:       
1725: 1725:public static void main(java.lang.String[]);
1726: 1726:   0: new #3; // class GenericHolder2
1727: 1727:   3: dup
1728: 1728:   4: invokespecial #4; // Method "<init>":()V
1729: 1729:   7: astore_1
1730: 1730:   8: aload_1
1731: 1731:   9: ldc #5; // String Item
1732: 1732:   11: invokevirtual #6; // Method set:(Object;)V
1733: 1733:   14: aload_1
1734: 1734:   15: invokevirtual #7; // Method get:()Object;
1735: 1735:   18: checkcast #8; // class java/lang/String
1736: 1736:   21: astore_2
1737: 1737:   22: return
1738: 1738:```
1739: 1739:
1740: 1740:所产生的字节码是相同的。对进入 `set()` 的类型进行检查是不需要的，因为这将由编译器执行。而对 `get()` 返回的值进行转型仍然是需要的，只不过不需要你来操作，它由编译器自动插入，这样你就不用编写（阅读）杂乱的代码。
1741: 1741:
1742: 1742:`get()` 和 `set()` 产生了相同的字节码，这就告诉我们泛型的所有动作都发生在边界处——对入参的编译器检查和对返回值的转型。这有助于澄清对擦除的困惑，记住：“边界就是动作发生的地方”。
1743: 1743:
1744: 1744:<!-- Compensating for Erasure -->
1745: 1745:
1746: 1746:## 补偿擦除
1747: 1747:
1748: 1748:因为擦除，我们将失去执行泛型代码中某些操作的能力。无法在运行时知道确切类型：
1749: 1749:
1750: 1750:```java
1751: 1751:// generics/Erased.java
1752: 1752:// {WillNotCompile}
1753: 1753:
1754: 1754:public class Erased<T> {
1755: 1755:    private final int SIZE = 100;
1756: 1756:
1757: 1757:    public void f(Object arg) {
1758: 1758:        // error: illegal generic type for instanceof
1759: 1759:        if (arg instanceof T) {
1760: 1760:        }
1761: 1761:        // error: unexpected type
1762: 1762:        T var = new T();
1763: 1763:        // error: generic array creation
1764: 1764:        T[] array = new T[SIZE];
1765: 1765:        // warning: [unchecked] unchecked cast
1766: 1766:        T[] array = (T[]) new Object[SIZE];
1767: 1767:
1768: 1768:    }
1769: 1769:}
1770: 1770:```
1771: 1771:
1772: 1772:有时，我们可以对这些问题进行编程，但是有时必须通过引入类型标签来补偿擦除。这意味着为所需的类型显式传递一个 **Class** 对象，以在类型表达式中使用它。
1773: 1773:
1774: 1774:例如，由于擦除了类型信息，因此在上一个程序中尝试使用 **instanceof** 将会失败。类型标签可以使用动态 `isInstance()` ：
1775: 1775:
1776: 1776:```java
1777: 1777:// generics/ClassTypeCapture.java
1778: 1778:
1779: 1779:class Building {
1780: 1780:}
1781: 1781:
1782: 1782:class House extends Building {
1783: 1783:}
1784: 1784:
1785: 1785:public class ClassTypeCapture<T> {
1786: 1786:    Class<T> kind;
1787: 1787:
1788: 1788:    public ClassTypeCapture(Class<T> kind) {
1789: 1789:        this.kind = kind;
1790: 1790:    }
1791: 1791:
1792: 1792:    public boolean f(Object arg) {
1793: 1793:        return kind.isInstance(arg);
1794: 1794:    }
1795: 1795:
1796: 1796:    public static void main(String[] args) {
1797: 1797:        ClassTypeCapture<Building> ctt1 =
1798: 1798:                new ClassTypeCapture<>(Building.class);
1799: 1799:        System.out.println(ctt1.f(new Building()));
1800: 1800:        System.out.println(ctt1.f(new House()));
1801: 1801:        ClassTypeCapture<House> ctt2 =
1802: 1802:                new ClassTypeCapture<>(House.class);
1803: 1803:        System.out.println(ctt2.f(new Building()));
1804: 1804:        System.out.println(ctt2.f(new House()));
1805: 1805:    }
1806: 1806:}
1807: 1807:/* Output:
1808: 1808:true
1809: 1809:true
1810: 1810:false
1811: 1811:true
1812: 1812:*/
1813: 1813:```
1814: 1814:
1815: 1815:编译器来保证类型标签与泛型参数相匹配。
1816: 1816:
1817: 1817:<!-- Creating Instances of Types -->
1818: 1818:
1819: 1819:### 创建类型的实例
1820: 1820:
1821: 1821:试图在 **Erased.java** 中 `new T()` 是行不通的，部分原因是由于擦除，部分原因是编译器无法验证 **T** 是否具有默认（无参）构造函数。但是在 C++ 中，此操作自然，直接且安全（在编译时检查）：
1822: 1822:
1823: 1823:```C++
1824: 1824:// generics/InstantiateGenericType.cpp
1825: 1825:// C++, not Java!
1826: 1826:
1827: 1827:template<class T> class Foo {
1828: 1828:  T x; // Create a field of type T
1829: 1829:  T* y; // Pointer to T
1830: 1830:public:
1831: 1831:  // Initialize the pointer:
1832: 1832:  Foo() { y = new T(); }
1833: 1833:};
1834: 1834:
1835: 1835:class Bar {};
1836: 1836:
1837: 1837:int main() {
1838: 1838:  Foo<Bar> fb;
1839: 1839:  Foo<int> fi; // ... and it works with primitives
1840: 1840:}
1841: 1841:```
1842: 1842:
1843: 1843:Java 中的解决方案是传入一个工厂对象，并使用该对象创建新实例。方便的工厂对象只是 **Class** 对象，因此，如果使用类型标记，则可以使用 `newInstance()` 创建该类型的新对象：
1844: 1844:
1845: 1845:```java
1846: 1846:// generics/InstantiateGenericType.java
1847: 1847:
1848: 1848:import java.util.function.Supplier;
1849: 1849:
1850: 1850:class ClassAsFactory<T> implements Supplier<T> {
1851: 1851:    Class<T> kind;
1852: 1852:
1853: 1853:    ClassAsFactory(Class<T> kind) {
1854: 1854:        this.kind = kind;
1855: 1855:    }
1856: 1856:
1857: 1857:    @Override
1858: 1858:    public T get() {
1859: 1859:        try {
1860: 1860:            return kind.newInstance();
1861: 1861:        } catch (InstantiationException |
1862: 1862:                IllegalAccessException e) {
1863: 1863:            throw new RuntimeException(e);
1864: 1864:        }
1865: 1865:    }
1866: 1866:}
1867: 1867:
1868: 1868:class Employee {
1869: 1869:    @Override
1870: 1870:    public String toString() {
1871: 1871:        return "Employee";
1872: 1872:    }
1873: 1873:}
1874: 1874:
1875: 1875:public class InstantiateGenericType {
1876: 1876:    public static void main(String[] args) {
1877: 1877:        ClassAsFactory<Employee> fe =
1878: 1878:                new ClassAsFactory<>(Employee.class);
1879: 1879:        System.out.println(fe.get());
1880: 1880:        ClassAsFactory<Integer> fi =
1881: 1881:                new ClassAsFactory<>(Integer.class);
1882: 1882:        try {
1883: 1883:            System.out.println(fi.get());
1884: 1884:        } catch (Exception e) {
1885: 1885:            System.out.println(e.getMessage());
1886: 1886:        }
1887: 1887:    }
1888: 1888:}
1889: 1889:/* Output:
1890: 1890:Employee
1891: 1891:java.lang.InstantiationException: java.lang.Integer
1892: 1892:*/
1893: 1893:```
1894: 1894:
1895: 1895:这样可以编译，但对于 `ClassAsFactory<Integer>` 会失败，这是因为 **Integer** 没有无参构造函数。由于错误不是在编译时捕获的，因此语言创建者不赞成这种方法。他们建议使用显式工厂（**Supplier**）并约束类型，以便只有实现该工厂的类可以这样创建对象。这是创建工厂的两种不同方法：
1896: 1896:
1897: 1897:```java
1898: 1898:// generics/FactoryConstraint.java
1899: 1899:
1900: 1900:import onjava.Suppliers;
1901: 1901:
1902: 1902:import java.util.ArrayList;
1903: 1903:import java.util.List;
1904: 1904:import java.util.function.Supplier;
1905: 1905:
1906: 1906:class IntegerFactory implements Supplier<Integer> {
1907: 1907:    private int i = 0;
1908: 1908:
1909: 1909:    @Override
1910: 1910:    public Integer get() {
1911: 1911:        return ++i;
1912: 1912:    }
1913: 1913:}
1914: 1914:
1915: 1915:class Widget {
1916: 1916:    private int id;
1917: 1917:
1918: 1918:    Widget(int n) {
1919: 1919:        id = n;
1920: 1920:    }
1921: 1921:
1922: 1922:    @Override
1923: 1923:    public String toString() {
1924: 1924:        return "Widget " + id;
1925: 1925:    }
1926: 1926:
1927: 1927:    public static
1928: 1928:    class Factory implements Supplier<Widget> {
1929: 1929:        private int i = 0;
1930: 1930:
1931: 1931:        @Override
1932: 1932:        public Widget get() {
1933: 1933:            return new Widget(++i);
1934: 1934:        }
1935: 1935:    }
1936: 1936:}
1937: 1937:
1938: 1938:class Fudge {
1939: 1939:    private static int count = 1;
1940: 1940:    private int n = count++;
1941: 1941:
1942: 1942:    @Override
1943: 1943:    public String toString() {
1944: 1944:        return "Fudge " + n;
1945: 1945:    }
1946: 1946:}
1947: 1947:
1948: 1948:class Foo2<T> {
1949: 1949:    private List<T> x = new ArrayList<>();
1950: 1950:
1951: 1951:    Foo2(Supplier<T> factory) {
1952: 1952:        Suppliers.fill(x, factory, 5);
1953: 1953:    }
1954: 1954:
1955: 1955:    @Override
1956: 1956:    public String toString() {
1957: 1957:        return x.toString();
1958: 1958:    }
1959: 1959:}
1960: 1960:
1961: 1961:public class FactoryConstraint {
1962: 1962:    public static void main(String[] args) {
1963: 1963:        System.out.println(
1964: 1964:                new Foo2<>(new IntegerFactory()));
1965: 1965:        System.out.println(
1966: 1966:                new Foo2<>(new Widget.Factory()));
1967: 1967:        System.out.println(
1968: 1968:                new Foo2<>(Fudge::new));
1969: 1969:    }
1970: 1970:}
1971: 1971:/* Output:
1972: 1972:[1, 2, 3, 4, 5]
1973: 1973:[Widget 1, Widget 2, Widget 3, Widget 4, Widget 5]
1974: 1974:[Fudge 1, Fudge 2, Fudge 3, Fudge 4, Fudge 5]
1975: 1975:*/
1976: 1976:```
1977: 1977:
1978: 1978:**IntegerFactory** 本身就是通过实现 `Supplier<Integer>` 的工厂。 **Widget** 包含一个内部类，它是一个工厂。还要注意，**Fudge** 并没有做任何类似于工厂的操作，并且传递 `Fudge::new` 仍然会产生工厂行为，因为编译器将对函数方法 `::new` 的调用转换为对 `get()` 的调用。
1979: 1979:
1980: 1980:另一种方法是模板方法设计模式。在以下示例中，`create()` 是模板方法，在子类中被重写以生成该类型的对象：
1981: 1981:
1982: 1982:```java
1983: 1983:// generics/CreatorGeneric.java
1984: 1984:
1985: 1985:abstract class GenericWithCreate<T> {
1986: 1986:    final T element;
1987: 1987:
1988: 1988:    GenericWithCreate() {
1989: 1989:        element = create();
1990: 1990:    }
1991: 1991:
1992: 1992:    abstract T create();
1993: 1993:}
1994: 1994:
1995: 1995:class X {
1996: 1996:}
1997: 1997:
1998: 1998:class XCreator extends GenericWithCreate<X> {
1999: 1999:    @Override
2000: 2000:    X create() {
2001: 2001:        return new X();
2002: 2002:    }
2003: 2003:
2004: 2004:    void f() {
2005: 2005:        System.out.println(
2006: 2006:                element.getClass().getSimpleName());
2007: 2007:    }
2008: 2008:}
2009: 2009:
2010: 2010:public class CreatorGeneric {
2011: 2011:    public static void main(String[] args) {
2012: 2012:        XCreator xc = new XCreator();
2013: 2013:        xc.f();
2014: 2014:    }
2015: 2015:}
2016: 2016:/* Output:
2017: 2017:X
2018: 2018:*/
2019: 2019:```
2020: 2020:
2021: 2021:**GenericWithCreate** 包含 `element` 字段，并通过无参构造函数强制其初始化，该构造函数又调用抽象的 `create()` 方法。这种创建方式可以在子类中定义，同时建立 **T** 的类型。
2022: 2022:
2023: 2023:<!-- Arrays of Generics -->
2024: 2024:
2025: 2025:### 泛型数组
2026: 2026:
2027: 2027:正如在 **Erased.java** 中所看到的，我们无法创建泛型数组。通用解决方案是在试图创建泛型数组的时候使用 **ArrayList** ：
2028: 2028:
2029: 2029:```java
2030: 2030:// generics/ListOfGenerics.java
2031: 2031:
2032: 2032:import java.util.ArrayList;
2033: 2033:import java.util.List;
2034: 2034:
2035: 2035:public class ListOfGenerics<T> {
2036: 2036:    private List<T> array = new ArrayList<>();
2037: 2037:
2038: 2038:    public void add(T item) {
2039: 2039:        array.add(item);
2040: 2040:    }
2041: 2041:
2042: 2042:    public T get(int index) {
2043: 2043:        return array.get(index);
2044: 2044:    }
2045: 2045:}
2046: 2046:```
2047: 2047:
2048: 2048:这样做可以获得数组的行为，并且还具有泛型提供的编译时类型安全性。
2049: 2049:
2050: 2050:有时，仍然会创建泛型类型的数组（例如， **ArrayList** 在内部使用数组）。可以通过使编译器满意的方式定义对数组的通用引用：
2051: 2051:
2052: 2052:```java
2053: 2053:// generics/ArrayOfGenericReference.java
2054: 2054:
2055: 2055:class Generic<T> {
2056: 2056:}
2057: 2057:
2058: 2058:public class ArrayOfGenericReference {
2059: 2059:    static Generic<Integer>[] gia;
2060: 2060:}
2061: 2061:```
2062: 2062:
2063: 2063:编译器接受此操作而不产生警告。但是我们永远无法创建具有该确切类型（包括类型参数）的数组，因此有点令人困惑。由于所有数组，无论它们持有什么类型，都具有相同的结构（每个数组插槽的大小和数组布局），因此似乎可以创建一个 **Object** 数组并将其转换为所需的数组类型。实际上，这确实可以编译，但是会产生 **ClassCastException** ：
2064: 2064:
2065: 2065:```java
2066: 2066:// generics/ArrayOfGeneric.java
2067: 2067:
2068: 2068:public class ArrayOfGeneric {
2069: 2069:    static final int SIZE = 100;
2070: 2070:    static Generic<Integer>[] gia;
2071: 2071:
2072: 2072:    @SuppressWarnings("unchecked")
2073: 2073:    public static void main(String[] args) {
2074: 2074:        try {
2075: 2075:            gia = (Generic<Integer>[]) new Object[SIZE];
2076: 2076:        } catch (ClassCastException e) {
2077: 2077:            System.out.println(e.getMessage());
2078: 2078:        }
2079: 2079:        // Runtime type is the raw (erased) type:
2080: 2080:        gia = (Generic<Integer>[]) new Generic[SIZE];
2081: 2081:        System.out.println(gia.getClass().getSimpleName());
2082: 2082:        gia[0] = new Generic<>();
2083: 2083:        //- gia[1] = new Object(); // Compile-time error
2084: 2084:        // Discovers type mismatch at compile time:
2085: 2085:        //- gia[2] = new Generic<Double>();
2086: 2086:    }
2087: 2087:}
2088: 2088:/* Output:
2089: 2089:[Ljava.lang.Object; cannot be cast to [LGeneric;
2090: 2090:Generic[]
2091: 2091:*/
2092: 2092:```
2093: 2093:
2094: 2094:问题在于数组会跟踪其实际类型，而该类型是在创建数组时建立的。因此，即使 `gia` 被强制转换为 `Generic<Integer>[]` ，该信息也仅在编译时存在（并且没有 **@SuppressWarnings** 注解，将会收到有关该强制转换的警告）。在运行时，它仍然是一个 **Object** 数组，这会引起问题。成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换。
2095: 2095:
2096: 2096:让我们看一个更复杂的示例。考虑一个包装数组的简单泛型包装器：
2097: 2097:
2098: 2098:```java
2099: 2099:// generics/GenericArray.java
2100: 2100:
2101: 2101:public class GenericArray<T> {
2102: 2102:    private T[] array;
2103: 2103:
2104: 2104:    @SuppressWarnings("unchecked")
2105: 2105:    public GenericArray(int sz) {
2106: 2106:        array = (T[]) new Object[sz];
2107: 2107:    }
2108: 2108:
2109: 2109:    public void put(int index, T item) {
2110: 2110:        array[index] = item;
2111: 2111:    }
2112: 2112:
2113: 2113:    public T get(int index) {
2114: 2114:        return array[index];
2115: 2115:    }
2116: 2116:
2117: 2117:    // Method that exposes the underlying representation:
2118: 2118:    public T[] rep() {
2119: 2119:        return array;
2120: 2120:    }
2121: 2121:
2122: 2122:    public static void main(String[] args) {
2123: 2123:        GenericArray<Integer> gai = new GenericArray<>(10);
2124: 2124:        try {
2125: 2125:            Integer[] ia = gai.rep();
2126: 2126:        } catch (ClassCastException e) {
2127: 2127:            System.out.println(e.getMessage());
2128: 2128:        }
2129: 2129:        // This is OK:
2130: 2130:        Object[] oa = gai.rep();
2131: 2131:    }
2132: 2132:}
2133: 2133:/* Output:
2134: 2134:[Ljava.lang.Object; cannot be cast to
2135: 2135:[Ljava.lang.Integer;
2136: 2136:*/
2137: 2137:```
2138: 2138:
2139: 2139:和以前一样，我们不能说 `T[] array = new T[sz]` ，所以我们创建了一个 **Object** 数组并将其强制转换。
2140: 2140:
2141: 2141:`rep()` 方法返回一个 `T[]` ，在主方法中它应该是 `gai` 的 `Integer[]`，但是如果调用它并尝试将结果转换为 `Integer[]` 引用，则会得到 **ClassCastException** ，这再次是因为实际的运行时类型为 `Object[]` 。
2142: 2142:
2143: 2143:如果再注释掉 **@SuppressWarnings** 注解后编译 **GenericArray.java** ，则编译器会产生警告：
2144: 2144:
2145: 2145:```java
2146: 2146:GenericArray.java uses unchecked or unsafe operations.
2147: 2147:Recompile with -Xlint:unchecked for details.
2148: 2148:```
2149: 2149:
2150: 2150:在这里，我们收到了一个警告，我们认为这是有关强制转换的。
2151: 2151:
2152: 2152:但是要真正确定，请使用 `-Xlint：unchecked` 进行编译：
2153: 2153:
2154: 2154:```java
2155: 2155:GenericArray.java:7: warning: [unchecked] unchecked cast    array = (T[])new Object[sz];                 ^  required: T[]  found:    Object[]  where T is a type-variable:    T extends Object declared in class GenericArray 1 warning
2156: 2156:```
2157: 2157:
2158: 2158:确实是在抱怨那个强制转换。由于警告会变成噪音，因此，一旦我们确认预期会出现特定警告，我们可以做的最好的办法就是使用 **@SuppressWarnings** 将其关闭。这样，当警告确实出现时，我们将进行实际调查。
2159: 2159:
2160: 2160:由于擦除，数组的运行时类型只能是 `Object[]` 。 如果我们立即将其转换为 `T[]` ，则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。因此，最好在集合中使用 `Object[]` ，并在使用数组元素时向 **T** 添加强制类型转换。让我们来看看在 **GenericArray.java** 示例中会是怎么样的：
2161: 2161:
2162: 2162:```java
2163: 2163:// generics/GenericArray2.java
2164: 2164:
2165: 2165:public class GenericArray2<T> {
2166: 2166:    private Object[] array;
2167: 2167:
2168: 2168:    public GenericArray2(int sz) {
2169: 2169:        array = new Object[sz];
2170: 2170:    }
2171: 2171:
2172: 2172:    public void put(int index, T item) {
2173: 2173:        array[index] = item;
2174: 2174:    }
2175: 2175:
2176: 2176:    @SuppressWarnings("unchecked")
2177: 2177:    public T get(int index) {
2178: 2178:        return (T) array[index];
2179: 2179:    }
2180: 2180:
2181: 2181:    @SuppressWarnings("unchecked")
2182: 2182:    public T[] rep() {
2183: 2183:        return (T[]) array; // Unchecked cast
2184: 2184:    }
2185: 2185:
2186: 2186:    public static void main(String[] args) {
2187: 2187:        GenericArray2<Integer> gai =
2188: 2188:                new GenericArray2<>(10);
2189: 2189:        for (int i = 0; i < 10; i++)
2190: 2190:            gai.put(i, i);
2191: 2191:        for (int i = 0; i < 10; i++)
2192: 2192:            System.out.print(gai.get(i) + " ");
2193: 2193:        System.out.println();
2194: 2194:        try {
2195: 2195:            Integer[] ia = gai.rep();
2196: 2196:        } catch (Exception e) {
2197: 2197:            System.out.println(e);
2198: 2198:        }
2199: 2199:    }
2200: 2200:}
2201: 2201:/* Output:
2202: 2202:0 1 2 3 4 5 6 7 8 9
2203: 2203:java.lang.ClassCastException: [Ljava.lang.Object;
2204: 2204:cannot be cast to [Ljava.lang.Integer;
2205: 2205:*/
2206: 2206:```
2207: 2207:
2208: 2208:最初，看起来并没有太大不同，只是转换的位置移动了。没有 **@SuppressWarnings** 注解，仍然会收到“unchecked”警告。但是，内部表示现在是 `Object[]` 而不是 `T[]` 。 调用 `get()` 时，它将对象强制转换为 **T** ，实际上这是正确的类型，因此很安全。但是，如果调用 `rep()` ，它将再次尝试将 `Object[]` 强制转换为 `T[]` ，但仍然不正确，并在编译时生成警告，并在运行时生成异常。因此，无法破坏基础数组的类型，该基础数组只能是 `Object[]` 。在内部将数组视为 `Object[]` 而不是 `T[]` 的优点是，我们不太可能会忘记数组的运行时类型并意外地引入了bug，尽管大多数（也许是全部）此类错误会在运行时被迅速检测到。
2209: 2209:
2210: 2210:对于新代码，请传入类型标记。在这种情况下，**GenericArray** 如下所示：
2211: 2211:
2212: 2212:```java
2213: 2213:// generics/GenericArrayWithTypeToken.java
2214: 2214:
2215: 2215:import java.lang.reflect.Array;
2216: 2216:
2217: 2217:public class GenericArrayWithTypeToken<T> {
2218: 2218:    private T[] array;
2219: 2219:
2220: 2220:    @SuppressWarnings("unchecked")
2221: 2221:    public GenericArrayWithTypeToken(Class<T> type, int sz) {
2222: 2222:        array = (T[]) Array.newInstance(type, sz);
2223: 2223:    }
2224: 2224:
2225: 2225:    public void put(int index, T item) {
2226: 2226:        array[index] = item;
2227: 2227:    }
2228: 2228:
2229: 2229:    public T get(int index) {
2230: 2230:        return array[index];
2231: 2231:    }
2232: 2232:
2233: 2233:    // Expose the underlying representation:
2234: 2234:    public T[] rep() {
2235: 2235:        return array;
2236: 2236:    }
2237: 2237:
2238: 2238:    public static void main(String[] args) {
2239: 2239:        GenericArrayWithTypeToken<Integer> gai =
2240: 2240:                new GenericArrayWithTypeToken<>(
2241: 2241:                        Integer.class, 10);
2242: 2242:        // This now works:
2243: 2243:        Integer[] ia = gai.rep();
2244: 2244:    }
2245: 2245:}
2246: 2246:```
2247: 2247:
2248: 2248:类型标记 **Class\<T\>** 被传递到构造函数中以从擦除中恢复，因此尽管必须使用 **@SuppressWarnings** 关闭来自强制类型转换的警告，但我们仍可以创建所需的实际数组类型。一旦获得了实际的类型，就可以返回它并产生所需的结果，如在主方法中看到的那样。数组的运行时类型是确切的类型 `T[]` 。
2249: 2249:
2250: 2250:不幸的是，如果查看 Java 标准库中的源代码，你会发现到处都有从 **Object** 数组到参数化类型的转换。例如，这是**ArrayList** 中，复制一个 **Collection** 的构造函数，这里为了简化，去除了源码中对此不重要的代码：
2251: 2251:
2252: 2252:```java
2253: 2253:public ArrayList(Collection c) {
2254: 2254:  size = c.size();
2255: 2255:  elementData = (E[])new Object[size];
2256: 2256:  c.toArray(elementData);
2257: 2257:}
2258: 2258:```
2259: 2259:
2260: 2260:如果你浏览 **ArrayList.java** 的代码，将会发现很多此类强制转换。当我们编译它时会发生什么？
2261: 2261:
2262: 2262:```java
2263: 2263:Note: ArrayList.java uses unchecked or unsafe operations
2264: 2264:Note: Recompile with -Xlint:unchecked for details.
2265: 2265:```
2266: 2266:
2267: 2267:果然，标准库会产生很多警告。如果你使用过 C 语言，尤其是使用 ANSI C 之前的语言，你会记住警告的特殊效果：发现警告后，可以忽略它们。因此，除非程序员必须对其进行处理，否则最好不要从编译器发出任何类型的消息。
2268: 2268:
2269: 2269:Neal Gafter（Java 5 的主要开发人员之一）在他的博客中[^2]指出，他在重写 Java 库时是很随意、马虎的，我们不应该像他那样做。Neal 还指出，他在不破坏现有接口的情况下无法修复某些 Java 库代码。因此，即使在 Java 库源代码中出现了一些习惯用法，它们也不一定是正确的做法。当查看库代码时，我们不能认为这就是要在自己代码中必须遵循的示例。
2270: 2270:
2271: 2271:请注意，在 Java 文献中推荐使用类型标记技术，例如 Gilad Bracha 的论文《Generics in the Java Programming Language》[^3]，他指出：“例如，这种用法已广泛用于新的 API 中以处理注解。” 我发现此技术在人们对于舒适度的看法方面存在一些不一致之处；有些人强烈喜欢本章前面介绍的工厂方法。
2272: 2272:
2273: 2273:<!-- Bounds -->
2274: 2274:
2275: 2275:## 边界
2276: 2276:
2277: 2277:*边界*（bounds）在本章的前面进行了简要介绍。边界允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法。
2278: 2278:
2279: 2279:由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 **Object** 可用的方法。但是，如果将该参数限制为某类型的子集，则可以调用该子集中的方法。为了应用约束，Java 泛型使用了 `extends` 关键字。
2280: 2280:
2281: 2281:重要的是要理解，当用于限定泛型类型时，`extends` 的含义与通常的意义截然不同。此示例展示边界的基础应用：
2282: 2282:
2283: 2283:```java
2284: 2284:// generics/BasicBounds.java
2285: 2285:
2286: 2286:interface HasColor {
2287: 2287:    java.awt.Color getColor();
2288: 2288:}
2289: 2289:
2290: 2290:class WithColor<T extends HasColor> {
2291: 2291:    T item;
2292: 2292:
2293: 2293:    WithColor(T item) {
2294: 2294:        this.item = item;
2295: 2295:    }
2296: 2296:
2297: 2297:    T getItem() {
2298: 2298:        return item;
2299: 2299:    }
2300: 2300:
2301: 2301:    // The bound allows you to call a method:
2302: 2302:    java.awt.Color color() {
2303: 2303:        return item.getColor();
2304: 2304:    }
2305: 2305:}
2306: 2306:
2307: 2307:class Coord {
2308: 2308:    public int x, y, z;
2309: 2309:}
2310: 2310:
2311: 2311:// This fails. Class must be first, then interfaces:
2312: 2312:// class WithColorCoord<T extends HasColor & Coord> {
2313: 2313:
2314: 2314:// Multiple bounds:
2315: 2315:class WithColorCoord<T extends Coord & HasColor> {
2316: 2316:    T item;
2317: 2317:
2318: 2318:    WithColorCoord(T item) {
2319: 2319:        this.item = item;
2320: 2320:    }
2321: 2321:
2322: 2322:    T getItem() {
2323: 2323:        return item;
2324: 2324:    }
2325: 2325:
2326: 2326:    java.awt.Color color() {
2327: 2327:        return item.getColor();
2328: 2328:    }
2329: 2329:
2330: 2330:    int getX() {
2331: 2331:        return item.x;
2332: 2332:    }
2333: 2333:
2334: 2334:    int getY() {
2335: 2335:        return item.y;
2336: 2336:    }
2337: 2337:
2338: 2338:    int getZ() {
2339: 2339:        return item.z;
2340: 2340:    }
2341: 2341:}
2342: 2342:
2343: 2343:interface Weight {
2344: 2344:    int weight();
2345: 2345:}
2346: 2346:
2347: 2347:// As with inheritance, you can have only one
2348: 2348:// concrete class but multiple interfaces:
2349: 2349:class Solid<T extends Coord & HasColor & Weight> {
2350: 2350:    T item;
2351: 2351:
2352: 2352:    Solid(T item) {
2353: 2353:        this.item = item;
2354: 2354:    }
2355: 2355:
2356: 2356:    T getItem() {
2357: 2357:        return item;
2358: 2358:    }
2359: 2359:
2360: 2360:    java.awt.Color color() {
2361: 2361:        return item.getColor();
2362: 2362:    }
2363: 2363:
2364: 2364:    int getX() {
2365: 2365:        return item.x;
2366: 2366:    }
2367: 2367:
2368: 2368:    int getY() {
2369: 2369:        return item.y;
2370: 2370:    }
2371: 2371:
2372: 2372:    int getZ() {
2373: 2373:        return item.z;
2374: 2374:    }
2375: 2375:
2376: 2376:    int weight() {
2377: 2377:        return item.weight();
2378: 2378:    }
2379: 2379:}
2380: 2380:
2381: 2381:class Bounded
2382: 2382:        extends Coord implements HasColor, Weight {
2383: 2383:    @Override
2384: 2384:    public java.awt.Color getColor() {
2385: 2385:        return null;
2386: 2386:    }
2387: 2387:
2388: 2388:    @Override
2389: 2389:    public int weight() {
2390: 2390:        return 0;
2391: 2391:    }
2392: 2392:}
2393: 2393:
2394: 2394:public class BasicBounds {
2395: 2395:    public static void main(String[] args) {
2396: 2396:        Solid<Bounded> solid =
2397: 2397:                new Solid<>(new Bounded());
2398: 2398:        solid.color();
2399: 2399:        solid.getY();
2400: 2400:        solid.weight();
2401: 2401:    }
2402: 2402:}
2403: 2403:```
2404: 2404:
2405: 2405:你可能会观察到 **BasicBounds.java** 中似乎包含一些冗余，它们可以通过继承来消除。在这里，每个继承级别还添加了边界约束：
2406: 2406:
2407: 2407:```java
2408: 2408:// generics/InheritBounds.java
2409: 2409:
2410: 2410:class HoldItem<T> {
2411: 2411:    T item;
2412: 2412:
2413: 2413:    HoldItem(T item) {
2414: 2414:        this.item = item;
2415: 2415:    }
2416: 2416:
2417: 2417:    T getItem() {
2418: 2418:        return item;
2419: 2419:    }
2420: 2420:}
2421: 2421:
2422: 2422:class WithColor2<T extends HasColor>
2423: 2423:        extends HoldItem<T> {
2424: 2424:    WithColor2(T item) {
2425: 2425:        super(item);
2426: 2426:    }
2427: 2427:
2428: 2428:    java.awt.Color color() {
2429: 2429:        return item.getColor();
2430: 2430:    }
2431: 2431:}
2432: 2432:
2433: 2433:class WithColorCoord2<T extends Coord & HasColor>
2434: 2434:        extends WithColor2<T> {
2435: 2435:    WithColorCoord2(T item) {
2436: 2436:        super(item);
2437: 2437:    }
2438: 2438:
2439: 2439:    int getX() {
2440: 2440:        return item.x;
2441: 2441:    }
2442: 2442:
2443: 2443:    int getY() {
2444: 2444:        return item.y;
2445: 2445:    }
2446: 2446:
2447: 2447:    int getZ() {
2448: 2448:        return item.z;
2449: 2449:    }
2450: 2450:}
2451: 2451:
2452: 2452:class Solid2<T extends Coord & HasColor & Weight>
2453: 2453:        extends WithColorCoord2<T> {
2454: 2454:    Solid2(T item) {
2455: 2455:        super(item);
2456: 2456:    }
2457: 2457:
2458: 2458:    int weight() {
2459: 2459:        return item.weight();
2460: 2460:    }
2461: 2461:}
2462: 2462:
2463: 2463:public class InheritBounds {
2464: 2464:    public static void main(String[] args) {
2465: 2465:        Solid2<Bounded> solid2 =
2466: 2466:                new Solid2<>(new Bounded());
2467: 2467:        solid2.color();
2468: 2468:        solid2.getY();
2469: 2469:        solid2.weight();
2470: 2470:    }
2471: 2471:}
2472: 2472:```
2473: 2473:
2474: 2474:**HoldItem** 拥有一个对象，因此此行为将继承到 **WithColor2** 中，这也需要其参数符合 **HasColor**。 **WithColorCoord2** 和 **Solid2** 进一步扩展了层次结构，并在每个级别添加了边界。现在，这些方法已被继承，并且在每个类中不再重复。
2475: 2475:
2476: 2476:这是一个具有更多层次的示例：
2477: 2477:
2478: 2478:```java
2479: 2479:// generics/EpicBattle.java
2480: 2480:// Bounds in Java generics
2481: 2481:
2482: 2482:import java.util.List;
2483: 2483:
2484: 2484:interface SuperPower {
2485: 2485:}
2486: 2486:
2487: 2487:interface XRayVision extends SuperPower {
2488: 2488:    void seeThroughWalls();
2489: 2489:}
2490: 2490:
2491: 2491:interface SuperHearing extends SuperPower {
2492: 2492:    void hearSubtleNoises();
2493: 2493:}
2494: 2494:
2495: 2495:interface SuperSmell extends SuperPower {
2496: 2496:    void trackBySmell();
2497: 2497:}
2498: 2498:
2499: 2499:class SuperHero<POWER extends SuperPower> {
2500: 2500:    POWER power;
2501: 2501:
2502: 2502:    SuperHero(POWER power) {
2503: 2503:        this.power = power;
2504: 2504:    }
2505: 2505:
2506: 2506:    POWER getPower() {
2507: 2507:        return power;
2508: 2508:    }
2509: 2509:}
2510: 2510:
2511: 2511:class SuperSleuth<POWER extends XRayVision>
2512: 2512:        extends SuperHero<POWER> {
2513: 2513:    SuperSleuth(POWER power) {
2514: 2514:        super(power);
2515: 2515:    }
2516: 2516:
2517: 2517:    void see() {
2518: 2518:        power.seeThroughWalls();
2519: 2519:    }
2520: 2520:}
2521: 2521:
2522: 2522:class
2523: 2523:CanineHero<POWER extends SuperHearing & SuperSmell>
2524: 2524:        extends SuperHero<POWER> {
2525: 2525:    CanineHero(POWER power) {
2526: 2526:        super(power);
2527: 2527:    }
2528: 2528:
2529: 2529:    void hear() {
2530: 2530:        power.hearSubtleNoises();
2531: 2531:    }
2532: 2532:
2533: 2533:    void smell() {
2534: 2534:        power.trackBySmell();
2535: 2535:    }
2536: 2536:}
2537: 2537:
2538: 2538:class SuperHearSmell
2539: 2539:        implements SuperHearing, SuperSmell {
2540: 2540:    @Override
2541: 2541:    public void hearSubtleNoises() {
2542: 2542:    }
2543: 2543:
2544: 2544:    @Override
2545: 2545:    public void trackBySmell() {
2546: 2546:    }
2547: 2547:}
2548: 2548:
2549: 2549:class DogPerson extends CanineHero<SuperHearSmell> {
2550: 2550:    DogPerson() {
2551: 2551:        super(new SuperHearSmell());
2552: 2552:    }
2553: 2553:}
2554: 2554:
2555: 2555:public class EpicBattle {
2556: 2556:    // Bounds in generic methods:
2557: 2557:    static <POWER extends SuperHearing>
2558: 2558:    void useSuperHearing(SuperHero<POWER> hero) {
2559: 2559:        hero.getPower().hearSubtleNoises();
2560: 2560:    }
2561: 2561:
2562: 2562:    static <POWER extends SuperHearing & SuperSmell>
2563: 2563:    void superFind(SuperHero<POWER> hero) {
2564: 2564:        hero.getPower().hearSubtleNoises();
2565: 2565:        hero.getPower().trackBySmell();
2566: 2566:    }
2567: 2567:
2568: 2568:    public static void main(String[] args) {
2569: 2569:        DogPerson dogPerson = new DogPerson();
2570: 2570:        useSuperHearing(dogPerson);
2571: 2571:        superFind(dogPerson);
2572: 2572:        // You can do this:
2573: 2573:        List<? extends SuperHearing> audioPeople;
2574: 2574:        // But you can't do this:
2575: 2575:        // List<? extends SuperHearing & SuperSmell> dogPs;
2576: 2576:    }
2577: 2577:}
2578: 2578:```
2579: 2579:
2580: 2580:接下来将要研究的通配符将会把范围限制在单个类型。
2581: 2581:
2582: 2582:<!-- Wildcards -->
2583: 2583:
2584: 2584:## 通配符
2585: 2585:
2586: 2586:你已经在 [集合](book/12-Collections.md) 章节中看到了一些简单示例使用了通配符——在泛型参数表达式中的问号，在 [类型信息](book/19-Type-Information.md) 一章中这种示例更多。本节将更深入地探讨这个特性。
2587: 2587:
2588: 2588:我们的起始示例要展示数组的一种特殊行为：你可以将派生类的数组赋值给基类的引用：
2589: 2589:
2590: 2590:```java
2591: 2591:// generics/CovariantArrays.java
2592: 2592:
2593: 2593:class Fruit {}
2594: 2594:
2595: 2595:class Apple extends Fruit {}
2596: 2596:
2597: 2597:class Jonathan extends Apple {}
2598: 2598:
2599: 2599:class Orange extends Fruit {}
2600: 2600:
2601: 2601:public class CovariantArrays {
2602: 2602:    
2603: 2603:    public static void main(String[] args) {
2604: 2604:        Fruit[] fruit = new Apple[10];
2605: 2605:        fruit[0] = new Apple(); // OK
2606: 2606:        fruit[1] = new Jonathan(); // OK
2607: 2607:        // Runtime type is Apple[], not Fruit[] or Orange[]:
2608: 2608:        try {
2609: 2609:            // Compiler allows you to add Fruit:
2610: 2610:            fruit[0] = new Fruit(); // ArrayStoreException
2611: 2611:        } catch (Exception e) {
2612: 2612:            System.out.println(e);
2613: 2613:        }
2614: 2614:        try {
2615: 2615:            // Compiler allows you to add Oranges:
2616: 2616:            fruit[0] = new Orange(); // ArrayStoreException
2617: 2617:        } catch (Exception e) {
2618: 2618:            System.out.println(e);
2619: 2619:        }
2620: 2620:    }
2621: 2621:}
2622: 2622:/* Output:
2623: 2623:java.lang.ArrayStoreException: Fruit
2624: 2624:java.lang.ArrayStoreException: Orange
2625: 2625:```
2626: 2626:
2627: 2627:`main()` 中的第一行创建了 **Apple** 数组，并赋值给一个 **Fruit** 数组引用。这是有意义的，因为 **Apple** 也是一种 **Fruit**，因此 **Apple** 数组应该也是一个 **Fruit** 数组。
2628: 2628:
2629: 2629:但是，如果实际的数组类型是 **Apple[]**，你可以在其中放置 **Apple** 或 **Apple** 的子类型，这在编译期和运行时都可以工作。但是你也可以在数组中放置 **Fruit** 对象。这对编译器来说是有意义的，因为它有一个 **Fruit[]** 引用——它有什么理由不允许将 **Fruit** 对象或任何从 **Fruit** 继承出来的对象（比如 **Orange**），放置到这个数组中呢？因此在编译期，这是允许的。然而，运行时的数组机制知道它处理的是 **Apple[]**，因此会在向数组中放置异构类型时抛出异常。
2630: 2630:
2631: 2631:向上转型用在这里不合适。你真正在做的是将一个数组赋值给另一个数组。数组的行为是持有其他对象，这里只是因为我们能够向上转型而已，所以很明显，数组对象可以保留有关它们包含的对象类型的规则。看起来就像数组对它们持有的对象是有意识的，因此在编译期检查和运行时检查之间，你不能滥用它们。
2632: 2632:
2633: 2633:数组的这种赋值并不是那么可怕，因为在运行时你可以发现插入了错误的类型。但是泛型的主要目标之一是将这种错误检测移到编译期。所以当我们试图使用泛型集合代替数组时，会发生什么呢？
2634: 2634:
2635: 2635:```java
2636: 2636:// generics/NonCovariantGenerics.java
2637: 2637:// {WillNotCompile}
2638: 2638:
2639: 2639:import java.util.*;
2640: 2640:
2641: 2641:public class NonCovariantGenerics {
2642: 2642:    // Compile Error: incompatible types:
2643: 2643:    List<Fruit> flist = new ArrayList<Apple>();
2644: 2644:}
2645: 2645:```
2646: 2646:
2647: 2647:尽管你在首次阅读这段代码时会认为“不能将一个 **Apple** 集合赋值给一个 **Fruit** 集合”。记住，泛型不仅仅是关于集合，它真正要表达的是“不能把一个涉及 **Apple** 的泛型赋值给一个涉及 **Fruit** 的泛型”。如果像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及到的集合，那么它可能会留下一些余地。但是它不知道任何有关这方面的信息，因此它拒绝向上转型。然而实际上这也不是向上转型—— **Apple** 的 **List** 不是 **Fruit** 的 **List**。**Apple** 的 **List** 将持有 **Apple** 和 **Apple** 的子类型，**Fruit** 的 **List** 将持有任何类型的 **Fruit**。是的，这包括 **Apple**，但是它不是一个 **Apple** 的 **List**，它仍然是 **Fruit** 的 **List**。**Apple** 的 **List** 在类型上不等价于 **Fruit** 的 **List**，即使 **Apple** 是一种 **Fruit** 类型。
2648: 2648:
2649: 2649:真正的问题是我们在讨论的集合类型，而不是集合持有对象的类型。与数组不同，泛型没有内建的协变类型。这是因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查，但是在使用泛型时，编译器和运行时系统不知道你想用类型做什么，以及应该采用什么规则。
2650: 2650:
2651: 2651:但是，有时你想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。
2652: 2652:
2653: 2653:```java
2654: 2654:// generics/GenericsAndCovariance.java
2655: 2655:
2656: 2656:import java.util.*;
2657: 2657:
2658: 2658:public class GenericsAndCovariance {
2659: 2659:    
2660: 2660:    public static void main(String[] args) {
2661: 2661:        // Wildcards allow covariance:
2662: 2662:        List<? extends Fruit> flist = new ArrayList<>();
2663: 2663:        // Compile Error: can't add any type of object:
2664: 2664:        // flist.add(new Apple());
2665: 2665:        // flist.add(new Fruit());
2666: 2666:        // flist.add(new Object());
2667: 2667:        flist.add(null); // Legal but uninteresting
2668: 2668:        // We know it returns at least Fruit:
2669: 2669:        Fruit f = flist.get(0);
2670: 2670:    }
2671: 2671:    
2672: 2672:}
2673: 2673:```
2674: 2674:
2675: 2675:**flist** 的类型现在是 `List<? extends Fruit>`，你可以读作“一个具有任何从 **Fruit** 继承的类型的列表”。然而，这实际上并不意味着这个 **List** 将持有任何类型的 **Fruit**。通配符引用的是明确的类型，因此它意味着“某种 **flist** 引用没有指定的具体类型”。因此这个被赋值的 **List** 必须持有诸如 **Fruit** 或 **Apple** 这样的指定类型，但是为了向上转型为 **Fruit**，这个类型是什么没人在意。
2676: 2676:
2677: 2677:**List** 必须持有一种具体的 **Fruit** 或 **Fruit** 的子类型，但是如果你不关心具体的类型是什么，那么你能对这样的 **List** 做什么呢？如果不知道 **List** 中持有的对象是什么类型，你怎能保证安全地向其中添加对象呢？就像在 **CovariantArrays.java** 中向上转型一样，你不能，除非编译器而不是运行时系统可以阻止这种操作的发生。你很快就会发现这个问题。
2678: 2678:
2679: 2679:你可能认为事情开始变得有点走极端了，因为现在你甚至不能向刚刚声明过将持有 **Apple** 对象的 **List** 中放入一个 **Apple** 对象。是的，但编译器并不知道这一点。`List<? extends Fruit>` 可能合法地指向一个 `List<Orange>`。一旦执行这种类型的向上转型，你就丢失了向其中传递任何对象的能力，甚至传递 **Object** 也不行。
2680: 2680:
2681: 2681:另一方面，如果你调用了一个返回 **Fruit** 的方法，则是安全的，因为你知道这个 **List** 中的任何对象至少具有 **Fruit** 类型，因此编译器允许这么做。
2682: 2682:
2683: 2683:### 编译器有多聪明
2684: 2684:
2685: 2685:现在你可能会猜想自己不能去调用任何接受参数的方法，但是考虑下面的代码：
2686: 2686:
2687: 2687:```java
2688: 2688:// generics/CompilerIntelligence.java
2689: 2689:
2690: 2690:import java.util.*;
2691: 2691:
2692: 2692:public class CompilerIntelligence {
2693: 2693:    
2694: 2694:    public static void main(String[] args) {
2695: 2695:        List<? extends Fruit> flist = Arrays.asList(new Apple());
2696: 2696:        Apple a = (Apple) flist.get(0); // No warning
2697: 2697:        flist.contains(new Apple()); // Argument is 'Object'
2698: 2698:        flist.indexOf(new Apple()); // Argument is 'Object'
2699: 2699:    }
2700: 2700:    
2701: 2701:}
2702: 2702:```
2703: 2703:
2704: 2704:这里对 `contains()` 和 `indexOf()` 的调用接受 **Apple** 对象作为参数，执行没问题。这是否意味着编译器实际上会检查代码，以查看是否有某个特定的方法修改了它的对象？
2705: 2705:
2706: 2706:通过查看 **ArrayList** 的文档，我们发现编译器没有那么聪明。尽管 `add()` 接受一个泛型参数类型的参数，但 `contains()` 和 `indexOf()` 接受的参数类型是 **Object**。因此当你指定一个 `ArrayList<? extends Fruit>` 时，`add()` 的参数就变成了"**? extends Fruit**"。从这个描述中，编译器无法得知这里需要 **Fruit** 的哪个具体子类型，因此它不会接受任何类型的 **Fruit**。如果你先把 **Apple** 向上转型为 **Fruit**，也没有关系——编译器仅仅会拒绝调用像 `add()` 这样参数列表中涉及通配符的方法。
2707: 2707:
2708: 2708:`contains()` 和 `indexOf()` 的参数类型是 **Object**，不涉及通配符，所以编译器允许调用它们。这意味着将由泛型类的设计者来决定哪些调用是“安全的”，并使用 **Object** 类作为它们的参数类型。为了禁止对类型中使用了通配符的方法调用，需要在参数列表中使用类型参数。
2709: 2709:
2710: 2710:下面展示一个简单的 **Holder** 类：
2711: 2711:
2712: 2712:```java
2713: 2713:// generics/Holder.java
2714: 2714:
2715: 2715:public class Holder<T> {
2716: 2716:
2717: 2717:    private T value;
2718: 2718:
2719: 2719:    public Holder() {}
2720: 2720:
2721: 2721:    public Holder(T val) {
2722: 2722:        value = val;
2723: 2723:    }
2724: 2724:
2725: 2725:    public void set(T val) {
2726: 2726:        value = val;
2727: 2727:    }
2728: 2728:
2729: 2729:    public T get() {
2730: 2730:        return value;
2731: 2731:    }
2732: 2732:
2733: 2733:    @Override
2734: 2734:    public boolean equals(Object o) {
2735: 2735:        return o instanceof Holder && Objects.equals(value, ((Holder) o).value);
2736: 2736:    }
2737: 2737:
2738: 2738:    @Override
2739: 2739:    public int hashCode() {
2740: 2740:        return Objects.hashCode(value);
2741: 2741:    }
2742: 2742:
2743: 2743:    public static void main(String[] args) {
2744: 2744:        Holder<Apple> apple = new Holder<>(new Apple());
2745: 2745:        Apple d = apple.get();
2746: 2746:        apple.set(d);
2747: 2747:        // Holder<Fruit> fruit = apple; // Cannot upcast
2748: 2748:        Holder<? extends Fruit> fruit = apple; // OK
2749: 2749:        Fruit p = fruit.get();
2750: 2750:        d = (Apple) fruit.get();
2751: 2751:        try {
2752: 2752:            Orange c = (Orange) fruit.get(); // No warning
2753: 2753:        } catch (Exception e) {
2754: 2754:            System.out.println(e);
2755: 2755:        }
2756: 2756:        // fruit.set(new Apple()); // Cannot call set()
2757: 2757:        // fruit.set(new Fruit()); // Cannot call set()
2758: 2758:        System.out.println(fruit.equals(d)); // OK
2759: 2759:    }
2760: 2760:}
2761: 2761:/* Output
2762: 2762:java.lang.ClassCastException: Apple cannot be cast to Orange
2763: 2763:false
2764: 2764:*/
2765: 2765:```
2766: 2766:
2767: 2767:**Holder** 有一个接受 **T** 类型对象的 `set()` 方法，一个返回 T 对象的 `get()` 方法和一个接受 Object 对象的 `equals()` 方法。正如你所见，如果创建了一个 `Holder<Apple>`，就不能将其向上转型为 `Holder<Fruit>`，但是可以向上转型为 `Holder<? extends Fruit>`。如果调用 `get()`，只能返回一个 **Fruit**——这就是在给定“任何扩展自 **Fruit** 的对象”这一边界后，它所能知道的一切了。如果你知道更多的信息，就可以将其转型到某种具体的 **Fruit** 而不会导致任何警告，但是存在得到 **ClassCastException** 的风险。`set()` 方法不能工作在 **Apple** 和 **Fruit** 上，因为 `set()` 的参数也是"**? extends Fruit**"，意味着它可以是任何事物，编译器无法验证“任何事物”的类型安全性。
2768: 2768:
2769: 2769:但是，`equals()` 方法可以正常工作，因为它接受的参数是 **Object** 而不是 **T** 类型。因此，编译器只关注传递进来和要返回的对象类型。它不会分析代码，以查看是否执行了任何实际的写入和读取操作。
2770: 2770:
2771: 2771:Java 7 引入了 **java.util.Objects** 库，使创建 `equals()` 和 `hashCode()` 方法变得更加容易，当然还有很多其他功能。`equals()` 方法的标准形式参考 [附录：理解 equals 和 hashCode 方法](book/Appendix-Understanding-equals-and-hashCode) 一章。
2772: 2772:
2773: 2773:### 逆变
2774: 2774:
2775: 2775:还可以走另外一条路，即使用超类型通配符。这里，可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 `<？super MyClass>` ，或者甚至使用类型参数： `<？super T>`（尽管你不能对泛型参数给出一个超类型边界；即不能声明 `<T super MyClass>` ）。这使得你可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，就可以向 **Collection** 写入了：
2776: 2776:
2777: 2777:```java
2778: 2778:// generics/SuperTypeWildcards.java
2779: 2779:import java.util.*;
2780: 2780:public class SuperTypeWildcards {
2781: 2781:    static void writeTo(List<? super Apple> apples) {
2782: 2782:        apples.add(new Apple());
2783: 2783:        apples.add(new Jonathan());
2784: 2784:        // apples.add(new Fruit()); // Error
2785: 2785:    }
2786: 2786:}
2787: 2787:```
2788: 2788:
2789: 2789:参数 **apples** 是 **Apple** 的某种基类型的 **List**，这样你就知道向其中添加 **Apple** 或 **Apple** 的子类型是安全的。但是因为 **Apple** 是下界，所以你知道向这样的 **List** 中添加 **Fruit** 是不安全的，因为这将使这个 **List** 敞开口子，从而可以向其中添加非 **Apple** 类型的对象，而这是违反静态类型安全的。
2790: 2790:下面的示例复习了一下逆变和通配符的的使用：
2791: 2791:
2792: 2792:```java
2793: 2793:// generics/GenericReading.java
2794: 2794:import java.util.*;
2795: 2795:
2796: 2796:public class GenericReading {
2797: 2797:    static List<Apple> apples = Arrays.asList(new Apple());
2798: 2798:    static List<Fruit> fruit = Arrays.asList(new Fruit());
2799: 2799:    
2800: 2800:    static <T> T readExact(List<T> list) {
2801: 2801:        return list.get(0);
2802: 2802:    }
2803: 2803:    
2804: 2804:    // A static method adapts to each call:
2805: 2805:    static void f1() {
2806: 2806:        Apple a = readExact(apples);
2807: 2807:        Fruit f = readExact(fruit);
2808: 2808:        f = readExact(apples);
2809: 2809:    }
2810: 2810:    
2811: 2811:    // A class type is established
2812: 2812:    // when the class is instantiated:
2813: 2813:    static class Reader<T> {
2814: 2814:        T readExact(List<T> list) { 
2815: 2815:            return list.get(0); 
2816: 2816:        }
2817: 2817:    }
2818: 2818:    
2819: 2819:    static void f2() {
2820: 2820:        Reader<Fruit> fruitReader = new Reader<>();
2821: 2821:        Fruit f = fruitReader.readExact(fruit);
2822: 2822:        //- Fruit a = fruitReader.readExact(apples);
2823: 2823:        // error: incompatible types: List<Apple>
2824: 2824:        // cannot be converted to List<Fruit>
2825: 2825:    }
2826: 2826:    
2827: 2827:    static class CovariantReader<T> {
2828: 2828:        T readCovariant(List<? extends T> list) {
2829: 2829:            return list.get(0);
2830: 2830:        }
2831: 2831:    }
2832: 2832:    
2833: 2833:    static void f3() {
2834: 2834:        CovariantReader<Fruit> fruitReader = new CovariantReader<>();
2835: 2835:        Fruit f = fruitReader.readCovariant(fruit);
2836: 2836:        Fruit a = fruitReader.readCovariant(apples);
2837: 2837:    }
2838: 2838:    
2839: 2839:    public static void main(String[] args) {
2840: 2840:        f1(); 
2841: 2841:        f2(); 
2842: 2842:        f3();
2843: 2843:    }
2844: 2844:}
2845: 2845:```
2846: 2846:
2847: 2847:`readExact()` 方法使用了精确的类型。如果使用这个没有任何通配符的精确类型，就可以向 **List** 中写入和读取这个精确类型。另外，对于返回值，静态的泛型方法 `readExact()` 可以有效地“适应”每个方法调用，并能够从 `List<Apple>` 中返回一个 **Apple** ，从 `List<Fruit>` 中返回一个 **Fruit** ，就像在 `f1()` 中看到的那样。因此，如果可以摆脱静态泛型方法，那么在读取时就不需要协变类型了。
2848: 2848:然而对于泛型类来说，当你创建这个类的实例时，就要为这个类确定参数。就像在 `f2()` 中看到的，**fruitReader** 实例可以从 `List<Fruit>` 中读取一个 **Fruit** ，因为这就是它的确切类型。但是 `List<Apple>` 也应该产生 **Fruit** 对象，而 **fruitReader** 不允许这么做。
2849: 2849:为了修正这个问题，`CovariantReader.readCovariant()` 方法将接受 `List<？extends T>` ，因此，从这个列表中读取一个 **T** 是安全的（你知道在这个列表中的所有对象至少是一个 **T** ，并且可能是从 T 导出的某种对象）。在 `f3()` 中，你可以看到现在可以从 `List<Apple>` 中读取 **Fruit** 了。
2850: 2850:
2851: 2851:### 无界通配符
2852: 2852:
2853: 2853:无界通配符 `<?>` 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器初看起来是支持这种判断的：
2854: 2854:
2855: 2855:```java
2856: 2856:// generics/UnboundedWildcards1.java
2857: 2857:import java.util.*;
2858: 2858:
2859: 2859:public class UnboundedWildcards1 {
2860: 2860:    static List list1;
2861: 2861:    static List<?> list2;
2862: 2862:    static List<? extends Object> list3;
2863: 2863:  
2864: 2864:    static void assign1(List list) {
2865: 2865:        list1 = list;
2866: 2866:        list2 = list;
2867: 2867:        //- list3 = list;
2868: 2868:        // warning: [unchecked] unchecked conversion
2869: 2869:        // list3 = list;
2870: 2870:        //         ^
2871: 2871:        // required: List<? extends Object>
2872: 2872:        // found:    List
2873: 2873:    }
2874: 2874:    
2875: 2875:    static void assign2(List<?> list) {
2876: 2876:        list1 = list;
2877: 2877:        list2 = list;
2878: 2878:        list3 = list;
2879: 2879:    }
2880: 2880:    
2881: 2881:    static void assign3(List<? extends Object> list) {
2882: 2882:        list1 = list;
2883: 2883:        list2 = list;
2884: 2884:        list3 = list;
2885: 2885:    }
2886: 2886:    
2887: 2887:    public static void main(String[] args) {
2888: 2888:        assign1(new ArrayList());
2889: 2889:        assign2(new ArrayList());
2890: 2890:        //- assign3(new ArrayList());
2891: 2891:        // warning: [unchecked] unchecked method invocation:
2892: 2892:        // method assign3 in class UnboundedWildcards1
2893: 2893:        // is applied to given types
2894: 2894:        // assign3(new ArrayList());
2895: 2895:        //        ^
2896: 2896:        // required: List<? extends Object>
2897: 2897:        // found: ArrayList
2898: 2898:        // warning: [unchecked] unchecked conversion
2899: 2899:        // assign3(new ArrayList());
2900: 2900:        //         ^
2901: 2901:        // required: List<? extends Object>
2902: 2902:        // found:    ArrayList
2903: 2903:        // 2 warnings
2904: 2904:        assign1(new ArrayList<>());
2905: 2905:        assign2(new ArrayList<>());
2906: 2906:        assign3(new ArrayList<>());
2907: 2907:        // Both forms are acceptable as List<?>:
2908: 2908:        List<?> wildList = new ArrayList();
2909: 2909:        wildList = new ArrayList<>();
2910: 2910:        assign1(wildList);
2911: 2911:        assign2(wildList);
2912: 2912:        assign3(wildList);
2913: 2913:    }
2914: 2914:}
2915: 2915:```
2916: 2916:
2917: 2917:有很多情况都和你在这里看到的情况类似，即编译器很少关心使用的是原生类型还是 `<?>` 。在这些情况中，`<?>` 可以被认为是一种装饰，但是它仍旧是很有价值的，因为，实际上它是在声明：“我是想用 Java 的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型。”
2918: 2918:第二个示例展示了无界通配符的一个重要应用。当你在处理多个泛型参数时，有时允许一个参数可以是任何类型，同时为其他参数确定某种特定类型的这种能力会显得很重要：
2919: 2919:
2920: 2920:```java
2921: 2921:// generics/UnboundedWildcards2.java
2922: 2922:import java.util.*;
2923: 2923:
2924: 2924:public class UnboundedWildcards2 {
2925: 2925:    static Map map1;
2926: 2926:    static Map<?,?> map2;
2927: 2927:    static Map<String,?> map3;
2928: 2928:  
2929: 2929:    static void assign1(Map map) { 
2930: 2930:        map1 = map; 
2931: 2931:    }
2932: 2932:    
2933: 2933:    static void assign2(Map<?,?> map) { 
2934: 2934:        map2 = map; 
2935: 2935:    }
2936: 2936:    
2937: 2937:    static void assign3(Map<String,?> map) { 
2938: 2938:        map3 = map; 
2939: 2939:    }
2940: 2940:    
2941: 2941:    public static void main(String[] args) {
2942: 2942:        assign1(new HashMap());
2943: 2943:        assign2(new HashMap());
2944: 2944:        //- assign3(new HashMap());
2945: 2945:        // warning: [unchecked] unchecked method invocation:
2946: 2946:        // method assign3 in class UnboundedWildcards2
2947: 2947:        // is applied to given types
2948: 2948:        //     assign3(new HashMap());
2949: 2949:        //            ^
2950: 2950:        //   required: Map<String,?>
2951: 2951:        //   found: HashMap
2952: 2952:        // warning: [unchecked] unchecked conversion
2953: 2953:        //     assign3(new HashMap());
2954: 2954:        //             ^
2955: 2955:        //   required: Map<String,?>
2956: 2956:        //   found:    HashMap
2957: 2957:        // 2 warnings
2958: 2958:        assign1(new HashMap<>());
2959: 2959:        assign2(new HashMap<>());
2960: 2960:        assign3(new HashMap<>());
2961: 2961:    }
2962: 2962:}
2963: 2963:```
2964: 2964:
2965: 2965:但是，当你拥有的全都是无界通配符时，就像在 `Map<?,?>` 中看到的那样，编译器看起来就无法将其与原生 **Map** 区分开了。另外， **UnboundedWildcards1.java** 展示了编译器处理  `List<?>` 和 `List<? extends Object>` 是不同的。
2966: 2966:令人困惑的是，编译器并非总是关注像 `List` 和 `List<?>` 之间的这种差异，因此它们看起来就像是相同的事物。事实上，因为泛型参数擦除到它的第一个边界，因此 `List<?>` 看起来等价于 `List<Object>` ，而 **List** 实际上也是 `List<Object>` ——除非这些语句都不为真。**List** 实际上表示“持有任何 **Object** 类型的原生 **List** ”，而 `List<?>` 表示“具有某种特定类型的非原生 **List** ，只是我们不知道类型是什么。”
2967: 2967:编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？下面的示例使用了前面定义的 `Holder<T>` 类，它包含接受 **Holder** 作为参数的各种方法，但是它们具有不同的形式：作为原生类型，具有具体的类型参数以及具有无界通配符参数：
2968: 2968:
2969: 2969:```java
2970: 2970:// generics/Wildcards.java
2971: 2971:// Exploring the meaning of wildcards
2972: 2972:
2973: 2973:public class Wildcards {
2974: 2974:    // Raw argument:
2975: 2975:    static void rawArgs(Holder holder, Object arg) {
2976: 2976:        //- holder.set(arg);
2977: 2977:        // warning: [unchecked] unchecked call to set(T)
2978: 2978:        // as a member of the raw type Holder
2979: 2979:        //     holder.set(arg);
2980: 2980:        //               ^
2981: 2981:        //   where T is a type-variable:
2982: 2982:        //     T extends Object declared in class Holder
2983: 2983:        // 1 warning
2984: 2984:
2985: 2985:        // Can't do this; don't have any 'T':
2986: 2986:        // T t = holder.get();
2987: 2987:
2988: 2988:        // OK, but type information is lost:
2989: 2989:        Object obj = holder.get();
2990: 2990:    }
2991: 2991:    
2992: 2992:    // Like rawArgs(), but errors instead of warnings:
2993: 2993:    static void unboundedArg(Holder<?> holder, Object arg) {
2994: 2994:        //- holder.set(arg);
2995: 2995:        // error: method set in class Holder<T>
2996: 2996:        // cannot be applied to given types;
2997: 2997:        //     holder.set(arg);
2998: 2998:        //           ^
2999: 2999:        //   required: CAP#1
3000: 3000:        //   found: Object
3001: 3001:        //   reason: argument mismatch;
3002: 3002:        //     Object cannot be converted to CAP#1
3003: 3003:        //   where T is a type-variable:
3004: 3004:        //     T extends Object declared in class Holder
3005: 3005:        //   where CAP#1 is a fresh type-variable:
3006: 3006:        //     CAP#1 extends Object from capture of ?
3007: 3007:        // 1 error
3008: 3008:
3009: 3009:        // Can't do this; don't have any 'T':
3010: 3010:        // T t = holder.get();
3011: 3011:
3012: 3012:        // OK, but type information is lost:
3013: 3013:        Object obj = holder.get();
3014: 3014:    }
3015: 3015:    
3016: 3016:    static <T> T exact1(Holder<T> holder) {
3017: 3017:        return holder.get();
3018: 3018:    }
3019: 3019:    
3020: 3020:    static <T> T exact2(Holder<T> holder, T arg) {
3021: 3021:        holder.set(arg);
3022: 3022:        return holder.get();
3023: 3023:    }
3024: 3024:    
3025: 3025:    static <T> T wildSubtype(Holder<? extends T> holder, T arg) {
3026: 3026:        //- holder.set(arg);
3027: 3027:        // error: method set in class Holder<T#2>
3028: 3028:        // cannot be applied to given types;
3029: 3029:        //     holder.set(arg);
3030: 3030:        //           ^
3031: 3031:        //   required: CAP#1
3032: 3032:        //   found: T#1
3033: 3033:        //   reason: argument mismatch;
3034: 3034:        //     T#1 cannot be converted to CAP#1
3035: 3035:        //   where T#1,T#2 are type-variables:
3036: 3036:        //     T#1 extends Object declared in method
3037: 3037:        //     <T#1>wildSubtype(Holder<? extends T#1>,T#1)
3038: 3038:        //     T#2 extends Object declared in class Holder
3039: 3039:        //   where CAP#1 is a fresh type-variable:
3040: 3040:        //     CAP#1 extends T#1 from
3041: 3041:        //       capture of ? extends T#1
3042: 3042:        // 1 error
3043: 3043:        return holder.get();
3044: 3044:    }
3045: 3045:    
3046: 3046:    static <T> void wildSupertype(Holder<? super T> holder, T arg) {
3047: 3047:        holder.set(arg);
3048: 3048:        //- T t = holder.get();
3049: 3049:        // error: incompatible types:
3050: 3050:        // CAP#1 cannot be converted to T
3051: 3051:        //     T t = holder.get();
3052: 3052:        //                     ^
3053: 3053:        //   where T is a type-variable:
3054: 3054:        //     T extends Object declared in method
3055: 3055:        //       <T>wildSupertype(Holder<? super T>,T)
3056: 3056:        //   where CAP#1 is a fresh type-variable:
3057: 3057:        //     CAP#1 extends Object super:
3058: 3058:        //       T from capture of ? super T
3059: 3059:        // 1 error
3060: 3060:
3061: 3061:        // OK, but type information is lost:
3062: 3062:        Object obj = holder.get();
3063: 3063:    }
3064: 3064:    
3065: 3065:    public static void main(String[] args) {
3066: 3066:        Holder raw = new Holder<>();
3067: 3067:        // Or:
3068: 3068:        raw = new Holder();
3069: 3069:        Holder<Long> qualified = new Holder<>();
3070: 3070:        Holder<?> unbounded = new Holder<>();
3071: 3071:        Holder<? extends Long> bounded = new Holder<>();
3072: 3072:        Long lng = 1L;
3073: 3073:
3074: 3074:        rawArgs(raw, lng);
3075: 3075:        rawArgs(qualified, lng);
3076: 3076:        rawArgs(unbounded, lng);
3077: 3077:        rawArgs(bounded, lng);
3078: 3078:
3079: 3079:        unboundedArg(raw, lng);
3080: 3080:        unboundedArg(qualified, lng);
3081: 3081:        unboundedArg(unbounded, lng);
3082: 3082:        unboundedArg(bounded, lng);
3083: 3083:
3084: 3084:        //- Object r1 = exact1(raw);
3085: 3085:        // warning: [unchecked] unchecked method invocation:
3086: 3086:        // method exact1 in class Wildcards is applied
3087: 3087:        // to given types
3088: 3088:        //      Object r1 = exact1(raw);
3089: 3089:        //                        ^
3090: 3090:        //   required: Holder<T>
3091: 3091:        //   found: Holder
3092: 3092:        //   where T is a type-variable:
3093: 3093:        //     T extends Object declared in
3094: 3094:        //     method <T>exact1(Holder<T>)
3095: 3095:        // warning: [unchecked] unchecked conversion
3096: 3096:        //      Object r1 = exact1(raw);
3097: 3097:        //                         ^
3098: 3098:        //   required: Holder<T>
3099: 3099:        //   found:    Holder
3100: 3100:        //   where T is a type-variable:
3101: 3101:        //     T extends Object declared in
3102: 3102:        //     method <T>exact1(Holder<T>)
3103: 3103:        // 2 warnings
3104: 3104:
3105: 3105:        Long r2 = exact1(qualified);
3106: 3106:        Object r3 = exact1(unbounded); // Must return Object
3107: 3107:        Long r4 = exact1(bounded);
3108: 3108:
3109: 3109:        //- Long r5 = exact2(raw, lng);
3110: 3110:        // warning: [unchecked] unchecked method invocation:
3111: 3111:        // method exact2 in class Wildcards is
3112: 3112:        // applied to given types
3113: 3113:        //     Long r5 = exact2(raw, lng);
3114: 3114:        //                     ^
3115: 3115:        //   required: Holder<T>,T
3116: 3116:        //   found: Holder,Long
3117: 3117:        //   where T is a type-variable:
3118: 3118:        //     T extends Object declared in
3119: 3119:        //       method <T>exact2(Holder<T>,T)
3120: 3120:        // warning: [unchecked] unchecked conversion
3121: 3121:        //     Long r5 = exact2(raw, lng);
3122: 3122:        //                      ^
3123: 3123:        //   required: Holder<T>
3124: 3124:        //   found:    Holder
3125: 3125:        //   where T is a type-variable:
3126: 3126:        //     T extends Object declared in
3127: 3127:        //       method <T>exact2(Holder<T>,T)
3128: 3128:        // 2 warnings
3129: 3129:
3130: 3130:        Long r6 = exact2(qualified, lng);
3131: 3131:
3132: 3132:        //- Long r7 = exact2(unbounded, lng);
3133: 3133:        // error: method exact2 in class Wildcards
3134: 3134:        // cannot be applied to given types;
3135: 3135:        //     Long r7 = exact2(unbounded, lng);
3136: 3136:        //               ^
3137: 3137:        //   required: Holder<T>,T
3138: 3138:        //   found: Holder<CAP#1>,Long
3139: 3139:        //   reason: inference variable T has
3140: 3140:        //     incompatible bounds
3141: 3141:        //     equality constraints: CAP#1
3142: 3142:        //     lower bounds: Long
3143: 3143:        //   where T is a type-variable:
3144: 3144:        //     T extends Object declared in
3145: 3145:        //       method <T>exact2(Holder<T>,T)
3146: 3146:        //   where CAP#1 is a fresh type-variable:
3147: 3147:        //     CAP#1 extends Object from capture of ?
3148: 3148:        // 1 error
3149: 3149:
3150: 3150:        //- Long r8 = exact2(bounded, lng);
3151: 3151:        // error: method exact2 in class Wildcards
3152: 3152:        // cannot be applied to given types;
3153: 3153:        //      Long r8 = exact2(bounded, lng);
3154: 3154:        //                ^
3155: 3155:        //   required: Holder<T>,T
3156: 3156:        //   found: Holder<CAP#1>,Long
3157: 3157:        //   reason: inference variable T
3158: 3158:        //     has incompatible bounds
3159: 3159:        //     equality constraints: CAP#1
3160: 3160:        //     lower bounds: Long
3161: 3161:        //   where T is a type-variable:
3162: 3162:        //     T extends Object declared in
3163: 3163:        //       method <T>exact2(Holder<T>,T)
3164: 3164:        //   where CAP#1 is a fresh type-variable:
3165: 3165:        //     CAP#1 extends Long from
3166: 3166:        //       capture of ? extends Long
3167: 3167:        // 1 error
3168: 3168:
3169: 3169:        //- Long r9 = wildSubtype(raw, lng);
3170: 3170:        // warning: [unchecked] unchecked method invocation:
3171: 3171:        // method wildSubtype in class Wildcards
3172: 3172:        // is applied to given types
3173: 3173:        //     Long r9 = wildSubtype(raw, lng);
3174: 3174:        //                          ^
3175: 3175:        //   required: Holder<? extends T>,T
3176: 3176:        //   found: Holder,Long
3177: 3177:        //   where T is a type-variable:
3178: 3178:        //     T extends Object declared in
3179: 3179:        //     method <T>wildSubtype(Holder<? extends T>,T)
3180: 3180:        // warning: [unchecked] unchecked conversion
3181: 3181:        //     Long r9 = wildSubtype(raw, lng);
3182: 3182:        //                           ^
3183: 3183:        //   required: Holder<? extends T>
3184: 3184:        //   found:    Holder
3185: 3185:        //   where T is a type-variable:
3186: 3186:        //     T extends Object declared in
3187: 3187:        //     method <T>wildSubtype(Holder<? extends T>,T)
3188: 3188:        // 2 warnings
3189: 3189:
3190: 3190:        Long r10 = wildSubtype(qualified, lng);
3191: 3191:        // OK, but can only return Object:
3192: 3192:        Object r11 = wildSubtype(unbounded, lng);
3193: 3193:        Long r12 = wildSubtype(bounded, lng);
3194: 3194:
3195: 3195:        //- wildSupertype(raw, lng);
3196: 3196:        // warning: [unchecked] unchecked method invocation:
3197: 3197:        //   method wildSupertype in class Wildcards
3198: 3198:        //   is applied to given types
3199: 3199:        //     wildSupertype(raw, lng);
3200: 3200:        //                  ^
3201: 3201:        //   required: Holder<? super T>,T
3202: 3202:        //   found: Holder,Long
3203: 3203:        //   where T is a type-variable:
3204: 3204:        //     T extends Object declared in
3205: 3205:        //     method <T>wildSupertype(Holder<? super T>,T)
3206: 3206:        // warning: [unchecked] unchecked conversion
3207: 3207:        //     wildSupertype(raw, lng);
3208: 3208:        //                   ^
3209: 3209:        //   required: Holder<? super T>
3210: 3210:        //   found:    Holder
3211: 3211:        //   where T is a type-variable:
3212: 3212:        //     T extends Object declared in
3213: 3213:        //     method <T>wildSupertype(Holder<? super T>,T)
3214: 3214:        // 2 warnings
3215: 3215:
3216: 3216:        wildSupertype(qualified, lng);
3217: 3217:
3218: 3218:        //- wildSupertype(unbounded, lng);
3219: 3219:        // error: method wildSupertype in class Wildcards
3220: 3220:        // cannot be applied to given types;
3221: 3221:        //     wildSupertype(unbounded, lng);
3222: 3222:        //     ^
3223: 3223:        //   required: Holder<? super T>,T
3224: 3224:        //   found: Holder<CAP#1>,Long
3225: 3225:        //   reason: cannot infer type-variable(s) T
3226: 3226:        //     (argument mismatch; Holder<CAP#1>
3227: 3227:        //     cannot be converted to Holder<? super T>)
3228: 3228:        //   where T is a type-variable:
3229: 3229:        //     T extends Object declared in
3230: 3230:        //     method <T>wildSupertype(Holder<? super T>,T)
3231: 3231:        //   where CAP#1 is a fresh type-variable:
3232: 3232:        //     CAP#1 extends Object from capture of ?
3233: 3233:        // 1 error
3234: 3234:
3235: 3235:        //- wildSupertype(bounded, lng);
3236: 3236:        // error: method wildSupertype in class Wildcards
3237: 3237:        // cannot be applied to given types;
3238: 3238:        //     wildSupertype(bounded, lng);
3239: 3239:        //     ^
3240: 3240:        //   required: Holder<? super T>,T
3241: 3241:        //   found: Holder<CAP#1>,Long
3242: 3242:        //   reason: cannot infer type-variable(s) T
3243: 3243:        //     (argument mismatch; Holder<CAP#1>
3244: 3244:        //     cannot be converted to Holder<? super T>)
3245: 3245:        //   where T is a type-variable:
3246: 3246:        //     T extends Object declared in
3247: 3247:        //     method <T>wildSupertype(Holder<? super T>,T)
3248: 3248:        //   where CAP#1 is a fresh type-variable:
3249: 3249:        //     CAP#1 extends Long from capture of
3250: 3250:        //     ? extends Long
3251: 3251:        // 1 error
3252: 3252:    }
3253: 3253:}
3254: 3254:```
3255: 3255:
3256: 3256:在 `rawArgs()` 中，编译器知道 `Holder` 是一个泛型类型，因此即使它在这里被表示成一个原生类型，编译器仍旧知道向 `set()` 传递一个 **Object** 是不安全的。由于它是原生类型，你可以将任何类型的对象传递给 `set()` ，而这个对象将被向上转型为 **Object** 。因此无论何时，只要使用了原生类型，都会放弃编译期检查。对 `get()` 的调用说明了相同的问题：没有任何 **T** 类型的对象，因此结果只能是一个 **Object**。
3257: 3257:人们很自然地会开始考虑原生 `Holder` 与 `Holder<?>` 是大致相同的事物。但是 `unboundedArg()` 强调它们是不同的——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，因为原生 **Holder** 将持有任何类型的组合，而 `Holder<?>` 将持有具有某种具体类型的同构集合，因此不能只是向其中传递 **Object** 。
3258: 3258:在 `exact1()` 和 `exact2()` 中，你可以看到使用了确切的泛型参数——没有任何通配符。你将看到，`exact2()`与 `exact1()` 具有不同的限制，因为它有额外的参数。
3259: 3259:在 `wildSubtype()` 中，在 **Holder** 类型上的限制被放松为包括持有任何扩展自 **T** 的对象的 **Holder** 。这还是意味着如果 T 是 **Fruit** ，那么 `holder` 可以是 `Holder<Apple>` ，这是合法的。为了防止将 **Orange** 放置到 `Holder<Apple>` 中，对 `set()` 的调用（或者对任何接受这个类型参数为参数的方法的调用）都是不允许的。但是，你仍旧知道任何来自 `Holder<？extends Fruit>` 的对象至少是 **Fruit** ，因此 `get()` （或者任何将产生具有这个类型参数的返回值的方法）都是允许的。
3260: 3260:`wildSupertype()` 展示了超类型通配符，这个方法展示了与 `wildSubtype()` 相反的行为：`holder` 可以是持有任何 T 的基类型的容器。因此， `set()` 可以接受 **T** ，因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是 **T** ）。但是，尝试着调用 `get()` 是没有用的，因为由 `holder` 持有的类型可以是任何超类型，因此唯一安全的类型就是 **Object** 。
3261: 3261:这个示例还展示了对于在 `unbounded()` 中使用无界通配符能够做什么不能做什么所做出的限制：因为你没有 **T**，所以你不能将 `set()` 或 `get()` 作用于 **T** 上。
3262: 3262:
3263: 3263:在 `main()` 方法中你看到了某些方法在接受某些类型的参数时没有报错和警告。为了迁移兼容性，`rawArgs()`  将接受所有 **Holder** 的不同变体，而不会产生警告。`unboundedArg()` 方法也可以接受相同的所有类型，尽管如前所述，它在方法体内部处理这些类型的方式并不相同。
3264: 3264:
3265: 3265:如果向接受“确切”泛型类型（没有通配符）的方法传递一个原生 **Holder** 引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息。如果向 `exact1()` 传递一个无界引用，就不会有任何可以确定返回类型的类型信息。
3266: 3266:可以看到，`exact2()` 具有最多的限制，因为它希望精确地得到一个 `Holder<T>` ，以及一个具有类型 **T** 的参数，正由于此，它将产生错误或警告，除非提供确切的参数。有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决于是否想要从泛型参数中返回类型确定的返回值（就像在 `wildSubtype()` 中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在 `wildSupertype()` 中看到的那样）。
3267: 3267:因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合你的需求的方法。
3268: 3268:
3269: 3269:### 捕获转换
3270: 3270:
3271: 3271:有一种特殊情况需要使用 `<?>` 而不是原生类型。如果向一个使用 `<?>` 的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。下面的示例演示了这种技术，它被称为捕获转换，因为未指定的通配符类型被捕获，并被转换为确切类型。这里，有关警告的注释只有在 `@SuppressWarnings` 注解被移除之后才能起作用：
3272: 3272:
3273: 3273:```java
3274: 3274:// generics/CaptureConversion.java
3275: 3275:
3276: 3276:public class CaptureConversion {
3277: 3277:    static <T> void f1(Holder<T> holder) {
3278: 3278:        T t = holder.get();
3279: 3279:        System.out.println(t.getClass().getSimpleName());
3280: 3280:    }
3281: 3281:  
3282: 3282:    static void f2(Holder<?> holder) {
3283: 3283:        f1(holder); // Call with captured type
3284: 3284:    }
3285: 3285:    
3286: 3286:    @SuppressWarnings("unchecked")
3287: 3287:    public static void main(String[] args) {
3288: 3288:        Holder raw = new Holder<>(1);
3289: 3289:        f1(raw);
3290: 3290:        // warning: [unchecked] unchecked method invocation:
3291: 3291:        // method f1 in class CaptureConversion
3292: 3292:        // is applied to given types
3293: 3293:        //     f1(raw);
3294: 3294:        //       ^
3295: 3295:        //   required: Holder<T>
3296: 3296:        //   found: Holder
3297: 3297:        //   where T is a type-variable:
3298: 3298:        //     T extends Object declared in
3299: 3299:        //     method <T>f1(Holder<T>)
3300: 3300:        // warning: [unchecked] unchecked conversion
3301: 3301:        //     f1(raw);
3302: 3302:        //        ^
3303: 3303:        //   required: Holder<T>
3304: 3304:        //   found:    Holder
3305: 3305:        //   where T is a type-variable:
3306: 3306:        //     T extends Object declared in
3307: 3307:        //     method <T>f1(Holder<T>)
3308: 3308:        // 2 warnings
3309: 3309:        f2(raw); // No warnings
3310: 3310:        
3311: 3311:        Holder rawBasic = new Holder();
3312: 3312:        rawBasic.set(new Object());
3313: 3313:        // warning: [unchecked] unchecked call to set(T)
3314: 3314:        // as a member of the raw type Holder
3315: 3315:        //     rawBasic.set(new Object());
3316: 3316:        //                 ^
3317: 3317:        //   where T is a type-variable:
3318: 3318:        //     T extends Object declared in class Holder
3319: 3319:        // 1 warning
3320: 3320:        f2(rawBasic); // No warnings
3321: 3321:        
3322: 3322:        // Upcast to Holder<?>, still figures it out:
3323: 3323:        Holder<?> wildcarded = new Holder<>(1.0);
3324: 3324:        f2(wildcarded);
3325: 3325:    }
3326: 3326:}
3327: 3327:/* Output:
3328: 3328:Integer
3329: 3329:Integer
3330: 3330:Object
3331: 3331:Double
3332: 3332:*/
3333: 3333:```
3334: 3334:
3335: 3335:`f1()` 中的类型参数都是确切的，没有通配符或边界。在 `f2()` 中，**Holder** 参数是一个无界通配符，因此它看起来是未知的。但是，在 `f2()` 中调用了 `f1()`，而 `f1()` 需要一个已知参数。这里所发生的是：在调用 `f2()` 的过程中捕获了参数类型，并在调用 `f1()` 时使用了这种类型。
3336: 3336:你可能想知道这项技术是否可以用于写入，但是这要求在传递 `Holder<?>` 时同时传递一个具体类型。捕获转换只有在这样的情况下可以工作：即在方法内部，你需要使用确切的类型。注意，不能从 `f2()` 中返回 **T**，因为 **T** 对于 `f2()` 来说是未知的。捕获转换十分有趣，但是非常受限。
3337: 3337:
3338: 3338:<!-- Issues -->
3339: 3339:
3340: 3340:## 问题
3341: 3341:
3342: 3342:本节将阐述在使用 Java 泛型时会出现的各类问题。
3343: 3343:
3344: 3344:### 任何基本类型都不能作为类型参数
3345: 3345:
3346: 3346:正如本章早先提到的，Java 泛型的限制之一是不能将基本类型用作类型参数。因此，不能创建  `ArrayList<int>` 之类的东西。
3347: 3347:解决方法是使用基本类型的包装器类以及自动装箱机制。如果创建一个 `ArrayList<Integer>`，并将基本类型 **int** 应用于这个集合，那么你将发现自动装箱机制将自动地实现 **int** 到 **Integer** 的双向转换——因此，这几乎就像是有一个 `ArrayList<int>` 一样：
3348: 3348:
3349: 3349:```java
3350: 3350:// generics/ListOfInt.java
3351: 3351:// Autoboxing compensates for the inability
3352: 3352:// to use primitives in generics
3353: 3353:import java.util.*;
3354: 3354:import java.util.stream.*;
3355: 3355:
3356: 3356:public class ListOfInt {
3357: 3357:    public static void main(String[] args) {
3358: 3358:        List<Integer> li = IntStream.range(38, 48)
3359: 3359:            .boxed() // Converts ints to Integers
3360: 3360:            .collect(Collectors.toList());
3361: 3361:        System.out.println(li);
3362: 3362:    }
3363: 3363:}
3364: 3364:/* Output:
3365: 3365:[38, 39, 40, 41, 42, 43, 44, 45, 46, 47]
3366: 3366:*/
3367: 3367:```
3368: 3368:
3369: 3369:通常，这种解决方案工作得很好——能够成功地存储和读取 **int**，自动装箱隐藏了转换的过程。但是如果性能成为问题的话，就需要使用专门为基本类型适配的特殊版本的集合；一个开源版本的实现是 **org.apache.commons.collections.primitives**。
3370: 3370:下面是另外一种方式，它可以创建持有 **Byte** 的 **Set**：
3371: 3371:
3372: 3372:```java
3373: 3373:// generics/ByteSet.java
3374: 3374:import java.util.*;
3375: 3375:
3376: 3376:public class ByteSet {
3377: 3377:    Byte[] possibles = { 1,2,3,4,5,6,7,8,9 };
3378: 3378:    Set<Byte> mySet = new HashSet<>(Arrays.asList(possibles));
3379: 3379:    // But you can't do this:
3380: 3380:    // Set<Byte> mySet2 = new HashSet<>(
3381: 3381:    // Arrays.<Byte>asList(1,2,3,4,5,6,7,8,9));
3382: 3382:}
3383: 3383:```
3384: 3384:
3385: 3385:自动装箱机制解决了一些问题，但并没有解决所有问题。
3386: 3386:
3387: 3387:在下面的示例中，**FillArray** 接口包含一些通用方法，这些方法使用 **Supplier** 来用对象填充数组（这使得类泛型在本例中无法工作，因为这个方法是静态的）。**Supplier** 实现来自 [数组](book/21-Arrays.md) 一章,并且在 `main()` 中，可以看到 `FillArray.fill()` 使用对象填充了数组：
3388: 3388:
3389: 3389:```java
3390: 3390:// generics/PrimitiveGenericTest.java
3391: 3391:import onjava.*;
3392: 3392:import java.util.*;
3393: 3393:import java.util.function.*;
3394: 3394:
3395: 3395:// Fill an array using a generator:
3396: 3396:interface FillArray {
3397: 3397:    static <T> T[] fill(T[] a, Supplier<T> gen) {
3398: 3398:        Arrays.setAll(a, n -> gen.get());
3399: 3399:        return a;
3400: 3400:    }
3401: 3401:    
3402: 3402:    static int[] fill(int[] a, IntSupplier gen) {
3403: 3403:        Arrays.setAll(a, n -> gen.getAsInt());
3404: 3404:        return a;
3405: 3405:    }
3406: 3406:    
3407: 3407:    static long[] fill(long[] a, LongSupplier gen) {
3408: 3408:        Arrays.setAll(a, n -> gen.getAsLong());
3409: 3409:        return a;
3410: 3410:    }
3411: 3411:    
3412: 3412:    static double[] fill(double[] a, DoubleSupplier gen) {
3413: 3413:        Arrays.setAll(a, n -> gen.getAsDouble());
3414: 3414:        return a;
3415: 3415:    }
3416: 3416:}
3417: 3417:
3418: 3418:public class PrimitiveGenericTest {
3419: 3419:    public static void main(String[] args) {
3420: 3420:        String[] strings = FillArray.fill(
3421: 3421:            new String[5], new Rand.String(9));
3422: 3422:        System.out.println(Arrays.toString(strings));
3423: 3423:        int[] integers = FillArray.fill(
3424: 3424:            new int[9], new Rand.Pint());
3425: 3425:        System.out.println(Arrays.toString(integers));
3426: 3426:    }
3427: 3427:}
3428: 3428:/* Output:
3429: 3429:[btpenpccu, xszgvgmei, nneeloztd, vewcippcy, gpoalkljl]
3430: 3430:[635, 8737, 3941, 4720, 6177, 8479, 6656, 3768, 4948]
3431: 3431:*/
3432: 3432:```
3433: 3433:
3434: 3434:自动装箱不适用于数组，因此我们必须创建 `FillArray.fill()` 的重载版本，或创建产生 **Wrapped** 输出的生成器。 **FillArray** 仅比 `java.util.Arrays.setAll()` 有用一点，因为它返回填充的数组。
3435: 3435:
3436: 3436:### 实现参数化接口
3437: 3437:
3438: 3438:一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。下面是产生这种冲突的情况：
3439: 3439:
3440: 3440:```java
3441: 3441:// generics/MultipleInterfaceVariants.java
3442: 3442:// {WillNotCompile}
3443: 3443:package generics;
3444: 3444:
3445: 3445:interface Payable<T> {}
3446: 3446:
3447: 3447:class Employee implements Payable<Employee> {}
3448: 3448:
3449: 3449:class Hourly extends Employee implements Payable<Hourly> {}
3450: 3450:```
3451: 3451:
3452: 3452:**Hourly** 不能编译，因为擦除会将  `Payable<Employe>` 和 `Payable<Hourly>` 简化为相同的类 **Payable**，这样，上面的代码就意味着在重复两次地实现相同的接口。十分有趣的是，如果从 **Payable** 的两种用法中都移除掉泛型参数（就像编译器在擦除阶段所做的那样）这段代码就可以编译。
3453: 3453:
3454: 3454:在使用某些更基本的 Java 接口，例如 `Comparable<T>` 时，这个问题可能会变得十分令人恼火，就像你在本节稍后看到的那样。
3455: 3455:
3456: 3456:### 转型和警告
3457: 3457:
3458: 3458:使用带有泛型类型参数的转型或 **instanceof** 不会有任何效果。下面的集合在内部将各个值存储为 **Object**，并在获取这些值时，再将它们转型回 **T**：
3459: 3459:
3460: 3460:```java
3461: 3461:// generics/GenericCast.java
3462: 3462:import java.util.*;
3463: 3463:import java.util.stream.*;
3464: 3464:
3465: 3465:class FixedSizeStack<T> {
3466: 3466:    private final int size;
3467: 3467:    private Object[] storage;
3468: 3468:    private int index = 0;
3469: 3469:    
3470: 3470:    FixedSizeStack(int size) {
3471: 3471:        this.size = size;
3472: 3472:        storage = new Object[size];
3473: 3473:    }
3474: 3474:    
3475: 3475:    public void push(T item) {
3476: 3476:        if(index < size)
3477: 3477:            storage[index++] = item;
3478: 3478:    }
3479: 3479:    
3480: 3480:    @SuppressWarnings("unchecked")
3481: 3481:    public T pop() {
3482: 3482:        return index == 0 ? null : (T)storage[--index];
3483: 3483:    }
3484: 3484:    
3485: 3485:    @SuppressWarnings("unchecked")
3486: 3486:    Stream<T> stream() {
3487: 3487:        return (Stream<T>)Arrays.stream(storage);
3488: 3488:    }
3489: 3489:}
3490: 3490:
3491: 3491:public class GenericCast {
3492: 3492:    static String[] letters = "ABCDEFGHIJKLMNOPQRS".split("");
3493: 3493:  
3494: 3494:    public static void main(String[] args) {
3495: 3495:        FixedSizeStack<String> strings =
3496: 3496:            new FixedSizeStack<>(letters.length);
3497: 3497:        Arrays.stream("ABCDEFGHIJKLMNOPQRS".split(""))
3498: 3498:            .forEach(strings::push);
3499: 3499:        System.out.println(strings.pop());
3500: 3500:        strings.stream()
3501: 3501:            .map(s -> s + " ")
3502: 3502:            .forEach(System.out::print);
3503: 3503:    }
3504: 3504:}
3505: 3505:/* Output:
3506: 3506:S
3507: 3507:A B C D E F G H I J K L M N O P Q R S
3508: 3508:*/
3509: 3509:```
3510: 3510:
3511: 3511:如果没有 **@SuppressWarnings** 注解，编译器将对 `pop()` 产生 “unchecked cast” 警告。由于擦除的原因，编译器无法知道这个转型是否是安全的，并且 `pop()` 方法实际上并没有执行任何转型。
3512: 3512:这是因为，**T** 被擦除到它的第一个边界，默认情况下是 **Object** ，因此 `pop()` 实际上只是将 **Object** 转型为 **Object**。
3513: 3513:有时，泛型没有消除对转型的需要，这就会由编译器产生警告，而这个警告是不恰当的。例如：
3514: 3514:
3515: 3515:```java
3516: 3516:// generics/NeedCasting.java
3517: 3517:import java.io.*;
3518: 3518:import java.util.*;
3519: 3519:
3520: 3520:public class NeedCasting {
3521: 3521:    @SuppressWarnings("unchecked")
3522: 3522:    public void f(String[] args) throws Exception {
3523: 3523:        ObjectInputStream in = new ObjectInputStream(
3524: 3524:            new FileInputStream(args[0]));
3525: 3525:        List<Widget> shapes = (List<Widget>)in.readObject();
3526: 3526:    }
3527: 3527:}
3528: 3528:```
3529: 3529:
3530: 3530:正如你将在 [附录：对象序列化](book/Appendix-Object-Serialization.md) 中学到的那样，`readObject()` 无法知道它正在读取的是什么，因此它返回的是必须转型的对象。但是当注释掉 **@SuppressWarnings** 注解并编译这个程序时，就会得到下面的警告。
3531: 3531:
3532: 3532:```
3533: 3533:NeedCasting.java uses unchecked or unsafe operations.
3534: 3534:Recompile with -Xlint:unchecked for details.
3535: 3535:
3536: 3536:And if you follow the instructions and recompile with  -
3537: 3537:Xlint:unchecked :(如果遵循这条指示，使用-Xlint:unchecked来重新编译：)
3538: 3538:
3539: 3539:NeedCasting.java:10: warning: [unchecked] unchecked cast
3540: 3540:    List<Widget> shapes = (List<Widget>)in.readObject();
3541: 3541:    required: List<Widget>
3542: 3542:    found: Object
3543: 3543:1 warning
3544: 3544:```
3545: 3545:
3546: 3546:你会被强制要求转型，但是又被告知不应该转型。为了解决这个问题，必须使用 Java 5 引入的新的转型形式，即通过泛型类来转型：
3547: 3547:
3548: 3548:```java
3549: 3549:// generics/ClassCasting.java
3550: 3550:import java.io.*;
3551: 3551:import java.util.*;
3552: 3552:
3553: 3553:public class ClassCasting {
3554: 3554:    @SuppressWarnings("unchecked")
3555: 3555:    public void f(String[] args) throws Exception {
3556: 3556:        ObjectInputStream in = new ObjectInputStream(
3557: 3557:            new FileInputStream(args[0]));
3558: 3558:        // Won't Compile:
3559: 3559:        //    List<Widget> lw1 =
3560: 3560:        //    List<>.class.cast(in.readObject());
3561: 3561:        List<Widget> lw2 = List.class.cast(in.readObject());
3562: 3562:    }
3563: 3563:}
3564: 3564:```
3565: 3565:
3566: 3566:但是，不能转型到实际类型（ `List<Widget>` ）。也就是说，不能声明：
3567: 3567:
3568: 3568:```
3569: 3569:List<Widget>.class.cast(in.readobject())
3570: 3570:```
3571: 3571:
3572: 3572:甚至当你添加一个像下面这样的另一个转型时：
3573: 3573:
3574: 3574:```
3575: 3575:(List<Widget>)List.class.cast(in.readobject())
3576: 3576:```
3577: 3577:
3578: 3578:仍旧会得到一个警告。
3579: 3579:
3580: 3580:### 重载
3581: 3581:
3582: 3582:下面的程序是不能编译的，即使它看起来是合理的：
3583: 3583:
3584: 3584:```java
3585: 3585:// generics/UseList.java
3586: 3586:// {WillNotCompile}
3587: 3587:import java.util.*;
3588: 3588:
3589: 3589:public class UseList<W, T> {
3590: 3590:    void f(List<T> v) {}
3591: 3591:    void f(List<W> v) {}
3592: 3592:}
3593: 3593:```
3594: 3594:
3595: 3595:因为擦除，所以重载方法产生了相同的类型签名。
3596: 3596:
3597: 3597:因而，当擦除后的参数不能产生唯一的参数列表时，你必须提供不同的方法名：
3598: 3598:
3599: 3599:```java
3600: 3600:// generics/UseList2.java
3601: 3601:
3602: 3602:import java.util.*;
3603: 3603:
3604: 3604:public class UseList2<W, T> {
3605: 3605:    void f1(List<T> v) {}
3606: 3606:    void f2(List<W> v) {}
3607: 3607:}
3608: 3608:```
3609: 3609:
3610: 3610:幸运的是，编译器可以检测到这类问题。
3611: 3611:
3612: 3612:### 基类劫持接口
3613: 3613:
3614: 3614:假设你有一个实现了 **Comparable** 接口的 **Pet** 类：
3615: 3615:
3616: 3616:```java
3617: 3617:// generics/ComparablePet.java
3618: 3618:
3619: 3619:public class ComparablePet implements Comparable<ComparablePet> {
3620: 3620:    @Override
3621: 3621:    public int compareTo(ComparablePet o) {
3622: 3622:        return 0;
3623: 3623:    }
3624: 3624:}
3625: 3625:```
3626: 3626:
3627: 3627:尝试缩小 **ComparablePet** 子类的比较类型是有意义的。例如，**Cat** 类可以与其他的 **Cat** 比较：
3628: 3628:
3629: 3629:```java
3630: 3630:// generics/HijackedInterface.java
3631: 3631:// {WillNotCompile}
3632: 3632:
3633: 3633:class Cat extends ComparablePet implements Comparable<Cat> {
3634: 3634:    // error: Comparable cannot be inherited with
3635: 3635:    // different arguments: <Cat> and <ComparablePet>
3636: 3636:    // class Cat
3637: 3637:    // ^
3638: 3638:    // 1 error
3639: 3639:    public int compareTo(Cat arg) {
3640: 3640:        return 0;
3641: 3641:    }
3642: 3642:}
3643: 3643:```
3644: 3644:
3645: 3645:不幸的是，这不能工作。一旦 **Comparable** 的类型参数设置为 **ComparablePet**，其他的实现类只能比较 **ComparablePet**：
3646: 3646:
3647: 3647:```java
3648: 3648:// generics/RestrictedComparablePets.java
3649: 3649:
3650: 3650:public class Hamster extends ComparablePet implements Comparable<ComparablePet> {
3651: 3651:
3652: 3652:    @Override
3653: 3653:    public int compareTo(ComparablePet arg) {
3654: 3654:        return 0;
3655: 3655:    }
3656: 3656:}
3657: 3657:// Or just:
3658: 3658:class Gecko extends ComparablePet {
3659: 3659:    public int compareTo(ComparablePet arg) {
3660: 3660:        return 0;
3661: 3661:    }
3662: 3662:}
3663: 3663:```
3664: 3664:
3665: 3665:**Hamster** 显示了重新实现 **ComparablePet** 中相同的接口是可能的，只要接口完全相同，包括参数类型。然而正如 **Gecko** 中所示，这与直接覆写基类的方法完全相同。
3666: 3666:
3667: 3667:<!-- Self-Bounded Types -->
3668: 3668:
3669: 3669:## 自限定的类型
3670: 3670:
3671: 3671:在 Java 泛型中，有一个似乎经常性出现的惯用法，它相当令人费解：
3672: 3672:
3673: 3673:```java
3674: 3674:class SelfBounded<T extends SelfBounded<T>> { // ...
3675: 3675:```
3676: 3676:
3677: 3677:这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。**SelfBounded** 类接受泛型参数 **T**，而 **T** 由一个边界类限定，这个边界就是拥有 **T** 作为其参数的 **SelfBounded**。
3678: 3678:
3679: 3679:当你首次看到它时，很难去解析它，它强调的是当 **extends** 关键字用于边界与用来创建子类明显是不同的。
3680: 3680:
3681: 3681:### 古怪的循环泛型
3682: 3682:
3683: 3683:为了理解自限定类型的含义，我们从这个惯用法的一个简单版本入手，它没有自限定的边界。
3684: 3684:
3685: 3685:不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类。也就是说，可以声明：
3686: 3686:
3687: 3687:```java
3688: 3688:// generics/CuriouslyRecurringGeneric.java
3689: 3689:
3690: 3690:class GenericType<T> {}
3691: 3691:
3692: 3692:public class CuriouslyRecurringGeneric
3693: 3693:  extends GenericType<CuriouslyRecurringGeneric> {}
3694: 3694:```
3695: 3695:
3696: 3696:这可以按照 Jim Coplien 在 C++ 中的*古怪的循环模版模式*的命名方式，称为古怪的循环泛型（CRG）。“古怪的循环”是指类相当古怪地出现在它自己的基类中这一事实。
3697: 3697:为了理解其含义，努力大声说：“我在创建一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为其参数。”当给出导出类的名字时，这个泛型基类能够实现什么呢？好吧，Java 中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为其参数和返回类型的基类。它还能将导出类型用作其域类型，尽管这些将被擦除为 **Object** 的类型。下面是表示了这种情况的一个泛型类：
3698: 3698:
3699: 3699:```java
3700: 3700:// generics/BasicHolder.java
3701: 3701:
3702: 3702:public class BasicHolder<T> {
3703: 3703:    T element;
3704: 3704:    void set(T arg) { element = arg; }
3705: 3705:    T get() { return element; }
3706: 3706:    void f() {
3707: 3707:        System.out.println(element.getClass().getSimpleName());
3708: 3708:    }
3709: 3709:}
3710: 3710:```
3711: 3711:
3712: 3712:这是一个普通的泛型类型，它的一些方法将接受和产生具有其参数类型的对象，还有一个方法在其存储的域上执行操作（尽管只是在这个域上执行 **Object** 操作）。
3713: 3713:我们可以在一个古怪的循环泛型中使用 **BasicHolder**：
3714: 3714:
3715: 3715:```java
3716: 3716:// generics/CRGWithBasicHolder.java
3717: 3717:
3718: 3718:class Subtype extends BasicHolder<Subtype> {}
3719: 3719:
3720: 3720:public class CRGWithBasicHolder {
3721: 3721:    public static void main(String[] args) {
3722: 3722:        Subtype st1 = new Subtype(), st2 = new Subtype();
3723: 3723:        st1.set(st2);
3724: 3724:        Subtype st3 = st1.get();
3725: 3725:        st1.f();
3726: 3726:    }
3727: 3727:}
3728: 3728:/* Output:
3729: 3729:Subtype
3730: 3730:*/
3731: 3731:```
3732: 3732:
3733: 3733:注意，这里有些东西很重要：新类 **Subtype** 接受的参数和返回的值具有 **Subtype** 类型而不仅仅是基类 **BasicHolder** 类型。这就是 CRG 的本质：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型。也就是说，在所产生的类中将使用确切类型而不是基类型。因此，在**Subtype** 中，传递给 `set()` 的参数和从 `get()` 返回的类型都是确切的 **Subtype**。
3734: 3734:
3735: 3735:### 自限定
3736: 3736:
3737: 3737:**BasicHolder** 可以使用任何类型作为其泛型参数，就像下面看到的那样：
3738: 3738:
3739: 3739:```java
3740: 3740:// generics/Unconstrained.java
3741: 3741:// (c)2017 MindView LLC: see Copyright.txt
3742: 3742:// We make no guarantees that this code is fit for any purpose.
3743: 3743:// Visit http://OnJava8.com for more book information.
3744: 3744:
3745: 3745:class Other {}
3746: 3746:class BasicOther extends BasicHolder<Other> {}
3747: 3747:
3748: 3748:public class Unconstrained {
3749: 3749:    public static void main(String[] args) {
3750: 3750:        BasicOther b = new BasicOther();
3751: 3751:        BasicOther b2 = new BasicOther();
3752: 3752:        b.set(new Other());
3753: 3753:        Other other = b.get();
3754: 3754:        b.f();
3755: 3755:    }
3756: 3756:}
3757: 3757:/* Output:
3758: 3758:Other
3759: 3759:*/
3760: 3760:```
3761: 3761:
3762: 3762:限定将采取额外的步骤，强制泛型当作其自身的边界参数来使用。观察所产生的类可以如何使用以及不可以如何使用：
3763: 3763:
3764: 3764:```java
3765: 3765:// generics/SelfBounding.java
3766: 3766:
3767: 3767:class SelfBounded<T extends SelfBounded<T>> {
3768: 3768:    T element;
3769: 3769:    SelfBounded<T> set(T arg) {
3770: 3770:        element = arg;
3771: 3771:        return this;
3772: 3772:    }
3773: 3773:    T get() { return element; }
3774: 3774:}
3775: 3775:
3776: 3776:class A extends SelfBounded<A> {}
3777: 3777:class B extends SelfBounded<A> {} // Also OK
3778: 3778:
3779: 3779:class C extends SelfBounded<C> {
3780: 3780:    C setAndGet(C arg) { 
3781: 3781:        set(arg); 
3782: 3782:        return get();
3783: 3783:    }
3784: 3784:}
3785: 3785:
3786: 3786:class D {}
3787: 3787:// Can't do this:
3788: 3788:// class E extends SelfBounded<D> {}
3789: 3789:// Compile error:
3790: 3790://   Type parameter D is not within its bound
3791: 3791:
3792: 3792:// Alas, you can do this, so you cannot force the idiom:
3793: 3793:class F extends SelfBounded {}
3794: 3794:
3795: 3795:public class SelfBounding {
3796: 3796:    public static void main(String[] args) {
3797: 3797:        A a = new A();
3798: 3798:        a.set(new A());
3799: 3799:        a = a.set(new A()).get();
3800: 3800:        a = a.get();
3801: 3801:        C c = new C();
3802: 3802:        c = c.setAndGet(new C());
3803: 3803:    }
3804: 3804:}
3805: 3805:```
3806: 3806:
3807: 3807:自限定所做的，就是要求在继承关系中，像下面这样使用这个类：
3808: 3808:
3809: 3809:```java
3810: 3810:class A extends SelfBounded<A>{}
3811: 3811:```
3812: 3812:
3813: 3813:这会强制要求将正在定义的类当作参数传递给基类。
3814: 3814:
3815: 3815:自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。正如你在 B 类的定义中所看到的，还可以从使用了另一个 **SelfBounded** 参数的 **SelfBounded** 中导出，尽管在 **A** 类看到的用法看起来是主要的用法。对定义 **E** 的尝试说明不能使用不是 **SelfBounded** 的类型参数。
3816: 3816:遗憾的是， **F** 可以编译，不会有任何警告，因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型。
3817: 3817:注意，可以移除自限定这个限制，这样所有的类仍旧是可以编译的，但是 **E** 也会因此而变得可编译：
3818: 3818:
3819: 3819:```java
3820: 3820:// generics/NotSelfBounded.java
3821: 3821:
3822: 3822:public class NotSelfBounded<T> {
3823: 3823:    T element;
3824: 3824:    NotSelfBounded<T> set(T arg) {
3825: 3825:        element = arg;
3826: 3826:        return this;
3827: 3827:    }
3828: 3828:    T get() { return element; }
3829: 3829:} 
3830: 3830:
3831: 3831:class A2 extends NotSelfBounded<A2> {}
3832: 3832:class B2 extends NotSelfBounded<A2> {}
3833: 3833:
3834: 3834:class C2 extends NotSelfBounded<C2> {
3835: 3835:    C2 setAndGet(C2 arg) { 
3836: 3836:        set(arg); 
3837: 3837:        return get(); 
3838: 3838:    }
3839: 3839:}
3840: 3840:
3841: 3841:class D2 {}
3842: 3842:// Now this is OK:
3843: 3843:class E2 extends NotSelfBounded<D2> {}
3844: 3844:```
3845: 3845:
3846: 3846:因此很明显，自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。这会强制要求使用这个类的每个人都要遵循这种形式。
3847: 3847:还可以将自限定用于泛型方法：
3848: 3848:
3849: 3849:```java
3850: 3850:// generics/SelfBoundingMethods.java
3851: 3851:// (c)2017 MindView LLC: see Copyright.txt
3852: 3852:// We make no guarantees that this code is fit for any purpose.
3853: 3853:// Visit http://OnJava8.com for more book information.
3854: 3854:
3855: 3855:public class SelfBoundingMethods {
3856: 3856:    static <T extends SelfBounded<T>> T f(T arg) {
3857: 3857:        return arg.set(arg).get();
3858: 3858:    }
3859: 3859:    
3860: 3860:    public static void main(String[] args) {
3861: 3861:        A a = f(new A());
3862: 3862:    }
3863: 3863:}
3864: 3864:```
3865: 3865:
3866: 3866:这可以防止这个方法被应用于除上述形式的自限定参数之外的任何事物上。
3867: 3867:
3868: 3868:### 参数协变
3869: 3869:
3870: 3870:自限定类型的价值在于它们可以产生*协变参数类型*——方法参数类型会随子类而变化。
3871: 3871:
3872: 3872:尽管自限定类型还可以产生与子类类型相同的返回类型，但是这并不十分重要，因为*协变返回类型*是在 Java 5 引入：
3873: 3873:
3874: 3874:```java
3875: 3875:// generics/CovariantReturnTypes.java
3876: 3876:
3877: 3877:class Base {}
3878: 3878:class Derived extends Base {}
3879: 3879:
3880: 3880:interface OrdinaryGetter {
3881: 3881:    Base get();
3882: 3882:}
3883: 3883:
3884: 3884:interface DerivedGetter extends OrdinaryGetter {
3885: 3885:    // Overridden method return type can vary:
3886: 3886:    @Override
3887: 3887:    Derived get();
3888: 3888:}
3889: 3889:
3890: 3890:public class CovariantReturnTypes {
3891: 3891:    void test(DerivedGetter d) {
3892: 3892:        Derived d2 = d.get();
3893: 3893:    }
3894: 3894:}
3895: 3895:```
3896: 3896:
3897: 3897:**DerivedGetter** 中的 `get()` 方法覆盖了 **OrdinaryGetter** 中的 `get()` ，并返回了一个从 `OrdinaryGetter.get()` 的返回类型中导出的类型。尽管这是完全合乎逻辑的事情（导出类方法应该能够返回比它覆盖的基类方法更具体的类型）但是这在早先的 Java 版本中是不合法的。
3898: 3898:
3899: 3899:自限定泛型事实上将产生确切的导出类型作为其返回值，就像在 `get()` 中所看到的一样：
3900: 3900:
3901: 3901:```java
3902: 3902:// generics/GenericsAndReturnTypes.java
3903: 3903:
3904: 3904:interface GenericGetter<T extends GenericGetter<T>> {
3905: 3905:    T get();
3906: 3906:}
3907: 3907:
3908: 3908:interface Getter extends GenericGetter<Getter> {}
3909: 3909:
3910: 3910:public class GenericsAndReturnTypes {
3911: 3911:    void test(Getter g) {
3912: 3912:        Getter result = g.get();
3913: 3913:        GenericGetter gg = g.get(); // Also the base type
3914: 3914:    }
3915: 3915:}
3916: 3916:```
3917: 3917:
3918: 3918:注意，这段代码不能编译，除非是使用囊括了协变返回类型的 Java 5。
3919: 3919:
3920: 3920:然而，在非泛型代码中，参数类型不能随子类型发生变化：
3921: 3921:
3922: 3922:```java
3923: 3923:// generics/OrdinaryArguments.java
3924: 3924:
3925: 3925:class OrdinarySetter {
3926: 3926:    void set(Base base) {
3927: 3927:        System.out.println("OrdinarySetter.set(Base)");
3928: 3928:    }
3929: 3929:}
3930: 3930:
3931: 3931:class DerivedSetter extends OrdinarySetter {
3932: 3932:    void set(Derived derived) {
3933: 3933:        System.out.println("DerivedSetter.set(Derived)");
3934: 3934:    }
3935: 3935:}
3936: 3936:
3937: 3937:public class OrdinaryArguments {
3938: 3938:    public static void main(String[] args) {
3939: 3939:        Base base = new Base();
3940: 3940:        Derived derived = new Derived();
3941: 3941:        DerivedSetter ds = new DerivedSetter();
3942: 3942:        ds.set(derived);
3943: 3943:        // Compiles--overloaded, not overridden!:
3944: 3944:        ds.set(base);
3945: 3945:    }
3946: 3946:}
3947: 3947:/* Output:
3948: 3948:DerivedSetter.set(Derived)
3949: 3949:OrdinarySetter.set(Base)
3950: 3950:*/
3951: 3951:```
3952: 3952:
3953: 3953:`set(derived)` 和 `set(base)` 都是合法的，因此 `DerivedSetter.set()` 没有覆盖 `OrdinarySetter.set()` ，而是重载了这个方法。从输出中可以看到，在 **DerivedSetter** 中有两个方法，因此基类版本仍旧是可用的，因此可以证明它被重载过。
3954: 3954:但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类型而不是基类型为参数：
3955: 3955:
3956: 3956:```java
3957: 3957:// generics/SelfBoundingAndCovariantArguments.java
3958: 3958:
3959: 3959:interface SelfBoundSetter<T extends SelfBoundSetter<T>> {
3960: 3960:    void set(T arg);
3961: 3961:}
3962: 3962:
3963: 3963:interface Setter extends SelfBoundSetter<Setter> {}
3964: 3964:
3965: 3965:public class SelfBoundingAndCovariantArguments {
3966: 3966:    void
3967: 3967:    testA(Setter s1, Setter s2, SelfBoundSetter sbs) {
3968: 3968:        s1.set(s2);
3969: 3969:        //- s1.set(sbs);
3970: 3970:        // error: method set in interface SelfBoundSetter<T>
3971: 3971:        // cannot be applied to given types;
3972: 3972:        //     s1.set(sbs);
3973: 3973:        //       ^
3974: 3974:        //   required: Setter
3975: 3975:        //   found: SelfBoundSetter
3976: 3976:        //   reason: argument mismatch;
3977: 3977:        // SelfBoundSetter cannot be converted to Setter
3978: 3978:        //   where T is a type-variable:
3979: 3979:        //     T extends SelfBoundSetter<T> declared in
3980: 3980:        //     interface SelfBoundSetter
3981: 3981:        // 1 error
3982: 3982:    }
3983: 3983:}
3984: 3984:```
3985: 3985:
3986: 3986:编译器不能识别将基类型当作参数传递给 `set()` 的尝试，因为没有任何方法具有这样的签名。实际上，这个参数已经被覆盖。
3987: 3987:如果不使用自限定类型，普通的继承机制就会介入，而你将能够重载，就像在非泛型的情况下一样：
3988: 3988:
3989: 3989:```java
3990: 3990:// generics/PlainGenericInheritance.java
3991: 3991:
3992: 3992:class GenericSetter<T> { // Not self-bounded
3993: 3993:    void set(T arg) {
3994: 3994:        System.out.println("GenericSetter.set(Base)");
3995: 3995:    }
3996: 3996:}
3997: 3997:
3998: 3998:class DerivedGS extends GenericSetter<Base> {
3999: 3999:    void set(Derived derived) {
4000: 4000:        System.out.println("DerivedGS.set(Derived)");
4001: 4001:    }
4002: 4002:}
4003: 4003:
4004: 4004:public class PlainGenericInheritance {
4005: 4005:    public static void main(String[] args) {
4006: 4006:        Base base = new Base();
4007: 4007:        Derived derived = new Derived();
4008: 4008:        DerivedGS dgs = new DerivedGS();
4009: 4009:        dgs.set(derived);
4010: 4010:        dgs.set(base); // Overloaded, not overridden!
4011: 4011:    }
4012: 4012:}
4013: 4013:/* Output:
4014: 4014:DerivedGS.set(Derived)
4015: 4015:GenericSetter.set(Base)
4016: 4016:*/
4017: 4017:```
4018: 4018:
4019: 4019:这段代码在模仿 **OrdinaryArguments.java**；在那个示例中，**DerivedSetter** 继承自包含一个 `set(Base)` 的**OrdinarySetter** 。而这里，**DerivedGS** 继承自泛型创建的也包含有一个 `set(Base)`的 `GenericSetter<Base>`。就像 **OrdinaryArguments.java** 一样，你可以从输出中看到， **DerivedGS** 包含两个  `set()` 的重载版本。如果不使用自限定，将重载参数类型。如果使用了自限定，只能获得方法的一个版本，它将接受确切的参数类型。
4020: 4020:
4021: 4021:<!-- Dynamic Type Safety -->
4022: 4022:
4023: 4023:## 动态类型安全
4024: 4024:
4025: 4025:因为可以向 Java 5 之前的代码传递泛型集合，所以旧式代码仍旧有可能会破坏你的集合。Java 5 的 **java.util.Collections** 中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：静态方法 `checkedCollection()` 、`checkedList()`、 `checkedMap()` 、 `checkedSet()` 、`checkedSortedMap()`和 `checkedSortedSet()`。这些方法每一个都会将你希望动态检查的集合当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。
4026: 4026:
4027: 4027:受检查的集合在你试图插入类型不正确的对象时抛出 **ClassCastException** ，这与泛型之前的（原生）集合形成了对比，对于后者来说，当你将对象从集合中取出时，才会通知你出现了问题。在后一种情况中，你知道存在问题，但是不知道罪魁祸首在哪里，如果使用受检查的集合，就可以发现谁在试图插入不良对象。
4028: 4028:让我们用受检查的集合来看看“将猫插入到狗列表中”这个问题。这里，`oldStyleMethod()` 表示遗留代码，因为它接受的是原生的 **List** ，而 **@SuppressWarnings（“unchecked”）** 注解对于压制所产生的警告是必需的：
4029: 4029:
4030: 4030:```java
4031: 4031:// generics/CheckedList.java
4032: 4032:// Using Collection.checkedList()
4033: 4033:import typeinfo.pets.*;
4034: 4034:import java.util.*;
4035: 4035:
4036: 4036:public class CheckedList {
4037: 4037:    @SuppressWarnings("unchecked")
4038: 4038:    static void oldStyleMethod(List probablyDogs) {
4039: 4039:        probablyDogs.add(new Cat());
4040: 4040:    }
4041: 4041:    
4042: 4042:    public static void main(String[] args) {
4043: 4043:        List<Dog> dogs1 = new ArrayList<>();
4044: 4044:        oldStyleMethod(dogs1); // Quietly accepts a Cat
4045: 4045:        List<Dog> dogs2 = Collections.checkedList(
4046: 4046:            new ArrayList<>(), Dog.class);
4047: 4047:        try {
4048: 4048:            oldStyleMethod(dogs2); // Throws an exception
4049: 4049:        } catch(Exception e) {
4050: 4050:            System.out.println("Expected: " + e);
4051: 4051:        }
4052: 4052:        // Derived types work fine:
4053: 4053:        List<Pet> pets = Collections.checkedList(
4054: 4054:            new ArrayList<>(), Pet.class);
4055: 4055:        pets.add(new Dog());
4056: 4056:        pets.add(new Cat());
4057: 4057:    }
4058: 4058:}
4059: 4059:/* Output:
4060: 4060:Expected: java.lang.ClassCastException: Attempt to
4061: 4061:insert class typeinfo.pets.Cat element into collection
4062: 4062:with element type class typeinfo.pets.Dog
4063: 4063:*/
4064: 4064:```
4065: 4065:
4066: 4066:运行这个程序时，你会发现插入一个 **Cat** 对于 **dogs1** 来说没有任何问题，而 **dogs2** 立即会在这个错误类型的插入操作上抛出一个异常。还可以看到，将导出类型的对象放置到将要检查基类型的受检查容器中是没有问题的。
4067: 4067:
4068: 4068:<!-- Exceptions -->
4069: 4069:
4070: 4070:## 泛型异常
4071: 4071:
4072: 4072:由于擦除的原因，**catch** 语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承自 **Throwable**（这将进一步阻止你去定义不能捕获的泛型异常）。
4073: 4073:但是，类型参数可能会在一个方法的 **throws** 子句中用到。这使得你可以编写随检查型异常类型变化的泛型代码：
4074: 4074:
4075: 4075:```java
4076: 4076:// generics/ThrowGenericException.java
4077: 4077:
4078: 4078:import java.util.*;
4079: 4079:
4080: 4080:interface Processor<T, E extends Exception> {
4081: 4081:    void process(List<T> resultCollector) throws E;
4082: 4082:}
4083: 4083:
4084: 4084:class ProcessRunner<T, E extends Exception>
4085: 4085:extends ArrayList<Processor<T, E>> {
4086: 4086:    List<T> processAll() throws E {
4087: 4087:        List<T> resultCollector = new ArrayList<>();
4088: 4088:        for(Processor<T, E> processor : this)
4089: 4089:            processor.process(resultCollector);
4090: 4090:        return resultCollector;
4091: 4091:    }
4092: 4092:}
4093: 4093:
4094: 4094:class Failure1 extends Exception {}
4095: 4095:
4096: 4096:class Processor1
4097: 4097:implements Processor<String, Failure1> {
4098: 4098:    static int count = 3;
4099: 4099:    @Override
4100: 4100:    public void process(List<String> resultCollector)
4101: 4101:    throws Failure1 {
4102: 4102:        if(count-- > 1)
4103: 4103:            resultCollector.add("Hep!");
4104: 4104:        else
4105: 4105:            resultCollector.add("Ho!");
4106: 4106:        if(count < 0)
4107: 4107:            throw new Failure1();
4108: 4108:    }
4109: 4109:}
4110: 4110:
4111: 4111:class Failure2 extends Exception {}
4112: 4112:
4113: 4113:class Processor2
4114: 4114:implements Processor<Integer, Failure2> {
4115: 4115:    static int count = 2;
4116: 4116:    @Override
4117: 4117:    public void process(List<Integer> resultCollector)
4118: 4118:    throws Failure2 {
4119: 4119:        if(count-- == 0)
4120: 4120:            resultCollector.add(47);
4121: 4121:        else {
4122: 4122:            resultCollector.add(11);
4123: 4123:        }
4124: 4124:        if(count < 0)
4125: 4125:            throw new Failure2();
4126: 4126:    }
4127: 4127:}
4128: 4128:
4129: 4129:public class ThrowGenericException {
4130: 4130:    public static void main(String[] args) {
4131: 4131:        ProcessRunner<String, Failure1> runner =
4132: 4132:            new ProcessRunner<>();
4133: 4133:        for(int i = 0; i < 3; i++)
4134: 4134:            runner.add(new Processor1());
4135: 4135:        try {
4136: 4136:            System.out.println(runner.processAll());
4137: 4137:        } catch(Failure1 e) {
4138: 4138:            System.out.println(e);
4139: 4139:        }
4140: 4140:
4141: 4141:        ProcessRunner<Integer, Failure2> runner2 =
4142: 4142:            new ProcessRunner<>();
4143: 4143:        for(int i = 0; i < 3; i++)
4144: 4144:            runner2.add(new Processor2());
4145: 4145:        try {
4146: 4146:            System.out.println(runner2.processAll());
4147: 4147:        } catch(Failure2 e) {
4148: 4148:            System.out.println(e);
4149: 4149:        }
4150: 4150:    }
4151: 4151:}
4152: 4152:/* Output:
4153: 4153:[Hep!, Hep!, Ho!]
4154: 4154:Failure2
4155: 4155:*/
4156: 4156:```
4157: 4157:
4158: 4158:**Processor** 执行 `process()` 方法，并且可能会抛出具有类型 **E** 的异常。`process()` 的结果存储在 `List<T>resultCollector` 中（这被称为*收集参数*）。**ProcessRunner** 有一个 `processAll()` 方法，它会在所持有的每个 **Process** 对象执行，并返回 **resultCollector** 。
4159: 4159:如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出这种泛化的代码。
4160: 4160:
4161: 4161:<!-- Mixins -->
4162: 4162:
4163: 4163:## 混型
4164: 4164:
4165: 4165:术语*混型*随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是你最后的手段，它将使组装多个类变得简单易行。
4166: 4166:混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点*面向切面编程* （AOP） 的味道，而切面经常被建议用来解决混型问题。
4167: 4167:
4168: 4168:### C++ 中的混型
4169: 4169:
4170: 4170:在 C++ 中，使用多重继承的最大理由，就是为了使用混型。但是，对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为混型就是继承自其类型参数的类。在 C++ 中，可以很容易地创建混型，因为 C++ 能够记住其模版参数的类型。
4171: 4171:下面是一个 C++ 示例，它有两个混型类型：一个使得你可以在每个对象中混入拥有一个时间戳这样的属性，而另一个可以混入一个序列号。
4172: 4172:
4173: 4173:```c++
4174: 4174:// generics/Mixins.cpp
4175: 4175:
4176: 4176:#include <string>
4177: 4177:#include <ctime>
4178: 4178:#include <iostream>
4179: 4179:using namespace std;
4180: 4180:
4181: 4181:template<class T> class TimeStamped : public T {
4182: 4182:    long timeStamp;
4183: 4183:public:
4184: 4184:    TimeStamped() { timeStamp = time(0); }
4185: 4185:    long getStamp() { return timeStamp; }
4186: 4186:};
4187: 4187:
4188: 4188:template<class T> class SerialNumbered : public T {
4189: 4189:    long serialNumber;
4190: 4190:    static long counter;
4191: 4191:public:
4192: 4192:    SerialNumbered() { serialNumber = counter++; }
4193: 4193:    long getSerialNumber() { return serialNumber; }
4194: 4194:};
4195: 4195:
4196: 4196:// Define and initialize the static storage:
4197: 4197:template<class T> long SerialNumbered<T>::counter = 1;
4198: 4198:
4199: 4199:class Basic {
4200: 4200:    string value;
4201: 4201:public:
4202: 4202:    void set(string val) { value = val; }
4203: 4203:    string get() { return value; }
4204: 4204:};
4205: 4205:
4206: 4206:int main() {
4207: 4207:    TimeStamped<SerialNumbered<Basic>> mixin1, mixin2;
4208: 4208:    mixin1.set("test string 1");
4209: 4209:    mixin2.set("test string 2");
4210: 4210:    cout << mixin1.get() << " " << mixin1.getStamp() <<
4211: 4211:      " " << mixin1.getSerialNumber() << endl;
4212: 4212:    cout << mixin2.get() << " " << mixin2.getStamp() <<
4213: 4213:      " " << mixin2.getSerialNumber() << endl;
4214: 4214:}
4215: 4215:/* Output:
4216: 4216:test string 1 1452987605 1
4217: 4217:test string 2 1452987605 2
4218: 4218:*/
4219: 4219:```
4220: 4220:
4221: 4221:在 `main()` 中， **mixin1** 和 **mixin2** 所产生的类型拥有所混入类型的所有方法。可以将混型看作是一种功能，它可以将现有类映射到新的子类上。注意，使用这种技术来创建一个混型是多么的轻而易举。基本上，只需要声明“这就是我想要的”，紧跟着它就发生了：
4222: 4222:
4223: 4223:```c++
4224: 4224:TimeStamped<SerialNumbered<Basic>> mixin1，mixin2；
4225: 4225:```
4226: 4226:
4227: 4227:遗憾的是，Java 泛型不允许这样。擦除会忘记基类类型，因此
4228: 4228:
4229: 4229:>  泛型类不能直接继承自一个泛型参数
4230: 4230:
4231: 4231:这突显了许多我在 Java 语言设计决策（以及与这些功能一起发布）中遇到的一大问题：处理一件事很有希望，但是当您实际尝试做一些有趣的事情时，您会发现自己做不到。
4232: 4232:
4233: 4233:### 与接口混合
4234: 4234:
4235: 4235:一种更常见的推荐解决方案是使用接口来产生混型效果，就像下面这样：
4236: 4236:
4237: 4237:```java
4238: 4238:// generics/Mixins.java
4239: 4239:
4240: 4240:import java.util.*;
4241: 4241:
4242: 4242:interface TimeStamped { long getStamp(); }
4243: 4243:
4244: 4244:class TimeStampedImp implements TimeStamped {
4245: 4245:    private final long timeStamp;
4246: 4246:    TimeStampedImp() {
4247: 4247:        timeStamp = new Date().getTime();
4248: 4248:    }
4249: 4249:    @Override
4250: 4250:    public long getStamp() { return timeStamp; }
4251: 4251:}
4252: 4252:
4253: 4253:interface SerialNumbered { long getSerialNumber(); }
4254: 4254:
4255: 4255:class SerialNumberedImp implements SerialNumbered {
4256: 4256:    private static long counter = 1;
4257: 4257:    private final long serialNumber = counter++;
4258: 4258:    @Override
4259: 4259:    public long getSerialNumber() { return serialNumber; }
4260: 4260:}
4261: 4261:
4262: 4262:interface Basic {
4263: 4263:    void set(String val);
4264: 4264:    String get();
4265: 4265:}
4266: 4266:
4267: 4267:class BasicImp implements Basic {
4268: 4268:    private String value;
4269: 4269:    @Override
4270: 4270:    public void set(String val) { value = val; }
4271: 4271:    @Override
4272: 4272:    public String get() { return value; }
4273: 4273:}
4274: 4274:
4275: 4275:class Mixin extends BasicImp
4276: 4276:implements TimeStamped, SerialNumbered {
4277: 4277:    private TimeStamped timeStamp = new TimeStampedImp();
4278: 4278:    private SerialNumbered serialNumber =
4279: 4279:        new SerialNumberedImp();
4280: 4280:    @Override
4281: 4281:    public long getStamp() {
4282: 4282:        return timeStamp.getStamp();
4283: 4283:    }
4284: 4284:    @Override
4285: 4285:    public long getSerialNumber() {
4286: 4286:        return serialNumber.getSerialNumber();
4287: 4287:    }
4288: 4288:}
4289: 4289:
4290: 4290:public class Mixins {
4291: 4291:    public static void main(String[] args) {
4292: 4292:        Mixin mixin1 = new Mixin(), mixin2 = new Mixin();
4293: 4293:        mixin1.set("test string 1");
4294: 4294:        mixin2.set("test string 2");
4295: 4295:        System.out.println(mixin1.get() + " " +
4296: 4296:            mixin1.getStamp() +  " " + mixin1.getSerialNumber());
4297: 4297:        System.out.println(mixin2.get() + " " +
4298: 4298:            mixin2.getStamp() +  " " + mixin2.getSerialNumber());
4299: 4299:    }
4300: 4300:}
4301: 4301:/* Output:
4302: 4302:test string 1 1494331663026 1
4303: 4303:test string 2 1494331663027 2
4304: 4304:*/
4305: 4305:```
4306: 4306:
4307: 4307:**Mixin** 类基本上是在使用*委托*，因此每个混入类型都要求在 **Mixin** 中有一个相应的域，而你必须在 **Mixin** 中编写所有必需的方法，将方法调用转发给恰当的对象。这个示例使用了非常简单的类，但是当使用更复杂的混型时，代码数量会急速增加。[^4]
4308: 4308:
4309: 4309:### 使用装饰器模式
4310: 4310:
4311: 4311:当你观察混型的使用方式时，就会发现混型概念好像与*装饰器*设计模式关系很近。装饰器经常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的。
4312: 4312:装饰器模式使用分层对象来动态透明地向单个对象中添加责任。装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。某些事物是可装饰的，可以通过将其他类包装在这个可装饰对象的四周，来将功能分层。这使得对装饰器的使用是透明的——无论对象是否被装饰，你都拥有一个可以向对象发送的公共消息集。装饰类也可以添加新方法，但是正如你所见，这将是受限的。
4313: 4313:装饰器是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。
4314: 4314:前面的示例可以被改写为使用装饰器：
4315: 4315:
4316: 4316:```java
4317: 4317:// generics/decorator/Decoration.java
4318: 4318:
4319: 4319:// {java generics.decorator.Decoration}
4320: 4320:package generics.decorator;
4321: 4321:import java.util.*;
4322: 4322:
4323: 4323:class Basic {
4324: 4324:    private String value;
4325: 4325:    public void set(String val) { value = val; }
4326: 4326:    public String get() { return value; }
4327: 4327:}
4328: 4328:
4329: 4329:class Decorator extends Basic {
4330: 4330:    protected Basic basic;
4331: 4331:    Decorator(Basic basic) { this.basic = basic; }
4332: 4332:    @Override
4333: 4333:    public void set(String val) { basic.set(val); }
4334: 4334:    @Override
4335: 4335:    public String get() { return basic.get(); }
4336: 4336:}
4337: 4337:
4338: 4338:class TimeStamped extends Decorator {
4339: 4339:    private final long timeStamp;
4340: 4340:    TimeStamped(Basic basic) {
4341: 4341:        super(basic);
4342: 4342:        timeStamp = new Date().getTime();
4343: 4343:    }
4344: 4344:    public long getStamp() { return timeStamp; }
4345: 4345:}
4346: 4346:
4347: 4347:class SerialNumbered extends Decorator {
4348: 4348:    private static long counter = 1;
4349: 4349:    private final long serialNumber = counter++;
4350: 4350:    SerialNumbered(Basic basic) { super(basic); }
4351: 4351:    public long getSerialNumber() { return serialNumber; }
4352: 4352:}
4353: 4353:
4354: 4354:public class Decoration {
4355: 4355:    public static void main(String[] args) {
4356: 4356:        TimeStamped t = new TimeStamped(new Basic());
4357: 4357:        TimeStamped t2 = new TimeStamped(
4358: 4358:            new SerialNumbered(new Basic()));
4359: 4359:        //- t2.getSerialNumber(); // Not available
4360: 4360:        SerialNumbered s = new SerialNumbered(new Basic());
4361: 4361:        SerialNumbered s2 = new SerialNumbered(
4362: 4362:            new TimeStamped(new Basic()));
4363: 4363:        //- s2.getStamp(); // Not available
4364: 4364:  }
4365: 4365:}
4366: 4366:```
4367: 4367:
4368: 4368:产生自泛型的类包含所有感兴趣的方法，但是由使用装饰器所产生的对象类型是最后被装饰的类型。也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。因此，装饰器只是对由混型提出的问题的一种局限的解决方案。
4369: 4369:
4370: 4370:### 与动态代理混合
4371: 4371:
4372: 4372:可以使用动态代理来创建一种比装饰器更贴近混型模型的机制（查看 [类型信息](book/19-Type-Information.md) 一章中关于 Java 的动态代理如何工作的解释）。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。
4373: 4373:由于动态代理的限制，每个被混入的类都必须是某个接口的实现：
4374: 4374:
4375: 4375:```java
4376: 4376:// generics/DynamicProxyMixin.java
4377: 4377:
4378: 4378:import java.lang.reflect.*;
4379: 4379:import java.util.*;
4380: 4380:import onjava.*;
4381: 4381:import static onjava.Tuple.*;
4382: 4382:
4383: 4383:class MixinProxy implements InvocationHandler {
4384: 4384:    Map<String, Object> delegatesByMethod;
4385: 4385:    @SuppressWarnings("unchecked")
4386: 4386:    MixinProxy(Tuple2<Object, Class<?>>... pairs) {
4387: 4387:        delegatesByMethod = new HashMap<>();
4388: 4388:        for(Tuple2<Object, Class<?>> pair : pairs) {
4389: 4389:            for(Method method : pair.a2.getMethods()) {
4390: 4390:                String methodName = method.getName();
4391: 4391:                // The first interface in the map
4392: 4392:                // implements the method.
4393: 4393:                if(!delegatesByMethod.containsKey(methodName))
4394: 4394:                    delegatesByMethod.put(methodName, pair.a1);
4395: 4395:            }
4396: 4396:        }
4397: 4397:    }
4398: 4398:    @Override
4399: 4399:    public Object invoke(Object proxy, Method method,
4400: 4400:      Object[] args) throws Throwable {
4401: 4401:        String methodName = method.getName();
4402: 4402:        Object delegate = delegatesByMethod.get(methodName);
4403: 4403:        return method.invoke(delegate, args);
4404: 4404:    }
4405: 4405:    
4406: 4406:    @SuppressWarnings("unchecked")
4407: 4407:    public static Object newInstance(Tuple2... pairs) {
4408: 4408:        Class[] interfaces = new Class[pairs.length];
4409: 4409:        for(int i = 0; i < pairs.length; i++) {
4410: 4410:            interfaces[i] = (Class)pairs[i].a2;
4411: 4411:        }
4412: 4412:        ClassLoader cl = pairs[0].a1.getClass().getClassLoader();
4413: 4413:        return Proxy.newProxyInstance(cl, interfaces, new MixinProxy(pairs));
4414: 4414:    }
4415: 4415:}
4416: 4416:
4417: 4417:public class DynamicProxyMixin {
4418: 4418:    public static void main(String[] args) {
4419: 4419:        Object mixin = MixinProxy.newInstance(
4420: 4420:          tuple(new BasicImp(), Basic.class),
4421: 4421:          tuple(new TimeStampedImp(), TimeStamped.class),
4422: 4422:          tuple(new SerialNumberedImp(), SerialNumbered.class));
4423: 4423:        Basic b = (Basic)mixin;
4424: 4424:        TimeStamped t = (TimeStamped)mixin;
4425: 4425:        SerialNumbered s = (SerialNumbered)mixin;
4426: 4426:        b.set("Hello");
4427: 4427:        System.out.println(b.get());
4428: 4428:        System.out.println(t.getStamp());
4429: 4429:        System.out.println(s.getSerialNumber());
4430: 4430:    }
4431: 4431:}
4432: 4432:/* Output:
4433: 4433:Hello
4434: 4434:1494331653339
4435: 4435:1
4436: 4436:*/
4437: 4437:```
4438: 4438:
4439: 4439:因为只有动态类型而不是静态类型才包含所有的混入类型，因此这仍旧不如 C++ 的方式好，因为可以在具有这些类型的对象上调用方法之前，你被强制要求必须先将这些对象向下转型到恰当的类型。但是，它明显地更接近于真正的混型。
4440: 4440:为了让 Java 支持混型，人们已经做了大量的工作朝着这个目标努力，包括创建了至少一种附加语言（ Jam 语言），它是专门用来支持混型的。
4441: 4441:
4442: 4442:<!-- Latent Typing -->
4443: 4443:
4444: 4444:## 潜在类型机制
4445: 4445:
4446: 4446:在本章的开头介绍过这样的思想，即要编写能够尽可能广泛地应用的代码。为了实现这一点，我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处。然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码。
4447: 4447:
4448: 4448:Java 泛型看起来是向这一方向迈进了一步。当你在编写或使用只是持有对象的泛型时，这些代码将可以工作于任何类型（除了基本类型，尽管正如你所见到的，自动装箱机制可以克服这一点）。或者，换个角度讲，“持有器”泛型能够声明：“我不关心你是什么类型”。如果代码不关心它将要作用的类型，那么这种代码就可以真正地应用于任何地方，并因此而相当泛化。
4449: 4449:
4450: 4450:还是正如你所见到的，当要在泛型类型上执行操作（即调用 **Object** 方法之外的方法）时，就会产生问题。擦除强制要求指定可能会用到的泛型类型的边界，以安全地调用代码中的泛型对象上的具体方法。这是对“泛化”概念的一种明显的限制，因为必须限制你的泛型类型，使它们继承自特定的类，或者实现特定的接口。在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类或接口没有任何区别。
4451: 4451:
4452: 4452:某些编程语言提供的一种解决方案称为*潜在类型机制*或*结构化类型机制*，而更古怪的术语称为*鸭子类型机制*，即“如果它走起来像鸭子，并且叫起来也像鸭子，那么你就可以将它当作鸭子对待。”鸭子类型机制变成了一种相当流行的术语，可能是因为它不像其他的术语那样承载着历史的包袱。
4453: 4453:
4454: 4454:泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得你可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以 `speak()` 和 `sit()` 即可。”由于不要求具体类型，因此代码就可以更加泛化。
4455: 4455:
4456: 4456:潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方。
4457: 4457:
4458: 4458:支持潜在类型机制的语言包括 Python（可以从 www.Python.org 免费下载）、C++、Ruby、SmallTalk 和 Go。Python 是动态类型语言（几乎所有的类型检查都发生在运行时），而 C++ 和 Go 是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查。
4459: 4459:
4460: 4460:### pyhton 中的潜在类型
4461: 4461:
4462: 4462:如果我们将上面的描述用 Python 来表示，如下所示：
4463: 4463:
4464: 4464:```python
4465: 4465:# generics/DogsAndRobots.py
4466: 4466:
4467: 4467:class Dog:
4468: 4468:    def speak(self):
4469: 4469:        print("Arf!")
4470: 4470:    def sit(self):
4471: 4471:        print("Sitting")
4472: 4472:    def reproduce(self):
4473: 4473:        pass
4474: 4474:
4475: 4475:class Robot:
4476: 4476:    def speak(self):
4477: 4477:        print("Click!")
4478: 4478:    def sit(self):
4479: 4479:        print("Clank!")
4480: 4480:    def oilChange(self):
4481: 4481:        pass
4482: 4482:
4483: 4483:def perform(anything):
4484: 4484:    anything.speak()
4485: 4485:    anything.sit()
4486: 4486:
4487: 4487:a = Dog()
4488: 4488:b = Robot()
4489: 4489:perform(a)
4490: 4490:perform(b)
4491: 4491:
4492: 4492:output = """
4493: 4493:Arf!
4494: 4494:Sitting
4495: 4495:Click!
4496: 4496:Clank!
4497: 4497:"""
4498: 4498:```
4499: 4499:
4500: 4500:Python 使用缩进来确定作用域（因此不需要任何花括号），而冒号将表示新的作用域的开始。“**#**” 表示注释到行尾，就像Java中的 “ **//** ”。类的方法需要显式地指定 **this** 引用的等价物作为第一个参数，按惯例成为 **self** 。构造器调用不要求任何类型的“ **new** ”关键字，并且 Python 允许普通（非成员）函数，就像 `perform()` 所表明的那样。注意，在 `perform(anything)` 中，没有任何针对 **anything** 的类型，**anything** 只是一个标识符，它必须能够执行 `perform()` 期望它执行的操作，因此这里隐含着一个接口。但是你从来都不必显式地写出这个接口——它是潜在的。`perform()` 不关心其参数的类型，因此我可以向它传递任何对象，只要该对象支持  `speak()` 和 `sit()` 方法。如果传递给 `perform()` 的对象不支持这些操作，那么将会得到运行时异常。
4501: 4501:
4502: 4502:输出规定使用三重引号创建带有内嵌换行符的字符串。
4503: 4503:
4504: 4504:### C++ 中的潜在类型
4505: 4505:
4506: 4506:我们可以用 C++ 产生相同的效果：
4507: 4507:
4508: 4508:```c++
4509: 4509:// generics/DogsAndRobots.cpp
4510: 4510:
4511: 4511:#include <iostream>
4512: 4512:using namespace std;
4513: 4513:
4514: 4514:class Dog {
4515: 4515:public:
4516: 4516:    void speak() { cout << "Arf!" << endl; }
4517: 4517:    void sit() { cout << "Sitting" << endl; }
4518: 4518:    void reproduce() {}
4519: 4519:};
4520: 4520:
4521: 4521:class Robot {
4522: 4522:public:
4523: 4523:    void speak() { cout << "Click!" << endl; }
4524: 4524:    void sit() { cout << "Clank!" << endl; }
4525: 4525:    void oilChange() {}
4526: 4526:};
4527: 4527:
4528: 4528:template<class T> void perform(T anything) {
4529: 4529:    anything.speak();
4530: 4530:    anything.sit();
4531: 4531:}
4532: 4532:
4533: 4533:int main() {
4534: 4534:    Dog d;
4535: 4535:    Robot r;
4536: 4536:    perform(d);
4537: 4537:    perform(r);
4538: 4538:}
4539: 4539:/* Output:
4540: 4540:Arf!
4541: 4541:Sitting
4542: 4542:Click!
4543: 4543:Clank!
4544: 4544:*/
4545: 4545:```
4546: 4546:
4547: 4547:在 Python 和 C++ 中，**Dog** 和 **Robot** 没有任何共同的东西，只是碰巧有两个方法具有相同的签名。从类型的观点看，它们是完全不同的类型。但是，`perform()` 不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。
4548: 4548:C++ 确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给你一个错误消息（这些错误消息从历史上看是相当可怕和冗长的，是 C++ 的模版名声欠佳的主要原因）。尽管它们是在不同时期实现这一点的，C++ 在编译期，而 Python 在运行时，但是这两种语言都可以确保类型不会被误用，因此被认为是强类型的。[^5]潜在类型机制没有损害强类型机制。
4549: 4549:
4550: 4550:### Go 中的潜在类型
4551: 4551:
4552: 4552:这里用 Go 语言编写相同的程序：
4553: 4553:
4554: 4554:```go
4555: 4555:// generics/dogsandrobots.go
4556: 4556:
4557: 4557:package main
4558: 4558:import "fmt"
4559: 4559:
4560: 4560:type Dog struct {}
4561: 4561:func (this Dog) speak() { fmt.Printf("Arf!\n")}
4562: 4562:func (this Dog) sit() { fmt.Printf("Sitting\n")}
4563: 4563:func (this Dog) reproduce() {}
4564: 4564:
4565: 4565:type Robot struct {}
4566: 4566:func (this Robot) speak() { fmt.Printf("Click!\n") }
4567: 4567:func (this Robot) sit() { fmt.Printf("Clank!\n") }
4568: 4568:func (this Robot) oilChange() {}
4569: 4569:
4570: 4570:func perform(speaker interface { speak(); sit() }) {
4571: 4571:  speaker.speak();
4572: 4572:  speaker.sit();
4573: 4573:}
4574: 4574:
4575: 4575:func main() {
4576: 4576:  perform(Dog{})
4577: 4577:  perform(Robot{})
4578: 4578:}
4579: 4579:/* Output:
4580: 4580:Arf!
4581: 4581:Sitting
4582: 4582:Click!
4583: 4583:Clank!
4584: 4584:*/
4585: 4585:```
4586: 4586:
4587: 4587:Go 没有 **class** 关键字，但是可以使用上述形式创建等效的基本类：它通常不定义为类，而是定义为 **struct** ，在其中定义数据字段（此处不存在）。 对于每种方法，都以 **func** 关键字开头，然后（为了将该方法附加到您的类上）放在括号中，该括号包含对象引用，该对象引用可以是任何标识符，但是我在这里使用 **this** 来提醒您，就像在 C ++ 或 Java 中的 **this** 一样。 然后，在Go中像这样定义其余的函数。
4588: 4588:
4589: 4589:Go也没有继承关系，因此这种“面向对象的目标”形式是相对原始的，并且可能是我无法花更多的时间来学习该语言的主要原因。 但是，Go 的组成很简单。
4590: 4590:
4591: 4591:`perform()` 函数使用潜在类型：参数的确切类型并不重要，只要它包含了 `speak()` 和  `sit()` 方法即可。 该接口在此处匿名定义，内联，如 `perform()` 的参数列表所示。
4592: 4592:
4593: 4593:`main()` 证明 `perform()` 确实对其参数的确切类型不在乎，只要可以在该参数上调用 `talk()` 和 `sit()` 即可。 但是，就像 C ++ 模板函数一样，在编译时检查类型。
4594: 4594:
4595: 4595:语法 **Dog {}** 和 **Robot {}** 创建匿名的 **Dog** 和 **Robot** 结构。
4596: 4596:
4597: 4597:### java中的直接潜在类型
4598: 4598:
4599: 4599:因为泛型是在这场竞赛的后期才添加到 Java 中，因此没有任何机会可以去实现任何类型的潜在类型机制，因此 Java 没有对这种特性的支持。所以，初看起来，Java 的泛型机制比支持潜在类型机制的语言更“缺乏泛化性”。（使用擦除来实现 Java 泛型的实现有时称为第二类泛型类型）例如，在 Java 8  之前如果我们试图用 Java 实现上面 dogs-and-robots 的示例，那么就会被强制要求使用一个类或接口，并在边界表达式中指定它：
4600: 4600:
4601: 4601:```java
4602: 4602:// generics/Performs.java
4603: 4603:
4604: 4604:public interface Performs {
4605: 4605:    void speak();
4606: 4606:    void sit();
4607: 4607:}
4608: 4608:```
4609: 4609:
4610: 4610:```java
4611: 4611:// generics/DogsAndRobots.java
4612: 4612:// No (direct) latent typing in Java
4613: 4613:import typeinfo.pets.*;
4614: 4614:
4615: 4615:class PerformingDog extends Dog implements Performs {
4616: 4616:    @Override
4617: 4617:    public void speak() { System.out.println("Woof!"); }
4618: 4618:    @Override
4619: 4619:    public void sit() { System.out.println("Sitting"); }
4620: 4620:    public void reproduce() {}
4621: 4621:}
4622: 4622:
4623: 4623:class Robot implements Performs {
4624: 4624:    public void speak() { System.out.println("Click!"); }
4625: 4625:    public void sit() { System.out.println("Clank!"); }
4626: 4626:    public void oilChange() {}
4627: 4627:}
4628: 4628:
4629: 4629:class Communicate {
4630: 4630:    public static <T extends Performs>
4631: 4631:      void perform(T performer) {
4632: 4632:        performer.speak();
4633: 4633:        performer.sit();
4634: 4634:    }
4635: 4635:}
4636: 4636:
4637: 4637:public class DogsAndRobots {
4638: 4638:    public static void main(String[] args) {
4639: 4639:        Communicate.perform(new PerformingDog());
4640: 4640:        Communicate.perform(new Robot());
4641: 4641:    }
4642: 4642:}
4643: 4643:/* Output:
4644: 4644:Woof!
4645: 4645:Sitting
4646: 4646:Click!
4647: 4647:Clank!
4648: 4648:*/
4649: 4649:```
4650: 4650:
4651: 4651:但是要注意，`perform()` 不需要使用泛型来工作，它可以被简单地指定为接受一个 **Performs** 对象：
4652: 4652:
4653: 4653:```java
4654: 4654:// generics/SimpleDogsAndRobots.java
4655: 4655:// Removing the generic; code still works
4656: 4656:
4657: 4657:class CommunicateSimply {
4658: 4658:    static void perform(Performs performer) {
4659: 4659:        performer.speak();
4660: 4660:        performer.sit();
4661: 4661:    }
4662: 4662:}
4663: 4663:
4664: 4664:public class SimpleDogsAndRobots {
4665: 4665:    public static void main(String[] args) {
4666: 4666:        CommunicateSimply.perform(new PerformingDog());
4667: 4667:        CommunicateSimply.perform(new Robot());
4668: 4668:    }
4669: 4669:}
4670: 4670:/* Output:
4671: 4671:Woof!
4672: 4672:Sitting
4673: 4673:Click!
4674: 4674:Clank!
4675: 4675:*/
4676: 4676:```
4677: 4677:
4678: 4678:在本例中，泛型不是必需的，因为这些类已经被强制要求实现 **Performs** 接口。
4679: 4679:
4680: 4680:<!-- Compensating for the Lack of (Direct) Latent -->
4681: 4681:
4682: 4682:## 对缺乏潜在类型机制的补偿
4683: 4683:
4684: 4684:尽管 Java 不直接支持潜在类型机制，但是这并不意味着泛型代码不能在不同的类型层次结构之间应用。也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。
4685: 4685:
4686: 4686:### 反射
4687: 4687:
4688: 4688:可以使用的一种方式是反射，下面的 `perform()` 方法就是用了潜在类型机制：
4689: 4689:
4690: 4690:```java
4691: 4691:// generics/LatentReflection.java
4692: 4692:// Using reflection for latent typing
4693: 4693:import java.lang.reflect.*;
4694: 4694:
4695: 4695:// Does not implement Performs:
4696: 4696:class Mime {
4697: 4697:    public void walkAgainstTheWind() {}
4698: 4698:    public void sit() {
4699: 4699:        System.out.println("Pretending to sit");
4700: 4700:    }
4701: 4701:    public void pushInvisibleWalls() {}
4702: 4702:    @Override
4703: 4703:    public String toString() { return "Mime"; }
4704: 4704:}
4705: 4705:
4706: 4706:// Does not implement Performs:
4707: 4707:class SmartDog {
4708: 4708:    public void speak() { System.out.println("Woof!"); }
4709: 4709:    public void sit() { System.out.println("Sitting"); }
4710: 4710:    public void reproduce() {}
4711: 4711:}
4712: 4712:
4713: 4713:class CommunicateReflectively {
4714: 4714:    public static void perform(Object speaker) {
4715: 4715:        Class<?> spkr = speaker.getClass();
4716: 4716:        try {
4717: 4717:            try {
4718: 4718:                Method speak = spkr.getMethod("speak");
4719: 4719:                speak.invoke(speaker);
4720: 4720:            } catch(NoSuchMethodException e) {
4721: 4721:                System.out.println(speaker + " cannot speak");
4722: 4722:            }
4723: 4723:            try {
4724: 4724:                Method sit = spkr.getMethod("sit");
4725: 4725:                sit.invoke(speaker);
4726: 4726:            } catch(NoSuchMethodException e) {
4727: 4727:                System.out.println(speaker + " cannot sit");
4728: 4728:            }
4729: 4729:        } catch(SecurityException |
4730: 4730:            IllegalAccessException |
4731: 4731:            IllegalArgumentException |
4732: 4732:            InvocationTargetException e) {
4733: 4733:            throw new RuntimeException(speaker.toString(), e);
4734: 4734:        }
4735: 4735:    }
4736: 4736:}
4737: 4737:
4738: 4738:public class LatentReflection {
4739: 4739:    public static void main(String[] args) {
4740: 4740:        CommunicateReflectively.perform(new SmartDog());
4741: 4741:        CommunicateReflectively.perform(new Robot());
4742: 4742:        CommunicateReflectively.perform(new Mime());
4743: 4743:    }
4744: 4744:}
4745: 4745:/* Output:
4746: 4746:Woof!
4747: 4747:Sitting
4748: 4748:Click!
4749: 4749:Clank!
4750: 4750:Mime cannot speak
4751: 4751:Pretending to sit
4752: 4752:*/
4753: 4753:```
4754: 4754:
4755: 4755:上例中，这些类完全是彼此分离的，没有任何公共基类（除了 **Object** ）或接口。通过反射, `CommunicateReflectively.perform()` 能够动态地确定所需要的方法是否可用并调用它们。它甚至能够处理 **Mime** 只具有一个必需的方法这一事实，并能够部分实现其目标。
4756: 4756:
4757: 4757:### 将一个方法应用于序列
4758: 4758:
4759: 4759:反射提供了一些有用的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。但是有可能实现编译期类型检查和潜在类型机制吗？
4760: 4760:
4761: 4761:让我们看一个说明这个问题的示例。假设想要创建一个 `apply()` 方法，它能够将任何方法应用于某个序列中的所有对象。这种情况下使用接口不适合，因为你想要将任何方法应用于一个对象集合，而接口不可能描述任何方法。如何用 Java 来实现这个需求呢？
4762: 4762:
4763: 4763:最初，我们可以用反射来解决这个问题，由于有了 Java 的可变参数，这种方式被证明是相当优雅的：
4764: 4764:
4765: 4765:```java
4766: 4766:// generics/Apply.java
4767: 4767:
4768: 4768:import java.lang.reflect.*;
4769: 4769:import java.util.*;
4770: 4770:
4771: 4771:public class Apply {
4772: 4772:    public static <T, S extends Iterable<T>>
4773: 4773:      void apply(S seq, Method f, Object... args) {
4774: 4774:        try {
4775: 4775:            for(T t: seq)
4776: 4776:                f.invoke(t, args);
4777: 4777:        } catch(IllegalAccessException |
4778: 4778:            IllegalArgumentException |
4779: 4779:            InvocationTargetException e) {
4780: 4780:            // Failures are programmer errors
4781: 4781:            throw new RuntimeException(e);
4782: 4782:        }
4783: 4783:    }
4784: 4784:}
4785: 4785:```
4786: 4786:
4787: 4787:在 **Apply.java** 中，异常被转换为 **RuntimeException** ，因为没有多少办法可以从这种异常中恢复——在这种情况下，它们实际上代表着程序员的错误。
4788: 4788:
4789: 4789:为什么我们不只使用 Java 8 方法参考（稍后显示）而不是反射方法 **f** ？ 注意，`invoke()` 和 `apply()` 的优点是它们可以接受任意数量的参数。 在某些情况下，灵活性可能至关重要。
4790: 4790:
4791: 4791:为了测试 **Apply** ，我们首先创建一个 **Shape** 类：
4792: 4792:
4793: 4793:```java
4794: 4794:// generics/Shape.java
4795: 4795:
4796: 4796:public class Shape {
4797: 4797:    private static long counter = 0;
4798: 4798:    private final long id = counter++;
4799: 4799:    @Override
4800: 4800:    public String toString() {
4801: 4801:        return getClass().getSimpleName() + " " + id;
4802: 4802:    }
4803: 4803:    public void rotate() {
4804: 4804:        System.out.println(this + " rotate");
4805: 4805:    }
4806: 4806:    public void resize(int newSize) {
4807: 4807:        System.out.println(this + " resize " + newSize);
4808: 4808:    }
4809: 4809:}
4810: 4810:```
4811: 4811:
4812: 4812:被一个子类 **Square** 继承：
4813: 4813:
4814: 4814:```java
4815: 4815:// generics/Square.java
4816: 4816:
4817: 4817:public class Square extends Shape {}
4818: 4818:```
4819: 4819:
4820: 4820:通过这些，我们可以测试 **Apply**：
4821: 4821:
4822: 4822:```java
4823: 4823:// generics/ApplyTest.java
4824: 4824:
4825: 4825:import java.util.*;
4826: 4826:import java.util.function.*;
4827: 4827:import onjava.*;
4828: 4828:
4829: 4829:public class ApplyTest {
4830: 4830:    public static
4831: 4831:    void main(String[] args) throws Exception {
4832: 4832:        List<Shape> shapes =
4833: 4833:          Suppliers.create(ArrayList::new, Shape::new, 3);
4834: 4834:        Apply.apply(shapes, Shape.class.getMethod("rotate"));
4835: 4835:        Apply.apply(shapes, Shape.class.getMethod("resize", int.class), 7);
4836: 4836:
4837: 4837:        List<Square> squares =
4838: 4838:          Suppliers.create(ArrayList::new, Square::new, 3);
4839: 4839:        Apply.apply(squares, Shape.class.getMethod("rotate"));
4840: 4840:        Apply.apply(squares, Shape.class.getMethod("resize", int.class), 7);
4841: 4841:
4842: 4842:        Apply.apply(new FilledList<>(Shape::new, 3),
4843: 4843:          Shape.class.getMethod("rotate"));
4844: 4844:        Apply.apply(new FilledList<>(Square::new, 3),
4845: 4845:          Shape.class.getMethod("rotate"));
4846: 4846:
4847: 4847:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
4848: 4848:          new SimpleQueue<>(), SimpleQueue::add,
4849: 4849:          Shape::new, 3);
4850: 4850:        Suppliers.fill(shapeQ, SimpleQueue::add,
4851: 4851:          Square::new, 3);
4852: 4852:        Apply.apply(shapeQ, Shape.class.getMethod("rotate"));
4853: 4853:    }
4854: 4854:}
4855: 4855:/* Output:
4856: 4856:Shape 0 rotate
4857: 4857:Shape 1 rotate
4858: 4858:Shape 2 rotate
4859: 4859:Shape 0 resize 7
4860: 4860:Shape 1 resize 7
4861: 4861:Shape 2 resize 7
4862: 4862:Square 3 rotate
4863: 4863:Square 4 rotate
4864: 4864:Square 5 rotate
4865: 4865:Square 3 resize 7
4866: 4866:Square 4 resize 7
4867: 4867:Square 5 resize 7
4868: 4868:Shape 6 rotate
4869: 4869:Shape 7 rotate
4870: 4870:Shape 8 rotate
4871: 4871:Square 9 rotate
4872: 4872:Square 10 rotate
4873: 4873:Square 11 rotate
4874: 4874:Shape 12 rotate
4875: 4875:Shape 13 rotate
4876: 4876:Shape 14 rotate
4877: 4877:Square 15 rotate
4878: 4878:Square 16 rotate
4879: 4879:Square 17 rotate
4880: 4880:*/
4881: 4881:```
4882: 4882:
4883: 4883:在 **Apply** 中，我们运气很好，因为碰巧在 Java 中内建了一个由 Java 集合类库使用的 **Iterable** 接口。正由于此， `apply()` 方法可以接受任何实现了 **Iterable** 接口的事物，包括诸如 **List** 这样的所有 **Collection** 类。但是它还可以接受其他任何事物，只要能够使这些事物是 **Iterable** 的——例如，在 `main()` 中使用下面定义的 **SimpleQueue** 类：
4884: 4884:
4885: 4885:```java
4886: 4886:// generics/SimpleQueue.java
4887: 4887:
4888: 4888:// A different kind of Iterable collection
4889: 4889:import java.util.*;
4890: 4890:
4891: 4891:public class SimpleQueue<T> implements Iterable<T> {
4892: 4892:    private LinkedList<T> storage = new LinkedList<>();
4893: 4893:    public void add(T t) { storage.offer(t); }
4894: 4894:    public T get() { return storage.poll(); }
4895: 4895:    @Override
4896: 4896:    public Iterator<T> iterator() {
4897: 4897:        return storage.iterator();
4898: 4898:    }
4899: 4899:}
4900: 4900:```
4901: 4901:
4902: 4902:正如反射解决方案看起来那样优雅，我们必须观察到反射（尽管在 Java 的最新版本中得到了显着改进）通常比非反射实现要慢，因为在运行时发生了很多事情。 但它不应阻止您尝试这种解决方案，这依然是值得考虑的一点。
4903: 4903:
4904: 4904:几乎可以肯定，你会首先使用 Java 8 的函数式方法，并且只有在解决了特殊需求时才诉诸反射。 这里对 **ApplyTest.java** 进行了重写，以利用 Java 8 的流和函数工具：
4905: 4905:
4906: 4906:```java
4907: 4907:// generics/ApplyFunctional.java
4908: 4908:
4909: 4909:import java.util.*;
4910: 4910:import java.util.stream.*;
4911: 4911:import java.util.function.*;
4912: 4912:import onjava.*;
4913: 4913:
4914: 4914:public class ApplyFunctional {
4915: 4915:    public static void main(String[] args) {
4916: 4916:        Stream.of(
4917: 4917:          Stream.generate(Shape::new).limit(2),
4918: 4918:          Stream.generate(Square::new).limit(2))
4919: 4919:        .flatMap(c -> c) // flatten into one stream
4920: 4920:        .peek(Shape::rotate)
4921: 4921:        .forEach(s -> s.resize(7));
4922: 4922:
4923: 4923:        new FilledList<>(Shape::new, 2)
4924: 4924:          .forEach(Shape::rotate);
4925: 4925:        new FilledList<>(Square::new, 2)
4926: 4926:          .forEach(Shape::rotate);
4927: 4927:
4928: 4928:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
4929: 4929:          new SimpleQueue<>(), SimpleQueue::add,
4930: 4930:          Shape::new, 2);
4931: 4931:        Suppliers.fill(shapeQ, SimpleQueue::add,
4932: 4932:          Square::new, 2);
4933: 4933:        shapeQ.forEach(Shape::rotate);
4934: 4934:    }
4935: 4935:}
4936: 4936:/* Output:
4937: 4937:Shape 0 rotate
4938: 4938:Shape 0 resize 7
4939: 4939:Shape 1 rotate
4940: 4940:Shape 1 resize 7
4941: 4941:Square 2 rotate
4942: 4942:Square 2 resize 7
4943: 4943:Square 3 rotate
4944: 4944:Square 3 resize 7
4945: 4945:Shape 4 rotate
4946: 4946:Shape 5 rotate
4947: 4947:Square 6 rotate
4948: 4948:Square 7 rotate
4949: 4949:Shape 8 rotate
4950: 4950:Shape 9 rotate
4951: 4951:Square 10 rotate
4952: 4952:Square 11 rotate
4953: 4953:*/
4954: 4954:```
4955: 4955:
4956: 4956:由于使用 Java 8，因此不需要 `Apply.apply()` 。
4957: 4957:
4958: 4958:我们首先生成两个 **Stream** ： 一个是 **Shape** ，一个是 **Square** ，并将它们展平为单个流。 尽管 Java 缺少功能语言中经常出现的 `flatten()` ，但是我们可以使用 `flatMap(c-> c)` 产生相同的结果，后者使用身份映射将操作简化为“  **flatten** ”。
4959: 4959:
4960: 4960:我们使用 `peek()` 当做对 `rotate()` 的调用，因为 `peek()` 执行一个操作（此处是出于副作用），并在未更改的情况下传递对象。
4961: 4961:
4962: 4962:注意，使用 **FilledList** 和 **shapeQ** 调用 `forEach()` 比 `Apply.apply()` 代码整洁得多。 在代码简单性和可读性方面，结果比以前的方法好得多。 并且，现在也不可能从  `main()` 引发异常。
4963: 4963:
4964: 4964:<!-- Assisted Latent Typing in Java 8 -->
4965: 4965:
4966: 4966:## Java8 中的辅助潜在类型
4967: 4967:
4968: 4968:先前声明关于 Java 缺乏对潜在类型的支持在 Java 8 之前是完全正确的。但是，Java 8 中的非绑定方法引用使我们能够产生一种潜在类型的形式，以满足创建一段可工作在不相干类型上的代码。因为 Java 最初并不是如此设计，所以结果可想而知，比其他语言中要尴尬一些。但是，至少现在成为了可能，只是缺乏令人惊艳之处。
4969: 4969:
4970: 4970:我在其他地方从没遇过这种技术，因此我将其称为辅助潜在类型。
4971: 4971:
4972: 4972:我们将重写 **DogsAndRobots.java** 来演示该技术。 为使外观看起来与原始示例尽可能相似，我仅向每个原始类名添加了 **A**：
4973: 4973:
4974: 4974:```java
4975: 4975:// generics/DogsAndRobotMethodReferences.java
4976: 4976:
4977: 4977:// "Assisted Latent Typing"
4978: 4978:import typeinfo.pets.*;
4979: 4979:import java.util.function.*;
4980: 4980:
4981: 4981:class PerformingDogA extends Dog {
4982: 4982:    public void speak() { System.out.println("Woof!"); }
4983: 4983:    public void sit() { System.out.println("Sitting"); }
4984: 4984:    public void reproduce() {}
4985: 4985:}
4986: 4986:
4987: 4987:class RobotA {
4988: 4988:    public void speak() { System.out.println("Click!"); }
4989: 4989:    public void sit() { System.out.println("Clank!"); }
4990: 4990:    public void oilChange() {}
4991: 4991:}
4992: 4992:
4993: 4993:class CommunicateA {
4994: 4994:    public static <P> void perform(P performer,
4995: 4995:      Consumer<P> action1, Consumer<P> action2) {
4996: 4996:        action1.accept(performer);
4997: 4997:        action2.accept(performer);
4998: 4998:    }
4999: 4999:}
5000: 5000:
5001: 5001:public class DogsAndRobotMethodReferences {
5002: 5002:    public static void main(String[] args) {
5003: 5003:        CommunicateA.perform(new PerformingDogA(),
5004: 5004:          PerformingDogA::speak, PerformingDogA::sit);
5005: 5005:        CommunicateA.perform(new RobotA(),
5006: 5006:          RobotA::speak, RobotA::sit);
5007: 5007:        CommunicateA.perform(new Mime(),
5008: 5008:          Mime::walkAgainstTheWind,
5009: 5009:          Mime::pushInvisibleWalls);
5010: 5010:    }
5011: 5011:}
5012: 5012:/* Output:
5013: 5013:Woof!
5014: 5014:Sitting
5015: 5015:Click!
5016: 5016:Clank!
5017: 5017:*/
5018: 5018:```
5019: 5019:
5020: 5020:**PerformingDogA** 和 **RobotA** 与 **DogsAndRobots.java** 中的相同，不同之处在于它们不继承通用接口 **Performs** ，因此它们没有通用性。
5021: 5021:
5022: 5022:`CommunicateA.perform()` 在没有约束的 **P** 上生成。 只要可以使用 `Consumer <P>`，它在这里就可以是任何东西，这些 `Consumer<P>` 代表不带参数的 **P** 方法的未绑定方法引用。当您调用 **Consumer**  的 `accept()` 方法时，它将方法引用绑定到执行者对象并调用该方法。 由于 [函数式编程](book/13-Functional-Programming.md) 一章中描述的“魔术”，我们可以将任何符合签名的未绑定方法引用传递给 `CommunicateA.perform()` 。
5023: 5023:
5024: 5024:之所以称其为“辅助”，是因为您必须显式地为 `perform()` 提供要使用的方法引用。 它不能只按名称调用方法。
5025: 5025:
5026: 5026:尽管传递未绑定的方法引用似乎要花很多力气，但潜在类型的最终目标还是可以实现的。 我们创建了一个代码片段 `CommunicateA.perform()` ，该代码可用于任何具有符合签名的方法引用的类型。 请注意，这与我们看到的其他语言中的潜在类型有所不同，因为这些语言不仅需要签名以符合规范，还需要方法名称。 因此，该技术可以说产生了更多的通用代码。
5027: 5027:
5028: 5028:为了证明这一点，我还从 **LatentReflection.java** 中引入了 **Mime**。
5029: 5029:
5030: 5030:### 使用**Suppliers**类的通用方法
5031: 5031:
5032: 5032:通过辅助潜在类型，我们可以定义本章其他部分中使用的 **Suppliers** 类。 此类包含使用生成器填充 **Collection** 的工具方法。 泛化这些操作很有意义：
5033: 5033:
5034: 5034:```java
5035: 5035:// onjava/Suppliers.java
5036: 5036:
5037: 5037:// A utility to use with Suppliers
5038: 5038:package onjava;
5039: 5039:import java.util.*;
5040: 5040:import java.util.function.*;
5041: 5041:import java.util.stream.*;
5042: 5042:
5043: 5043:public class Suppliers {
5044: 5044:    // Create a collection and fill it:
5045: 5045:    public static <T, C extends Collection<T>> C
5046: 5046:      create(Supplier<C> factory, Supplier<T> gen, int n) {
5047: 5047:        return Stream.generate(gen)
5048: 5048:            .limit(n)
5049: 5049:            .collect(factory, C::add, C::addAll);
5050: 5050:    }
5051: 5051:    
5052: 5052:    // Fill an existing collection:
5053: 5053:    public static <T, C extends Collection<T>>
5054: 5054:      C fill(C coll, Supplier<T> gen, int n) {
5055: 5055:        Stream.generate(gen)
5056: 5056:            .limit(n)
5057: 5057:            .forEach(coll::add);
5058: 5058:        return coll;
5059: 5059:    }
5060: 5060:    
5061: 5061:    // Use an unbound method reference to
5062: 5062:    // produce a more general method:
5063: 5063:    public static <H, A> H fill(H holder,
5064: 5064:      BiConsumer<H, A> adder, Supplier<A> gen, int n) {
5065: 5065:        Stream.generate(gen)
5066: 5066:            .limit(n)
5067: 5067:            .forEach(a -> adder.accept(holder, a));
5068: 5068:        return holder;
5069: 5069:    }
5070: 5070:}
5071: 5071:```
5072: 5072:
5073: 5073:`create()` 为你创建一个新的 **Collection** 子类型，而 `fill()` 的第一个版本将元素放入 **Collection** 的现有子类型中。 请注意，还会返回传入的容器的确切类型，因此不会丢失类型信息。[^6]
5074: 5074:
5075: 5075:前两种方法一般都受约束，只能与 **Collection** 子类型一起使用。`fill()` 的第二个版本适用于任何类型的 **holder** 。 它需要一个附加参数：未绑定方法引用 `adder. fill()` ，使用辅助潜在类型来使其与任何具有添加元素方法的 **holder** 类型一起使用。因为此未绑定方法 **adder** 必须带有一个参数（要添加到 **holder** 的元素），所以 **adder** 必须是 `BiConsumer <H，A>` ，其中 **H** 是要绑定到的 **holder** 对象的类型，而 **A** 是要被添加的绑定元素类型。 对 `accept()` 的调用将使用参数 a 调用对象 **holder** 上的未绑定方法 **holder**。
5076: 5076:
5077: 5077:在一个稍作模拟的测试中对 **Suppliers** 工具程序进行了测试，该仿真还使用了本章前面定义的 **RandomList** ：
5078: 5078:
5079: 5079:```java
5080: 5080:// generics/BankTeller.java
5081: 5081:
5082: 5082:// A very simple bank teller simulation
5083: 5083:import java.util.*;
5084: 5084:import onjava.*;
5085: 5085:
5086: 5086:class Customer {
5087: 5087:    private static long counter = 1;
5088: 5088:    private final long id = counter++;
5089: 5089:    @Override
5090: 5090:    public String toString() {
5091: 5091:        return "Customer " + id;
5092: 5092:    }
5093: 5093:}
5094: 5094:
5095: 5095:class Teller {
5096: 5096:    private static long counter = 1;
5097: 5097:    private final long id = counter++;
5098: 5098:    @Override
5099: 5099:    public String toString() {
5100: 5100:        return "Teller " + id;
5101: 5101:    }
5102: 5102:}
5103: 5103:
5104: 5104:class Bank {
5105: 5105:    private List<BankTeller> tellers =
5106: 5106:        new ArrayList<>();
5107: 5107:    public void put(BankTeller bt) {
5108: 5108:        tellers.add(bt);
5109: 5109:    }
5110: 5110:}
5111: 5111:
5112: 5112:public class BankTeller {
5113: 5113:    public static void serve(Teller t, Customer c) {
5114: 5114:        System.out.println(t + " serves " + c);
5115: 5115:    }
5116: 5116:    public static void main(String[] args) {
5117: 5117:        // Demonstrate create():
5118: 5118:        RandomList<Teller> tellers =
5119: 5119:            Suppliers.create(
5120: 5120:            RandomList::new, Teller::new, 4);
5121: 5121:        // Demonstrate fill():
5122: 5122:        List<Customer> customers = Suppliers.fill(
5123: 5123:            new ArrayList<>(), Customer::new, 12);
5124: 5124:        customers.forEach(c ->
5125: 5125:            serve(tellers.select(), c));
5126: 5126:        // Demonstrate assisted latent typing:
5127: 5127:        Bank bank = Suppliers.fill(
5128: 5128:            new Bank(), Bank::put, BankTeller::new, 3);
5129: 5129:        // Can also use second version of fill():
5130: 5130:        List<Customer> customers2 = Suppliers.fill(
5131: 5131:            new ArrayList<>(),
5132: 5132:            List::add, Customer::new, 12);
5133: 5133:    }
5134: 5134:}
5135: 5135:/* Output:
5136: 5136:Teller 3 serves Customer 1
5137: 5137:Teller 2 serves Customer 2
5138: 5138:Teller 3 serves Customer 3
5139: 5139:Teller 1 serves Customer 4
5140: 5140:Teller 1 serves Customer 5
5141: 5141:Teller 3 serves Customer 6
5142: 5142:Teller 1 serves Customer 7
5143: 5143:Teller 2 serves Customer 8
5144: 5144:Teller 3 serves Customer 9
5145: 5145:Teller 3 serves Customer 10
5146: 5146:Teller 2 serves Customer 11
5147: 5147:Teller 4 serves Customer 12
5148: 5148:*/
5149: 5149:```
5150: 5150:
5151: 5151:可以看到 `create()` 生成一个新的 **Collection** 对象，而 `fill()` 添加到现有 **Collection** 中。第二个版本`fill()` 显示，它不仅与无关的新类型 **Bank** 一起使用，还能与 **List** 一起使用。因此，从技术上讲，`fill()` 的第一个版本在技术上不是必需的，但在使用 **Collection** 时提供了较短的语法。
5152: 5152:
5153: 5153:<!-- Summary: Is Casting Really So Bad? -->
5154: 5154:
5155: 5155:## 总结：类型转换真的如此之糟吗？
5156: 5156:
5157: 5157:自从 C++ 模版出现以来，我就一直在致力于解释它，我可能比大多数人都更早地提出了下面的论点。直到最近，我才停下来，去思考这个论点到底在多少时间内是有效的——我将要描述的问题到底有多少次可以穿越障碍得以解决。
5158: 5158:
5159: 5159:这个论点就是：使用泛型类型机制的最吸引人的地方，就是在使用集合类的地方，这些类包括诸如各种 **List** 、各种 **Set** 、各种 **Map** 等你在 [集合](book/12-Collections.md) 和 [附录：集合主题](book/Appendix-Collection-Topics.md) 这两章所见。在 Java 5 之前，当你将一个对象放置到集合中时，这个对象就会被向上转型为 **Object** ，因此你会丢失类型信息。当你想要将这个对象从集合中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。我用的示例是持有 **Cat** 的 **List** （这个示例的一种使用苹果和桔子的变体在 [集合](book/12-Collections.md) 章节的开头展示过）。如果没有 Java 5 泛型版本的集合，你放到容集里和从集合中取回的都是 **Object** 。因此，我们很可能会将一个 **Dog** 放置到 **Cat** 的 **List** 中。
5160: 5160:
5161: 5161:但是，泛型出现之前的 Java 并不会让你误用放入到集合中的对象。如果将一个 **Dog** 扔到 **Cat** 的集合中，并且试图将这个集合中的所有东西都当作 **Cat** 处理，那么当你从这个 **Cat** 集合中取回那个 **Dog** 引用，并试图将其转型为 **Cat** 时，就会得到一个 **RuntimeException** 。你仍旧可以发现问题，但是是在运行时而非编译期发现它的。
5162: 5162:
5163: 5163:在本书以前的版本中，我曾经说过：
5164: 5164:
5165: 5165:> 这不止令人恼火，它还可能会产生难以发现的缺陷。如果这个程序的某个部分（或数个部分）向集合中插入了对象，并且通过异常，你在程序的另一个独立的部分中发现有不良对象被放置到了集合中，那么必须发现这个不良插入到底是在何处发生的。
5166: 5166:
5167: 5167:但是，随着对这个论点的进一步检查，我开始怀疑它了。首先，这会多么频繁地发生呢？我记得这类事情从未发生在我身上，并且当我在会议上询问其他人时，我也从来没有听说过有人碰上过。另一本书使用了一个称为 **files** 的 list 示例，它包含 **String** 对象。在这个示例中，向 **files** 中添加一个 **File** 对象看起来相当自然，因此这个对象的名字可能叫 **fileNames** 更好。无论 Java 提供了多少类型检查，仍旧可能会写出晦涩的程序，而编写差劲儿的程序即便可以编译，它仍旧是编写差劲儿的程序。可能大多数人都会使用命名良好的集合，例如 **cats** ，因为它们可以向试图添加非 **Cat** 对象的程序员提供可视的警告。并且即便这类事情发生了，它真正又能潜伏多久呢？只要你开始用真实数据来运行测试，就会非常快地看到异常。
5168: 5168:
5169: 5169:有一位作者甚至断言，这样的缺陷将“*潜伏数年*”。但是我不记得有任何大量的相关报告，来说明人们在查找“狗在猫列表中”这类缺陷时困难重重，或者是说明人们会非常频繁地产生这种错误。然而，你将在 [多线程编程](book/24-Concurrent-Programming.md) 章节中看到，在使用线程时，出现那些可能看起来极罕见的缺陷，是很寻常并容易发生的事，而且，对于到底出了什么错，这些缺陷只能给你一个很模糊的概念。因此，对于泛型是添加到 Java 中的非常显著和相当复杂的特性这一点，“狗在猫列表中”这个论据真的能够成为它的理由吗？
5170: 5170:我相信被称为*泛型*的通用语言特性（并非必须是其在 Java 中的特定实现）的目的在于可表达性，而不仅仅是为了创建类型安全的集合。类型安全的集合是能够创建更通用代码这一能力所带来的副作用。
5171: 5171:因此，即便“狗在猫列表中”这个论据经常被用来证明泛型是必要的，但是它仍旧是有问题的。就像我在本章开头声称的，我不相信这就是泛型这个概念真正的含义。相反，泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。正如你在本章中看到的，编写真正泛化的“持有器”类（ Java 的容器就是这种类）相当简单，但是编写出能够操作其泛型类型的泛化代码就需要额外的努力了，这些努力需要类创建者和类消费者共同付出，他们必须理解这些代码的概念和实现。这些额外的努力会增加使用这种特性的难度，并可能会因此而使其在某些场合缺乏可应用性，而在这些场合中，它可能会带来附加的价值。
5172: 5172:
5173: 5173:还要注意到，因为泛型是后来添加到 Java 中，而不是从一开始就设计到这种语言中的，所以某些容器无法达到它们应该具备的健壮性。例如，观察一下 **Map** ，在特定的方法 `containsKey(Object key) `和 `get(Object key)` 中就包含这类情况。如果这些类是使用在它们之前就存在的泛型设计的，那么这些方法将会使用参数化类型而不是 **Object** ，因此也就可以提供这些泛型假设会提供的编译期检查。例如，在 C++ 的 **map** 中，键的类型总是在编译期检查的。
5174: 5174:
5175: 5175:有一件事很明显：在一种语言已经被广泛应用之后，在其较新的版本中引入任何种类的泛型机制，都会是一项非常非常棘手的任务，并且是一项不付出艰辛就无法完成的任务。在 C++ 中，模版是在其最初的 ISO 版本中就引入的（即便如此，也引发了阵痛，因为在第一个标准 C++ 出现之前，有很多非模版版本在使用），因此实际上模版一直都是这种语言的一部分。在 Java 中，泛型是在这种语言首次发布大约 10 年之后才引入的，因此向泛型迁移的问题特别多，并且对泛型的设计产生了明显的影响。其结果就是，程序员将承受这些痛苦，而这一切都是由于 Java 设计者在设计 1.0 版本时所表现出来的短视造成的。当 Java 最初被创建时，它的设计者们当然了解 C++ 的模版，他们甚至考虑将其囊括到 Java 语言中，但是出于这样或那样的原因，他们决定将模版排除在外（其迹象就是他们过于匆忙）。因此， Java 语言和使用它的程序员都将承受这些痛苦。只有时间将会说明 Java 的泛型方式对这种语言所造成的最终影响。
5176: 5176:某些语言，已经融入了更简洁、影响更小的方式，来实现参数化类型。我们不可能不去想象这样的语言将会成为 Java 的继任者，因为它们采用的方式，与 C++ 通过 C 来实现的方式相同：按原样使用它，然后对其进行改进。
5177: 5177:
5178: 5178:## 进阶阅读
5179: 5179:
5180: 5180:泛型的入门文档是 《Generics in the Java Programming Language》，作者是 Gilad Bracha，可以从 http://java.oracle.com 获取。
5181: 5181:
5182: 5182:Angelika Langer 的《Java Generics FAQs》是一份非常有帮助的资料，可以从 http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html 获取。
5183: 5183:
5184: 5184:你可以从 《Adding Wildcards to the Java Programming Language》中学到更多关于通配符的知识，作者是 Torgerson、Ernst、Hansen、von der Ahe、Bracha 和 Gafter，地址是 http://www.jot.fm/issues/issue_2004_12/article5。
5185: 5185:
5186: 5186:Neal After 对于 Java 问题（尤其是擦除）的看法可以从这里找到：http://www.infoq.com/articles/neal-gafter-on-java。
5187: 5187:
5188: 5188:[^1]: 在编写本章期间，Angelika Langer的 Java 泛型常见问题解答以及她的其他著作（与Klaus Kreft一起）是非常宝贵的。
5189: 5189:[^2]: [http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html](http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html)
5190: 5190:[^3]: 参见本章章末引文。
5191: 5191:[^4]: 注意，一些编程环境，如 Eclipse 和 IntelliJ IDEA，将会自动生成委托代码。
5192: 5192:[^5]: 因为可以使用转型，有效地禁止了类型系统，一些人就认为 C++ 是弱类型，但这太极端了。一种可能更好的说法是 C++ 是有一道暗门的强类型语言。
5193: 5193:[^6]: 我再次从 Brian Goetz 那获得帮助。
5194: 5194:
5195: 5195:<!-- 分页 -->
5196: 5196:
5197: 5197:<div style="page-break-after: always;"></div>
5198: 
5199: 1:[TOC]
5200: 2:
5201: 3:<!-- Generics -->
5202: 4:
5203: 5:# 第二十章 泛型
5204: 6:
5205: 7:> 普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。
5206: 8:
5207: 9:多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。除了 `final` 类（或只提供私有构造函数的类）任何类型都可被扩展，所以大部分时候这种灵活性是自带的。
5208: 10:
5209: 11:拘泥于单一的继承体系太过局限，因为只有继承体系中的对象才能适用基类作为参数的方法中。如果方法以接口而不是类作为参数，限制就宽松多了，只要实现了接口就可以。这给予调用方一种选项，通过调整现有的类来实现接口，满足方法参数要求。接口可以突破继承体系的限制。
5210: 12:
5211: 13:即便是接口也还是有诸多限制。一旦指定了接口，它就要求你的代码必须使用特定的接口。而我们希望编写更通用的代码，能够适用“非特定的类型”，而不是一个具体的接口或类。
5212: 14:
5213: 15:这就是泛型的概念，是 Java 5 的重大变化之一。泛型实现了*参数化类型*，这样你编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。随后你会发现 Java 中泛型的实现并没有那么“泛”，你可能会质疑“泛型”这个词是否合适用来描述这一功能。
5214: 16:
5215: 17:如果你从未接触过参数化类型机制，你会发现泛型对 Java 语言确实是个很有益的补充。在你实例化一个类型参数时，编译器会负责转型并确保类型的正确性。这是一大进步。
5216: 18:
5217: 19:然而，如果你了解其他语言（例如 C++ ）的参数化机制，你会发现，Java 泛型并不能满足所有的预期。使用别人创建好的泛型相对容易，但是创建自己的泛型时，就会遇到很多意料之外的麻烦。
5218: 20:
5219: 21:这并不是说 Java 泛型毫无用处。在很多情况下，它可以使代码更直接更优雅。不过，如果你见识过那种实现了更纯粹的泛型的编程语言，那么，Java 可能会令你失望。本章会介绍 Java 泛型的优点与局限。我会解释 Java 的泛型是如何发展成现在这样的，希望能够帮助你更有效地使用这个特性。[^1]
5220: 22:
5221: 23:### 与 C++ 的比较
5222: 24:
5223: 25:Java 的设计者曾说过，这门语言的灵感主要来自 C++ 。尽管如此，学习 Java 时基本不用参考 C++ 。
5224: 26:
5225: 27:但是，Java 中的泛型需要与 C++ 进行对比，理由有两个：首先，理解 C++ *模板*（泛型的主要灵感来源，包括基本语法）的某些特性，有助于理解泛型的基础理念。同时，非常重要的一点是，你可以了解 Java 泛型的局限是什么，以及为什么会有这些局限。最终的目标是明确 Java 泛型的边界，让你成为一个程序高手。只有知道了某个技术不能做什么，你才能更好地做到所能做的（部分原因是，不必浪费时间在死胡同里）。
5226: 28:
5227: 29:第二个原因是，在 Java 社区中，大家普遍对 C++ 模板有一种误解，而这种误解可能会令你在理解泛型的意图时产生偏差。
5228: 30:
5229: 31:因此，本章中会介绍少量 C++ 模板的例子，仅当它们确实可以加深理解时才会引入。
5230: 32:
5231: 33:<!-- Simple Generics -->
5232: 34:
5233: 35:## 简单泛型
5234: 36:
5235: 37:促成泛型出现的最主要的动机之一是为了创建*集合类*，参见 [集合](book/12-Collections.md) 章节。集合用于存放要使用到的对象。数组也是如此，不过集合比数组更加灵活，功能更丰富。几乎所有程序在运行过程中都会涉及到一组对象，因此集合是可复用性最高的类库之一。
5236: 38:
5237: 39:我们先看一个只能持有单个对象的类。这个类可以明确指定其持有的对象的类型：
5238: 40:
5239: 41:```java
5240: 42:// generics/Holder1.java
5241: 43:
5242: 44:class Automobile {}
5243: 45:
5244: 46:public class Holder1 {
5245: 47:    private Automobile a;
5246: 48:    public Holder1(Automobile a) { this.a = a; }
5247: 49:    Automobile get() { return a; }
5248: 50:}
5249: 51:```
5250: 52:
5251: 53:这个类的可复用性不高，它无法持有其他类型的对象。我们可不希望为碰到的每个类型都编写一个新的类。
5252: 54:
5253: 55:在 Java 5 之前，我们可以让这个类直接持有 `Object` 类型的对象：
5254: 56:
5255: 57:```java
5256: 58:// generics/ObjectHolder.java
5257: 59:
5258: 60:public class ObjectHolder {
5259: 61:    private Object a;
5260: 62:    public ObjectHolder(Object a) { this.a = a; }
5261: 63:    public void set(Object a) { this.a = a; }
5262: 64:    public Object get() { return a; }
5263: 65:    
5264: 66:    public static void main(String[] args) {
5265: 67:        ObjectHolder h2 = new ObjectHolder(new Automobile());
5266: 68:        Automobile a = (Automobile)h2.get();
5267: 69:        h2.set("Not an Automobile");
5268: 70:        String s = (String)h2.get();
5269: 71:        h2.set(1); // 自动装箱为 Integer
5270: 72:        Integer x = (Integer)h2.get();
5271: 73:    }
5272: 74:}
5273: 75:```
5274: 76:
5275: 77:现在，`ObjectHolder` 可以持有任何类型的对象，在上面的示例中，一个 `ObjectHolder` 先后持有了三种不同类型的对象。
5276: 78:
5277: 79:一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。
5278: 80:
5279: 81:因此，与其使用 `Object` ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用*类型参数*，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，`T` 就是类型参数：
5280: 82:
5281: 83:```java
5282: 84:// generics/GenericHolder.java
5283: 85:
5284: 86:public class GenericHolder<T> {
5285: 87:    private T a;
5286: 88:    public GenericHolder() {}
5287: 89:    public void set(T a) { this.a = a; }
5288: 90:    public T get() { return a; }
5289: 91:    
5290: 92:    public static void main(String[] args) {
5291: 93:        GenericHolder<Automobile> h3 = new GenericHolder<Automobile>();
5292: 94:        h3.set(new Automobile()); // 此处有类型校验
5293: 95:        Automobile a = h3.get();  // 无需类型转换
5294: 96:        //- h3.set("Not an Automobile"); // 报错
5295: 97:        //- h3.set(1);  // 报错
5296: 98:    }
5297: 99:}
5298: 100:```
5299: 101:
5300: 102:创建 `GenericHolder` 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 `main()` 中那样使用。然后，你就只能在 `GenericHolder` 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当你调用 `get()` 取值时，直接就是正确的类型。
5301: 103:
5302: 104:这就是 Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。
5303: 105:
5304: 106:你可能注意到 `h3` 的定义非常繁复。在 `=` 左边有 `GenericHolder<Automobile>`, 右边又重复了一次。在 Java 5 中，这种写法被解释成“必要的”，但在 Java 7 中设计者修正了这个问题（新的简写语法随后成为备受欢迎的特性）。以下是简写的例子：
5305: 107:
5306: 108:```java
5307: 109:// generics/Diamond.java
5308: 110:
5309: 111:class Bob {}
5310: 112:
5311: 113:public class Diamond<T> {
5312: 114:    public static void main(String[] args) {
5313: 115:        GenericHolder<Bob> h3 = new GenericHolder<>();
5314: 116:        h3.set(new Bob());
5315: 117:    }
5316: 118:}
5317: 119:```
5318: 120:
5319: 121:注意，在 `h3` 的定义处，`=` 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。在本书剩余部分都会使用这种语法。
5320: 122:
5321: 123:一般来说，你可以认为泛型和其他类型差不多，只不过它们碰巧有类型参数罢了。在使用泛型时，你只需要指定它们的名称和类型参数列表即可。
5322: 124:
5323: 125:### 一个元组类库
5324: 126:
5325: 127:有时一个方法需要能返回多个对象。而 **return** 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得了编译时的类型安全。
5326: 128:
5327: 129:这个概念称为*元组*，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 *数据传输对象* 或 *信使* ）。
5328: 130:
5329: 131:通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组：
5330: 132:
5331: 133:```java
5332: 134:// onjava/Tuple2.java
5333: 135:package onjava;
5334: 136:
5335: 137:public class Tuple2<A, B> {
5336: 138:    public final A a1;
5337: 139:    public final B a2;
5338: 140:    public Tuple2(A a, B b) { a1 = a; a2 = b; }
5339: 141:    public String rep() { return a1 + ", " + a2; }
5340: 142:  
5341: 143:    @Override
5342: 144:    public String toString() {
5343: 145:        return "(" + rep() + ")";
5344: 146:    }
5345: 147:}
5346: 148:```
5347: 149:
5348: 150:构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。
5349: 151:
5350: 152:初次阅读上面的代码时，你可能认为这违反了 Java 编程的封装原则。`a1` 和 `a2` 应该声明为 **private**，然后提供 `getFirst()` 和 `getSecond()` 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取 `a1` 和 `a2` 然后对它们执行任何操作，但无法对 `a1` 和 `a2` 重新赋值。例子中的 `final` 可以实现同样的效果，并且更为简洁明了。
5351: 153:
5352: 154:另一种设计思路是允许元组的用户给 `a1` 和 `a2` 重新赋值。然而，采用上例中的形式无疑更加安全，如果用户想存储不同的元素，就会强制他们创建新的 `Tuple2` 对象。
5353: 155:
5354: 156:我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了：
5355: 157:
5356: 158:```java
5357: 159:// onjava/Tuple3.java
5358: 160:package onjava;
5359: 161:
5360: 162:public class Tuple3<A, B, C> extends Tuple2<A, B> {
5361: 163:    public final C a3;
5362: 164:    public Tuple3(A a, B b, C c) {
5363: 165:        super(a, b);
5364: 166:        a3 = c;
5365: 167:    }
5366: 168:    
5367: 169:    @Override
5368: 170:    public String rep() {
5369: 171:        return super.rep() + ", " + a3;
5370: 172:    }
5371: 173:}
5372: 174:
5373: 175:// onjava/Tuple4.java
5374: 176:package onjava;
5375: 177:
5376: 178:public class Tuple4<A, B, C, D>
5377: 179:  extends Tuple3<A, B, C> {
5378: 180:    public final D a4;
5379: 181:    public Tuple4(A a, B b, C c, D d) {
5380: 182:        super(a, b, c);
5381: 183:        a4 = d;
5382: 184:    }
5383: 185:    
5384: 186:    @Override
5385: 187:    public String rep() {
5386: 188:        return super.rep() + ", " + a4;
5387: 189:    }
5388: 190:}
5389: 191:
5390: 192:// onjava/Tuple5.java
5391: 193:package onjava;
5392: 194:
5393: 195:public class Tuple5<A, B, C, D, E>
5394: 196:  extends Tuple4<A, B, C, D> {
5395: 197:    public final E a5;
5396: 198:    public Tuple5(A a, B b, C c, D d, E e) {
5397: 199:        super(a, b, c, d);
5398: 200:        a5 = e;
5399: 201:    }
5400: 202:    
5401: 203:    @Override
5402: 204:    public String rep() {
5403: 205:        return super.rep() + ", " + a5;
5404: 206:    }
5405: 207:}
5406: 208:```
5407: 209:
5408: 210:演示需要，再定义两个类：
5409: 211:
5410: 212:```java
5411: 213:// generics/Amphibian.java
5412: 214:public class Amphibian {}
5413: 215:
5414: 216:// generics/Vehicle.java
5415: 217:public class Vehicle {}
5416: 218:```
5417: 219:
5418: 220:使用元组时，你只需要定义一个长度适合的元组，将其作为返回值即可。注意下面例子中方法的返回类型：
5419: 221:
5420: 222:```java
5421: 223:// generics/TupleTest.java
5422: 224:import onjava.*;
5423: 225:
5424: 226:public class TupleTest {
5425: 227:    static Tuple2<String, Integer> f() {
5426: 228:        // 47 自动装箱为 Integer
5427: 229:        return new Tuple2<>("hi", 47);
5428: 230:    }
5429: 231:  
5430: 232:    static Tuple3<Amphibian, String, Integer> g() {
5431: 233:        return new Tuple3<>(new Amphibian(), "hi", 47);
5432: 234:    }
5433: 235:  
5434: 236:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
5435: 237:        return new Tuple4<>(new Vehicle(), new Amphibian(), "hi", 47);
5436: 238:    }
5437: 239:  
5438: 240:    static Tuple5<Vehicle, Amphibian, String, Integer, Double> k() {
5439: 241:        return new Tuple5<>(new Vehicle(), new Amphibian(), "hi", 47, 11.1);
5440: 242:    }
5441: 243:  
5442: 244:    public static void main(String[] args) {
5443: 245:        Tuple2<String, Integer> ttsi = f();
5444: 246:        System.out.println(ttsi);
5445: 247:        // ttsi.a1 = "there"; // 编译错误，因为 final 不能重新赋值
5446: 248:        System.out.println(g());
5447: 249:        System.out.println(h());
5448: 250:        System.out.println(k());
5449: 251:    }
5450: 252:}
5451: 253:
5452: 254:/* 输出：
5453: 255: (hi, 47)
5454: 256: (Amphibian@1540e19d, hi, 47)
5455: 257: (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47)
5456: 258: (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1)
5457: 259: */
5458: 260:```
5459: 261:
5460: 262:有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。
5461: 263:
5462: 264:通过 `ttsi.a1 = "there"` 语句的报错，我们可以看出，**final** 声明确实可以确保 **public** 字段在对象被构造出来之后就不能重新赋值了。
5463: 265:
5464: 266:在上面的程序中，`new` 表达式有些啰嗦。本章稍后会介绍，如何利用 *泛型方法* 简化它们。
5465: 267:
5466: 268:### 一个堆栈类
5467: 269:
5468: 270:接下来我们看一个稍微复杂一点的例子：堆栈。在 [集合](book/12-Collections.md) 一章中，我们用 `LinkedList` 实现了 `onjava.Stack` 类。在那个例子中，`LinkedList` 本身已经具备了创建堆栈所需的方法。`Stack` 是通过两个泛型类 `Stack<T>` 和 `LinkedList<T>` 的组合来创建。我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。
5469: 271:
5470: 272:这次我们不用 `LinkedList` 来实现自己的内部链式存储机制。
5471: 273:
5472: 274:```java
5473: 275:// generics/LinkedStack.java
5474: 276:// 用链式结构实现的堆栈
5475: 277:
5476: 278:public class LinkedStack<T> {
5477: 279:    private static class Node<U> {
5478: 280:        U item;
5479: 281:        Node<U> next;
5480: 282:    
5481: 283:        Node() { item = null; next = null; }
5482: 284:        
5483: 285:        Node(U item, Node<U> next) {
5484: 286:            this.item = item;
5485: 287:            this.next = next;
5486: 288:        }
5487: 289:    
5488: 290:        boolean end() {
5489: 291:            return item == null && next == null;
5490: 292:        }
5491: 293:    }
5492: 294:  
5493: 295:    private Node<T> top = new Node<>();  // 栈顶
5494: 296:  
5495: 297:    public void push(T item) {
5496: 298:        top = new Node<>(item, top);
5497: 299:    }
5498: 300:  
5499: 301:    public T pop() {
5500: 302:        T result = top.item;
5501: 303:        if (!top.end()) {
5502: 304:            top = top.next;
5503: 305:        }
5504: 306:        return result;
5505: 307:    }
5506: 308:  
5507: 309:    public static void main(String[] args) {
5508: 310:        LinkedStack<String> lss = new LinkedStack<>();
5509: 311:        for (String s : "Phasers on stun!".split(" ")) {
5510: 312:            lss.push(s);
5511: 313:        }
5512: 314:        String s;
5513: 315:        while ((s = lss.pop()) != null) {
5514: 316:            System.out.println(s);
5515: 317:        }
5516: 318:    }
5517: 319:}
5518: 320:```
5519: 321:
5520: 322:输出结果：
5521: 323:
5522: 324:```java
5523: 325:stun!
5524: 326:on
5525: 327:Phasers
5526: 328:```
5527: 329:
5528: 330:内部类 `Node` 也是一个泛型，它拥有自己的类型参数。
5529: 331:
5530: 332:这个例子使用了一个 *末端标识* (end sentinel) 来判断栈何时为空。这个末端标识是在构造 `LinkedStack` 时创建的。然后，每次调用 `push()` 就会创建一个 `Node<T>` 对象，并将其链接到前一个 `Node<T>` 对象。当你调用 `pop()` 方法时，总是返回 `top.item`，然后丢弃当前 `top` 所指向的 `Node<T>`，并将 `top` 指向下一个 `Node<T>`，除非到达末端标识，这时就不能再移动 `top` 了。如果已经到达末端，程序还继续调用 `pop()` 方法，它只能得到 `null`，说明栈已经空了。
5531: 333:
5532: 334:### RandomList
5533: 335:
5534: 336:作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 `select()` 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型：
5535: 337:
5536: 338:```java
5537: 339:// generics/RandomList.java
5538: 340:import java.util.*;
5539: 341:import java.util.stream.*;
5540: 342:
5541: 343:public class RandomList<T> extends ArrayList<T> {
5542: 344:    private Random rand = new Random(47);
5543: 345:  
5544: 346:    public T select() {
5545: 347:        return get(rand.nextInt(size()));
5546: 348:    }
5547: 349:  
5548: 350:    public static void main(String[] args) {
5549: 351:        RandomList<String> rs = new RandomList<>();
5550: 352:        Arrays.stream("The quick brown fox jumped over the lazy brown dog".split(" ")).forEach(rs::add);
5551: 353:        IntStream.range(0, 11).forEach(i -> 
5552: 354:            System.out.print(rs.select() + " "));
5553: 355:    }
5554: 356:}
5555: 357:```
5556: 358:
5557: 359:输出结果：
5558: 360:
5559: 361:```java
5560: 362:brown over fox quick quick dog brown The brown lazy brown
5561: 363:```
5562: 364:
5563: 365:`RandomList` 继承了 `ArrayList` 的所有方法。本例中只添加了 `select()` 这个方法。
5564: 366:
5565: 367:<!-- Generic Interfaces -->
5566: 368:
5567: 369:## 泛型接口
5568: 370:
5569: 371:泛型也可以应用于接口。例如 *生成器*，这是一种专门负责创建对象的类。实际上，这是 *工厂方法* 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。
5570: 372:
5571: 373:一般而言，一个生成器只定义一个方法，用于创建对象。例如 `java.util.function` 类库中的 `Supplier` 就是一个生成器，调用其 `get()` 获取对象。`get()` 是泛型方法，返回值为类型参数 `T`。
5572: 374:
5573: 375:为了演示 `Supplier`，我们需要定义几个类。下面是个咖啡相关的继承体系：
5574: 376:
5575: 377:```java
5576: 378:// generics/coffee/Coffee.java
5577: 379:package generics.coffee;
5578: 380:
5579: 381:public class Coffee {
5580: 382:    private static long counter = 0;
5581: 383:    private final long id = counter++;
5582: 384:  
5583: 385:    @Override
5584: 386:    public String toString() {
5585: 387:        return getClass().getSimpleName() + " " + id;
5586: 388:    }
5587: 389:}
5588: 390:
5589: 391:
5590: 392:// generics/coffee/Latte.java
5591: 393:package generics.coffee;
5592: 394:public class Latte extends Coffee {}
5593: 395:
5594: 396:
5595: 397:// generics/coffee/Mocha.java
5596: 398:package generics.coffee;
5597: 399:public class Mocha extends Coffee {}
5598: 400:
5599: 401:
5600: 402:// generics/coffee/Cappuccino.java
5601: 403:package generics.coffee;
5602: 404:public class Cappuccino extends Coffee {}
5603: 405:
5604: 406:
5605: 407:// generics/coffee/Americano.java
5606: 408:package generics.coffee;
5607: 409:public class Americano extends Coffee {}
5608: 410:
5609: 411:
5610: 412:// generics/coffee/Breve.java
5611: 413:package generics.coffee;
5612: 414:public class Breve extends Coffee {}
5613: 415:```
5614: 416:
5615: 417:现在，我们可以编写一个类，实现 `Supplier<Coffee>` 接口，它能够随机生成不同类型的 `Coffee` 对象：
5616: 418:
5617: 419:```java
5618: 420:// generics/coffee/CoffeeSupplier.java
5619: 421:// {java generics.coffee.CoffeeSupplier}
5620: 422:package generics.coffee;
5621: 423:import java.util.*;
5622: 424:import java.util.function.*;
5623: 425:import java.util.stream.*;
5624: 426:
5625: 427:public class CoffeeSupplier
5626: 428:implements Supplier<Coffee>, Iterable<Coffee> {
5627: 429:    private Class<?>[] types = { Latte.class, Mocha.class, 
5628: 430:        Cappuccino.class, Americano.class, Breve.class };
5629: 431:    private static Random rand = new Random(47);
5630: 432:  
5631: 433:    public CoffeeSupplier() {}
5632: 434:    // For iteration:
5633: 435:    private int size = 0;
5634: 436:    public CoffeeSupplier(int sz) { size = sz; }
5635: 437:  
5636: 438:    @Override
5637: 439:    public Coffee get() {
5638: 440:        try {
5639: 441:            return (Coffee) types[rand.nextInt(types.length)].newInstance();
5640: 442:        } catch (InstantiationException | IllegalAccessException e) {
5641: 443:            throw new RuntimeException(e);
5642: 444:        }
5643: 445:    }
5644: 446:  
5645: 447:    class CoffeeIterator implements Iterator<Coffee> {
5646: 448:        int count = size;
5647: 449:        @Override
5648: 450:        public boolean hasNext() { return count > 0; }
5649: 451:        @Override
5650: 452:        public Coffee next() {
5651: 453:            count--;
5652: 454:            return CoffeeSupplier.this.get();
5653: 455:        }
5654: 456:        @Override
5655: 457:        public void remove() {
5656: 458:            throw new UnsupportedOperationException();
5657: 459:        }
5658: 460:    }
5659: 461:  
5660: 462:    @Override
5661: 463:    public Iterator<Coffee> iterator() {
5662: 464:        return new CoffeeIterator();
5663: 465:    }
5664: 466:  
5665: 467:    public static void main(String[] args) {
5666: 468:        Stream.generate(new CoffeeSupplier())
5667: 469:              .limit(5)
5668: 470:              .forEach(System.out::println);
5669: 471:        for (Coffee c : new CoffeeSupplier(5)) {
5670: 472:            System.out.println(c);
5671: 473:        }
5672: 474:    }
5673: 475:}
5674: 476:```
5675: 477:
5676: 478:输出结果：
5677: 479:
5678: 480:```java
5679: 481:Americano 0
5680: 482:Latte 1
5681: 483:Americano 2
5682: 484:Mocha 3
5683: 485:Mocha 4
5684: 486:Breve 5
5685: 487:Americano 6
5686: 488:Latte 7
5687: 489:Cappuccino 8
5688: 490:Cappuccino 9
5689: 491:```
5690: 492:
5691: 493:参数化的 `Supplier` 接口确保 `get()` 返回值是参数的类型。`CoffeeSupplier` 同时还实现了 `Iterable` 接口，所以能用于 *for-in* 语句。不过，它还需要知道何时终止循环，这正是第二个构造函数的作用。
5692: 494:
5693: 495:下面是另一个实现 `Supplier<T>` 接口的例子，它负责生成 Fibonacci 数列：
5694: 496:
5695: 497:```java
5696: 498:// generics/Fibonacci.java
5697: 499:// Generate a Fibonacci sequence
5698: 500:import java.util.function.*;
5699: 501:import java.util.stream.*;
5700: 502:
5701: 503:public class Fibonacci implements Supplier<Integer> {
5702: 504:    private int count = 0;
5703: 505:    @Override
5704: 506:    public Integer get() { return fib(count++); }
5705: 507:  
5706: 508:    private int fib(int n) {
5707: 509:        if(n < 2) return 1;
5708: 510:        return fib(n-2) + fib(n-1);
5709: 511:    }
5710: 512:  
5711: 513:    public static void main(String[] args) {
5712: 514:        Stream.generate(new Fibonacci())
5713: 515:              .limit(18)
5714: 516:              .map(n -> n + " ")
5715: 517:              .forEach(System.out::print);
5716: 518:    }
5717: 519:}
5718: 520:```
5719: 521:
5720: 522:输出结果：
5721: 523:
5722: 524:```java
5723: 525:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
5724: 526:```
5725: 527:
5726: 528:虽然我们在 `Fibonacci` 类的里里外外使用的都是 `int` 类型，但是其参数类型却是 `Integer`。这个例子引出了 Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备自动装箱和拆箱的功能，可以很方便地在基本类型和相应的包装类之间进行转换。通过这个例子中 `Fibonacci` 类对 `int` 的使用，我们已经看到了这种效果。
5727: 529:
5728: 530:如果还想更进一步，编写一个实现了 `Iterable` 的 `Fibnoacci` 生成器。我们的一个选择是重写这个类，令其实现 `Iterable` 接口。不过，你并不是总能拥有源代码的控制权，并且，除非必须这么做，否则，我们也不愿意重写一个类。而且我们还有另一种选择，就是创建一个 *适配器* (Adapter) 来实现所需的接口，我们在前面介绍过这个设计模式。
5729: 531:
5730: 532:有多种方法可以实现适配器。例如，可以通过继承来创建适配器类：
5731: 533:
5732: 534:```java
5733: 535:// generics/IterableFibonacci.java
5734: 536:// Adapt the Fibonacci class to make it Iterable
5735: 537:import java.util.*;
5736: 538:
5737: 539:public class IterableFibonacci
5738: 540:extends Fibonacci implements Iterable<Integer> {
5739: 541:    private int n;
5740: 542:    public IterableFibonacci(int count) { n = count; }
5741: 543:  
5742: 544:    @Override
5743: 545:    public Iterator<Integer> iterator() {
5744: 546:        return new Iterator<Integer>() {
5745: 547:            @Override
5746: 548:            public boolean hasNext() { return n > 0; }
5747: 549:            @Override
5748: 550:            public Integer next() {
5749: 551:                n--;
5750: 552:                return IterableFibonacci.this.get();
5751: 553:            }
5752: 554:            @Override
5753: 555:            public void remove() { // Not implemented
5754: 556:                throw new UnsupportedOperationException();
5755: 557:            }
5756: 558:        };
5757: 559:    }
5758: 560:  
5759: 561:    public static void main(String[] args) {
5760: 562:        for(int i : new IterableFibonacci(18))
5761: 563:            System.out.print(i + " ");
5762: 564:    }
5763: 565:}
5764: 566:```
5765: 567:
5766: 568:输出结果：
5767: 569:
5768: 570:```java
5769: 571:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
5770: 572:```
5771: 573:
5772: 574:在 *for-in* 语句中使用 `IterableFibonacci`，必须在构造函数中提供一个边界值，这样 `hasNext()` 才知道何时返回 **false**，结束循环。
5773: 575:
5774: 576:<!-- Generic Methods -->
5775: 577:
5776: 578:## 泛型方法
5777: 579:
5778: 580:到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。
5779: 581:
5780: 582:泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。
5781: 583:
5782: 584:如果方法是 **static** 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型类型参数，则它必须是泛型方法。
5783: 585:
5784: 586:要定义泛型方法，请将泛型参数列表放置在返回值之前，如下所示：
5785: 587:
5786: 588:```java
5787: 589:// generics/GenericMethods.java
5788: 590:
5789: 591:public class GenericMethods {
5790: 592:    public <T> void f(T x) {
5791: 593:        System.out.println(x.getClass().getName());
5792: 594:    }
5793: 595:
5794: 596:    public static void main(String[] args) {
5795: 597:        GenericMethods gm = new GenericMethods();
5796: 598:        gm.f("");
5797: 599:        gm.f(1);
5798: 600:        gm.f(1.0);
5799: 601:        gm.f(1.0F);
5800: 602:        gm.f('c');
5801: 603:        gm.f(gm);
5802: 604:    }
5803: 605:}
5804: 606:/* Output:
5805: 607:java.lang.String
5806: 608:java.lang.Integer
5807: 609:java.lang.Double
5808: 610:java.lang.Float
5809: 611:java.lang.Character
5810: 612:GenericMethods
5811: 613:*/
5812: 614:```
5813: 615:
5814: 616:尽管可以同时对类及其方法进行参数化，但这里未将 **GenericMethods** 类参数化。只有方法 `f()` 具有类型参数，该参数由方法返回类型之前的参数列表指示。
5815: 617:
5816: 618:对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 *类型参数推断*。因此，对 `f()` 的调用看起来像普通的方法调用，并且 `f()` 看起来像被重载了无数次一样。它甚至会接受 **GenericMethods** 类型的参数。
5817: 619:
5818: 620:如果使用基本类型调用 `f()` ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。
5819: 621:
5820: 622:<!-- Varargs and Generic Methods -->
5821: 623:
5822: 624:### 变长参数和泛型方法
5823: 625:
5824: 626:泛型方法和变长参数列表可以很好地共存：
5825: 627:
5826: 628:```java
5827: 629:// generics/GenericVarargs.java
5828: 630:
5829: 631:import java.util.ArrayList;
5830: 632:import java.util.List;
5831: 633:
5832: 634:public class GenericVarargs {
5833: 635:    @SafeVarargs
5834: 636:    public static <T> List<T> makeList(T... args) {
5835: 637:        List<T> result = new ArrayList<>();
5836: 638:        for (T item : args)
5837: 639:            result.add(item);
5838: 640:        return result;
5839: 641:    }
5840: 642:
5841: 643:    public static void main(String[] args) {
5842: 644:        List<String> ls = makeList("A");
5843: 645:        System.out.println(ls);
5844: 646:        ls = makeList("A", "B", "C");
5845: 647:        System.out.println(ls);
5846: 648:        ls = makeList(
5847: 649:                "ABCDEFFHIJKLMNOPQRSTUVWXYZ".split(""));
5848: 650:        System.out.println(ls);
5849: 651:    }
5850: 652:}
5851: 653:/* Output:
5852: 654:[A]
5853: 655:[A, B, C]
5854: 656:[A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R,
5855: 657:S, T, U, V, W, X, Y, Z]
5856: 658:*/
5857: 659:```
5858: 660:
5859: 661:此处显示的 `makeList()` 方法产生的功能与标准库的 `java.util.Arrays.asList()` 方法相同。
5860: 662:
5861: 663:`@SafeVarargs` 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。
5862: 664:
5863: 665:<!-- A General-Purpose Supplier -->
5864: 666:
5865: 667:### 一个泛型的 Supplier
5866: 668:
5867: 669:这是一个为任意具有无参构造方法的类生成 **Supplier** 的类。为了减少键入，它还包括一个用于生成 **BasicSupplier** 的泛型方法：
5868: 670:
5869: 671:```java
5870: 672:// onjava/BasicSupplier.java
5871: 673:// Supplier from a class with a no-arg constructor
5872: 674:package onjava;
5873: 675:
5874: 676:import java.util.function.Supplier;
5875: 677:
5876: 678:public class BasicSupplier<T> implements Supplier<T> {
5877: 679:    private Class<T> type;
5878: 680:
5879: 681:    public BasicSupplier(Class<T> type) {
5880: 682:        this.type = type;
5881: 683:    }
5882: 684:
5883: 685:    @Override
5884: 686:    public T get() {
5885: 687:        try {
5886: 688:            // Assumes type is a public class:
5887: 689:            return type.newInstance();
5888: 690:        } catch (InstantiationException |
5889: 691:                IllegalAccessException e) {
5890: 692:            throw new RuntimeException(e);
5891: 693:        }
5892: 694:    }
5893: 695:
5894: 696:    // Produce a default Supplier from a type token:
5895: 697:    public static <T> Supplier<T> create(Class<T> type) {
5896: 698:        return new BasicSupplier<>(type);
5897: 699:    }
5898: 700:}
5899: 701:```
5900: 702:
5901: 703:此类提供了产生以下对象的基本实现：
5902: 704:
5903: 705:1. 是 **public** 的。 因为 **BasicSupplier** 在单独的包中，所以相关的类必须具有 **public** 权限，而不仅仅是包级访问权限。
5904: 706:
5905: 707:2. 具有无参构造方法。要创建一个这样的 **BasicSupplier** 对象，请调用 `create()` 方法，并将要生成类型的类型令牌传递给它。通用的 `create()` 方法提供了 `BasicSupplier.create(MyType.class)` 这种较简洁的语法来代替较笨拙的 `new BasicSupplier <MyType>(MyType.class)`。
5906: 708:
5907: 709:例如，这是一个具有无参构造方法的简单类：
5908: 710:
5909: 711:```java
5910: 712:// generics/CountedObject.java
5911: 713:
5912: 714:public class CountedObject {
5913: 715:    private static long counter = 0;
5914: 716:    private final long id = counter++;
5915: 717:
5916: 718:    public long id() {
5917: 719:        return id;
5918: 720:    }
5919: 721:
5920: 722:    @Override
5921: 723:    public String toString() {
5922: 724:        return "CountedObject " + id;
5923: 725:    }
5924: 726:}
5925: 727:```
5926: 728:
5927: 729:**CountedObject** 类可以跟踪自身创建了多少个实例，并通过 `toString()` 报告这些实例的数量。 **BasicSupplier** 可以轻松地为 **CountedObject** 创建 **Supplier**：
5928: 730:
5929: 731:```java
5930: 732:  // generics/BasicSupplierDemo.java
5931: 733:
5932: 734:import onjava.BasicSupplier;
5933: 735:
5934: 736:import java.util.stream.Stream;
5935: 737:
5936: 738:public class BasicSupplierDemo {
5937: 739:    public static void main(String[] args) {
5938: 740:        Stream.generate(
5939: 741:                BasicSupplier.create(CountedObject.class))
5940: 742:                .limit(5)
5941: 743:                .forEach(System.out::println);
5942: 744:    }
5943: 745:}
5944: 746:/* Output:
5945: 747:CountedObject 0
5946: 748:CountedObject 1
5947: 749:CountedObject 2
5948: 750:CountedObject 3
5949: 751:CountedObject 4
5950: 752:*/
5951: 753:```
5952: 754:
5953: 755:泛型方法减少了产生 **Supplier** 对象所需的代码量。 Java 泛型强制传递 **Class** 对象，以便在 `create()` 方法中将其用于类型推断。
5954: 756:
5955: 757:<!-- Simplifying Tuple Use -->
5956: 758:
5957: 759:### 简化元组的使用
5958: 760:
5959: 761:使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库。在这里，我们使用重载的静态方法创建元组：
5960: 762:
5961: 763:```java
5962: 764:// onjava/Tuple.java
5963: 765:// Tuple library using type argument inference
5964: 766:package onjava;
5965: 767:
5966: 768:public class Tuple {
5967: 769:    public static <A, B> Tuple2<A, B> tuple(A a, B b) {
5968: 770:        return new Tuple2<>(a, b);
5969: 771:    }
5970: 772:
5971: 773:    public static <A, B, C> Tuple3<A, B, C>
5972: 774:    tuple(A a, B b, C c) {
5973: 775:        return new Tuple3<>(a, b, c);
5974: 776:    }
5975: 777:
5976: 778:    public static <A, B, C, D> Tuple4<A, B, C, D>
5977: 779:    tuple(A a, B b, C c, D d) {
5978: 780:        return new Tuple4<>(a, b, c, d);
5979: 781:    }
5980: 782:
5981: 783:    public static <A, B, C, D, E>
5982: 784:    Tuple5<A, B, C, D, E> tuple(A a, B b, C c, D d, E e) {
5983: 785:        return new Tuple5<>(a, b, c, d, e);
5984: 786:    }
5985: 787:}
5986: 788:```
5987: 789:
5988: 790:我们修改 **TupleTest.java** 来测试 **Tuple.java** :
5989: 791:
5990: 792:```java
5991: 793:// generics/TupleTest2.java
5992: 794:
5993: 795:import onjava.Tuple2;
5994: 796:import onjava.Tuple3;
5995: 797:import onjava.Tuple4;
5996: 798:import onjava.Tuple5;
5997: 799:
5998: 800:import static onjava.Tuple.tuple;
5999: 801:
6000: 802:public class TupleTest2 {
6001: 803:    static Tuple2<String, Integer> f() {
6002: 804:        return tuple("hi", 47);
6003: 805:    }
6004: 806:
6005: 807:    static Tuple2 f2() {
6006: 808:        return tuple("hi", 47);
6007: 809:    }
6008: 810:
6009: 811:    static Tuple3<Amphibian, String, Integer> g() {
6010: 812:        return tuple(new Amphibian(), "hi", 47);
6011: 813:    }
6012: 814:
6013: 815:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
6014: 816:        return tuple(
6015: 817:                new Vehicle(), new Amphibian(), "hi", 47);
6016: 818:    }
6017: 819:
6018: 820:    static Tuple5<Vehicle, Amphibian,
6019: 821:            String, Integer, Double> k() {
6020: 822:        return tuple(new Vehicle(), new Amphibian(),
6021: 823:                "hi", 47, 11.1);
6022: 824:    }
6023: 825:
6024: 826:    public static void main(String[] args) {
6025: 827:        Tuple2<String, Integer> ttsi = f();
6026: 828:        System.out.println(ttsi);
6027: 829:        System.out.println(f2());
6028: 830:        System.out.println(g());
6029: 831:        System.out.println(h());
6030: 832:        System.out.println(k());
6031: 833:    }
6032: 834:}
6033: 835:/* Output:
6034: 836:(hi, 47)
6035: 837:(hi, 47)
6036: 838:(Amphibian@14ae5a5, hi, 47)
6037: 839:(Vehicle@135fbaa4, Amphibian@45ee12a7, hi, 47)
6038: 840:(Vehicle@4b67cf4d, Amphibian@7ea987ac, hi, 47, 11.1)
6039: 841:*/
6040: 842:```
6041: 843:
6042: 844:请注意，`f()` 返回一个参数化的 **Tuple2** 对象，而 `f2()` 返回一个未参数化的 **Tuple2** 对象。编译器不会在这里警告 `f2()` ，因为返回值未以参数化方式使用。从某种意义上说，它被“向上转型”为一个未参数化的 **Tuple2** 。 但是，如果尝试将 `f2()` 的结果放入到参数化的 **Tuple2** 中，则编译器将发出警告。
6043: 845:
6044: 846:<!-- A Set Utility -->
6045: 847:
6046: 848:### 一个 Set 工具
6047: 849:
6048: 850:对于泛型方法的另一个示例，请考虑由 **Set** 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法：
6049: 851:
6050: 852:```java
6051: 853:// onjava/Sets.java
6052: 854:
6053: 855:package onjava;
6054: 856:
6055: 857:import java.util.HashSet;
6056: 858:import java.util.Set;
6057: 859:
6058: 860:public class Sets {
6059: 861:    public static <T> Set<T> union(Set<T> a, Set<T> b) {
6060: 862:        Set<T> result = new HashSet<>(a);
6061: 863:        result.addAll(b);
6062: 864:        return result;
6063: 865:    }
6064: 866:
6065: 867:    public static <T>
6066: 868:    Set<T> intersection(Set<T> a, Set<T> b) {
6067: 869:        Set<T> result = new HashSet<>(a);
6068: 870:        result.retainAll(b);
6069: 871:        return result;
6070: 872:    }
6071: 873:
6072: 874:    // Subtract subset from superset:
6073: 875:    public static <T> Set<T>
6074: 876:    difference(Set<T> superset, Set<T> subset) {
6075: 877:        Set<T> result = new HashSet<>(superset);
6076: 878:        result.removeAll(subset);
6077: 879:        return result;
6078: 880:    }
6079: 881:
6080: 882:    // Reflexive--everything not in the intersection:
6081: 883:    public static <T> Set<T> complement(Set<T> a, Set<T> b) {
6082: 884:        return difference(union(a, b), intersection(a, b));
6083: 885:    }
6084: 886:}
6085: 887:```
6086: 888:
6087: 889:前三个方法通过将第一个参数的引用复制到新的 **HashSet** 对象中来复制第一个参数，因此不会直接修改参数集合。因此，返回值是一个新的 **Set** 对象。
6088: 890:
6089: 891:这四种方法代表数学集合操作： `union()` 返回一个包含两个参数并集的 **Set** ， `intersection()` 返回一个包含两个参数集合交集的 **Set** ， `difference()` 从 **superset** 中减去 **subset** 的元素 ，而 `complement()` 返回所有不在交集中的元素的 **Set**。作为显示这些方法效果的简单示例的一部分，下面是一个包含不同水彩名称的 **enum** ：
6090: 892:
6091: 893:```java
6092: 894:// generics/watercolors/Watercolors.java
6093: 895:
6094: 896:package watercolors;
6095: 897:
6096: 898:public enum Watercolors {
6097: 899:    ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW,
6098: 900:    ORANGE, BRILLIANT_RED, CRIMSON, MAGENTA,
6099: 901:    ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE,
6100: 902:    PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE,
6101: 903:    PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN,
6102: 904:    YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
6103: 905:    BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK
6104: 906:}
6105: 907:```
6106: 908:
6107: 909:为了方便起见（不必全限定所有名称），将其静态导入到以下示例中。本示例使用 **EnumSet** 轻松从 **enum** 中创建 **Set** 。（可以在[第二十二章 枚举](book/22-Enumerations.md)一章中了解有关 **EnumSet** 的更多信息。）在这里，静态方法 `EnumSet.range()` 要求提供所要在结果 **Set** 中创建的元素范围的第一个和最后一个元素：
6108: 910:
6109: 911:```java
6110: 912:// generics/WatercolorSets.java
6111: 913:
6112: 914:import watercolors.*;
6113: 915:
6114: 916:import java.util.EnumSet;
6115: 917:import java.util.Set;
6116: 918:
6117: 919:import static watercolors.Watercolors.*;
6118: 920:import static onjava.Sets.*;
6119: 921:
6120: 922:public class WatercolorSets {
6121: 923:    public static void main(String[] args) {
6122: 924:        Set<Watercolors> set1 =
6123: 925:                EnumSet.range(BRILLIANT_RED, VIRIDIAN_HUE);
6124: 926:        Set<Watercolors> set2 =
6125: 927:                EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER);
6126: 928:        System.out.println("set1: " + set1);
6127: 929:        System.out.println("set2: " + set2);
6128: 930:        System.out.println(
6129: 931:                "union(set1, set2): " + union(set1, set2));
6130: 932:        Set<Watercolors> subset = intersection(set1, set2);
6131: 933:        System.out.println(
6132: 934:                "intersection(set1, set2): " + subset);
6133: 935:        System.out.println("difference(set1, subset): " +
6134: 936:                difference(set1, subset));
6135: 937:        System.out.println("difference(set2, subset): " +
6136: 938:                difference(set2, subset));
6137: 939:        System.out.println("complement(set1, set2): " +
6138: 940:                complement(set1, set2));
6139: 941:    }
6140: 942:}
6141: 943:/* Output:
6142: 944:set1: [BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER,
6143: 945:VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
6144: 946:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE]
6145: 947:set2: [CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
6146: 948:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE,
6147: 949:SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
6148: 950:BURNT_UMBER]
6149: 951:union(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
6150: 952:YELLOW_OCHRE, MAGENTA, SAP_GREEN, CERULEAN_BLUE_HUE,
6151: 953:ULTRAMARINE, VIRIDIAN_HUE, VIOLET, RAW_UMBER,
6152: 954:ROSE_MADDER, PERMANENT_GREEN, BURNT_UMBER,
6153: 955:PHTHALO_BLUE, CRIMSON, COBALT_BLUE_HUE]
6154: 956:intersection(set1, set2): [PERMANENT_GREEN,
6155: 957:CERULEAN_BLUE_HUE, ULTRAMARINE, VIRIDIAN_HUE,
6156: 958:PHTHALO_BLUE, COBALT_BLUE_HUE]
6157: 959:difference(set1, subset): [BRILLIANT_RED, MAGENTA,
6158: 960:VIOLET, CRIMSON, ROSE_MADDER]
6159: 961:difference(set2, subset): [BURNT_SIENNA, YELLOW_OCHRE,
6160: 962:BURNT_UMBER, SAP_GREEN, RAW_UMBER]
6161: 963:complement(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
6162: 964:YELLOW_OCHRE, MAGENTA, SAP_GREEN, VIOLET, RAW_UMBER,
6163: 965:ROSE_MADDER, BURNT_UMBER, CRIMSON]
6164: 966:*/
6165: 967:```
6166: 968:
6167: 969:接下来的例子使用 `Sets.difference()` 方法来展示 **java.util** 包中各种 **Collection** 和 **Map** 类之间的方法差异：
6168: 970:
6169: 971:```java
6170: 972:// onjava/CollectionMethodDifferences.java
6171: 973:// {java onjava.CollectionMethodDifferences}
6172: 974:
6173: 975:package onjava;
6174: 976:
6175: 977:import java.lang.reflect.Method;
6176: 978:import java.util.*;
6177: 979:import java.util.stream.Collectors;
6178: 980:
6179: 981:public class CollectionMethodDifferences {
6180: 982:    static Set<String> methodSet(Class<?> type) {
6181: 983:        return Arrays.stream(type.getMethods())
6182: 984:                .map(Method::getName)
6183: 985:                .collect(Collectors.toCollection(TreeSet::new));
6184: 986:    }
6185: 987:
6186: 988:    static void interfaces(Class<?> type) {
6187: 989:        System.out.print("Interfaces in " +
6188: 990:                type.getSimpleName() + ": ");
6189: 991:        System.out.println(
6190: 992:                Arrays.stream(type.getInterfaces())
6191: 993:                        .map(Class::getSimpleName)
6192: 994:                        .collect(Collectors.toList()));
6193: 995:    }
6194: 996:
6195: 997:    static Set<String> object = methodSet(Object.class);
6196: 998:
6197: 999:    static {
6198: 1000:        object.add("clone");
6199: 1001:    }
6200: 1002:
6201: 1003:    static void
6202: 1004:    difference(Class<?> superset, Class<?> subset) {
6203: 1005:        System.out.print(superset.getSimpleName() +
6204: 1006:                " extends " + subset.getSimpleName() +
6205: 1007:                ", adds: ");
6206: 1008:        Set<String> comp = Sets.difference(
6207: 1009:                methodSet(superset), methodSet(subset));
6208: 1010:        comp.removeAll(object); // Ignore 'Object' methods
6209: 1011:        System.out.println(comp);
6210: 1012:        interfaces(superset);
6211: 1013:    }
6212: 1014:
6213: 1015:    public static void main(String[] args) {
6214: 1016:        System.out.println("Collection: " +
6215: 1017:                methodSet(Collection.class));
6216: 1018:        interfaces(Collection.class);
6217: 1019:        difference(Set.class, Collection.class);
6218: 1020:        difference(HashSet.class, Set.class);
6219: 1021:        difference(LinkedHashSet.class, HashSet.class);
6220: 1022:        difference(TreeSet.class, Set.class);
6221: 1023:        difference(List.class, Collection.class);
6222: 1024:        difference(ArrayList.class, List.class);
6223: 1025:        difference(LinkedList.class, List.class);
6224: 1026:        difference(Queue.class, Collection.class);
6225: 1027:        difference(PriorityQueue.class, Queue.class);
6226: 1028:        System.out.println("Map: " + methodSet(Map.class));
6227: 1029:        difference(HashMap.class, Map.class);
6228: 1030:        difference(LinkedHashMap.class, HashMap.class);
6229: 1031:        difference(SortedMap.class, Map.class);
6230: 1032:        difference(TreeMap.class, Map.class);
6231: 1033:    }
6232: 1034:}
6233: 1035:/* Output:
6234: 1036:Collection: [add, addAll, clear, contains, containsAll,
6235: 1037:equals, forEach, hashCode, isEmpty, iterator,
6236: 1038:parallelStream, remove, removeAll, removeIf, retainAll,
6237: 1039:size, spliterator, stream, toArray]
6238: 1040:Interfaces in Collection: [Iterable]
6239: 1041:Set extends Collection, adds: []
6240: 1042:Interfaces in Set: [Collection]
6241: 1043:HashSet extends Set, adds: []
6242: 1044:Interfaces in HashSet: [Set, Cloneable, Serializable]
6243: 1045:LinkedHashSet extends HashSet, adds: []
6244: 1046:Interfaces in LinkedHashSet: [Set, Cloneable,
6245: 1047:Serializable]
6246: 1048:TreeSet extends Set, adds: [headSet,
6247: 1049:descendingIterator, descendingSet, pollLast, subSet,
6248: 1050:floor, tailSet, ceiling, last, lower, comparator,
6249: 1051:pollFirst, first, higher]
6250: 1052:Interfaces in TreeSet: [NavigableSet, Cloneable,
6251: 1053:Serializable]
6252: 1054:List extends Collection, adds: [replaceAll, get,
6253: 1055:indexOf, subList, set, sort, lastIndexOf, listIterator]
6254: 1056:Interfaces in List: [Collection]
6255: 1057:ArrayList extends List, adds: [trimToSize,
6256: 1058:ensureCapacity]
6257: 1059:Interfaces in ArrayList: [List, RandomAccess,
6258: 1060:Cloneable, Serializable]
6259: 1061:LinkedList extends List, adds: [offerFirst, poll,
6260: 1062:getLast, offer, getFirst, removeFirst, element,
6261: 1063:removeLastOccurrence, peekFirst, peekLast, push,
6262: 1064:pollFirst, removeFirstOccurrence, descendingIterator,
6263: 1065:pollLast, removeLast, pop, addLast, peek, offerLast,
6264: 1066:addFirst]
6265: 1067:Interfaces in LinkedList: [List, Deque, Cloneable,
6266: 1068:Serializable]
6267: 1069:Queue extends Collection, adds: [poll, peek, offer,
6268: 1070:element]
6269: 1071:Interfaces in Queue: [Collection]
6270: 1072:PriorityQueue extends Queue, adds: [comparator]
6271: 1073:Interfaces in PriorityQueue: [Serializable]
6272: 1074:Map: [clear, compute, computeIfAbsent,
6273: 1075:computeIfPresent, containsKey, containsValue, entrySet,
6274: 1076:equals, forEach, get, getOrDefault, hashCode, isEmpty,
6275: 1077:keySet, merge, put, putAll, putIfAbsent, remove,
6276: 1078:replace, replaceAll, size, values]
6277: 1079:HashMap extends Map, adds: []
6278: 1080:Interfaces in HashMap: [Map, Cloneable, Serializable]
6279: 1081:LinkedHashMap extends HashMap, adds: []
6280: 1082:Interfaces in LinkedHashMap: [Map]
6281: 1083:SortedMap extends Map, adds: [lastKey, subMap,
6282: 1084:comparator, firstKey, headMap, tailMap]
6283: 1085:Interfaces in SortedMap: [Map]
6284: 1086:TreeMap extends Map, adds: [descendingKeySet,
6285: 1087:navigableKeySet, higherEntry, higherKey, floorKey,
6286: 1088:subMap, ceilingKey, pollLastEntry, firstKey, lowerKey,
6287: 1089:headMap, tailMap, lowerEntry, ceilingEntry,
6288: 1090:descendingMap, pollFirstEntry, lastKey, firstEntry,
6289: 1091:floorEntry, comparator, lastEntry]
6290: 1092:Interfaces in TreeMap: [NavigableMap, Cloneable,
6291: 1093:Serializable]
6292: 1094:*/
6293: 1095:```
6294: 1096:
6295: 1097:在第十二章 [集合的本章小结](book/12-Collections.md#本章小结) 部分将会用到这里的输出结果。
6296: 1098:
6297: 1099:<!-- Building Complex Models -->
6298: 1100:
6299: 1101:## 构建复杂模型
6300: 1102:
6301: 1103:泛型的一个重要好处是能够简单安全地创建复杂模型。例如，我们可以轻松地创建一个元组列表：
6302: 1104:
6303: 1105:```java
6304: 1106:// generics/TupleList.java
6305: 1107:// Combining generic types to make complex generic types
6306: 1108:
6307: 1109:import onjava.Tuple4;
6308: 1110:
6309: 1111:import java.util.ArrayList;
6310: 1112:
6311: 1113:public class TupleList<A, B, C, D>
6312: 1114:        extends ArrayList<Tuple4<A, B, C, D>> {
6313: 1115:    public static void main(String[] args) {
6314: 1116:        TupleList<Vehicle, Amphibian, String, Integer> tl =
6315: 1117:                new TupleList<>();
6316: 1118:        tl.add(TupleTest2.h());
6317: 1119:        tl.add(TupleTest2.h());
6318: 1120:        tl.forEach(System.out::println);
6319: 1121:    }
6320: 1122:}
6321: 1123:/* Output:
6322: 1124:(Vehicle@7cca494b, Amphibian@7ba4f24f, hi, 47)
6323: 1125:(Vehicle@3b9a45b3, Amphibian@7699a589, hi, 47)
6324: 1126:*/
6325: 1127:```
6326: 1128:
6327: 1129:这将产生一个功能强大的数据结构，而无需太多代码。
6328: 1130:
6329: 1131:下面是第二个例子。每个类都是组成块，总体包含很多个块。在这里，该模型是一个具有过道，货架和产品的零售商店：
6330: 1132:
6331: 1133:```java
6332: 1134:// generics/Store.java
6333: 1135:// Building a complex model using generic collections
6334: 1136:
6335: 1137:import onjava.Suppliers;
6336: 1138:
6337: 1139:import java.util.ArrayList;
6338: 1140:import java.util.Random;
6339: 1141:import java.util.function.Supplier;
6340: 1142:
6341: 1143:class Product {
6342: 1144:    private final int id;
6343: 1145:    private String description;
6344: 1146:    private double price;
6345: 1147:
6346: 1148:    Product(int idNumber, String descr, double price) {
6347: 1149:        id = idNumber;
6348: 1150:        description = descr;
6349: 1151:        this.price = price;
6350: 1152:        System.out.println(toString());
6351: 1153:    }
6352: 1154:
6353: 1155:    @Override
6354: 1156:    public String toString() {
6355: 1157:        return id + ": " + description +
6356: 1158:                ", price: $" + price;
6357: 1159:    }
6358: 1160:
6359: 1161:    public void priceChange(double change) {
6360: 1162:        price += change;
6361: 1163:    }
6362: 1164:
6363: 1165:    public static Supplier<Product> generator =
6364: 1166:            new Supplier<Product>() {
6365: 1167:                private Random rand = new Random(47);
6366: 1168:
6367: 1169:                @Override
6368: 1170:                public Product get() {
6369: 1171:                    return new Product(rand.nextInt(1000), "Test",
6370: 1172:                            Math.round(
6371: 1173:                                    rand.nextDouble() * 1000.0) + 0.99);
6372: 1174:                }
6373: 1175:            };
6374: 1176:}
6375: 1177:
6376: 1178:class Shelf extends ArrayList<Product> {
6377: 1179:    Shelf(int nProducts) {
6378: 1180:        Suppliers.fill(this, Product.generator, nProducts);
6379: 1181:    }
6380: 1182:}
6381: 1183:
6382: 1184:class Aisle extends ArrayList<Shelf> {
6383: 1185:    Aisle(int nShelves, int nProducts) {
6384: 1186:        for (int i = 0; i < nShelves; i++)
6385: 1187:            add(new Shelf(nProducts));
6386: 1188:    }
6387: 1189:}
6388: 1190:
6389: 1191:class CheckoutStand {
6390: 1192:}
6391: 1193:
6392: 1194:class Office {
6393: 1195:}
6394: 1196:
6395: 1197:public class Store extends ArrayList<Aisle> {
6396: 1198:    private ArrayList<CheckoutStand> checkouts =
6397: 1199:            new ArrayList<>();
6398: 1200:    private Office office = new Office();
6399: 1201:
6400: 1202:    public Store(
6401: 1203:            int nAisles, int nShelves, int nProducts) {
6402: 1204:        for (int i = 0; i < nAisles; i++)
6403: 1205:            add(new Aisle(nShelves, nProducts));
6404: 1206:    }
6405: 1207:
6406: 1208:    @Override
6407: 1209:    public String toString() {
6408: 1210:        StringBuilder result = new StringBuilder();
6409: 1211:        for (Aisle a : this)
6410: 1212:            for (Shelf s : a)
6411: 1213:                for (Product p : s) {
6412: 1214:                    result.append(p);
6413: 1215:                    result.append("\n");
6414: 1216:                }
6415: 1217:        return result.toString();
6416: 1218:    }
6417: 1219:
6418: 1220:    public static void main(String[] args) {
6419: 1221:        System.out.println(new Store(5, 4, 3));
6420: 1222:    }
6421: 1223:}
6422: 1224:/* Output: (First 8 Lines)
6423: 1225:258: Test, price: $400.99
6424: 1226:861: Test, price: $160.99
6425: 1227:868: Test, price: $417.99
6426: 1228:207: Test, price: $268.99
6427: 1229:551: Test, price: $114.99
6428: 1230:278: Test, price: $804.99
6429: 1231:520: Test, price: $554.99
6430: 1232:140: Test, price: $530.99
6431: 1233:                  ...
6432: 1234:*/
6433: 1235:```
6434: 1236:
6435: 1237:`Store.toString()` 显示了结果：尽管有复杂的层次结构，但多层的集合仍然是类型安全的和可管理的。令人印象深刻的是，组装这样的模型并不需要耗费过多精力。
6436: 1238:
6437: 1239:**Shelf** 使用 `Suppliers.fill()` 这个实用程序，该实用程序接受 **Collection** （第一个参数），并使用 **Supplier** （第二个参数），以元素的数量为 **n** （第三个参数）来填充它。 **Suppliers** 类将会在本章末尾定义，其中的方法都是在执行某种填充操作，并在本章的其他示例中使用。
6438: 1240:
6439: 1241:<!-- The Mystery of Erasure -->
6440: 1242:
6441: 1243:## 泛型擦除
6442: 1244:
6443: 1245:当你开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的。例如，尽管可以说  `ArrayList.class`，但不能说成 `ArrayList<Integer>.class`。考虑下面的情况：
6444: 1246:
6445: 1247:```java
6446: 1248:// generics/ErasedTypeEquivalence.java
6447: 1249:
6448: 1250:import java.util.*;
6449: 1251:
6450: 1252:public class ErasedTypeEquivalence {
6451: 1253:    
6452: 1254:    public static void main(String[] args) {
6453: 1255:        Class c1 = new ArrayList<String>().getClass();
6454: 1256:        Class c2 = new ArrayList<Integer>().getClass();
6455: 1257:        System.out.println(c1 == c2);
6456: 1258:    }
6457: 1259:    
6458: 1260:}
6459: 1261:/* Output:
6460: 1262:true
6461: 1263:*/
6462: 1264:```
6463: 1265:
6464: 1266:`ArrayList<String>` 和 `ArrayList<Integer>` 应该是不同的类型。不同的类型会有不同的行为。例如，如果尝试向 `ArrayList<String>` 中放入一个 `Integer`，所得到的行为（失败）和向 `ArrayList<Integer>` 中放入一个 `Integer` 所得到的行为（成功）完全不同。然而上面的程序认为它们是相同的类型。
6465: 1267:
6466: 1268:下面的例子是对该谜题的补充：
6467: 1269:
6468: 1270:```java
6469: 1271:// generics/LostInformation.java
6470: 1272:
6471: 1273:import java.util.*;
6472: 1274:
6473: 1275:class Frob {}
6474: 1276:class Fnorkle {}
6475: 1277:class Quark<Q> {}
6476: 1278:
6477: 1279:class Particle<POSITION, MOMENTUM> {}
6478: 1280:
6479: 1281:public class LostInformation {
6480: 1282:
6481: 1283:    public static void main(String[] args) {
6482: 1284:        List<Frob> list = new ArrayList<>();
6483: 1285:        Map<Frob, Fnorkle> map = new HashMap<>();
6484: 1286:        Quark<Fnorkle> quark = new Quark<>();
6485: 1287:        Particle<Long, Double> p = new Particle<>();
6486: 1288:        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));
6487: 1289:        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));
6488: 1290:        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));
6489: 1291:        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));
6490: 1292:    }
6491: 1293:
6492: 1294:}
6493: 1295:/* Output:
6494: 1296:[E]
6495: 1297:[K,V]
6496: 1298:[Q]
6497: 1299:[POSITION,MOMENTUM]
6498: 1300:*/
6499: 1301:```
6500: 1302:
6501: 1303:根据 JDK 文档，**Class.getTypeParameters()** “返回一个 **TypeVariable** 对象数组，表示泛型声明中声明的类型参数...” 这暗示你可以发现这些参数类型。但是正如上例中输出所示，你只能看到用作参数占位符的标识符，这并非有用的信息。
6502: 1304:
6503: 1305:残酷的现实是：
6504: 1306:
6505: 1307:在泛型代码内部，无法获取任何有关泛型参数类型的信息。
6506: 1308:
6507: 1309:因此，你可以知道如类型参数标识符和泛型边界这些信息，但无法得知实际的类型参数从而用来创建特定的实例。如果你曾是 C++ 程序员，那么这个事实会让你很沮丧，在使用 Java 泛型工作时，它是必须处理的最基本的问题。
6508: 1310:
6509: 1311:Java 泛型是使用擦除实现的。这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此，`List<String>` 和 `List<Integer>` 在运行时实际上是相同的类型。它们都被擦除成原生类型 `List`。
6510: 1312:
6511: 1313:理解擦除并知道如何处理它，是你在学习 Java 泛型时面临的最大障碍之一。这也是本节将要探讨的内容。
6512: 1314:
6513: 1315:### C++ 的方式
6514: 1316:
6515: 1317:下面是使用模版的 C++ 示例。你会看到类型参数的语法十分相似，因为 Java 是受 C++ 启发的：
6516: 1318:
6517: 1319:```c++
6518: 1320:// generics/Templates.cpp
6519: 1321:
6520: 1322:#include <iostream>
6521: 1323:using namespace std;
6522: 1324:
6523: 1325:template<class T> class Manipulator {
6524: 1326:    T obj;
6525: 1327:public:
6526: 1328:    Manipulator(T x) { obj = x; }
6527: 1329:    void manipulate() { obj.f(); }
6528: 1330:};
6529: 1331:
6530: 1332:class HasF {
6531: 1333:public:
6532: 1334:    void f() { cout << "HasF::f()" << endl; }
6533: 1335:};
6534: 1336:
6535: 1337:int main() {
6536: 1338:    HasF hf;
6537: 1339:    Manipulator<HasF> manipulator(hf);
6538: 1340:    manipulator.manipulate();
6539: 1341:}
6540: 1342:/* Output:
6541: 1343:HasF::f()
6542: 1344:*/
6543: 1345:```
6544: 1346:
6545: 1347:**Manipulator** 类存储了一个 **T** 类型的对象。`manipulate()` 方法会调用 **obj** 上的 `f()` 方法。它是如何知道类型参数 **T** 中存在 `f()` 方法的呢？C++ 编译器会在你实例化模版时进行检查，所以在 `Manipulator<HasF>` 实例化的那一刻，它看到 **HasF** 中含有一个方法 `f()`。如果情况并非如此，你就会得到一个编译期错误，保持类型安全。
6546: 1348:
6547: 1349:用 C++ 编写这种代码很简单，因为当模版被实例化时，模版代码就知道模版参数的类型。Java 泛型就不同了。下面是 **HasF** 的 Java 版本：
6548: 1350:
6549: 1351:```java
6550: 1352:// generics/HasF.java
6551: 1353:
6552: 1354:public class HasF {
6553: 1355:    public void f() {
6554: 1356:        System.out.println("HasF.f()");
6555: 1357:    }
6556: 1358:}
6557: 1359:```
6558: 1360:
6559: 1361:如果我们将示例的其余代码用 Java 实现，就不会通过编译：
6560: 1362:
6561: 1363:```java
6562: 1364:// generics/Manipulation.java
6563: 1365:// {WillNotCompile}
6564: 1366:
6565: 1367:class Manipulator<T> {
6566: 1368:    private T obj;
6567: 1369:    
6568: 1370:    Manipulator(T x) {
6569: 1371:        obj = x;
6570: 1372:    }
6571: 1373:    
6572: 1374:    // Error: cannot find symbol: method f():
6573: 1375:    public void manipulate() {
6574: 1376:        obj.f();
6575: 1377:    }
6576: 1378:}
6577: 1379:
6578: 1380:public class Manipulation {
6579: 1381:	public static void main(String[] args) {
6580: 1382:        HasF hf = new HasF();
6581: 1383:        Manipulator<HasF> manipulator = new Manipulator<>(hf);
6582: 1384:        manipulator.manipulate();
6583: 1385:    }
6584: 1386:}
6585: 1387:```
6586: 1388:
6587: 1389:因为擦除，Java 编译器无法将 `manipulate()` 方法必须能调用 **obj** 的 `f()` 方法这一需求映射到 HasF 具有 `f()` 方法这个事实上。为了调用 `f()`，我们必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。这里重用了 **extends** 关键字。由于有了边界，下面的代码就能通过编译：
6588: 1390:
6589: 1391:```java
6590: 1392:public class Manipulator2<T extends HasF> {
6591: 1393:    private T obj;
6592: 1394:
6593: 1395:    Manipulator2(T x) {
6594: 1396:        obj = x;
6595: 1397:    }
6596: 1398:
6597: 1399:    public void manipulate() {
6598: 1400:        obj.f();
6599: 1401:    }
6600: 1402:}
6601: 1403:```
6602: 1404:
6603: 1405:边界 `<T extends HasF>` 声明 T 必须是 HasF 类型或其子类。如果情况确实如此，就可以安全地在 **obj** 上调用 `f()` 方法。
6604: 1406:
6605: 1407:我们说泛型类型参数会擦除到它的第一个边界（可能有多个边界，稍后你将看到）。我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的示例，**T** 擦除到了 **HasF**，就像在类的声明中用 **HasF** 替换了 **T** 一样。
6606: 1408:
6607: 1409:你可能正确地观察到了泛型在 **Manipulator2.java** 中没有贡献任何事。你可以很轻松地自己去执行擦除，生成没有泛型的类：
6608: 1410:
6609: 1411:```java
6610: 1412:// generics/Manipulator3.java
6611: 1413:
6612: 1414:class Manipulator3 {
6613: 1415:    private HasF obj;
6614: 1416:    
6615: 1417:    Manipulator3(HasF x) {
6616: 1418:        obj = x;
6617: 1419:    }
6618: 1420:    
6619: 1421:    public void manipulate() {
6620: 1422:        obj.f();
6621: 1423:    }
6622: 1424:}
6623: 1425:```
6624: 1426:
6625: 1427:这提出了很重要的一点：泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用。因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换更加复杂。但是，不能因此认为使用 `<T extends HasF>` 形式就是有缺陷的。例如，如果某个类有一个返回 **T** 的方法，那么泛型就有所帮助，因为它们之后将返回确切的类型：
6626: 1428:
6627: 1429:```java
6628: 1430:// generics/ReturnGenericType.java
6629: 1431:
6630: 1432:public class ReturnGenericType<T extends HasF> {
6631: 1433:    private T obj;
6632: 1434:    
6633: 1435:    ReturnGenericType(T x) {
6634: 1436:        obj = x;
6635: 1437:    }
6636: 1438:    
6637: 1439:    public T get() {
6638: 1440:        return obj;
6639: 1441:    }
6640: 1442:}
6641: 1443:```
6642: 1444:
6643: 1445:你必须查看所有的代码，从而确定代码是否复杂到必须使用泛型的程度。
6644: 1446:
6645: 1447:我们将在本章稍后看到有关边界的更多细节。
6646: 1448:
6647: 1449:### 迁移兼容性
6648: 1450:
6649: 1451:为了减少潜在的关于擦除的困惑，你必须清楚地认识到这不是一个语言特性。它是 Java 实现泛型的一种妥协，因为泛型不是 Java 语言出现时就有的，所以就有了这种妥协。它会使你痛苦，因此你需要尽早习惯它并了解为什么它会这样。
6650: 1452:
6651: 1453:如果 Java 1.0 就含有泛型的话，那么这个特性就不会使用擦除来实现——它会使用具体化，保持参数类型为第一类实体，因此你就能在类型参数上执行基于类型的语言操作和反射操作。本章稍后你会看到，擦除减少了泛型的泛化性。泛型在 Java 中仍然是有用的，只是不如它们本来设想的那么有用，而原因就是擦除。
6652: 1454:
6653: 1455:在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文使用泛型类型。泛型类型只有在静态类型检测期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如， `List<T>` 这样的类型注解会被擦除为 **List**，普通的类型变量在未指定边界的情况下会被擦除为 **Object**。
6654: 1456:
6655: 1457:擦除的核心动机是你可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称为“迁移兼容性”。在理想情况下，所有事物将在指定的某天被泛化。在现实中，即使程序员只编写泛型代码，他们也必须处理 Java 5 之前编写的非泛型类库。这些类库的作者可能从没想过要泛化他们的代码，或许他们可能刚刚开始接触泛型。
6656: 1458:
6657: 1459:因此 Java 泛型不仅必须支持向后兼容性——现有的代码和类文件仍然合法，继续保持之前的含义——而且还必须支持迁移兼容性，使得类库能按照它们自己的步调变为泛型，当某个类库变为泛型时，不会破坏依赖于它的代码和应用。在确定了这个目标后，Java 设计者们和从事此问题相关工作的各个团队决策认为擦除是唯一可行的解决方案。擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。
6658: 1460:
6659: 1461:例如，假设一个应用使用了两个类库 **X** 和 **Y**，**Y** 使用了类库 **Z**。随着 Java 5 的出现，这个应用和这些类库的创建者最终可能希望迁移到泛型上。但是当进行迁移时，它们有着不同的动机和限制。为了实现迁移兼容性，每个类库与应用必须与其他所有的部分是否使用泛型无关。因此，它们不能探测其他类库是否使用了泛型。因此，某个特定的类库使用了泛型这样的证据必须被”擦除“。
6660: 1462:
6661: 1463:如果没有某种类型的迁移途径，所有已经构建了很长时间的类库就需要与希望迁移到 Java 泛型上的开发者们说再见了。类库毫无争议是编程语言的一部分，对生产效率有着极大的影响，所以这种代码无法接受。擦除是否是最佳的或唯一的迁移途径，还待时间来证明。
6662: 1464:
6663: 1465:### 擦除的问题
6664: 1466:
6665: 1467:因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。擦除允许你继续使用现有的非泛型客户端代码，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会骤然破坏所有现有的代码。
6666: 1468:
6667: 1469:擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作中，例如转型、**instanceof** 操作和 **new** 表达式。因为所有关于参数的类型信息都丢失了，当你在编写泛型代码时，必须时刻提醒自己，你只是看起来拥有有关参数的类型信息而已。
6668: 1470:
6669: 1471:考虑如下的代码段：
6670: 1472:
6671: 1473:```java
6672: 1474:class Foo<T> {
6673: 1475:    T var;
6674: 1476:}
6675: 1477:```
6676: 1478:
6677: 1479:看上去当你创建一个 **Foo** 实例时：
6678: 1480:
6679: 1481:```java
6680: 1482:Foo<Cat> f = new Foo<>();
6681: 1483:```
6682: 1484:
6683: 1485:**class** **Foo** 中的代码应该知道现在工作于 **Cat** 之上。泛型语法也在强烈暗示整个类中所有 T 出现的地方都被替换，就像在 C++ 中一样。但是事实并非如此，当你在编写这个类的代码时，必须提醒自己：“不，这只是一个 **Object**“。
6684: 1486:
6685: 1487:另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管你可能希望这样：
6686: 1488:
6687: 1489:```java
6688: 1490:// generics/ErasureAndInheritance.java
6689: 1491:
6690: 1492:class GenericBase<T> {
6691: 1493:    private T element;
6692: 1494:    
6693: 1495:    public void set(T arg) {
6694: 1496:        element = arg;
6695: 1497:    }
6696: 1498:    
6697: 1499:    public T get() {
6698: 1500:        return element;
6699: 1501:    }
6700: 1502:}
6701: 1503:
6702: 1504:class Derived1<T> extends GenericBase<T> {}
6703: 1505:
6704: 1506:class Derived2 extends GenericBase {} // No warning
6705: 1507:
6706: 1508:// class Derived3 extends GenericBase<?> {}
6707: 1509:// Strange error:
6708: 1510:// unexpected type
6709: 1511:// required: class or interface without bounds
6710: 1512:public class ErasureAndInteritance {
6711: 1513:    @SuppressWarnings("unchecked")
6712: 1514:    public static void main(String[] args) {
6713: 1515:        Derived2 d2 = new Derived2();
6714: 1516:        Object obj = d2.get();
6715: 1517:        d2.set(obj); // Warning here!
6716: 1518:    }
6717: 1519:}
6718: 1520:```
6719: 1521:
6720: 1522:**Derived2** 继承自 **GenericBase**，但是没有任何类型参数，编译器没有发出任何警告。直到调用 `set()` 方法时才出现警告。
6721: 1523:
6722: 1524:为了关闭警告，Java 提供了一个注解，我们可以在列表中看到它：
6723: 1525:
6724: 1526:```java
6725: 1527:@SuppressWarnings("unchecked")
6726: 1528:```
6727: 1529:
6728: 1530:这个注解放置在产生警告的方法上，而不是整个类上。当你要关闭警告时，最好尽可能地“聚焦”，这样就不会因为过于宽泛地关闭警告，而导致意外地遮蔽掉真正的问题。
6729: 1531:
6730: 1532:可以推断，**Derived3** 产生的错误意味着编译器期望得到一个原生基类。
6731: 1533:
6732: 1534:当你希望将类型参数不仅仅当作 Object 处理时，就需要付出额外努力来管理边界，并且与在 C++、Ada 和 Eiffel 这样的语言中获得参数化类型相比，你需要付出多得多的努力来获得少得多的回报。这并不是说，对于大多数的编程问题而言，这些语言通常都会比 Java 更得心应手，只是说它们的参数化类型机制相比 Java 更灵活、更强大。
6733: 1535:
6734: 1536:### 边界处的动作
6735: 1537:
6736: 1538:因为擦除，我发现了泛型最令人困惑的方面是可以表示没有任何意义的事物。例如：
6737: 1539:
6738: 1540:```java
6739: 1541:// generics/ArrayMaker.java
6740: 1542:
6741: 1543:import java.lang.reflect.*;
6742: 1544:import java.util.*;
6743: 1545:
6744: 1546:public class ArrayMaker<T> {
6745: 1547:    private Class<T> kind;
6746: 1548:
6747: 1549:    public ArrayMaker(Class<T> kind) {
6748: 1550:        this.kind = kind;
6749: 1551:    }
6750: 1552:
6751: 1553:    @SuppressWarnings("unchecked")
6752: 1554:    T[] create(int size) {
6753: 1555:        return (T[]) Array.newInstance(kind, size);
6754: 1556:    }
6755: 1557:
6756: 1558:    public static void main(String[] args) {
6757: 1559:        ArrayMaker<String> stringMaker = new ArrayMaker<>(String.class);
6758: 1560:        String[] stringArray = stringMaker.create(9);
6759: 1561:        System.out.println(Arrays.toString(stringArray));
6760: 1562:    }
6761: 1563:}
6762: 1564:/* Output
6763: 1565:[null,null,null,null,null,null,null,null,null]
6764: 1566:*/
6765: 1567:```
6766: 1568:
6767: 1569:即使 **kind** 被存储为 `Class<T>`，擦除也意味着它实际被存储为没有任何参数的 **Class**。因此，当你在使用它时，例如创建数组，`Array.newInstance()` 实际上并未拥有 **kind** 所蕴含的类型信息。所以它不会产生具体的结果，因而必须转型，这会产生一条令你无法满意的警告。
6768: 1570:
6769: 1571:注意，对于在泛型中创建数组，使用 `Array.newInstance()` 是推荐的方式。
6770: 1572:
6771: 1573:如果我们创建一个集合而不是数组，情况就不同了：
6772: 1574:
6773: 1575:```java
6774: 1576:// generics/ListMaker.java
6775: 1577:
6776: 1578:import java.util.*;
6777: 1579:
6778: 1580:public class ListMaker<T> {
6779: 1581:    List<T> create() {
6780: 1582:        return new ArrayList<>();
6781: 1583:    }
6782: 1584:    
6783: 1585:    public static void main(String[] args) {
6784: 1586:        ListMaker<String> stringMaker = new ListMaker<>();
6785: 1587:        List<String> stringList = stringMaker.create();
6786: 1588:    }
6787: 1589:}
6788: 1590:```
6789: 1591:
6790: 1592:编译器不会给出任何警告，尽管我们知道（从擦除中）在 `create()` 内部的 `new ArrayList<>()` 中的 `<T>` 被移除了——在运行时，类内部没有任何 `<T>`，因此这看起来毫无意义。但是如果你遵从这种思路，并将这个表达式改为 `new ArrayList()`，编译器就会发出警告。
6791: 1593:
6792: 1594:本例中这么做真的毫无意义吗？如果在创建 **List** 的同时向其中放入一些对象呢，像这样：
6793: 1595:
6794: 1596:```java
6795: 1597:// generics/FilledList.java
6796: 1598:
6797: 1599:import java.util.*;
6798: 1600:import java.util.function.*;
6799: 1601:import onjava.*;
6800: 1602:
6801: 1603:public class FilledList<T> extends ArrayList<T> {
6802: 1604:    FilledList(Supplier<T> gen, int size) {
6803: 1605:        Suppliers.fill(this, gen, size);
6804: 1606:    }
6805: 1607:    
6806: 1608:    public FilledList(T t, int size) {
6807: 1609:        for (int i = 0; i < size; i++) {
6808: 1610:            this.add(t);
6809: 1611:        }
6810: 1612:    }
6811: 1613:    
6812: 1614:    public static void main(String[] args) {
6813: 1615:        List<String> list = new FilledList<>("Hello", 4);
6814: 1616:        System.out.println(list);
6815: 1617:        // Supplier version:
6816: 1618:        List<Integer> ilist = new FilledList<>(() -> 47, 4);
6817: 1619:        System.out.println(ilist);
6818: 1620:    }
6819: 1621:}
6820: 1622:/* Output:
6821: 1623:[Hello,Hello,Hello,Hello]
6822: 1624:[47,47,47,47]
6823: 1625:*/
6824: 1626:```
6825: 1627:
6826: 1628:即使编译器无法得知 `add()` 中的 **T** 的任何信息，但它仍可以在编译期确保你放入 **FilledList** 中的对象是 **T** 类型。因此，即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。
6827: 1629:
6828: 1630:因为擦除移除了方法体中的类型信息，所以在运行时的问题就是*边界*：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。
6829: 1631:
6830: 1632:考虑如下这段非泛型示例：
6831: 1633:
6832: 1634:```java
6833: 1635:// generics/SimpleHolder.java
6834: 1636:
6835: 1637:public class SimpleHolder {
6836: 1638:    private Object obj;
6837: 1639:    
6838: 1640:    public void set(Object obj) {
6839: 1641:        this.obj = obj;
6840: 1642:    }
6841: 1643:    
6842: 1644:    public Object get() {
6843: 1645:        return obj;
6844: 1646:    }
6845: 1647:    
6846: 1648:    public static void main(String[] args) {
6847: 1649:        SimpleHolder holder = new SimpleHolder();
6848: 1650:        holder.set("Item");
6849: 1651:        String s = (String) holder.get();
6850: 1652:    }
6851: 1653:}
6852: 1654:```
6853: 1655:
6854: 1656:如果用 **javap -c SimpleHolder** 反编译这个类，会得到如下内容（经过编辑）：
6855: 1657:
6856: 1658:```java
6857: 1659:public void set(java.lang.Object);
6858: 1660:   0: aload_0
6859: 1661:   1: aload_1
6860: 1662:   2: putfield #2; // Field obj:Object;
6861: 1663:   5: return
6862: 1664:    
6863: 1665:public java.lang.Object get();
6864: 1666:   0: aload_0
6865: 1667:   1: getfield #2; // Field obj:Object;
6866: 1668:   4: areturn
6867: 1669:    
6868: 1670:public static void main(java.lang.String[]);
6869: 1671:   0: new #3; // class SimpleHolder
6870: 1672:   3: dup
6871: 1673:   4: invokespecial #4; // Method "<init>":()V
6872: 1674:   7: astore_1
6873: 1675:   8: aload_1
6874: 1676:   9: ldc #5; // String Item
6875: 1677:   11: invokevirtual #6; // Method set:(Object;)V
6876: 1678:   14: aload_1
6877: 1679:   15: invokevirtual #7; // Method get:()Object;
6878: 1680:   18: checkcast #8; // class java/lang/String
6879: 1681:   21: astore_2
6880: 1682:   22: return
6881: 1683:```
6882: 1684:
6883: 1685:`set()` 和 `get()` 方法存储和产生值，转型在调用 `get()` 时接受检查。
6884: 1686:
6885: 1687:现在将泛型融入上例代码中：
6886: 1688:
6887: 1689:```java
6888: 1690:// generics/GenericHolder2.java
6889: 1691:
6890: 1692:public class GenericHolder2<T> {
6891: 1693:    private T obj;
6892: 1694:
6893: 1695:    public void set(T obj) {
6894: 1696:        this.obj = obj;
6895: 1697:    }
6896: 1698:
6897: 1699:    public T get() {
6898: 1700:        return obj;
6899: 1701:    }
6900: 1702:
6901: 1703:    public static void main(String[] args) {
6902: 1704:        GenericHolder2<String> holder =  new GenericHolder2<>();
6903: 1705:        holder.set("Item");
6904: 1706:        String s = holder.get();
6905: 1707:    }
6906: 1708:}
6907: 1709:```
6908: 1710:
6909: 1711:从 `get()` 返回后的转型消失了，但是我们还知道传递给 `set()` 的值在编译期会被检查。下面是相关的字节码：
6910: 1712:
6911: 1713:```java
6912: 1714:public void set(java.lang.Object);
6913: 1715:   0: aload_0
6914: 1716:   1: aload_1
6915: 1717:   2: putfield #2; // Field obj:Object;
6916: 1718:   5: return
6917: 1719:       
6918: 1720:public java.lang.Object get();
6919: 1721:   0: aload_0
6920: 1722:   1: getfield #2; // Field obj:Object;
6921: 1723:   4: areturn
6922: 1724:       
6923: 1725:public static void main(java.lang.String[]);
6924: 1726:   0: new #3; // class GenericHolder2
6925: 1727:   3: dup
6926: 1728:   4: invokespecial #4; // Method "<init>":()V
6927: 1729:   7: astore_1
6928: 1730:   8: aload_1
6929: 1731:   9: ldc #5; // String Item
6930: 1732:   11: invokevirtual #6; // Method set:(Object;)V
6931: 1733:   14: aload_1
6932: 1734:   15: invokevirtual #7; // Method get:()Object;
6933: 1735:   18: checkcast #8; // class java/lang/String
6934: 1736:   21: astore_2
6935: 1737:   22: return
6936: 1738:```
6937: 1739:
6938: 1740:所产生的字节码是相同的。对进入 `set()` 的类型进行检查是不需要的，因为这将由编译器执行。而对 `get()` 返回的值进行转型仍然是需要的，只不过不需要你来操作，它由编译器自动插入，这样你就不用编写（阅读）杂乱的代码。
6939: 1741:
6940: 1742:`get()` 和 `set()` 产生了相同的字节码，这就告诉我们泛型的所有动作都发生在边界处——对入参的编译器检查和对返回值的转型。这有助于澄清对擦除的困惑，记住：“边界就是动作发生的地方”。
6941: 1743:
6942: 1744:<!-- Compensating for Erasure -->
6943: 1745:
6944: 1746:## 补偿擦除
6945: 1747:
6946: 1748:因为擦除，我们将失去执行泛型代码中某些操作的能力。无法在运行时知道确切类型：
6947: 1749:
6948: 1750:```java
6949: 1751:// generics/Erased.java
6950: 1752:// {WillNotCompile}
6951: 1753:
6952: 1754:public class Erased<T> {
6953: 1755:    private final int SIZE = 100;
6954: 1756:
6955: 1757:    public void f(Object arg) {
6956: 1758:        // error: illegal generic type for instanceof
6957: 1759:        if (arg instanceof T) {
6958: 1760:        }
6959: 1761:        // error: unexpected type
6960: 1762:        T var = new T();
6961: 1763:        // error: generic array creation
6962: 1764:        T[] array = new T[SIZE];
6963: 1765:        // warning: [unchecked] unchecked cast
6964: 1766:        T[] array = (T[]) new Object[SIZE];
6965: 1767:
6966: 1768:    }
6967: 1769:}
6968: 1770:```
6969: 1771:
6970: 1772:有时，我们可以对这些问题进行编程，但是有时必须通过引入类型标签来补偿擦除。这意味着为所需的类型显式传递一个 **Class** 对象，以在类型表达式中使用它。
6971: 1773:
6972: 1774:例如，由于擦除了类型信息，因此在上一个程序中尝试使用 **instanceof** 将会失败。类型标签可以使用动态 `isInstance()` ：
6973: 1775:
6974: 1776:```java
6975: 1777:// generics/ClassTypeCapture.java
6976: 1778:
6977: 1779:class Building {
6978: 1780:}
6979: 1781:
6980: 1782:class House extends Building {
6981: 1783:}
6982: 1784:
6983: 1785:public class ClassTypeCapture<T> {
6984: 1786:    Class<T> kind;
6985: 1787:
6986: 1788:    public ClassTypeCapture(Class<T> kind) {
6987: 1789:        this.kind = kind;
6988: 1790:    }
6989: 1791:
6990: 1792:    public boolean f(Object arg) {
6991: 1793:        return kind.isInstance(arg);
6992: 1794:    }
6993: 1795:
6994: 1796:    public static void main(String[] args) {
6995: 1797:        ClassTypeCapture<Building> ctt1 =
6996: 1798:                new ClassTypeCapture<>(Building.class);
6997: 1799:        System.out.println(ctt1.f(new Building()));
6998: 1800:        System.out.println(ctt1.f(new House()));
6999: 1801:        ClassTypeCapture<House> ctt2 =
7000: 1802:                new ClassTypeCapture<>(House.class);
7001: 1803:        System.out.println(ctt2.f(new Building()));
7002: 1804:        System.out.println(ctt2.f(new House()));
7003: 1805:    }
7004: 1806:}
7005: 1807:/* Output:
7006: 1808:true
7007: 1809:true
7008: 1810:false
7009: 1811:true
7010: 1812:*/
7011: 1813:```
7012: 1814:
7013: 1815:编译器来保证类型标签与泛型参数相匹配。
7014: 1816:
7015: 1817:<!-- Creating Instances of Types -->
7016: 1818:
7017: 1819:### 创建类型的实例
7018: 1820:
7019: 1821:试图在 **Erased.java** 中 `new T()` 是行不通的，部分原因是由于擦除，部分原因是编译器无法验证 **T** 是否具有默认（无参）构造函数。但是在 C++ 中，此操作自然，直接且安全（在编译时检查）：
7020: 1822:
7021: 1823:```C++
7022: 1824:// generics/InstantiateGenericType.cpp
7023: 1825:// C++, not Java!
7024: 1826:
7025: 1827:template<class T> class Foo {
7026: 1828:  T x; // Create a field of type T
7027: 1829:  T* y; // Pointer to T
7028: 1830:public:
7029: 1831:  // Initialize the pointer:
7030: 1832:  Foo() { y = new T(); }
7031: 1833:};
7032: 1834:
7033: 1835:class Bar {};
7034: 1836:
7035: 1837:int main() {
7036: 1838:  Foo<Bar> fb;
7037: 1839:  Foo<int> fi; // ... and it works with primitives
7038: 1840:}
7039: 1841:```
7040: 1842:
7041: 1843:Java 中的解决方案是传入一个工厂对象，并使用该对象创建新实例。方便的工厂对象只是 **Class** 对象，因此，如果使用类型标记，则可以使用 `newInstance()` 创建该类型的新对象：
7042: 1844:
7043: 1845:```java
7044: 1846:// generics/InstantiateGenericType.java
7045: 1847:
7046: 1848:import java.util.function.Supplier;
7047: 1849:
7048: 1850:class ClassAsFactory<T> implements Supplier<T> {
7049: 1851:    Class<T> kind;
7050: 1852:
7051: 1853:    ClassAsFactory(Class<T> kind) {
7052: 1854:        this.kind = kind;
7053: 1855:    }
7054: 1856:
7055: 1857:    @Override
7056: 1858:    public T get() {
7057: 1859:        try {
7058: 1860:            return kind.newInstance();
7059: 1861:        } catch (InstantiationException |
7060: 1862:                IllegalAccessException e) {
7061: 1863:            throw new RuntimeException(e);
7062: 1864:        }
7063: 1865:    }
7064: 1866:}
7065: 1867:
7066: 1868:class Employee {
7067: 1869:    @Override
7068: 1870:    public String toString() {
7069: 1871:        return "Employee";
7070: 1872:    }
7071: 1873:}
7072: 1874:
7073: 1875:public class InstantiateGenericType {
7074: 1876:    public static void main(String[] args) {
7075: 1877:        ClassAsFactory<Employee> fe =
7076: 1878:                new ClassAsFactory<>(Employee.class);
7077: 1879:        System.out.println(fe.get());
7078: 1880:        ClassAsFactory<Integer> fi =
7079: 1881:                new ClassAsFactory<>(Integer.class);
7080: 1882:        try {
7081: 1883:            System.out.println(fi.get());
7082: 1884:        } catch (Exception e) {
7083: 1885:            System.out.println(e.getMessage());
7084: 1886:        }
7085: 1887:    }
7086: 1888:}
7087: 1889:/* Output:
7088: 1890:Employee
7089: 1891:java.lang.InstantiationException: java.lang.Integer
7090: 1892:*/
7091: 1893:```
7092: 1894:
7093: 1895:这样可以编译，但对于 `ClassAsFactory<Integer>` 会失败，这是因为 **Integer** 没有无参构造函数。由于错误不是在编译时捕获的，因此语言创建者不赞成这种方法。他们建议使用显式工厂（**Supplier**）并约束类型，以便只有实现该工厂的类可以这样创建对象。这是创建工厂的两种不同方法：
7094: 1896:
7095: 1897:```java
7096: 1898:// generics/FactoryConstraint.java
7097: 1899:
7098: 1900:import onjava.Suppliers;
7099: 1901:
7100: 1902:import java.util.ArrayList;
7101: 1903:import java.util.List;
7102: 1904:import java.util.function.Supplier;
7103: 1905:
7104: 1906:class IntegerFactory implements Supplier<Integer> {
7105: 1907:    private int i = 0;
7106: 1908:
7107: 1909:    @Override
7108: 1910:    public Integer get() {
7109: 1911:        return ++i;
7110: 1912:    }
7111: 1913:}
7112: 1914:
7113: 1915:class Widget {
7114: 1916:    private int id;
7115: 1917:
7116: 1918:    Widget(int n) {
7117: 1919:        id = n;
7118: 1920:    }
7119: 1921:
7120: 1922:    @Override
7121: 1923:    public String toString() {
7122: 1924:        return "Widget " + id;
7123: 1925:    }
7124: 1926:
7125: 1927:    public static
7126: 1928:    class Factory implements Supplier<Widget> {
7127: 1929:        private int i = 0;
7128: 1930:
7129: 1931:        @Override
7130: 1932:        public Widget get() {
7131: 1933:            return new Widget(++i);
7132: 1934:        }
7133: 1935:    }
7134: 1936:}
7135: 1937:
7136: 1938:class Fudge {
7137: 1939:    private static int count = 1;
7138: 1940:    private int n = count++;
7139: 1941:
7140: 1942:    @Override
7141: 1943:    public String toString() {
7142: 1944:        return "Fudge " + n;
7143: 1945:    }
7144: 1946:}
7145: 1947:
7146: 1948:class Foo2<T> {
7147: 1949:    private List<T> x = new ArrayList<>();
7148: 1950:
7149: 1951:    Foo2(Supplier<T> factory) {
7150: 1952:        Suppliers.fill(x, factory, 5);
7151: 1953:    }
7152: 1954:
7153: 1955:    @Override
7154: 1956:    public String toString() {
7155: 1957:        return x.toString();
7156: 1958:    }
7157: 1959:}
7158: 1960:
7159: 1961:public class FactoryConstraint {
7160: 1962:    public static void main(String[] args) {
7161: 1963:        System.out.println(
7162: 1964:                new Foo2<>(new IntegerFactory()));
7163: 1965:        System.out.println(
7164: 1966:                new Foo2<>(new Widget.Factory()));
7165: 1967:        System.out.println(
7166: 1968:                new Foo2<>(Fudge::new));
7167: 1969:    }
7168: 1970:}
7169: 1971:/* Output:
7170: 1972:[1, 2, 3, 4, 5]
7171: 1973:[Widget 1, Widget 2, Widget 3, Widget 4, Widget 5]
7172: 1974:[Fudge 1, Fudge 2, Fudge 3, Fudge 4, Fudge 5]
7173: 1975:*/
7174: 1976:```
7175: 1977:
7176: 1978:**IntegerFactory** 本身就是通过实现 `Supplier<Integer>` 的工厂。 **Widget** 包含一个内部类，它是一个工厂。还要注意，**Fudge** 并没有做任何类似于工厂的操作，并且传递 `Fudge::new` 仍然会产生工厂行为，因为编译器将对函数方法 `::new` 的调用转换为对 `get()` 的调用。
7177: 1979:
7178: 1980:另一种方法是模板方法设计模式。在以下示例中，`create()` 是模板方法，在子类中被重写以生成该类型的对象：
7179: 1981:
7180: 1982:```java
7181: 1983:// generics/CreatorGeneric.java
7182: 1984:
7183: 1985:abstract class GenericWithCreate<T> {
7184: 1986:    final T element;
7185: 1987:
7186: 1988:    GenericWithCreate() {
7187: 1989:        element = create();
7188: 1990:    }
7189: 1991:
7190: 1992:    abstract T create();
7191: 1993:}
7192: 1994:
7193: 1995:class X {
7194: 1996:}
7195: 1997:
7196: 1998:class XCreator extends GenericWithCreate<X> {
7197: 1999:    @Override
7198: 2000:    X create() {
7199: 2001:        return new X();
7200: 2002:    }
7201: 2003:
7202: 2004:    void f() {
7203: 2005:        System.out.println(
7204: 2006:                element.getClass().getSimpleName());
7205: 2007:    }
7206: 2008:}
7207: 2009:
7208: 2010:public class CreatorGeneric {
7209: 2011:    public static void main(String[] args) {
7210: 2012:        XCreator xc = new XCreator();
7211: 2013:        xc.f();
7212: 2014:    }
7213: 2015:}
7214: 2016:/* Output:
7215: 2017:X
7216: 2018:*/
7217: 2019:```
7218: 2020:
7219: 2021:**GenericWithCreate** 包含 `element` 字段，并通过无参构造函数强制其初始化，该构造函数又调用抽象的 `create()` 方法。这种创建方式可以在子类中定义，同时建立 **T** 的类型。
7220: 2022:
7221: 2023:<!-- Arrays of Generics -->
7222: 2024:
7223: 2025:### 泛型数组
7224: 2026:
7225: 2027:正如在 **Erased.java** 中所看到的，我们无法创建泛型数组。通用解决方案是在试图创建泛型数组的时候使用 **ArrayList** ：
7226: 2028:
7227: 2029:```java
7228: 2030:// generics/ListOfGenerics.java
7229: 2031:
7230: 2032:import java.util.ArrayList;
7231: 2033:import java.util.List;
7232: 2034:
7233: 2035:public class ListOfGenerics<T> {
7234: 2036:    private List<T> array = new ArrayList<>();
7235: 2037:
7236: 2038:    public void add(T item) {
7237: 2039:        array.add(item);
7238: 2040:    }
7239: 2041:
7240: 2042:    public T get(int index) {
7241: 2043:        return array.get(index);
7242: 2044:    }
7243: 2045:}
7244: 2046:```
7245: 2047:
7246: 2048:这样做可以获得数组的行为，并且还具有泛型提供的编译时类型安全性。
7247: 2049:
7248: 2050:有时，仍然会创建泛型类型的数组（例如， **ArrayList** 在内部使用数组）。可以通过使编译器满意的方式定义对数组的通用引用：
7249: 2051:
7250: 2052:```java
7251: 2053:// generics/ArrayOfGenericReference.java
7252: 2054:
7253: 2055:class Generic<T> {
7254: 2056:}
7255: 2057:
7256: 2058:public class ArrayOfGenericReference {
7257: 2059:    static Generic<Integer>[] gia;
7258: 2060:}
7259: 2061:```
7260: 2062:
7261: 2063:编译器接受此操作而不产生警告。但是我们永远无法创建具有该确切类型（包括类型参数）的数组，因此有点令人困惑。由于所有数组，无论它们持有什么类型，都具有相同的结构（每个数组插槽的大小和数组布局），因此似乎可以创建一个 **Object** 数组并将其转换为所需的数组类型。实际上，这确实可以编译，但是会产生 **ClassCastException** ：
7262: 2064:
7263: 2065:```java
7264: 2066:// generics/ArrayOfGeneric.java
7265: 2067:
7266: 2068:public class ArrayOfGeneric {
7267: 2069:    static final int SIZE = 100;
7268: 2070:    static Generic<Integer>[] gia;
7269: 2071:
7270: 2072:    @SuppressWarnings("unchecked")
7271: 2073:    public static void main(String[] args) {
7272: 2074:        try {
7273: 2075:            gia = (Generic<Integer>[]) new Object[SIZE];
7274: 2076:        } catch (ClassCastException e) {
7275: 2077:            System.out.println(e.getMessage());
7276: 2078:        }
7277: 2079:        // Runtime type is the raw (erased) type:
7278: 2080:        gia = (Generic<Integer>[]) new Generic[SIZE];
7279: 2081:        System.out.println(gia.getClass().getSimpleName());
7280: 2082:        gia[0] = new Generic<>();
7281: 2083:        //- gia[1] = new Object(); // Compile-time error
7282: 2084:        // Discovers type mismatch at compile time:
7283: 2085:        //- gia[2] = new Generic<Double>();
7284: 2086:    }
7285: 2087:}
7286: 2088:/* Output:
7287: 2089:[Ljava.lang.Object; cannot be cast to [LGeneric;
7288: 2090:Generic[]
7289: 2091:*/
7290: 2092:```
7291: 2093:
7292: 2094:问题在于数组会跟踪其实际类型，而该类型是在创建数组时建立的。因此，即使 `gia` 被强制转换为 `Generic<Integer>[]` ，该信息也仅在编译时存在（并且没有 **@SuppressWarnings** 注解，将会收到有关该强制转换的警告）。在运行时，它仍然是一个 **Object** 数组，这会引起问题。成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换。
7293: 2095:
7294: 2096:让我们看一个更复杂的示例。考虑一个包装数组的简单泛型包装器：
7295: 2097:
7296: 2098:```java
7297: 2099:// generics/GenericArray.java
7298: 2100:
7299: 2101:public class GenericArray<T> {
7300: 2102:    private T[] array;
7301: 2103:
7302: 2104:    @SuppressWarnings("unchecked")
7303: 2105:    public GenericArray(int sz) {
7304: 2106:        array = (T[]) new Object[sz];
7305: 2107:    }
7306: 2108:
7307: 2109:    public void put(int index, T item) {
7308: 2110:        array[index] = item;
7309: 2111:    }
7310: 2112:
7311: 2113:    public T get(int index) {
7312: 2114:        return array[index];
7313: 2115:    }
7314: 2116:
7315: 2117:    // Method that exposes the underlying representation:
7316: 2118:    public T[] rep() {
7317: 2119:        return array;
7318: 2120:    }
7319: 2121:
7320: 2122:    public static void main(String[] args) {
7321: 2123:        GenericArray<Integer> gai = new GenericArray<>(10);
7322: 2124:        try {
7323: 2125:            Integer[] ia = gai.rep();
7324: 2126:        } catch (ClassCastException e) {
7325: 2127:            System.out.println(e.getMessage());
7326: 2128:        }
7327: 2129:        // This is OK:
7328: 2130:        Object[] oa = gai.rep();
7329: 2131:    }
7330: 2132:}
7331: 2133:/* Output:
7332: 2134:[Ljava.lang.Object; cannot be cast to
7333: 2135:[Ljava.lang.Integer;
7334: 2136:*/
7335: 2137:```
7336: 2138:
7337: 2139:和以前一样，我们不能说 `T[] array = new T[sz]` ，所以我们创建了一个 **Object** 数组并将其强制转换。
7338: 2140:
7339: 2141:`rep()` 方法返回一个 `T[]` ，在主方法中它应该是 `gai` 的 `Integer[]`，但是如果调用它并尝试将结果转换为 `Integer[]` 引用，则会得到 **ClassCastException** ，这再次是因为实际的运行时类型为 `Object[]` 。
7340: 2142:
7341: 2143:如果再注释掉 **@SuppressWarnings** 注解后编译 **GenericArray.java** ，则编译器会产生警告：
7342: 2144:
7343: 2145:```java
7344: 2146:GenericArray.java uses unchecked or unsafe operations.
7345: 2147:Recompile with -Xlint:unchecked for details.
7346: 2148:```
7347: 2149:
7348: 2150:在这里，我们收到了一个警告，我们认为这是有关强制转换的。
7349: 2151:
7350: 2152:但是要真正确定，请使用 `-Xlint：unchecked` 进行编译：
7351: 2153:
7352: 2154:```java
7353: 2155:GenericArray.java:7: warning: [unchecked] unchecked cast    array = (T[])new Object[sz];                 ^  required: T[]  found:    Object[]  where T is a type-variable:    T extends Object declared in class GenericArray 1 warning
7354: 2156:```
7355: 2157:
7356: 2158:确实是在抱怨那个强制转换。由于警告会变成噪音，因此，一旦我们确认预期会出现特定警告，我们可以做的最好的办法就是使用 **@SuppressWarnings** 将其关闭。这样，当警告确实出现时，我们将进行实际调查。
7357: 2159:
7358: 2160:由于擦除，数组的运行时类型只能是 `Object[]` 。 如果我们立即将其转换为 `T[]` ，则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。因此，最好在集合中使用 `Object[]` ，并在使用数组元素时向 **T** 添加强制类型转换。让我们来看看在 **GenericArray.java** 示例中会是怎么样的：
7359: 2161:
7360: 2162:```java
7361: 2163:// generics/GenericArray2.java
7362: 2164:
7363: 2165:public class GenericArray2<T> {
7364: 2166:    private Object[] array;
7365: 2167:
7366: 2168:    public GenericArray2(int sz) {
7367: 2169:        array = new Object[sz];
7368: 2170:    }
7369: 2171:
7370: 2172:    public void put(int index, T item) {
7371: 2173:        array[index] = item;
7372: 2174:    }
7373: 2175:
7374: 2176:    @SuppressWarnings("unchecked")
7375: 2177:    public T get(int index) {
7376: 2178:        return (T) array[index];
7377: 2179:    }
7378: 2180:
7379: 2181:    @SuppressWarnings("unchecked")
7380: 2182:    public T[] rep() {
7381: 2183:        return (T[]) array; // Unchecked cast
7382: 2184:    }
7383: 2185:
7384: 2186:    public static void main(String[] args) {
7385: 2187:        GenericArray2<Integer> gai =
7386: 2188:                new GenericArray2<>(10);
7387: 2189:        for (int i = 0; i < 10; i++)
7388: 2190:            gai.put(i, i);
7389: 2191:        for (int i = 0; i < 10; i++)
7390: 2192:            System.out.print(gai.get(i) + " ");
7391: 2193:        System.out.println();
7392: 2194:        try {
7393: 2195:            Integer[] ia = gai.rep();
7394: 2196:        } catch (Exception e) {
7395: 2197:            System.out.println(e);
7396: 2198:        }
7397: 2199:    }
7398: 2200:}
7399: 2201:/* Output:
7400: 2202:0 1 2 3 4 5 6 7 8 9
7401: 2203:java.lang.ClassCastException: [Ljava.lang.Object;
7402: 2204:cannot be cast to [Ljava.lang.Integer;
7403: 2205:*/
7404: 2206:```
7405: 2207:
7406: 2208:最初，看起来并没有太大不同，只是转换的位置移动了。没有 **@SuppressWarnings** 注解，仍然会收到“unchecked”警告。但是，内部表示现在是 `Object[]` 而不是 `T[]` 。 调用 `get()` 时，它将对象强制转换为 **T** ，实际上这是正确的类型，因此很安全。但是，如果调用 `rep()` ，它将再次尝试将 `Object[]` 强制转换为 `T[]` ，但仍然不正确，并在编译时生成警告，并在运行时生成异常。因此，无法破坏基础数组的类型，该基础数组只能是 `Object[]` 。在内部将数组视为 `Object[]` 而不是 `T[]` 的优点是，我们不太可能会忘记数组的运行时类型并意外地引入了bug，尽管大多数（也许是全部）此类错误会在运行时被迅速检测到。
7407: 2209:
7408: 2210:对于新代码，请传入类型标记。在这种情况下，**GenericArray** 如下所示：
7409: 2211:
7410: 2212:```java
7411: 2213:// generics/GenericArrayWithTypeToken.java
7412: 2214:
7413: 2215:import java.lang.reflect.Array;
7414: 2216:
7415: 2217:public class GenericArrayWithTypeToken<T> {
7416: 2218:    private T[] array;
7417: 2219:
7418: 2220:    @SuppressWarnings("unchecked")
7419: 2221:    public GenericArrayWithTypeToken(Class<T> type, int sz) {
7420: 2222:        array = (T[]) Array.newInstance(type, sz);
7421: 2223:    }
7422: 2224:
7423: 2225:    public void put(int index, T item) {
7424: 2226:        array[index] = item;
7425: 2227:    }
7426: 2228:
7427: 2229:    public T get(int index) {
7428: 2230:        return array[index];
7429: 2231:    }
7430: 2232:
7431: 2233:    // Expose the underlying representation:
7432: 2234:    public T[] rep() {
7433: 2235:        return array;
7434: 2236:    }
7435: 2237:
7436: 2238:    public static void main(String[] args) {
7437: 2239:        GenericArrayWithTypeToken<Integer> gai =
7438: 2240:                new GenericArrayWithTypeToken<>(
7439: 2241:                        Integer.class, 10);
7440: 2242:        // This now works:
7441: 2243:        Integer[] ia = gai.rep();
7442: 2244:    }
7443: 2245:}
7444: 2246:```
7445: 2247:
7446: 2248:类型标记 **Class\<T\>** 被传递到构造函数中以从擦除中恢复，因此尽管必须使用 **@SuppressWarnings** 关闭来自强制类型转换的警告，但我们仍可以创建所需的实际数组类型。一旦获得了实际的类型，就可以返回它并产生所需的结果，如在主方法中看到的那样。数组的运行时类型是确切的类型 `T[]` 。
7447: 2249:
7448: 2250:不幸的是，如果查看 Java 标准库中的源代码，你会发现到处都有从 **Object** 数组到参数化类型的转换。例如，这是**ArrayList** 中，复制一个 **Collection** 的构造函数，这里为了简化，去除了源码中对此不重要的代码：
7449: 2251:
7450: 2252:```java
7451: 2253:public ArrayList(Collection c) {
7452: 2254:  size = c.size();
7453: 2255:  elementData = (E[])new Object[size];
7454: 2256:  c.toArray(elementData);
7455: 2257:}
7456: 2258:```
7457: 2259:
7458: 2260:如果你浏览 **ArrayList.java** 的代码，将会发现很多此类强制转换。当我们编译它时会发生什么？
7459: 2261:
7460: 2262:```java
7461: 2263:Note: ArrayList.java uses unchecked or unsafe operations
7462: 2264:Note: Recompile with -Xlint:unchecked for details.
7463: 2265:```
7464: 2266:
7465: 2267:果然，标准库会产生很多警告。如果你使用过 C 语言，尤其是使用 ANSI C 之前的语言，你会记住警告的特殊效果：发现警告后，可以忽略它们。因此，除非程序员必须对其进行处理，否则最好不要从编译器发出任何类型的消息。
7466: 2268:
7467: 2269:Neal Gafter（Java 5 的主要开发人员之一）在他的博客中[^2]指出，他在重写 Java 库时是很随意、马虎的，我们不应该像他那样做。Neal 还指出，他在不破坏现有接口的情况下无法修复某些 Java 库代码。因此，即使在 Java 库源代码中出现了一些习惯用法，它们也不一定是正确的做法。当查看库代码时，我们不能认为这就是要在自己代码中必须遵循的示例。
7468: 2270:
7469: 2271:请注意，在 Java 文献中推荐使用类型标记技术，例如 Gilad Bracha 的论文《Generics in the Java Programming Language》[^3]，他指出：“例如，这种用法已广泛用于新的 API 中以处理注解。” 我发现此技术在人们对于舒适度的看法方面存在一些不一致之处；有些人强烈喜欢本章前面介绍的工厂方法。
7470: 2272:
7471: 2273:<!-- Bounds -->
7472: 2274:
7473: 2275:## 边界
7474: 2276:
7475: 2277:*边界*（bounds）在本章的前面进行了简要介绍。边界允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法。
7476: 2278:
7477: 2279:由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 **Object** 可用的方法。但是，如果将该参数限制为某类型的子集，则可以调用该子集中的方法。为了应用约束，Java 泛型使用了 `extends` 关键字。
7478: 2280:
7479: 2281:重要的是要理解，当用于限定泛型类型时，`extends` 的含义与通常的意义截然不同。此示例展示边界的基础应用：
7480: 2282:
7481: 2283:```java
7482: 2284:// generics/BasicBounds.java
7483: 2285:
7484: 2286:interface HasColor {
7485: 2287:    java.awt.Color getColor();
7486: 2288:}
7487: 2289:
7488: 2290:class WithColor<T extends HasColor> {
7489: 2291:    T item;
7490: 2292:
7491: 2293:    WithColor(T item) {
7492: 2294:        this.item = item;
7493: 2295:    }
7494: 2296:
7495: 2297:    T getItem() {
7496: 2298:        return item;
7497: 2299:    }
7498: 2300:
7499: 2301:    // The bound allows you to call a method:
7500: 2302:    java.awt.Color color() {
7501: 2303:        return item.getColor();
7502: 2304:    }
7503: 2305:}
7504: 2306:
7505: 2307:class Coord {
7506: 2308:    public int x, y, z;
7507: 2309:}
7508: 2310:
7509: 2311:// This fails. Class must be first, then interfaces:
7510: 2312:// class WithColorCoord<T extends HasColor & Coord> {
7511: 2313:
7512: 2314:// Multiple bounds:
7513: 2315:class WithColorCoord<T extends Coord & HasColor> {
7514: 2316:    T item;
7515: 2317:
7516: 2318:    WithColorCoord(T item) {
7517: 2319:        this.item = item;
7518: 2320:    }
7519: 2321:
7520: 2322:    T getItem() {
7521: 2323:        return item;
7522: 2324:    }
7523: 2325:
7524: 2326:    java.awt.Color color() {
7525: 2327:        return item.getColor();
7526: 2328:    }
7527: 2329:
7528: 2330:    int getX() {
7529: 2331:        return item.x;
7530: 2332:    }
7531: 2333:
7532: 2334:    int getY() {
7533: 2335:        return item.y;
7534: 2336:    }
7535: 2337:
7536: 2338:    int getZ() {
7537: 2339:        return item.z;
7538: 2340:    }
7539: 2341:}
7540: 2342:
7541: 2343:interface Weight {
7542: 2344:    int weight();
7543: 2345:}
7544: 2346:
7545: 2347:// As with inheritance, you can have only one
7546: 2348:// concrete class but multiple interfaces:
7547: 2349:class Solid<T extends Coord & HasColor & Weight> {
7548: 2350:    T item;
7549: 2351:
7550: 2352:    Solid(T item) {
7551: 2353:        this.item = item;
7552: 2354:    }
7553: 2355:
7554: 2356:    T getItem() {
7555: 2357:        return item;
7556: 2358:    }
7557: 2359:
7558: 2360:    java.awt.Color color() {
7559: 2361:        return item.getColor();
7560: 2362:    }
7561: 2363:
7562: 2364:    int getX() {
7563: 2365:        return item.x;
7564: 2366:    }
7565: 2367:
7566: 2368:    int getY() {
7567: 2369:        return item.y;
7568: 2370:    }
7569: 2371:
7570: 2372:    int getZ() {
7571: 2373:        return item.z;
7572: 2374:    }
7573: 2375:
7574: 2376:    int weight() {
7575: 2377:        return item.weight();
7576: 2378:    }
7577: 2379:}
7578: 2380:
7579: 2381:class Bounded
7580: 2382:        extends Coord implements HasColor, Weight {
7581: 2383:    @Override
7582: 2384:    public java.awt.Color getColor() {
7583: 2385:        return null;
7584: 2386:    }
7585: 2387:
7586: 2388:    @Override
7587: 2389:    public int weight() {
7588: 2390:        return 0;
7589: 2391:    }
7590: 2392:}
7591: 2393:
7592: 2394:public class BasicBounds {
7593: 2395:    public static void main(String[] args) {
7594: 2396:        Solid<Bounded> solid =
7595: 2397:                new Solid<>(new Bounded());
7596: 2398:        solid.color();
7597: 2399:        solid.getY();
7598: 2400:        solid.weight();
7599: 2401:    }
7600: 2402:}
7601: 2403:```
7602: 2404:
7603: 2405:你可能会观察到 **BasicBounds.java** 中似乎包含一些冗余，它们可以通过继承来消除。在这里，每个继承级别还添加了边界约束：
7604: 2406:
7605: 2407:```java
7606: 2408:// generics/InheritBounds.java
7607: 2409:
7608: 2410:class HoldItem<T> {
7609: 2411:    T item;
7610: 2412:
7611: 2413:    HoldItem(T item) {
7612: 2414:        this.item = item;
7613: 2415:    }
7614: 2416:
7615: 2417:    T getItem() {
7616: 2418:        return item;
7617: 2419:    }
7618: 2420:}
7619: 2421:
7620: 2422:class WithColor2<T extends HasColor>
7621: 2423:        extends HoldItem<T> {
7622: 2424:    WithColor2(T item) {
7623: 2425:        super(item);
7624: 2426:    }
7625: 2427:
7626: 2428:    java.awt.Color color() {
7627: 2429:        return item.getColor();
7628: 2430:    }
7629: 2431:}
7630: 2432:
7631: 2433:class WithColorCoord2<T extends Coord & HasColor>
7632: 2434:        extends WithColor2<T> {
7633: 2435:    WithColorCoord2(T item) {
7634: 2436:        super(item);
7635: 2437:    }
7636: 2438:
7637: 2439:    int getX() {
7638: 2440:        return item.x;
7639: 2441:    }
7640: 2442:
7641: 2443:    int getY() {
7642: 2444:        return item.y;
7643: 2445:    }
7644: 2446:
7645: 2447:    int getZ() {
7646: 2448:        return item.z;
7647: 2449:    }
7648: 2450:}
7649: 2451:
7650: 2452:class Solid2<T extends Coord & HasColor & Weight>
7651: 2453:        extends WithColorCoord2<T> {
7652: 2454:    Solid2(T item) {
7653: 2455:        super(item);
7654: 2456:    }
7655: 2457:
7656: 2458:    int weight() {
7657: 2459:        return item.weight();
7658: 2460:    }
7659: 2461:}
7660: 2462:
7661: 2463:public class InheritBounds {
7662: 2464:    public static void main(String[] args) {
7663: 2465:        Solid2<Bounded> solid2 =
7664: 2466:                new Solid2<>(new Bounded());
7665: 2467:        solid2.color();
7666: 2468:        solid2.getY();
7667: 2469:        solid2.weight();
7668: 2470:    }
7669: 2471:}
7670: 2472:```
7671: 2473:
7672: 2474:**HoldItem** 拥有一个对象，因此此行为将继承到 **WithColor2** 中，这也需要其参数符合 **HasColor**。 **WithColorCoord2** 和 **Solid2** 进一步扩展了层次结构，并在每个级别添加了边界。现在，这些方法已被继承，并且在每个类中不再重复。
7673: 2475:
7674: 2476:这是一个具有更多层次的示例：
7675: 2477:
7676: 2478:```java
7677: 2479:// generics/EpicBattle.java
7678: 2480:// Bounds in Java generics
7679: 2481:
7680: 2482:import java.util.List;
7681: 2483:
7682: 2484:interface SuperPower {
7683: 2485:}
7684: 2486:
7685: 2487:interface XRayVision extends SuperPower {
7686: 2488:    void seeThroughWalls();
7687: 2489:}
7688: 2490:
7689: 2491:interface SuperHearing extends SuperPower {
7690: 2492:    void hearSubtleNoises();
7691: 2493:}
7692: 2494:
7693: 2495:interface SuperSmell extends SuperPower {
7694: 2496:    void trackBySmell();
7695: 2497:}
7696: 2498:
7697: 2499:class SuperHero<POWER extends SuperPower> {
7698: 2500:    POWER power;
7699: 2501:
7700: 2502:    SuperHero(POWER power) {
7701: 2503:        this.power = power;
7702: 2504:    }
7703: 2505:
7704: 2506:    POWER getPower() {
7705: 2507:        return power;
7706: 2508:    }
7707: 2509:}
7708: 2510:
7709: 2511:class SuperSleuth<POWER extends XRayVision>
7710: 2512:        extends SuperHero<POWER> {
7711: 2513:    SuperSleuth(POWER power) {
7712: 2514:        super(power);
7713: 2515:    }
7714: 2516:
7715: 2517:    void see() {
7716: 2518:        power.seeThroughWalls();
7717: 2519:    }
7718: 2520:}
7719: 2521:
7720: 2522:class
7721: 2523:CanineHero<POWER extends SuperHearing & SuperSmell>
7722: 2524:        extends SuperHero<POWER> {
7723: 2525:    CanineHero(POWER power) {
7724: 2526:        super(power);
7725: 2527:    }
7726: 2528:
7727: 2529:    void hear() {
7728: 2530:        power.hearSubtleNoises();
7729: 2531:    }
7730: 2532:
7731: 2533:    void smell() {
7732: 2534:        power.trackBySmell();
7733: 2535:    }
7734: 2536:}
7735: 2537:
7736: 2538:class SuperHearSmell
7737: 2539:        implements SuperHearing, SuperSmell {
7738: 2540:    @Override
7739: 2541:    public void hearSubtleNoises() {
7740: 2542:    }
7741: 2543:
7742: 2544:    @Override
7743: 2545:    public void trackBySmell() {
7744: 2546:    }
7745: 2547:}
7746: 2548:
7747: 2549:class DogPerson extends CanineHero<SuperHearSmell> {
7748: 2550:    DogPerson() {
7749: 2551:        super(new SuperHearSmell());
7750: 2552:    }
7751: 2553:}
7752: 2554:
7753: 2555:public class EpicBattle {
7754: 2556:    // Bounds in generic methods:
7755: 2557:    static <POWER extends SuperHearing>
7756: 2558:    void useSuperHearing(SuperHero<POWER> hero) {
7757: 2559:        hero.getPower().hearSubtleNoises();
7758: 2560:    }
7759: 2561:
7760: 2562:    static <POWER extends SuperHearing & SuperSmell>
7761: 2563:    void superFind(SuperHero<POWER> hero) {
7762: 2564:        hero.getPower().hearSubtleNoises();
7763: 2565:        hero.getPower().trackBySmell();
7764: 2566:    }
7765: 2567:
7766: 2568:    public static void main(String[] args) {
7767: 2569:        DogPerson dogPerson = new DogPerson();
7768: 2570:        useSuperHearing(dogPerson);
7769: 2571:        superFind(dogPerson);
7770: 2572:        // You can do this:
7771: 2573:        List<? extends SuperHearing> audioPeople;
7772: 2574:        // But you can't do this:
7773: 2575:        // List<? extends SuperHearing & SuperSmell> dogPs;
7774: 2576:    }
7775: 2577:}
7776: 2578:```
7777: 2579:
7778: 2580:接下来将要研究的通配符将会把范围限制在单个类型。
7779: 2581:
7780: 2582:<!-- Wildcards -->
7781: 2583:
7782: 2584:## 通配符
7783: 2585:
7784: 2586:你已经在 [集合](book/12-Collections.md) 章节中看到了一些简单示例使用了通配符——在泛型参数表达式中的问号，在 [类型信息](book/19-Type-Information.md) 一章中这种示例更多。本节将更深入地探讨这个特性。
7785: 2587:
7786: 2588:我们的起始示例要展示数组的一种特殊行为：你可以将派生类的数组赋值给基类的引用：
7787: 2589:
7788: 2590:```java
7789: 2591:// generics/CovariantArrays.java
7790: 2592:
7791: 2593:class Fruit {}
7792: 2594:
7793: 2595:class Apple extends Fruit {}
7794: 2596:
7795: 2597:class Jonathan extends Apple {}
7796: 2598:
7797: 2599:class Orange extends Fruit {}
7798: 2600:
7799: 2601:public class CovariantArrays {
7800: 2602:    
7801: 2603:    public static void main(String[] args) {
7802: 2604:        Fruit[] fruit = new Apple[10];
7803: 2605:        fruit[0] = new Apple(); // OK
7804: 2606:        fruit[1] = new Jonathan(); // OK
7805: 2607:        // Runtime type is Apple[], not Fruit[] or Orange[]:
7806: 2608:        try {
7807: 2609:            // Compiler allows you to add Fruit:
7808: 2610:            fruit[0] = new Fruit(); // ArrayStoreException
7809: 2611:        } catch (Exception e) {
7810: 2612:            System.out.println(e);
7811: 2613:        }
7812: 2614:        try {
7813: 2615:            // Compiler allows you to add Oranges:
7814: 2616:            fruit[0] = new Orange(); // ArrayStoreException
7815: 2617:        } catch (Exception e) {
7816: 2618:            System.out.println(e);
7817: 2619:        }
7818: 2620:    }
7819: 2621:}
7820: 2622:/* Output:
7821: 2623:java.lang.ArrayStoreException: Fruit
7822: 2624:java.lang.ArrayStoreException: Orange
7823: 2625:```
7824: 2626:
7825: 2627:`main()` 中的第一行创建了 **Apple** 数组，并赋值给一个 **Fruit** 数组引用。这是有意义的，因为 **Apple** 也是一种 **Fruit**，因此 **Apple** 数组应该也是一个 **Fruit** 数组。
7826: 2628:
7827: 2629:但是，如果实际的数组类型是 **Apple[]**，你可以在其中放置 **Apple** 或 **Apple** 的子类型，这在编译期和运行时都可以工作。但是你也可以在数组中放置 **Fruit** 对象。这对编译器来说是有意义的，因为它有一个 **Fruit[]** 引用——它有什么理由不允许将 **Fruit** 对象或任何从 **Fruit** 继承出来的对象（比如 **Orange**），放置到这个数组中呢？因此在编译期，这是允许的。然而，运行时的数组机制知道它处理的是 **Apple[]**，因此会在向数组中放置异构类型时抛出异常。
7828: 2630:
7829: 2631:向上转型用在这里不合适。你真正在做的是将一个数组赋值给另一个数组。数组的行为是持有其他对象，这里只是因为我们能够向上转型而已，所以很明显，数组对象可以保留有关它们包含的对象类型的规则。看起来就像数组对它们持有的对象是有意识的，因此在编译期检查和运行时检查之间，你不能滥用它们。
7830: 2632:
7831: 2633:数组的这种赋值并不是那么可怕，因为在运行时你可以发现插入了错误的类型。但是泛型的主要目标之一是将这种错误检测移到编译期。所以当我们试图使用泛型集合代替数组时，会发生什么呢？
7832: 2634:
7833: 2635:```java
7834: 2636:// generics/NonCovariantGenerics.java
7835: 2637:// {WillNotCompile}
7836: 2638:
7837: 2639:import java.util.*;
7838: 2640:
7839: 2641:public class NonCovariantGenerics {
7840: 2642:    // Compile Error: incompatible types:
7841: 2643:    List<Fruit> flist = new ArrayList<Apple>();
7842: 2644:}
7843: 2645:```
7844: 2646:
7845: 2647:尽管你在首次阅读这段代码时会认为“不能将一个 **Apple** 集合赋值给一个 **Fruit** 集合”。记住，泛型不仅仅是关于集合，它真正要表达的是“不能把一个涉及 **Apple** 的泛型赋值给一个涉及 **Fruit** 的泛型”。如果像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及到的集合，那么它可能会留下一些余地。但是它不知道任何有关这方面的信息，因此它拒绝向上转型。然而实际上这也不是向上转型—— **Apple** 的 **List** 不是 **Fruit** 的 **List**。**Apple** 的 **List** 将持有 **Apple** 和 **Apple** 的子类型，**Fruit** 的 **List** 将持有任何类型的 **Fruit**。是的，这包括 **Apple**，但是它不是一个 **Apple** 的 **List**，它仍然是 **Fruit** 的 **List**。**Apple** 的 **List** 在类型上不等价于 **Fruit** 的 **List**，即使 **Apple** 是一种 **Fruit** 类型。
7846: 2648:
7847: 2649:真正的问题是我们在讨论的集合类型，而不是集合持有对象的类型。与数组不同，泛型没有内建的协变类型。这是因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查，但是在使用泛型时，编译器和运行时系统不知道你想用类型做什么，以及应该采用什么规则。
7848: 2650:
7849: 2651:但是，有时你想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。
7850: 2652:
7851: 2653:```java
7852: 2654:// generics/GenericsAndCovariance.java
7853: 2655:
7854: 2656:import java.util.*;
7855: 2657:
7856: 2658:public class GenericsAndCovariance {
7857: 2659:    
7858: 2660:    public static void main(String[] args) {
7859: 2661:        // Wildcards allow covariance:
7860: 2662:        List<? extends Fruit> flist = new ArrayList<>();
7861: 2663:        // Compile Error: can't add any type of object:
7862: 2664:        // flist.add(new Apple());
7863: 2665:        // flist.add(new Fruit());
7864: 2666:        // flist.add(new Object());
7865: 2667:        flist.add(null); // Legal but uninteresting
7866: 2668:        // We know it returns at least Fruit:
7867: 2669:        Fruit f = flist.get(0);
7868: 2670:    }
7869: 2671:    
7870: 2672:}
7871: 2673:```
7872: 2674:
7873: 2675:**flist** 的类型现在是 `List<? extends Fruit>`，你可以读作“一个具有任何从 **Fruit** 继承的类型的列表”。然而，这实际上并不意味着这个 **List** 将持有任何类型的 **Fruit**。通配符引用的是明确的类型，因此它意味着“某种 **flist** 引用没有指定的具体类型”。因此这个被赋值的 **List** 必须持有诸如 **Fruit** 或 **Apple** 这样的指定类型，但是为了向上转型为 **Fruit**，这个类型是什么没人在意。
7874: 2676:
7875: 2677:**List** 必须持有一种具体的 **Fruit** 或 **Fruit** 的子类型，但是如果你不关心具体的类型是什么，那么你能对这样的 **List** 做什么呢？如果不知道 **List** 中持有的对象是什么类型，你怎能保证安全地向其中添加对象呢？就像在 **CovariantArrays.java** 中向上转型一样，你不能，除非编译器而不是运行时系统可以阻止这种操作的发生。你很快就会发现这个问题。
7876: 2678:
7877: 2679:你可能认为事情开始变得有点走极端了，因为现在你甚至不能向刚刚声明过将持有 **Apple** 对象的 **List** 中放入一个 **Apple** 对象。是的，但编译器并不知道这一点。`List<? extends Fruit>` 可能合法地指向一个 `List<Orange>`。一旦执行这种类型的向上转型，你就丢失了向其中传递任何对象的能力，甚至传递 **Object** 也不行。
7878: 2680:
7879: 2681:另一方面，如果你调用了一个返回 **Fruit** 的方法，则是安全的，因为你知道这个 **List** 中的任何对象至少具有 **Fruit** 类型，因此编译器允许这么做。
7880: 2682:
7881: 2683:### 编译器有多聪明
7882: 2684:
7883: 2685:现在你可能会猜想自己不能去调用任何接受参数的方法，但是考虑下面的代码：
7884: 2686:
7885: 2687:```java
7886: 2688:// generics/CompilerIntelligence.java
7887: 2689:
7888: 2690:import java.util.*;
7889: 2691:
7890: 2692:public class CompilerIntelligence {
7891: 2693:    
7892: 2694:    public static void main(String[] args) {
7893: 2695:        List<? extends Fruit> flist = Arrays.asList(new Apple());
7894: 2696:        Apple a = (Apple) flist.get(0); // No warning
7895: 2697:        flist.contains(new Apple()); // Argument is 'Object'
7896: 2698:        flist.indexOf(new Apple()); // Argument is 'Object'
7897: 2699:    }
7898: 2700:    
7899: 2701:}
7900: 2702:```
7901: 2703:
7902: 2704:这里对 `contains()` 和 `indexOf()` 的调用接受 **Apple** 对象作为参数，执行没问题。这是否意味着编译器实际上会检查代码，以查看是否有某个特定的方法修改了它的对象？
7903: 2705:
7904: 2706:通过查看 **ArrayList** 的文档，我们发现编译器没有那么聪明。尽管 `add()` 接受一个泛型参数类型的参数，但 `contains()` 和 `indexOf()` 接受的参数类型是 **Object**。因此当你指定一个 `ArrayList<? extends Fruit>` 时，`add()` 的参数就变成了"**? extends Fruit**"。从这个描述中，编译器无法得知这里需要 **Fruit** 的哪个具体子类型，因此它不会接受任何类型的 **Fruit**。如果你先把 **Apple** 向上转型为 **Fruit**，也没有关系——编译器仅仅会拒绝调用像 `add()` 这样参数列表中涉及通配符的方法。
7905: 2707:
7906: 2708:`contains()` 和 `indexOf()` 的参数类型是 **Object**，不涉及通配符，所以编译器允许调用它们。这意味着将由泛型类的设计者来决定哪些调用是“安全的”，并使用 **Object** 类作为它们的参数类型。为了禁止对类型中使用了通配符的方法调用，需要在参数列表中使用类型参数。
7907: 2709:
7908: 2710:下面展示一个简单的 **Holder** 类：
7909: 2711:
7910: 2712:```java
7911: 2713:// generics/Holder.java
7912: 2714:
7913: 2715:public class Holder<T> {
7914: 2716:
7915: 2717:    private T value;
7916: 2718:
7917: 2719:    public Holder() {}
7918: 2720:
7919: 2721:    public Holder(T val) {
7920: 2722:        value = val;
7921: 2723:    }
7922: 2724:
7923: 2725:    public void set(T val) {
7924: 2726:        value = val;
7925: 2727:    }
7926: 2728:
7927: 2729:    public T get() {
7928: 2730:        return value;
7929: 2731:    }
7930: 2732:
7931: 2733:    @Override
7932: 2734:    public boolean equals(Object o) {
7933: 2735:        return o instanceof Holder && Objects.equals(value, ((Holder) o).value);
7934: 2736:    }
7935: 2737:
7936: 2738:    @Override
7937: 2739:    public int hashCode() {
7938: 2740:        return Objects.hashCode(value);
7939: 2741:    }
7940: 2742:
7941: 2743:    public static void main(String[] args) {
7942: 2744:        Holder<Apple> apple = new Holder<>(new Apple());
7943: 2745:        Apple d = apple.get();
7944: 2746:        apple.set(d);
7945: 2747:        // Holder<Fruit> fruit = apple; // Cannot upcast
7946: 2748:        Holder<? extends Fruit> fruit = apple; // OK
7947: 2749:        Fruit p = fruit.get();
7948: 2750:        d = (Apple) fruit.get();
7949: 2751:        try {
7950: 2752:            Orange c = (Orange) fruit.get(); // No warning
7951: 2753:        } catch (Exception e) {
7952: 2754:            System.out.println(e);
7953: 2755:        }
7954: 2756:        // fruit.set(new Apple()); // Cannot call set()
7955: 2757:        // fruit.set(new Fruit()); // Cannot call set()
7956: 2758:        System.out.println(fruit.equals(d)); // OK
7957: 2759:    }
7958: 2760:}
7959: 2761:/* Output
7960: 2762:java.lang.ClassCastException: Apple cannot be cast to Orange
7961: 2763:false
7962: 2764:*/
7963: 2765:```
7964: 2766:
7965: 2767:**Holder** 有一个接受 **T** 类型对象的 `set()` 方法，一个返回 T 对象的 `get()` 方法和一个接受 Object 对象的 `equals()` 方法。正如你所见，如果创建了一个 `Holder<Apple>`，就不能将其向上转型为 `Holder<Fruit>`，但是可以向上转型为 `Holder<? extends Fruit>`。如果调用 `get()`，只能返回一个 **Fruit**——这就是在给定“任何扩展自 **Fruit** 的对象”这一边界后，它所能知道的一切了。如果你知道更多的信息，就可以将其转型到某种具体的 **Fruit** 而不会导致任何警告，但是存在得到 **ClassCastException** 的风险。`set()` 方法不能工作在 **Apple** 和 **Fruit** 上，因为 `set()` 的参数也是"**? extends Fruit**"，意味着它可以是任何事物，编译器无法验证“任何事物”的类型安全性。
7966: 2768:
7967: 2769:但是，`equals()` 方法可以正常工作，因为它接受的参数是 **Object** 而不是 **T** 类型。因此，编译器只关注传递进来和要返回的对象类型。它不会分析代码，以查看是否执行了任何实际的写入和读取操作。
7968: 2770:
7969: 2771:Java 7 引入了 **java.util.Objects** 库，使创建 `equals()` 和 `hashCode()` 方法变得更加容易，当然还有很多其他功能。`equals()` 方法的标准形式参考 [附录：理解 equals 和 hashCode 方法](book/Appendix-Understanding-equals-and-hashCode) 一章。
7970: 2772:
7971: 2773:### 逆变
7972: 2774:
7973: 2775:还可以走另外一条路，即使用超类型通配符。这里，可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 `<？super MyClass>` ，或者甚至使用类型参数： `<？super T>`（尽管你不能对泛型参数给出一个超类型边界；即不能声明 `<T super MyClass>` ）。这使得你可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，就可以向 **Collection** 写入了：
7974: 2776:
7975: 2777:```java
7976: 2778:// generics/SuperTypeWildcards.java
7977: 2779:import java.util.*;
7978: 2780:public class SuperTypeWildcards {
7979: 2781:    static void writeTo(List<? super Apple> apples) {
7980: 2782:        apples.add(new Apple());
7981: 2783:        apples.add(new Jonathan());
7982: 2784:        // apples.add(new Fruit()); // Error
7983: 2785:    }
7984: 2786:}
7985: 2787:```
7986: 2788:
7987: 2789:参数 **apples** 是 **Apple** 的某种基类型的 **List**，这样你就知道向其中添加 **Apple** 或 **Apple** 的子类型是安全的。但是因为 **Apple** 是下界，所以你知道向这样的 **List** 中添加 **Fruit** 是不安全的，因为这将使这个 **List** 敞开口子，从而可以向其中添加非 **Apple** 类型的对象，而这是违反静态类型安全的。
7988: 2790:下面的示例复习了一下逆变和通配符的的使用：
7989: 2791:
7990: 2792:```java
7991: 2793:// generics/GenericReading.java
7992: 2794:import java.util.*;
7993: 2795:
7994: 2796:public class GenericReading {
7995: 2797:    static List<Apple> apples = Arrays.asList(new Apple());
7996: 2798:    static List<Fruit> fruit = Arrays.asList(new Fruit());
7997: 2799:    
7998: 2800:    static <T> T readExact(List<T> list) {
7999: 2801:        return list.get(0);
8000: 2802:    }
8001: 2803:    
8002: 2804:    // A static method adapts to each call:
8003: 2805:    static void f1() {
8004: 2806:        Apple a = readExact(apples);
8005: 2807:        Fruit f = readExact(fruit);
8006: 2808:        f = readExact(apples);
8007: 2809:    }
8008: 2810:    
8009: 2811:    // A class type is established
8010: 2812:    // when the class is instantiated:
8011: 2813:    static class Reader<T> {
8012: 2814:        T readExact(List<T> list) { 
8013: 2815:            return list.get(0); 
8014: 2816:        }
8015: 2817:    }
8016: 2818:    
8017: 2819:    static void f2() {
8018: 2820:        Reader<Fruit> fruitReader = new Reader<>();
8019: 2821:        Fruit f = fruitReader.readExact(fruit);
8020: 2822:        //- Fruit a = fruitReader.readExact(apples);
8021: 2823:        // error: incompatible types: List<Apple>
8022: 2824:        // cannot be converted to List<Fruit>
8023: 2825:    }
8024: 2826:    
8025: 2827:    static class CovariantReader<T> {
8026: 2828:        T readCovariant(List<? extends T> list) {
8027: 2829:            return list.get(0);
8028: 2830:        }
8029: 2831:    }
8030: 2832:    
8031: 2833:    static void f3() {
8032: 2834:        CovariantReader<Fruit> fruitReader = new CovariantReader<>();
8033: 2835:        Fruit f = fruitReader.readCovariant(fruit);
8034: 2836:        Fruit a = fruitReader.readCovariant(apples);
8035: 2837:    }
8036: 2838:    
8037: 2839:    public static void main(String[] args) {
8038: 2840:        f1(); 
8039: 2841:        f2(); 
8040: 2842:        f3();
8041: 2843:    }
8042: 2844:}
8043: 2845:```
8044: 2846:
8045: 2847:`readExact()` 方法使用了精确的类型。如果使用这个没有任何通配符的精确类型，就可以向 **List** 中写入和读取这个精确类型。另外，对于返回值，静态的泛型方法 `readExact()` 可以有效地“适应”每个方法调用，并能够从 `List<Apple>` 中返回一个 **Apple** ，从 `List<Fruit>` 中返回一个 **Fruit** ，就像在 `f1()` 中看到的那样。因此，如果可以摆脱静态泛型方法，那么在读取时就不需要协变类型了。
8046: 2848:然而对于泛型类来说，当你创建这个类的实例时，就要为这个类确定参数。就像在 `f2()` 中看到的，**fruitReader** 实例可以从 `List<Fruit>` 中读取一个 **Fruit** ，因为这就是它的确切类型。但是 `List<Apple>` 也应该产生 **Fruit** 对象，而 **fruitReader** 不允许这么做。
8047: 2849:为了修正这个问题，`CovariantReader.readCovariant()` 方法将接受 `List<？extends T>` ，因此，从这个列表中读取一个 **T** 是安全的（你知道在这个列表中的所有对象至少是一个 **T** ，并且可能是从 T 导出的某种对象）。在 `f3()` 中，你可以看到现在可以从 `List<Apple>` 中读取 **Fruit** 了。
8048: 2850:
8049: 2851:### 无界通配符
8050: 2852:
8051: 2853:无界通配符 `<?>` 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器初看起来是支持这种判断的：
8052: 2854:
8053: 2855:```java
8054: 2856:// generics/UnboundedWildcards1.java
8055: 2857:import java.util.*;
8056: 2858:
8057: 2859:public class UnboundedWildcards1 {
8058: 2860:    static List list1;
8059: 2861:    static List<?> list2;
8060: 2862:    static List<? extends Object> list3;
8061: 2863:  
8062: 2864:    static void assign1(List list) {
8063: 2865:        list1 = list;
8064: 2866:        list2 = list;
8065: 2867:        //- list3 = list;
8066: 2868:        // warning: [unchecked] unchecked conversion
8067: 2869:        // list3 = list;
8068: 2870:        //         ^
8069: 2871:        // required: List<? extends Object>
8070: 2872:        // found:    List
8071: 2873:    }
8072: 2874:    
8073: 2875:    static void assign2(List<?> list) {
8074: 2876:        list1 = list;
8075: 2877:        list2 = list;
8076: 2878:        list3 = list;
8077: 2879:    }
8078: 2880:    
8079: 2881:    static void assign3(List<? extends Object> list) {
8080: 2882:        list1 = list;
8081: 2883:        list2 = list;
8082: 2884:        list3 = list;
8083: 2885:    }
8084: 2886:    
8085: 2887:    public static void main(String[] args) {
8086: 2888:        assign1(new ArrayList());
8087: 2889:        assign2(new ArrayList());
8088: 2890:        //- assign3(new ArrayList());
8089: 2891:        // warning: [unchecked] unchecked method invocation:
8090: 2892:        // method assign3 in class UnboundedWildcards1
8091: 2893:        // is applied to given types
8092: 2894:        // assign3(new ArrayList());
8093: 2895:        //        ^
8094: 2896:        // required: List<? extends Object>
8095: 2897:        // found: ArrayList
8096: 2898:        // warning: [unchecked] unchecked conversion
8097: 2899:        // assign3(new ArrayList());
8098: 2900:        //         ^
8099: 2901:        // required: List<? extends Object>
8100: 2902:        // found:    ArrayList
8101: 2903:        // 2 warnings
8102: 2904:        assign1(new ArrayList<>());
8103: 2905:        assign2(new ArrayList<>());
8104: 2906:        assign3(new ArrayList<>());
8105: 2907:        // Both forms are acceptable as List<?>:
8106: 2908:        List<?> wildList = new ArrayList();
8107: 2909:        wildList = new ArrayList<>();
8108: 2910:        assign1(wildList);
8109: 2911:        assign2(wildList);
8110: 2912:        assign3(wildList);
8111: 2913:    }
8112: 2914:}
8113: 2915:```
8114: 2916:
8115: 2917:有很多情况都和你在这里看到的情况类似，即编译器很少关心使用的是原生类型还是 `<?>` 。在这些情况中，`<?>` 可以被认为是一种装饰，但是它仍旧是很有价值的，因为，实际上它是在声明：“我是想用 Java 的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型。”
8116: 2918:第二个示例展示了无界通配符的一个重要应用。当你在处理多个泛型参数时，有时允许一个参数可以是任何类型，同时为其他参数确定某种特定类型的这种能力会显得很重要：
8117: 2919:
8118: 2920:```java
8119: 2921:// generics/UnboundedWildcards2.java
8120: 2922:import java.util.*;
8121: 2923:
8122: 2924:public class UnboundedWildcards2 {
8123: 2925:    static Map map1;
8124: 2926:    static Map<?,?> map2;
8125: 2927:    static Map<String,?> map3;
8126: 2928:  
8127: 2929:    static void assign1(Map map) { 
8128: 2930:        map1 = map; 
8129: 2931:    }
8130: 2932:    
8131: 2933:    static void assign2(Map<?,?> map) { 
8132: 2934:        map2 = map; 
8133: 2935:    }
8134: 2936:    
8135: 2937:    static void assign3(Map<String,?> map) { 
8136: 2938:        map3 = map; 
8137: 2939:    }
8138: 2940:    
8139: 2941:    public static void main(String[] args) {
8140: 2942:        assign1(new HashMap());
8141: 2943:        assign2(new HashMap());
8142: 2944:        //- assign3(new HashMap());
8143: 2945:        // warning: [unchecked] unchecked method invocation:
8144: 2946:        // method assign3 in class UnboundedWildcards2
8145: 2947:        // is applied to given types
8146: 2948:        //     assign3(new HashMap());
8147: 2949:        //            ^
8148: 2950:        //   required: Map<String,?>
8149: 2951:        //   found: HashMap
8150: 2952:        // warning: [unchecked] unchecked conversion
8151: 2953:        //     assign3(new HashMap());
8152: 2954:        //             ^
8153: 2955:        //   required: Map<String,?>
8154: 2956:        //   found:    HashMap
8155: 2957:        // 2 warnings
8156: 2958:        assign1(new HashMap<>());
8157: 2959:        assign2(new HashMap<>());
8158: 2960:        assign3(new HashMap<>());
8159: 2961:    }
8160: 2962:}
8161: 2963:```
8162: 2964:
8163: 2965:但是，当你拥有的全都是无界通配符时，就像在 `Map<?,?>` 中看到的那样，编译器看起来就无法将其与原生 **Map** 区分开了。另外， **UnboundedWildcards1.java** 展示了编译器处理  `List<?>` 和 `List<? extends Object>` 是不同的。
8164: 2966:令人困惑的是，编译器并非总是关注像 `List` 和 `List<?>` 之间的这种差异，因此它们看起来就像是相同的事物。事实上，因为泛型参数擦除到它的第一个边界，因此 `List<?>` 看起来等价于 `List<Object>` ，而 **List** 实际上也是 `List<Object>` ——除非这些语句都不为真。**List** 实际上表示“持有任何 **Object** 类型的原生 **List** ”，而 `List<?>` 表示“具有某种特定类型的非原生 **List** ，只是我们不知道类型是什么。”
8165: 2967:编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？下面的示例使用了前面定义的 `Holder<T>` 类，它包含接受 **Holder** 作为参数的各种方法，但是它们具有不同的形式：作为原生类型，具有具体的类型参数以及具有无界通配符参数：
8166: 2968:
8167: 2969:```java
8168: 2970:// generics/Wildcards.java
8169: 2971:// Exploring the meaning of wildcards
8170: 2972:
8171: 2973:public class Wildcards {
8172: 2974:    // Raw argument:
8173: 2975:    static void rawArgs(Holder holder, Object arg) {
8174: 2976:        //- holder.set(arg);
8175: 2977:        // warning: [unchecked] unchecked call to set(T)
8176: 2978:        // as a member of the raw type Holder
8177: 2979:        //     holder.set(arg);
8178: 2980:        //               ^
8179: 2981:        //   where T is a type-variable:
8180: 2982:        //     T extends Object declared in class Holder
8181: 2983:        // 1 warning
8182: 2984:
8183: 2985:        // Can't do this; don't have any 'T':
8184: 2986:        // T t = holder.get();
8185: 2987:
8186: 2988:        // OK, but type information is lost:
8187: 2989:        Object obj = holder.get();
8188: 2990:    }
8189: 2991:    
8190: 2992:    // Like rawArgs(), but errors instead of warnings:
8191: 2993:    static void unboundedArg(Holder<?> holder, Object arg) {
8192: 2994:        //- holder.set(arg);
8193: 2995:        // error: method set in class Holder<T>
8194: 2996:        // cannot be applied to given types;
8195: 2997:        //     holder.set(arg);
8196: 2998:        //           ^
8197: 2999:        //   required: CAP#1
8198: 3000:        //   found: Object
8199: 3001:        //   reason: argument mismatch;
8200: 3002:        //     Object cannot be converted to CAP#1
8201: 3003:        //   where T is a type-variable:
8202: 3004:        //     T extends Object declared in class Holder
8203: 3005:        //   where CAP#1 is a fresh type-variable:
8204: 3006:        //     CAP#1 extends Object from capture of ?
8205: 3007:        // 1 error
8206: 3008:
8207: 3009:        // Can't do this; don't have any 'T':
8208: 3010:        // T t = holder.get();
8209: 3011:
8210: 3012:        // OK, but type information is lost:
8211: 3013:        Object obj = holder.get();
8212: 3014:    }
8213: 3015:    
8214: 3016:    static <T> T exact1(Holder<T> holder) {
8215: 3017:        return holder.get();
8216: 3018:    }
8217: 3019:    
8218: 3020:    static <T> T exact2(Holder<T> holder, T arg) {
8219: 3021:        holder.set(arg);
8220: 3022:        return holder.get();
8221: 3023:    }
8222: 3024:    
8223: 3025:    static <T> T wildSubtype(Holder<? extends T> holder, T arg) {
8224: 3026:        //- holder.set(arg);
8225: 3027:        // error: method set in class Holder<T#2>
8226: 3028:        // cannot be applied to given types;
8227: 3029:        //     holder.set(arg);
8228: 3030:        //           ^
8229: 3031:        //   required: CAP#1
8230: 3032:        //   found: T#1
8231: 3033:        //   reason: argument mismatch;
8232: 3034:        //     T#1 cannot be converted to CAP#1
8233: 3035:        //   where T#1,T#2 are type-variables:
8234: 3036:        //     T#1 extends Object declared in method
8235: 3037:        //     <T#1>wildSubtype(Holder<? extends T#1>,T#1)
8236: 3038:        //     T#2 extends Object declared in class Holder
8237: 3039:        //   where CAP#1 is a fresh type-variable:
8238: 3040:        //     CAP#1 extends T#1 from
8239: 3041:        //       capture of ? extends T#1
8240: 3042:        // 1 error
8241: 3043:        return holder.get();
8242: 3044:    }
8243: 3045:    
8244: 3046:    static <T> void wildSupertype(Holder<? super T> holder, T arg) {
8245: 3047:        holder.set(arg);
8246: 3048:        //- T t = holder.get();
8247: 3049:        // error: incompatible types:
8248: 3050:        // CAP#1 cannot be converted to T
8249: 3051:        //     T t = holder.get();
8250: 3052:        //                     ^
8251: 3053:        //   where T is a type-variable:
8252: 3054:        //     T extends Object declared in method
8253: 3055:        //       <T>wildSupertype(Holder<? super T>,T)
8254: 3056:        //   where CAP#1 is a fresh type-variable:
8255: 3057:        //     CAP#1 extends Object super:
8256: 3058:        //       T from capture of ? super T
8257: 3059:        // 1 error
8258: 3060:
8259: 3061:        // OK, but type information is lost:
8260: 3062:        Object obj = holder.get();
8261: 3063:    }
8262: 3064:    
8263: 3065:    public static void main(String[] args) {
8264: 3066:        Holder raw = new Holder<>();
8265: 3067:        // Or:
8266: 3068:        raw = new Holder();
8267: 3069:        Holder<Long> qualified = new Holder<>();
8268: 3070:        Holder<?> unbounded = new Holder<>();
8269: 3071:        Holder<? extends Long> bounded = new Holder<>();
8270: 3072:        Long lng = 1L;
8271: 3073:
8272: 3074:        rawArgs(raw, lng);
8273: 3075:        rawArgs(qualified, lng);
8274: 3076:        rawArgs(unbounded, lng);
8275: 3077:        rawArgs(bounded, lng);
8276: 3078:
8277: 3079:        unboundedArg(raw, lng);
8278: 3080:        unboundedArg(qualified, lng);
8279: 3081:        unboundedArg(unbounded, lng);
8280: 3082:        unboundedArg(bounded, lng);
8281: 3083:
8282: 3084:        //- Object r1 = exact1(raw);
8283: 3085:        // warning: [unchecked] unchecked method invocation:
8284: 3086:        // method exact1 in class Wildcards is applied
8285: 3087:        // to given types
8286: 3088:        //      Object r1 = exact1(raw);
8287: 3089:        //                        ^
8288: 3090:        //   required: Holder<T>
8289: 3091:        //   found: Holder
8290: 3092:        //   where T is a type-variable:
8291: 3093:        //     T extends Object declared in
8292: 3094:        //     method <T>exact1(Holder<T>)
8293: 3095:        // warning: [unchecked] unchecked conversion
8294: 3096:        //      Object r1 = exact1(raw);
8295: 3097:        //                         ^
8296: 3098:        //   required: Holder<T>
8297: 3099:        //   found:    Holder
8298: 3100:        //   where T is a type-variable:
8299: 3101:        //     T extends Object declared in
8300: 3102:        //     method <T>exact1(Holder<T>)
8301: 3103:        // 2 warnings
8302: 3104:
8303: 3105:        Long r2 = exact1(qualified);
8304: 3106:        Object r3 = exact1(unbounded); // Must return Object
8305: 3107:        Long r4 = exact1(bounded);
8306: 3108:
8307: 3109:        //- Long r5 = exact2(raw, lng);
8308: 3110:        // warning: [unchecked] unchecked method invocation:
8309: 3111:        // method exact2 in class Wildcards is
8310: 3112:        // applied to given types
8311: 3113:        //     Long r5 = exact2(raw, lng);
8312: 3114:        //                     ^
8313: 3115:        //   required: Holder<T>,T
8314: 3116:        //   found: Holder,Long
8315: 3117:        //   where T is a type-variable:
8316: 3118:        //     T extends Object declared in
8317: 3119:        //       method <T>exact2(Holder<T>,T)
8318: 3120:        // warning: [unchecked] unchecked conversion
8319: 3121:        //     Long r5 = exact2(raw, lng);
8320: 3122:        //                      ^
8321: 3123:        //   required: Holder<T>
8322: 3124:        //   found:    Holder
8323: 3125:        //   where T is a type-variable:
8324: 3126:        //     T extends Object declared in
8325: 3127:        //       method <T>exact2(Holder<T>,T)
8326: 3128:        // 2 warnings
8327: 3129:
8328: 3130:        Long r6 = exact2(qualified, lng);
8329: 3131:
8330: 3132:        //- Long r7 = exact2(unbounded, lng);
8331: 3133:        // error: method exact2 in class Wildcards
8332: 3134:        // cannot be applied to given types;
8333: 3135:        //     Long r7 = exact2(unbounded, lng);
8334: 3136:        //               ^
8335: 3137:        //   required: Holder<T>,T
8336: 3138:        //   found: Holder<CAP#1>,Long
8337: 3139:        //   reason: inference variable T has
8338: 3140:        //     incompatible bounds
8339: 3141:        //     equality constraints: CAP#1
8340: 3142:        //     lower bounds: Long
8341: 3143:        //   where T is a type-variable:
8342: 3144:        //     T extends Object declared in
8343: 3145:        //       method <T>exact2(Holder<T>,T)
8344: 3146:        //   where CAP#1 is a fresh type-variable:
8345: 3147:        //     CAP#1 extends Object from capture of ?
8346: 3148:        // 1 error
8347: 3149:
8348: 3150:        //- Long r8 = exact2(bounded, lng);
8349: 3151:        // error: method exact2 in class Wildcards
8350: 3152:        // cannot be applied to given types;
8351: 3153:        //      Long r8 = exact2(bounded, lng);
8352: 3154:        //                ^
8353: 3155:        //   required: Holder<T>,T
8354: 3156:        //   found: Holder<CAP#1>,Long
8355: 3157:        //   reason: inference variable T
8356: 3158:        //     has incompatible bounds
8357: 3159:        //     equality constraints: CAP#1
8358: 3160:        //     lower bounds: Long
8359: 3161:        //   where T is a type-variable:
8360: 3162:        //     T extends Object declared in
8361: 3163:        //       method <T>exact2(Holder<T>,T)
8362: 3164:        //   where CAP#1 is a fresh type-variable:
8363: 3165:        //     CAP#1 extends Long from
8364: 3166:        //       capture of ? extends Long
8365: 3167:        // 1 error
8366: 3168:
8367: 3169:        //- Long r9 = wildSubtype(raw, lng);
8368: 3170:        // warning: [unchecked] unchecked method invocation:
8369: 3171:        // method wildSubtype in class Wildcards
8370: 3172:        // is applied to given types
8371: 3173:        //     Long r9 = wildSubtype(raw, lng);
8372: 3174:        //                          ^
8373: 3175:        //   required: Holder<? extends T>,T
8374: 3176:        //   found: Holder,Long
8375: 3177:        //   where T is a type-variable:
8376: 3178:        //     T extends Object declared in
8377: 3179:        //     method <T>wildSubtype(Holder<? extends T>,T)
8378: 3180:        // warning: [unchecked] unchecked conversion
8379: 3181:        //     Long r9 = wildSubtype(raw, lng);
8380: 3182:        //                           ^
8381: 3183:        //   required: Holder<? extends T>
8382: 3184:        //   found:    Holder
8383: 3185:        //   where T is a type-variable:
8384: 3186:        //     T extends Object declared in
8385: 3187:        //     method <T>wildSubtype(Holder<? extends T>,T)
8386: 3188:        // 2 warnings
8387: 3189:
8388: 3190:        Long r10 = wildSubtype(qualified, lng);
8389: 3191:        // OK, but can only return Object:
8390: 3192:        Object r11 = wildSubtype(unbounded, lng);
8391: 3193:        Long r12 = wildSubtype(bounded, lng);
8392: 3194:
8393: 3195:        //- wildSupertype(raw, lng);
8394: 3196:        // warning: [unchecked] unchecked method invocation:
8395: 3197:        //   method wildSupertype in class Wildcards
8396: 3198:        //   is applied to given types
8397: 3199:        //     wildSupertype(raw, lng);
8398: 3200:        //                  ^
8399: 3201:        //   required: Holder<? super T>,T
8400: 3202:        //   found: Holder,Long
8401: 3203:        //   where T is a type-variable:
8402: 3204:        //     T extends Object declared in
8403: 3205:        //     method <T>wildSupertype(Holder<? super T>,T)
8404: 3206:        // warning: [unchecked] unchecked conversion
8405: 3207:        //     wildSupertype(raw, lng);
8406: 3208:        //                   ^
8407: 3209:        //   required: Holder<? super T>
8408: 3210:        //   found:    Holder
8409: 3211:        //   where T is a type-variable:
8410: 3212:        //     T extends Object declared in
8411: 3213:        //     method <T>wildSupertype(Holder<? super T>,T)
8412: 3214:        // 2 warnings
8413: 3215:
8414: 3216:        wildSupertype(qualified, lng);
8415: 3217:
8416: 3218:        //- wildSupertype(unbounded, lng);
8417: 3219:        // error: method wildSupertype in class Wildcards
8418: 3220:        // cannot be applied to given types;
8419: 3221:        //     wildSupertype(unbounded, lng);
8420: 3222:        //     ^
8421: 3223:        //   required: Holder<? super T>,T
8422: 3224:        //   found: Holder<CAP#1>,Long
8423: 3225:        //   reason: cannot infer type-variable(s) T
8424: 3226:        //     (argument mismatch; Holder<CAP#1>
8425: 3227:        //     cannot be converted to Holder<? super T>)
8426: 3228:        //   where T is a type-variable:
8427: 3229:        //     T extends Object declared in
8428: 3230:        //     method <T>wildSupertype(Holder<? super T>,T)
8429: 3231:        //   where CAP#1 is a fresh type-variable:
8430: 3232:        //     CAP#1 extends Object from capture of ?
8431: 3233:        // 1 error
8432: 3234:
8433: 3235:        //- wildSupertype(bounded, lng);
8434: 3236:        // error: method wildSupertype in class Wildcards
8435: 3237:        // cannot be applied to given types;
8436: 3238:        //     wildSupertype(bounded, lng);
8437: 3239:        //     ^
8438: 3240:        //   required: Holder<? super T>,T
8439: 3241:        //   found: Holder<CAP#1>,Long
8440: 3242:        //   reason: cannot infer type-variable(s) T
8441: 3243:        //     (argument mismatch; Holder<CAP#1>
8442: 3244:        //     cannot be converted to Holder<? super T>)
8443: 3245:        //   where T is a type-variable:
8444: 3246:        //     T extends Object declared in
8445: 3247:        //     method <T>wildSupertype(Holder<? super T>,T)
8446: 3248:        //   where CAP#1 is a fresh type-variable:
8447: 3249:        //     CAP#1 extends Long from capture of
8448: 3250:        //     ? extends Long
8449: 3251:        // 1 error
8450: 3252:    }
8451: 3253:}
8452: 3254:```
8453: 3255:
8454: 3256:在 `rawArgs()` 中，编译器知道 `Holder` 是一个泛型类型，因此即使它在这里被表示成一个原生类型，编译器仍旧知道向 `set()` 传递一个 **Object** 是不安全的。由于它是原生类型，你可以将任何类型的对象传递给 `set()` ，而这个对象将被向上转型为 **Object** 。因此无论何时，只要使用了原生类型，都会放弃编译期检查。对 `get()` 的调用说明了相同的问题：没有任何 **T** 类型的对象，因此结果只能是一个 **Object**。
8455: 3257:人们很自然地会开始考虑原生 `Holder` 与 `Holder<?>` 是大致相同的事物。但是 `unboundedArg()` 强调它们是不同的——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，因为原生 **Holder** 将持有任何类型的组合，而 `Holder<?>` 将持有具有某种具体类型的同构集合，因此不能只是向其中传递 **Object** 。
8456: 3258:在 `exact1()` 和 `exact2()` 中，你可以看到使用了确切的泛型参数——没有任何通配符。你将看到，`exact2()`与 `exact1()` 具有不同的限制，因为它有额外的参数。
8457: 3259:在 `wildSubtype()` 中，在 **Holder** 类型上的限制被放松为包括持有任何扩展自 **T** 的对象的 **Holder** 。这还是意味着如果 T 是 **Fruit** ，那么 `holder` 可以是 `Holder<Apple>` ，这是合法的。为了防止将 **Orange** 放置到 `Holder<Apple>` 中，对 `set()` 的调用（或者对任何接受这个类型参数为参数的方法的调用）都是不允许的。但是，你仍旧知道任何来自 `Holder<？extends Fruit>` 的对象至少是 **Fruit** ，因此 `get()` （或者任何将产生具有这个类型参数的返回值的方法）都是允许的。
8458: 3260:`wildSupertype()` 展示了超类型通配符，这个方法展示了与 `wildSubtype()` 相反的行为：`holder` 可以是持有任何 T 的基类型的容器。因此， `set()` 可以接受 **T** ，因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是 **T** ）。但是，尝试着调用 `get()` 是没有用的，因为由 `holder` 持有的类型可以是任何超类型，因此唯一安全的类型就是 **Object** 。
8459: 3261:这个示例还展示了对于在 `unbounded()` 中使用无界通配符能够做什么不能做什么所做出的限制：因为你没有 **T**，所以你不能将 `set()` 或 `get()` 作用于 **T** 上。
8460: 3262:
8461: 3263:在 `main()` 方法中你看到了某些方法在接受某些类型的参数时没有报错和警告。为了迁移兼容性，`rawArgs()`  将接受所有 **Holder** 的不同变体，而不会产生警告。`unboundedArg()` 方法也可以接受相同的所有类型，尽管如前所述，它在方法体内部处理这些类型的方式并不相同。
8462: 3264:
8463: 3265:如果向接受“确切”泛型类型（没有通配符）的方法传递一个原生 **Holder** 引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息。如果向 `exact1()` 传递一个无界引用，就不会有任何可以确定返回类型的类型信息。
8464: 3266:可以看到，`exact2()` 具有最多的限制，因为它希望精确地得到一个 `Holder<T>` ，以及一个具有类型 **T** 的参数，正由于此，它将产生错误或警告，除非提供确切的参数。有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决于是否想要从泛型参数中返回类型确定的返回值（就像在 `wildSubtype()` 中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在 `wildSupertype()` 中看到的那样）。
8465: 3267:因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合你的需求的方法。
8466: 3268:
8467: 3269:### 捕获转换
8468: 3270:
8469: 3271:有一种特殊情况需要使用 `<?>` 而不是原生类型。如果向一个使用 `<?>` 的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。下面的示例演示了这种技术，它被称为捕获转换，因为未指定的通配符类型被捕获，并被转换为确切类型。这里，有关警告的注释只有在 `@SuppressWarnings` 注解被移除之后才能起作用：
8470: 3272:
8471: 3273:```java
8472: 3274:// generics/CaptureConversion.java
8473: 3275:
8474: 3276:public class CaptureConversion {
8475: 3277:    static <T> void f1(Holder<T> holder) {
8476: 3278:        T t = holder.get();
8477: 3279:        System.out.println(t.getClass().getSimpleName());
8478: 3280:    }
8479: 3281:  
8480: 3282:    static void f2(Holder<?> holder) {
8481: 3283:        f1(holder); // Call with captured type
8482: 3284:    }
8483: 3285:    
8484: 3286:    @SuppressWarnings("unchecked")
8485: 3287:    public static void main(String[] args) {
8486: 3288:        Holder raw = new Holder<>(1);
8487: 3289:        f1(raw);
8488: 3290:        // warning: [unchecked] unchecked method invocation:
8489: 3291:        // method f1 in class CaptureConversion
8490: 3292:        // is applied to given types
8491: 3293:        //     f1(raw);
8492: 3294:        //       ^
8493: 3295:        //   required: Holder<T>
8494: 3296:        //   found: Holder
8495: 3297:        //   where T is a type-variable:
8496: 3298:        //     T extends Object declared in
8497: 3299:        //     method <T>f1(Holder<T>)
8498: 3300:        // warning: [unchecked] unchecked conversion
8499: 3301:        //     f1(raw);
8500: 3302:        //        ^
8501: 3303:        //   required: Holder<T>
8502: 3304:        //   found:    Holder
8503: 3305:        //   where T is a type-variable:
8504: 3306:        //     T extends Object declared in
8505: 3307:        //     method <T>f1(Holder<T>)
8506: 3308:        // 2 warnings
8507: 3309:        f2(raw); // No warnings
8508: 3310:        
8509: 3311:        Holder rawBasic = new Holder();
8510: 3312:        rawBasic.set(new Object());
8511: 3313:        // warning: [unchecked] unchecked call to set(T)
8512: 3314:        // as a member of the raw type Holder
8513: 3315:        //     rawBasic.set(new Object());
8514: 3316:        //                 ^
8515: 3317:        //   where T is a type-variable:
8516: 3318:        //     T extends Object declared in class Holder
8517: 3319:        // 1 warning
8518: 3320:        f2(rawBasic); // No warnings
8519: 3321:        
8520: 3322:        // Upcast to Holder<?>, still figures it out:
8521: 3323:        Holder<?> wildcarded = new Holder<>(1.0);
8522: 3324:        f2(wildcarded);
8523: 3325:    }
8524: 3326:}
8525: 3327:/* Output:
8526: 3328:Integer
8527: 3329:Integer
8528: 3330:Object
8529: 3331:Double
8530: 3332:*/
8531: 3333:```
8532: 3334:
8533: 3335:`f1()` 中的类型参数都是确切的，没有通配符或边界。在 `f2()` 中，**Holder** 参数是一个无界通配符，因此它看起来是未知的。但是，在 `f2()` 中调用了 `f1()`，而 `f1()` 需要一个已知参数。这里所发生的是：在调用 `f2()` 的过程中捕获了参数类型，并在调用 `f1()` 时使用了这种类型。
8534: 3336:你可能想知道这项技术是否可以用于写入，但是这要求在传递 `Holder<?>` 时同时传递一个具体类型。捕获转换只有在这样的情况下可以工作：即在方法内部，你需要使用确切的类型。注意，不能从 `f2()` 中返回 **T**，因为 **T** 对于 `f2()` 来说是未知的。捕获转换十分有趣，但是非常受限。
8535: 3337:
8536: 3338:<!-- Issues -->
8537: 3339:
8538: 3340:## 问题
8539: 3341:
8540: 3342:本节将阐述在使用 Java 泛型时会出现的各类问题。
8541: 3343:
8542: 3344:### 任何基本类型都不能作为类型参数
8543: 3345:
8544: 3346:正如本章早先提到的，Java 泛型的限制之一是不能将基本类型用作类型参数。因此，不能创建  `ArrayList<int>` 之类的东西。
8545: 3347:解决方法是使用基本类型的包装器类以及自动装箱机制。如果创建一个 `ArrayList<Integer>`，并将基本类型 **int** 应用于这个集合，那么你将发现自动装箱机制将自动地实现 **int** 到 **Integer** 的双向转换——因此，这几乎就像是有一个 `ArrayList<int>` 一样：
8546: 3348:
8547: 3349:```java
8548: 3350:// generics/ListOfInt.java
8549: 3351:// Autoboxing compensates for the inability
8550: 3352:// to use primitives in generics
8551: 3353:import java.util.*;
8552: 3354:import java.util.stream.*;
8553: 3355:
8554: 3356:public class ListOfInt {
8555: 3357:    public static void main(String[] args) {
8556: 3358:        List<Integer> li = IntStream.range(38, 48)
8557: 3359:            .boxed() // Converts ints to Integers
8558: 3360:            .collect(Collectors.toList());
8559: 3361:        System.out.println(li);
8560: 3362:    }
8561: 3363:}
8562: 3364:/* Output:
8563: 3365:[38, 39, 40, 41, 42, 43, 44, 45, 46, 47]
8564: 3366:*/
8565: 3367:```
8566: 3368:
8567: 3369:通常，这种解决方案工作得很好——能够成功地存储和读取 **int**，自动装箱隐藏了转换的过程。但是如果性能成为问题的话，就需要使用专门为基本类型适配的特殊版本的集合；一个开源版本的实现是 **org.apache.commons.collections.primitives**。
8568: 3370:下面是另外一种方式，它可以创建持有 **Byte** 的 **Set**：
8569: 3371:
8570: 3372:```java
8571: 3373:// generics/ByteSet.java
8572: 3374:import java.util.*;
8573: 3375:
8574: 3376:public class ByteSet {
8575: 3377:    Byte[] possibles = { 1,2,3,4,5,6,7,8,9 };
8576: 3378:    Set<Byte> mySet = new HashSet<>(Arrays.asList(possibles));
8577: 3379:    // But you can't do this:
8578: 3380:    // Set<Byte> mySet2 = new HashSet<>(
8579: 3381:    // Arrays.<Byte>asList(1,2,3,4,5,6,7,8,9));
8580: 3382:}
8581: 3383:```
8582: 3384:
8583: 3385:自动装箱机制解决了一些问题，但并没有解决所有问题。
8584: 3386:
8585: 3387:在下面的示例中，**FillArray** 接口包含一些通用方法，这些方法使用 **Supplier** 来用对象填充数组（这使得类泛型在本例中无法工作，因为这个方法是静态的）。**Supplier** 实现来自 [数组](book/21-Arrays.md) 一章,并且在 `main()` 中，可以看到 `FillArray.fill()` 使用对象填充了数组：
8586: 3388:
8587: 3389:```java
8588: 3390:// generics/PrimitiveGenericTest.java
8589: 3391:import onjava.*;
8590: 3392:import java.util.*;
8591: 3393:import java.util.function.*;
8592: 3394:
8593: 3395:// Fill an array using a generator:
8594: 3396:interface FillArray {
8595: 3397:    static <T> T[] fill(T[] a, Supplier<T> gen) {
8596: 3398:        Arrays.setAll(a, n -> gen.get());
8597: 3399:        return a;
8598: 3400:    }
8599: 3401:    
8600: 3402:    static int[] fill(int[] a, IntSupplier gen) {
8601: 3403:        Arrays.setAll(a, n -> gen.getAsInt());
8602: 3404:        return a;
8603: 3405:    }
8604: 3406:    
8605: 3407:    static long[] fill(long[] a, LongSupplier gen) {
8606: 3408:        Arrays.setAll(a, n -> gen.getAsLong());
8607: 3409:        return a;
8608: 3410:    }
8609: 3411:    
8610: 3412:    static double[] fill(double[] a, DoubleSupplier gen) {
8611: 3413:        Arrays.setAll(a, n -> gen.getAsDouble());
8612: 3414:        return a;
8613: 3415:    }
8614: 3416:}
8615: 3417:
8616: 3418:public class PrimitiveGenericTest {
8617: 3419:    public static void main(String[] args) {
8618: 3420:        String[] strings = FillArray.fill(
8619: 3421:            new String[5], new Rand.String(9));
8620: 3422:        System.out.println(Arrays.toString(strings));
8621: 3423:        int[] integers = FillArray.fill(
8622: 3424:            new int[9], new Rand.Pint());
8623: 3425:        System.out.println(Arrays.toString(integers));
8624: 3426:    }
8625: 3427:}
8626: 3428:/* Output:
8627: 3429:[btpenpccu, xszgvgmei, nneeloztd, vewcippcy, gpoalkljl]
8628: 3430:[635, 8737, 3941, 4720, 6177, 8479, 6656, 3768, 4948]
8629: 3431:*/
8630: 3432:```
8631: 3433:
8632: 3434:自动装箱不适用于数组，因此我们必须创建 `FillArray.fill()` 的重载版本，或创建产生 **Wrapped** 输出的生成器。 **FillArray** 仅比 `java.util.Arrays.setAll()` 有用一点，因为它返回填充的数组。
8633: 3435:
8634: 3436:### 实现参数化接口
8635: 3437:
8636: 3438:一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。下面是产生这种冲突的情况：
8637: 3439:
8638: 3440:```java
8639: 3441:// generics/MultipleInterfaceVariants.java
8640: 3442:// {WillNotCompile}
8641: 3443:package generics;
8642: 3444:
8643: 3445:interface Payable<T> {}
8644: 3446:
8645: 3447:class Employee implements Payable<Employee> {}
8646: 3448:
8647: 3449:class Hourly extends Employee implements Payable<Hourly> {}
8648: 3450:```
8649: 3451:
8650: 3452:**Hourly** 不能编译，因为擦除会将  `Payable<Employe>` 和 `Payable<Hourly>` 简化为相同的类 **Payable**，这样，上面的代码就意味着在重复两次地实现相同的接口。十分有趣的是，如果从 **Payable** 的两种用法中都移除掉泛型参数（就像编译器在擦除阶段所做的那样）这段代码就可以编译。
8651: 3453:
8652: 3454:在使用某些更基本的 Java 接口，例如 `Comparable<T>` 时，这个问题可能会变得十分令人恼火，就像你在本节稍后看到的那样。
8653: 3455:
8654: 3456:### 转型和警告
8655: 3457:
8656: 3458:使用带有泛型类型参数的转型或 **instanceof** 不会有任何效果。下面的集合在内部将各个值存储为 **Object**，并在获取这些值时，再将它们转型回 **T**：
8657: 3459:
8658: 3460:```java
8659: 3461:// generics/GenericCast.java
8660: 3462:import java.util.*;
8661: 3463:import java.util.stream.*;
8662: 3464:
8663: 3465:class FixedSizeStack<T> {
8664: 3466:    private final int size;
8665: 3467:    private Object[] storage;
8666: 3468:    private int index = 0;
8667: 3469:    
8668: 3470:    FixedSizeStack(int size) {
8669: 3471:        this.size = size;
8670: 3472:        storage = new Object[size];
8671: 3473:    }
8672: 3474:    
8673: 3475:    public void push(T item) {
8674: 3476:        if(index < size)
8675: 3477:            storage[index++] = item;
8676: 3478:    }
8677: 3479:    
8678: 3480:    @SuppressWarnings("unchecked")
8679: 3481:    public T pop() {
8680: 3482:        return index == 0 ? null : (T)storage[--index];
8681: 3483:    }
8682: 3484:    
8683: 3485:    @SuppressWarnings("unchecked")
8684: 3486:    Stream<T> stream() {
8685: 3487:        return (Stream<T>)Arrays.stream(storage);
8686: 3488:    }
8687: 3489:}
8688: 3490:
8689: 3491:public class GenericCast {
8690: 3492:    static String[] letters = "ABCDEFGHIJKLMNOPQRS".split("");
8691: 3493:  
8692: 3494:    public static void main(String[] args) {
8693: 3495:        FixedSizeStack<String> strings =
8694: 3496:            new FixedSizeStack<>(letters.length);
8695: 3497:        Arrays.stream("ABCDEFGHIJKLMNOPQRS".split(""))
8696: 3498:            .forEach(strings::push);
8697: 3499:        System.out.println(strings.pop());
8698: 3500:        strings.stream()
8699: 3501:            .map(s -> s + " ")
8700: 3502:            .forEach(System.out::print);
8701: 3503:    }
8702: 3504:}
8703: 3505:/* Output:
8704: 3506:S
8705: 3507:A B C D E F G H I J K L M N O P Q R S
8706: 3508:*/
8707: 3509:```
8708: 3510:
8709: 3511:如果没有 **@SuppressWarnings** 注解，编译器将对 `pop()` 产生 “unchecked cast” 警告。由于擦除的原因，编译器无法知道这个转型是否是安全的，并且 `pop()` 方法实际上并没有执行任何转型。
8710: 3512:这是因为，**T** 被擦除到它的第一个边界，默认情况下是 **Object** ，因此 `pop()` 实际上只是将 **Object** 转型为 **Object**。
8711: 3513:有时，泛型没有消除对转型的需要，这就会由编译器产生警告，而这个警告是不恰当的。例如：
8712: 3514:
8713: 3515:```java
8714: 3516:// generics/NeedCasting.java
8715: 3517:import java.io.*;
8716: 3518:import java.util.*;
8717: 3519:
8718: 3520:public class NeedCasting {
8719: 3521:    @SuppressWarnings("unchecked")
8720: 3522:    public void f(String[] args) throws Exception {
8721: 3523:        ObjectInputStream in = new ObjectInputStream(
8722: 3524:            new FileInputStream(args[0]));
8723: 3525:        List<Widget> shapes = (List<Widget>)in.readObject();
8724: 3526:    }
8725: 3527:}
8726: 3528:```
8727: 3529:
8728: 3530:正如你将在 [附录：对象序列化](book/Appendix-Object-Serialization.md) 中学到的那样，`readObject()` 无法知道它正在读取的是什么，因此它返回的是必须转型的对象。但是当注释掉 **@SuppressWarnings** 注解并编译这个程序时，就会得到下面的警告。
8729: 3531:
8730: 3532:```
8731: 3533:NeedCasting.java uses unchecked or unsafe operations.
8732: 3534:Recompile with -Xlint:unchecked for details.
8733: 3535:
8734: 3536:And if you follow the instructions and recompile with  -
8735: 3537:Xlint:unchecked :(如果遵循这条指示，使用-Xlint:unchecked来重新编译：)
8736: 3538:
8737: 3539:NeedCasting.java:10: warning: [unchecked] unchecked cast
8738: 3540:    List<Widget> shapes = (List<Widget>)in.readObject();
8739: 3541:    required: List<Widget>
8740: 3542:    found: Object
8741: 3543:1 warning
8742: 3544:```
8743: 3545:
8744: 3546:你会被强制要求转型，但是又被告知不应该转型。为了解决这个问题，必须使用 Java 5 引入的新的转型形式，即通过泛型类来转型：
8745: 3547:
8746: 3548:```java
8747: 3549:// generics/ClassCasting.java
8748: 3550:import java.io.*;
8749: 3551:import java.util.*;
8750: 3552:
8751: 3553:public class ClassCasting {
8752: 3554:    @SuppressWarnings("unchecked")
8753: 3555:    public void f(String[] args) throws Exception {
8754: 3556:        ObjectInputStream in = new ObjectInputStream(
8755: 3557:            new FileInputStream(args[0]));
8756: 3558:        // Won't Compile:
8757: 3559:        //    List<Widget> lw1 =
8758: 3560:        //    List<>.class.cast(in.readObject());
8759: 3561:        List<Widget> lw2 = List.class.cast(in.readObject());
8760: 3562:    }
8761: 3563:}
8762: 3564:```
8763: 3565:
8764: 3566:但是，不能转型到实际类型（ `List<Widget>` ）。也就是说，不能声明：
8765: 3567:
8766: 3568:```
8767: 3569:List<Widget>.class.cast(in.readobject())
8768: 3570:```
8769: 3571:
8770: 3572:甚至当你添加一个像下面这样的另一个转型时：
8771: 3573:
8772: 3574:```
8773: 3575:(List<Widget>)List.class.cast(in.readobject())
8774: 3576:```
8775: 3577:
8776: 3578:仍旧会得到一个警告。
8777: 3579:
8778: 3580:### 重载
8779: 3581:
8780: 3582:下面的程序是不能编译的，即使它看起来是合理的：
8781: 3583:
8782: 3584:```java
8783: 3585:// generics/UseList.java
8784: 3586:// {WillNotCompile}
8785: 3587:import java.util.*;
8786: 3588:
8787: 3589:public class UseList<W, T> {
8788: 3590:    void f(List<T> v) {}
8789: 3591:    void f(List<W> v) {}
8790: 3592:}
8791: 3593:```
8792: 3594:
8793: 3595:因为擦除，所以重载方法产生了相同的类型签名。
8794: 3596:
8795: 3597:因而，当擦除后的参数不能产生唯一的参数列表时，你必须提供不同的方法名：
8796: 3598:
8797: 3599:```java
8798: 3600:// generics/UseList2.java
8799: 3601:
8800: 3602:import java.util.*;
8801: 3603:
8802: 3604:public class UseList2<W, T> {
8803: 3605:    void f1(List<T> v) {}
8804: 3606:    void f2(List<W> v) {}
8805: 3607:}
8806: 3608:```
8807: 3609:
8808: 3610:幸运的是，编译器可以检测到这类问题。
8809: 3611:
8810: 3612:### 基类劫持接口
8811: 3613:
8812: 3614:假设你有一个实现了 **Comparable** 接口的 **Pet** 类：
8813: 3615:
8814: 3616:```java
8815: 3617:// generics/ComparablePet.java
8816: 3618:
8817: 3619:public class ComparablePet implements Comparable<ComparablePet> {
8818: 3620:    @Override
8819: 3621:    public int compareTo(ComparablePet o) {
8820: 3622:        return 0;
8821: 3623:    }
8822: 3624:}
8823: 3625:```
8824: 3626:
8825: 3627:尝试缩小 **ComparablePet** 子类的比较类型是有意义的。例如，**Cat** 类可以与其他的 **Cat** 比较：
8826: 3628:
8827: 3629:```java
8828: 3630:// generics/HijackedInterface.java
8829: 3631:// {WillNotCompile}
8830: 3632:
8831: 3633:class Cat extends ComparablePet implements Comparable<Cat> {
8832: 3634:    // error: Comparable cannot be inherited with
8833: 3635:    // different arguments: <Cat> and <ComparablePet>
8834: 3636:    // class Cat
8835: 3637:    // ^
8836: 3638:    // 1 error
8837: 3639:    public int compareTo(Cat arg) {
8838: 3640:        return 0;
8839: 3641:    }
8840: 3642:}
8841: 3643:```
8842: 3644:
8843: 3645:不幸的是，这不能工作。一旦 **Comparable** 的类型参数设置为 **ComparablePet**，其他的实现类只能比较 **ComparablePet**：
8844: 3646:
8845: 3647:```java
8846: 3648:// generics/RestrictedComparablePets.java
8847: 3649:
8848: 3650:public class Hamster extends ComparablePet implements Comparable<ComparablePet> {
8849: 3651:
8850: 3652:    @Override
8851: 3653:    public int compareTo(ComparablePet arg) {
8852: 3654:        return 0;
8853: 3655:    }
8854: 3656:}
8855: 3657:// Or just:
8856: 3658:class Gecko extends ComparablePet {
8857: 3659:    public int compareTo(ComparablePet arg) {
8858: 3660:        return 0;
8859: 3661:    }
8860: 3662:}
8861: 3663:```
8862: 3664:
8863: 3665:**Hamster** 显示了重新实现 **ComparablePet** 中相同的接口是可能的，只要接口完全相同，包括参数类型。然而正如 **Gecko** 中所示，这与直接覆写基类的方法完全相同。
8864: 3666:
8865: 3667:<!-- Self-Bounded Types -->
8866: 3668:
8867: 3669:## 自限定的类型
8868: 3670:
8869: 3671:在 Java 泛型中，有一个似乎经常性出现的惯用法，它相当令人费解：
8870: 3672:
8871: 3673:```java
8872: 3674:class SelfBounded<T extends SelfBounded<T>> { // ...
8873: 3675:```
8874: 3676:
8875: 3677:这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。**SelfBounded** 类接受泛型参数 **T**，而 **T** 由一个边界类限定，这个边界就是拥有 **T** 作为其参数的 **SelfBounded**。
8876: 3678:
8877: 3679:当你首次看到它时，很难去解析它，它强调的是当 **extends** 关键字用于边界与用来创建子类明显是不同的。
8878: 3680:
8879: 3681:### 古怪的循环泛型
8880: 3682:
8881: 3683:为了理解自限定类型的含义，我们从这个惯用法的一个简单版本入手，它没有自限定的边界。
8882: 3684:
8883: 3685:不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类。也就是说，可以声明：
8884: 3686:
8885: 3687:```java
8886: 3688:// generics/CuriouslyRecurringGeneric.java
8887: 3689:
8888: 3690:class GenericType<T> {}
8889: 3691:
8890: 3692:public class CuriouslyRecurringGeneric
8891: 3693:  extends GenericType<CuriouslyRecurringGeneric> {}
8892: 3694:```
8893: 3695:
8894: 3696:这可以按照 Jim Coplien 在 C++ 中的*古怪的循环模版模式*的命名方式，称为古怪的循环泛型（CRG）。“古怪的循环”是指类相当古怪地出现在它自己的基类中这一事实。
8895: 3697:为了理解其含义，努力大声说：“我在创建一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为其参数。”当给出导出类的名字时，这个泛型基类能够实现什么呢？好吧，Java 中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为其参数和返回类型的基类。它还能将导出类型用作其域类型，尽管这些将被擦除为 **Object** 的类型。下面是表示了这种情况的一个泛型类：
8896: 3698:
8897: 3699:```java
8898: 3700:// generics/BasicHolder.java
8899: 3701:
8900: 3702:public class BasicHolder<T> {
8901: 3703:    T element;
8902: 3704:    void set(T arg) { element = arg; }
8903: 3705:    T get() { return element; }
8904: 3706:    void f() {
8905: 3707:        System.out.println(element.getClass().getSimpleName());
8906: 3708:    }
8907: 3709:}
8908: 3710:```
8909: 3711:
8910: 3712:这是一个普通的泛型类型，它的一些方法将接受和产生具有其参数类型的对象，还有一个方法在其存储的域上执行操作（尽管只是在这个域上执行 **Object** 操作）。
8911: 3713:我们可以在一个古怪的循环泛型中使用 **BasicHolder**：
8912: 3714:
8913: 3715:```java
8914: 3716:// generics/CRGWithBasicHolder.java
8915: 3717:
8916: 3718:class Subtype extends BasicHolder<Subtype> {}
8917: 3719:
8918: 3720:public class CRGWithBasicHolder {
8919: 3721:    public static void main(String[] args) {
8920: 3722:        Subtype st1 = new Subtype(), st2 = new Subtype();
8921: 3723:        st1.set(st2);
8922: 3724:        Subtype st3 = st1.get();
8923: 3725:        st1.f();
8924: 3726:    }
8925: 3727:}
8926: 3728:/* Output:
8927: 3729:Subtype
8928: 3730:*/
8929: 3731:```
8930: 3732:
8931: 3733:注意，这里有些东西很重要：新类 **Subtype** 接受的参数和返回的值具有 **Subtype** 类型而不仅仅是基类 **BasicHolder** 类型。这就是 CRG 的本质：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型。也就是说，在所产生的类中将使用确切类型而不是基类型。因此，在**Subtype** 中，传递给 `set()` 的参数和从 `get()` 返回的类型都是确切的 **Subtype**。
8932: 3734:
8933: 3735:### 自限定
8934: 3736:
8935: 3737:**BasicHolder** 可以使用任何类型作为其泛型参数，就像下面看到的那样：
8936: 3738:
8937: 3739:```java
8938: 3740:// generics/Unconstrained.java
8939: 3741:// (c)2017 MindView LLC: see Copyright.txt
8940: 3742:// We make no guarantees that this code is fit for any purpose.
8941: 3743:// Visit http://OnJava8.com for more book information.
8942: 3744:
8943: 3745:class Other {}
8944: 3746:class BasicOther extends BasicHolder<Other> {}
8945: 3747:
8946: 3748:public class Unconstrained {
8947: 3749:    public static void main(String[] args) {
8948: 3750:        BasicOther b = new BasicOther();
8949: 3751:        BasicOther b2 = new BasicOther();
8950: 3752:        b.set(new Other());
8951: 3753:        Other other = b.get();
8952: 3754:        b.f();
8953: 3755:    }
8954: 3756:}
8955: 3757:/* Output:
8956: 3758:Other
8957: 3759:*/
8958: 3760:```
8959: 3761:
8960: 3762:限定将采取额外的步骤，强制泛型当作其自身的边界参数来使用。观察所产生的类可以如何使用以及不可以如何使用：
8961: 3763:
8962: 3764:```java
8963: 3765:// generics/SelfBounding.java
8964: 3766:
8965: 3767:class SelfBounded<T extends SelfBounded<T>> {
8966: 3768:    T element;
8967: 3769:    SelfBounded<T> set(T arg) {
8968: 3770:        element = arg;
8969: 3771:        return this;
8970: 3772:    }
8971: 3773:    T get() { return element; }
8972: 3774:}
8973: 3775:
8974: 3776:class A extends SelfBounded<A> {}
8975: 3777:class B extends SelfBounded<A> {} // Also OK
8976: 3778:
8977: 3779:class C extends SelfBounded<C> {
8978: 3780:    C setAndGet(C arg) { 
8979: 3781:        set(arg); 
8980: 3782:        return get();
8981: 3783:    }
8982: 3784:}
8983: 3785:
8984: 3786:class D {}
8985: 3787:// Can't do this:
8986: 3788:// class E extends SelfBounded<D> {}
8987: 3789:// Compile error:
8988: 3790://   Type parameter D is not within its bound
8989: 3791:
8990: 3792:// Alas, you can do this, so you cannot force the idiom:
8991: 3793:class F extends SelfBounded {}
8992: 3794:
8993: 3795:public class SelfBounding {
8994: 3796:    public static void main(String[] args) {
8995: 3797:        A a = new A();
8996: 3798:        a.set(new A());
8997: 3799:        a = a.set(new A()).get();
8998: 3800:        a = a.get();
8999: 3801:        C c = new C();
9000: 3802:        c = c.setAndGet(new C());
9001: 3803:    }
9002: 3804:}
9003: 3805:```
9004: 3806:
9005: 3807:自限定所做的，就是要求在继承关系中，像下面这样使用这个类：
9006: 3808:
9007: 3809:```java
9008: 3810:class A extends SelfBounded<A>{}
9009: 3811:```
9010: 3812:
9011: 3813:这会强制要求将正在定义的类当作参数传递给基类。
9012: 3814:
9013: 3815:自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。正如你在 B 类的定义中所看到的，还可以从使用了另一个 **SelfBounded** 参数的 **SelfBounded** 中导出，尽管在 **A** 类看到的用法看起来是主要的用法。对定义 **E** 的尝试说明不能使用不是 **SelfBounded** 的类型参数。
9014: 3816:遗憾的是， **F** 可以编译，不会有任何警告，因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型。
9015: 3817:注意，可以移除自限定这个限制，这样所有的类仍旧是可以编译的，但是 **E** 也会因此而变得可编译：
9016: 3818:
9017: 3819:```java
9018: 3820:// generics/NotSelfBounded.java
9019: 3821:
9020: 3822:public class NotSelfBounded<T> {
9021: 3823:    T element;
9022: 3824:    NotSelfBounded<T> set(T arg) {
9023: 3825:        element = arg;
9024: 3826:        return this;
9025: 3827:    }
9026: 3828:    T get() { return element; }
9027: 3829:} 
9028: 3830:
9029: 3831:class A2 extends NotSelfBounded<A2> {}
9030: 3832:class B2 extends NotSelfBounded<A2> {}
9031: 3833:
9032: 3834:class C2 extends NotSelfBounded<C2> {
9033: 3835:    C2 setAndGet(C2 arg) { 
9034: 3836:        set(arg); 
9035: 3837:        return get(); 
9036: 3838:    }
9037: 3839:}
9038: 3840:
9039: 3841:class D2 {}
9040: 3842:// Now this is OK:
9041: 3843:class E2 extends NotSelfBounded<D2> {}
9042: 3844:```
9043: 3845:
9044: 3846:因此很明显，自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。这会强制要求使用这个类的每个人都要遵循这种形式。
9045: 3847:还可以将自限定用于泛型方法：
9046: 3848:
9047: 3849:```java
9048: 3850:// generics/SelfBoundingMethods.java
9049: 3851:// (c)2017 MindView LLC: see Copyright.txt
9050: 3852:// We make no guarantees that this code is fit for any purpose.
9051: 3853:// Visit http://OnJava8.com for more book information.
9052: 3854:
9053: 3855:public class SelfBoundingMethods {
9054: 3856:    static <T extends SelfBounded<T>> T f(T arg) {
9055: 3857:        return arg.set(arg).get();
9056: 3858:    }
9057: 3859:    
9058: 3860:    public static void main(String[] args) {
9059: 3861:        A a = f(new A());
9060: 3862:    }
9061: 3863:}
9062: 3864:```
9063: 3865:
9064: 3866:这可以防止这个方法被应用于除上述形式的自限定参数之外的任何事物上。
9065: 3867:
9066: 3868:### 参数协变
9067: 3869:
9068: 3870:自限定类型的价值在于它们可以产生*协变参数类型*——方法参数类型会随子类而变化。
9069: 3871:
9070: 3872:尽管自限定类型还可以产生与子类类型相同的返回类型，但是这并不十分重要，因为*协变返回类型*是在 Java 5 引入：
9071: 3873:
9072: 3874:```java
9073: 3875:// generics/CovariantReturnTypes.java
9074: 3876:
9075: 3877:class Base {}
9076: 3878:class Derived extends Base {}
9077: 3879:
9078: 3880:interface OrdinaryGetter {
9079: 3881:    Base get();
9080: 3882:}
9081: 3883:
9082: 3884:interface DerivedGetter extends OrdinaryGetter {
9083: 3885:    // Overridden method return type can vary:
9084: 3886:    @Override
9085: 3887:    Derived get();
9086: 3888:}
9087: 3889:
9088: 3890:public class CovariantReturnTypes {
9089: 3891:    void test(DerivedGetter d) {
9090: 3892:        Derived d2 = d.get();
9091: 3893:    }
9092: 3894:}
9093: 3895:```
9094: 3896:
9095: 3897:**DerivedGetter** 中的 `get()` 方法覆盖了 **OrdinaryGetter** 中的 `get()` ，并返回了一个从 `OrdinaryGetter.get()` 的返回类型中导出的类型。尽管这是完全合乎逻辑的事情（导出类方法应该能够返回比它覆盖的基类方法更具体的类型）但是这在早先的 Java 版本中是不合法的。
9096: 3898:
9097: 3899:自限定泛型事实上将产生确切的导出类型作为其返回值，就像在 `get()` 中所看到的一样：
9098: 3900:
9099: 3901:```java
9100: 3902:// generics/GenericsAndReturnTypes.java
9101: 3903:
9102: 3904:interface GenericGetter<T extends GenericGetter<T>> {
9103: 3905:    T get();
9104: 3906:}
9105: 3907:
9106: 3908:interface Getter extends GenericGetter<Getter> {}
9107: 3909:
9108: 3910:public class GenericsAndReturnTypes {
9109: 3911:    void test(Getter g) {
9110: 3912:        Getter result = g.get();
9111: 3913:        GenericGetter gg = g.get(); // Also the base type
9112: 3914:    }
9113: 3915:}
9114: 3916:```
9115: 3917:
9116: 3918:注意，这段代码不能编译，除非是使用囊括了协变返回类型的 Java 5。
9117: 3919:
9118: 3920:然而，在非泛型代码中，参数类型不能随子类型发生变化：
9119: 3921:
9120: 3922:```java
9121: 3923:// generics/OrdinaryArguments.java
9122: 3924:
9123: 3925:class OrdinarySetter {
9124: 3926:    void set(Base base) {
9125: 3927:        System.out.println("OrdinarySetter.set(Base)");
9126: 3928:    }
9127: 3929:}
9128: 3930:
9129: 3931:class DerivedSetter extends OrdinarySetter {
9130: 3932:    void set(Derived derived) {
9131: 3933:        System.out.println("DerivedSetter.set(Derived)");
9132: 3934:    }
9133: 3935:}
9134: 3936:
9135: 3937:public class OrdinaryArguments {
9136: 3938:    public static void main(String[] args) {
9137: 3939:        Base base = new Base();
9138: 3940:        Derived derived = new Derived();
9139: 3941:        DerivedSetter ds = new DerivedSetter();
9140: 3942:        ds.set(derived);
9141: 3943:        // Compiles--overloaded, not overridden!:
9142: 3944:        ds.set(base);
9143: 3945:    }
9144: 3946:}
9145: 3947:/* Output:
9146: 3948:DerivedSetter.set(Derived)
9147: 3949:OrdinarySetter.set(Base)
9148: 3950:*/
9149: 3951:```
9150: 3952:
9151: 3953:`set(derived)` 和 `set(base)` 都是合法的，因此 `DerivedSetter.set()` 没有覆盖 `OrdinarySetter.set()` ，而是重载了这个方法。从输出中可以看到，在 **DerivedSetter** 中有两个方法，因此基类版本仍旧是可用的，因此可以证明它被重载过。
9152: 3954:但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类型而不是基类型为参数：
9153: 3955:
9154: 3956:```java
9155: 3957:// generics/SelfBoundingAndCovariantArguments.java
9156: 3958:
9157: 3959:interface SelfBoundSetter<T extends SelfBoundSetter<T>> {
9158: 3960:    void set(T arg);
9159: 3961:}
9160: 3962:
9161: 3963:interface Setter extends SelfBoundSetter<Setter> {}
9162: 3964:
9163: 3965:public class SelfBoundingAndCovariantArguments {
9164: 3966:    void
9165: 3967:    testA(Setter s1, Setter s2, SelfBoundSetter sbs) {
9166: 3968:        s1.set(s2);
9167: 3969:        //- s1.set(sbs);
9168: 3970:        // error: method set in interface SelfBoundSetter<T>
9169: 3971:        // cannot be applied to given types;
9170: 3972:        //     s1.set(sbs);
9171: 3973:        //       ^
9172: 3974:        //   required: Setter
9173: 3975:        //   found: SelfBoundSetter
9174: 3976:        //   reason: argument mismatch;
9175: 3977:        // SelfBoundSetter cannot be converted to Setter
9176: 3978:        //   where T is a type-variable:
9177: 3979:        //     T extends SelfBoundSetter<T> declared in
9178: 3980:        //     interface SelfBoundSetter
9179: 3981:        // 1 error
9180: 3982:    }
9181: 3983:}
9182: 3984:```
9183: 3985:
9184: 3986:编译器不能识别将基类型当作参数传递给 `set()` 的尝试，因为没有任何方法具有这样的签名。实际上，这个参数已经被覆盖。
9185: 3987:如果不使用自限定类型，普通的继承机制就会介入，而你将能够重载，就像在非泛型的情况下一样：
9186: 3988:
9187: 3989:```java
9188: 3990:// generics/PlainGenericInheritance.java
9189: 3991:
9190: 3992:class GenericSetter<T> { // Not self-bounded
9191: 3993:    void set(T arg) {
9192: 3994:        System.out.println("GenericSetter.set(Base)");
9193: 3995:    }
9194: 3996:}
9195: 3997:
9196: 3998:class DerivedGS extends GenericSetter<Base> {
9197: 3999:    void set(Derived derived) {
9198: 4000:        System.out.println("DerivedGS.set(Derived)");
9199: 4001:    }
9200: 4002:}
9201: 4003:
9202: 4004:public class PlainGenericInheritance {
9203: 4005:    public static void main(String[] args) {
9204: 4006:        Base base = new Base();
9205: 4007:        Derived derived = new Derived();
9206: 4008:        DerivedGS dgs = new DerivedGS();
9207: 4009:        dgs.set(derived);
9208: 4010:        dgs.set(base); // Overloaded, not overridden!
9209: 4011:    }
9210: 4012:}
9211: 4013:/* Output:
9212: 4014:DerivedGS.set(Derived)
9213: 4015:GenericSetter.set(Base)
9214: 4016:*/
9215: 4017:```
9216: 4018:
9217: 4019:这段代码在模仿 **OrdinaryArguments.java**；在那个示例中，**DerivedSetter** 继承自包含一个 `set(Base)` 的**OrdinarySetter** 。而这里，**DerivedGS** 继承自泛型创建的也包含有一个 `set(Base)`的 `GenericSetter<Base>`。就像 **OrdinaryArguments.java** 一样，你可以从输出中看到， **DerivedGS** 包含两个  `set()` 的重载版本。如果不使用自限定，将重载参数类型。如果使用了自限定，只能获得方法的一个版本，它将接受确切的参数类型。
9218: 4020:
9219: 4021:<!-- Dynamic Type Safety -->
9220: 4022:
9221: 4023:## 动态类型安全
9222: 4024:
9223: 4025:因为可以向 Java 5 之前的代码传递泛型集合，所以旧式代码仍旧有可能会破坏你的集合。Java 5 的 **java.util.Collections** 中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：静态方法 `checkedCollection()` 、`checkedList()`、 `checkedMap()` 、 `checkedSet()` 、`checkedSortedMap()`和 `checkedSortedSet()`。这些方法每一个都会将你希望动态检查的集合当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。
9224: 4026:
9225: 4027:受检查的集合在你试图插入类型不正确的对象时抛出 **ClassCastException** ，这与泛型之前的（原生）集合形成了对比，对于后者来说，当你将对象从集合中取出时，才会通知你出现了问题。在后一种情况中，你知道存在问题，但是不知道罪魁祸首在哪里，如果使用受检查的集合，就可以发现谁在试图插入不良对象。
9226: 4028:让我们用受检查的集合来看看“将猫插入到狗列表中”这个问题。这里，`oldStyleMethod()` 表示遗留代码，因为它接受的是原生的 **List** ，而 **@SuppressWarnings（“unchecked”）** 注解对于压制所产生的警告是必需的：
9227: 4029:
9228: 4030:```java
9229: 4031:// generics/CheckedList.java
9230: 4032:// Using Collection.checkedList()
9231: 4033:import typeinfo.pets.*;
9232: 4034:import java.util.*;
9233: 4035:
9234: 4036:public class CheckedList {
9235: 4037:    @SuppressWarnings("unchecked")
9236: 4038:    static void oldStyleMethod(List probablyDogs) {
9237: 4039:        probablyDogs.add(new Cat());
9238: 4040:    }
9239: 4041:    
9240: 4042:    public static void main(String[] args) {
9241: 4043:        List<Dog> dogs1 = new ArrayList<>();
9242: 4044:        oldStyleMethod(dogs1); // Quietly accepts a Cat
9243: 4045:        List<Dog> dogs2 = Collections.checkedList(
9244: 4046:            new ArrayList<>(), Dog.class);
9245: 4047:        try {
9246: 4048:            oldStyleMethod(dogs2); // Throws an exception
9247: 4049:        } catch(Exception e) {
9248: 4050:            System.out.println("Expected: " + e);
9249: 4051:        }
9250: 4052:        // Derived types work fine:
9251: 4053:        List<Pet> pets = Collections.checkedList(
9252: 4054:            new ArrayList<>(), Pet.class);
9253: 4055:        pets.add(new Dog());
9254: 4056:        pets.add(new Cat());
9255: 4057:    }
9256: 4058:}
9257: 4059:/* Output:
9258: 4060:Expected: java.lang.ClassCastException: Attempt to
9259: 4061:insert class typeinfo.pets.Cat element into collection
9260: 4062:with element type class typeinfo.pets.Dog
9261: 4063:*/
9262: 4064:```
9263: 4065:
9264: 4066:运行这个程序时，你会发现插入一个 **Cat** 对于 **dogs1** 来说没有任何问题，而 **dogs2** 立即会在这个错误类型的插入操作上抛出一个异常。还可以看到，将导出类型的对象放置到将要检查基类型的受检查容器中是没有问题的。
9265: 4067:
9266: 4068:<!-- Exceptions -->
9267: 4069:
9268: 4070:## 泛型异常
9269: 4071:
9270: 4072:由于擦除的原因，**catch** 语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承自 **Throwable**（这将进一步阻止你去定义不能捕获的泛型异常）。
9271: 4073:但是，类型参数可能会在一个方法的 **throws** 子句中用到。这使得你可以编写随检查型异常类型变化的泛型代码：
9272: 4074:
9273: 4075:```java
9274: 4076:// generics/ThrowGenericException.java
9275: 4077:
9276: 4078:import java.util.*;
9277: 4079:
9278: 4080:interface Processor<T, E extends Exception> {
9279: 4081:    void process(List<T> resultCollector) throws E;
9280: 4082:}
9281: 4083:
9282: 4084:class ProcessRunner<T, E extends Exception>
9283: 4085:extends ArrayList<Processor<T, E>> {
9284: 4086:    List<T> processAll() throws E {
9285: 4087:        List<T> resultCollector = new ArrayList<>();
9286: 4088:        for(Processor<T, E> processor : this)
9287: 4089:            processor.process(resultCollector);
9288: 4090:        return resultCollector;
9289: 4091:    }
9290: 4092:}
9291: 4093:
9292: 4094:class Failure1 extends Exception {}
9293: 4095:
9294: 4096:class Processor1
9295: 4097:implements Processor<String, Failure1> {
9296: 4098:    static int count = 3;
9297: 4099:    @Override
9298: 4100:    public void process(List<String> resultCollector)
9299: 4101:    throws Failure1 {
9300: 4102:        if(count-- > 1)
9301: 4103:            resultCollector.add("Hep!");
9302: 4104:        else
9303: 4105:            resultCollector.add("Ho!");
9304: 4106:        if(count < 0)
9305: 4107:            throw new Failure1();
9306: 4108:    }
9307: 4109:}
9308: 4110:
9309: 4111:class Failure2 extends Exception {}
9310: 4112:
9311: 4113:class Processor2
9312: 4114:implements Processor<Integer, Failure2> {
9313: 4115:    static int count = 2;
9314: 4116:    @Override
9315: 4117:    public void process(List<Integer> resultCollector)
9316: 4118:    throws Failure2 {
9317: 4119:        if(count-- == 0)
9318: 4120:            resultCollector.add(47);
9319: 4121:        else {
9320: 4122:            resultCollector.add(11);
9321: 4123:        }
9322: 4124:        if(count < 0)
9323: 4125:            throw new Failure2();
9324: 4126:    }
9325: 4127:}
9326: 4128:
9327: 4129:public class ThrowGenericException {
9328: 4130:    public static void main(String[] args) {
9329: 4131:        ProcessRunner<String, Failure1> runner =
9330: 4132:            new ProcessRunner<>();
9331: 4133:        for(int i = 0; i < 3; i++)
9332: 4134:            runner.add(new Processor1());
9333: 4135:        try {
9334: 4136:            System.out.println(runner.processAll());
9335: 4137:        } catch(Failure1 e) {
9336: 4138:            System.out.println(e);
9337: 4139:        }
9338: 4140:
9339: 4141:        ProcessRunner<Integer, Failure2> runner2 =
9340: 4142:            new ProcessRunner<>();
9341: 4143:        for(int i = 0; i < 3; i++)
9342: 4144:            runner2.add(new Processor2());
9343: 4145:        try {
9344: 4146:            System.out.println(runner2.processAll());
9345: 4147:        } catch(Failure2 e) {
9346: 4148:            System.out.println(e);
9347: 4149:        }
9348: 4150:    }
9349: 4151:}
9350: 4152:/* Output:
9351: 4153:[Hep!, Hep!, Ho!]
9352: 4154:Failure2
9353: 4155:*/
9354: 4156:```
9355: 4157:
9356: 4158:**Processor** 执行 `process()` 方法，并且可能会抛出具有类型 **E** 的异常。`process()` 的结果存储在 `List<T>resultCollector` 中（这被称为*收集参数*）。**ProcessRunner** 有一个 `processAll()` 方法，它会在所持有的每个 **Process** 对象执行，并返回 **resultCollector** 。
9357: 4159:如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出这种泛化的代码。
9358: 4160:
9359: 4161:<!-- Mixins -->
9360: 4162:
9361: 4163:## 混型
9362: 4164:
9363: 4165:术语*混型*随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是你最后的手段，它将使组装多个类变得简单易行。
9364: 4166:混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点*面向切面编程* （AOP） 的味道，而切面经常被建议用来解决混型问题。
9365: 4167:
9366: 4168:### C++ 中的混型
9367: 4169:
9368: 4170:在 C++ 中，使用多重继承的最大理由，就是为了使用混型。但是，对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为混型就是继承自其类型参数的类。在 C++ 中，可以很容易地创建混型，因为 C++ 能够记住其模版参数的类型。
9369: 4171:下面是一个 C++ 示例，它有两个混型类型：一个使得你可以在每个对象中混入拥有一个时间戳这样的属性，而另一个可以混入一个序列号。
9370: 4172:
9371: 4173:```c++
9372: 4174:// generics/Mixins.cpp
9373: 4175:
9374: 4176:#include <string>
9375: 4177:#include <ctime>
9376: 4178:#include <iostream>
9377: 4179:using namespace std;
9378: 4180:
9379: 4181:template<class T> class TimeStamped : public T {
9380: 4182:    long timeStamp;
9381: 4183:public:
9382: 4184:    TimeStamped() { timeStamp = time(0); }
9383: 4185:    long getStamp() { return timeStamp; }
9384: 4186:};
9385: 4187:
9386: 4188:template<class T> class SerialNumbered : public T {
9387: 4189:    long serialNumber;
9388: 4190:    static long counter;
9389: 4191:public:
9390: 4192:    SerialNumbered() { serialNumber = counter++; }
9391: 4193:    long getSerialNumber() { return serialNumber; }
9392: 4194:};
9393: 4195:
9394: 4196:// Define and initialize the static storage:
9395: 4197:template<class T> long SerialNumbered<T>::counter = 1;
9396: 4198:
9397: 4199:class Basic {
9398: 4200:    string value;
9399: 4201:public:
9400: 4202:    void set(string val) { value = val; }
9401: 4203:    string get() { return value; }
9402: 4204:};
9403: 4205:
9404: 4206:int main() {
9405: 4207:    TimeStamped<SerialNumbered<Basic>> mixin1, mixin2;
9406: 4208:    mixin1.set("test string 1");
9407: 4209:    mixin2.set("test string 2");
9408: 4210:    cout << mixin1.get() << " " << mixin1.getStamp() <<
9409: 4211:      " " << mixin1.getSerialNumber() << endl;
9410: 4212:    cout << mixin2.get() << " " << mixin2.getStamp() <<
9411: 4213:      " " << mixin2.getSerialNumber() << endl;
9412: 4214:}
9413: 4215:/* Output:
9414: 4216:test string 1 1452987605 1
9415: 4217:test string 2 1452987605 2
9416: 4218:*/
9417: 4219:```
9418: 4220:
9419: 4221:在 `main()` 中， **mixin1** 和 **mixin2** 所产生的类型拥有所混入类型的所有方法。可以将混型看作是一种功能，它可以将现有类映射到新的子类上。注意，使用这种技术来创建一个混型是多么的轻而易举。基本上，只需要声明“这就是我想要的”，紧跟着它就发生了：
9420: 4222:
9421: 4223:```c++
9422: 4224:TimeStamped<SerialNumbered<Basic>> mixin1，mixin2；
9423: 4225:```
9424: 4226:
9425: 4227:遗憾的是，Java 泛型不允许这样。擦除会忘记基类类型，因此
9426: 4228:
9427: 4229:>  泛型类不能直接继承自一个泛型参数
9428: 4230:
9429: 4231:这突显了许多我在 Java 语言设计决策（以及与这些功能一起发布）中遇到的一大问题：处理一件事很有希望，但是当您实际尝试做一些有趣的事情时，您会发现自己做不到。
9430: 4232:
9431: 4233:### 与接口混合
9432: 4234:
9433: 4235:一种更常见的推荐解决方案是使用接口来产生混型效果，就像下面这样：
9434: 4236:
9435: 4237:```java
9436: 4238:// generics/Mixins.java
9437: 4239:
9438: 4240:import java.util.*;
9439: 4241:
9440: 4242:interface TimeStamped { long getStamp(); }
9441: 4243:
9442: 4244:class TimeStampedImp implements TimeStamped {
9443: 4245:    private final long timeStamp;
9444: 4246:    TimeStampedImp() {
9445: 4247:        timeStamp = new Date().getTime();
9446: 4248:    }
9447: 4249:    @Override
9448: 4250:    public long getStamp() { return timeStamp; }
9449: 4251:}
9450: 4252:
9451: 4253:interface SerialNumbered { long getSerialNumber(); }
9452: 4254:
9453: 4255:class SerialNumberedImp implements SerialNumbered {
9454: 4256:    private static long counter = 1;
9455: 4257:    private final long serialNumber = counter++;
9456: 4258:    @Override
9457: 4259:    public long getSerialNumber() { return serialNumber; }
9458: 4260:}
9459: 4261:
9460: 4262:interface Basic {
9461: 4263:    void set(String val);
9462: 4264:    String get();
9463: 4265:}
9464: 4266:
9465: 4267:class BasicImp implements Basic {
9466: 4268:    private String value;
9467: 4269:    @Override
9468: 4270:    public void set(String val) { value = val; }
9469: 4271:    @Override
9470: 4272:    public String get() { return value; }
9471: 4273:}
9472: 4274:
9473: 4275:class Mixin extends BasicImp
9474: 4276:implements TimeStamped, SerialNumbered {
9475: 4277:    private TimeStamped timeStamp = new TimeStampedImp();
9476: 4278:    private SerialNumbered serialNumber =
9477: 4279:        new SerialNumberedImp();
9478: 4280:    @Override
9479: 4281:    public long getStamp() {
9480: 4282:        return timeStamp.getStamp();
9481: 4283:    }
9482: 4284:    @Override
9483: 4285:    public long getSerialNumber() {
9484: 4286:        return serialNumber.getSerialNumber();
9485: 4287:    }
9486: 4288:}
9487: 4289:
9488: 4290:public class Mixins {
9489: 4291:    public static void main(String[] args) {
9490: 4292:        Mixin mixin1 = new Mixin(), mixin2 = new Mixin();
9491: 4293:        mixin1.set("test string 1");
9492: 4294:        mixin2.set("test string 2");
9493: 4295:        System.out.println(mixin1.get() + " " +
9494: 4296:            mixin1.getStamp() +  " " + mixin1.getSerialNumber());
9495: 4297:        System.out.println(mixin2.get() + " " +
9496: 4298:            mixin2.getStamp() +  " " + mixin2.getSerialNumber());
9497: 4299:    }
9498: 4300:}
9499: 4301:/* Output:
9500: 4302:test string 1 1494331663026 1
9501: 4303:test string 2 1494331663027 2
9502: 4304:*/
9503: 4305:```
9504: 4306:
9505: 4307:**Mixin** 类基本上是在使用*委托*，因此每个混入类型都要求在 **Mixin** 中有一个相应的域，而你必须在 **Mixin** 中编写所有必需的方法，将方法调用转发给恰当的对象。这个示例使用了非常简单的类，但是当使用更复杂的混型时，代码数量会急速增加。[^4]
9506: 4308:
9507: 4309:### 使用装饰器模式
9508: 4310:
9509: 4311:当你观察混型的使用方式时，就会发现混型概念好像与*装饰器*设计模式关系很近。装饰器经常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的。
9510: 4312:装饰器模式使用分层对象来动态透明地向单个对象中添加责任。装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。某些事物是可装饰的，可以通过将其他类包装在这个可装饰对象的四周，来将功能分层。这使得对装饰器的使用是透明的——无论对象是否被装饰，你都拥有一个可以向对象发送的公共消息集。装饰类也可以添加新方法，但是正如你所见，这将是受限的。
9511: 4313:装饰器是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。
9512: 4314:前面的示例可以被改写为使用装饰器：
9513: 4315:
9514: 4316:```java
9515: 4317:// generics/decorator/Decoration.java
9516: 4318:
9517: 4319:// {java generics.decorator.Decoration}
9518: 4320:package generics.decorator;
9519: 4321:import java.util.*;
9520: 4322:
9521: 4323:class Basic {
9522: 4324:    private String value;
9523: 4325:    public void set(String val) { value = val; }
9524: 4326:    public String get() { return value; }
9525: 4327:}
9526: 4328:
9527: 4329:class Decorator extends Basic {
9528: 4330:    protected Basic basic;
9529: 4331:    Decorator(Basic basic) { this.basic = basic; }
9530: 4332:    @Override
9531: 4333:    public void set(String val) { basic.set(val); }
9532: 4334:    @Override
9533: 4335:    public String get() { return basic.get(); }
9534: 4336:}
9535: 4337:
9536: 4338:class TimeStamped extends Decorator {
9537: 4339:    private final long timeStamp;
9538: 4340:    TimeStamped(Basic basic) {
9539: 4341:        super(basic);
9540: 4342:        timeStamp = new Date().getTime();
9541: 4343:    }
9542: 4344:    public long getStamp() { return timeStamp; }
9543: 4345:}
9544: 4346:
9545: 4347:class SerialNumbered extends Decorator {
9546: 4348:    private static long counter = 1;
9547: 4349:    private final long serialNumber = counter++;
9548: 4350:    SerialNumbered(Basic basic) { super(basic); }
9549: 4351:    public long getSerialNumber() { return serialNumber; }
9550: 4352:}
9551: 4353:
9552: 4354:public class Decoration {
9553: 4355:    public static void main(String[] args) {
9554: 4356:        TimeStamped t = new TimeStamped(new Basic());
9555: 4357:        TimeStamped t2 = new TimeStamped(
9556: 4358:            new SerialNumbered(new Basic()));
9557: 4359:        //- t2.getSerialNumber(); // Not available
9558: 4360:        SerialNumbered s = new SerialNumbered(new Basic());
9559: 4361:        SerialNumbered s2 = new SerialNumbered(
9560: 4362:            new TimeStamped(new Basic()));
9561: 4363:        //- s2.getStamp(); // Not available
9562: 4364:  }
9563: 4365:}
9564: 4366:```
9565: 4367:
9566: 4368:产生自泛型的类包含所有感兴趣的方法，但是由使用装饰器所产生的对象类型是最后被装饰的类型。也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。因此，装饰器只是对由混型提出的问题的一种局限的解决方案。
9567: 4369:
9568: 4370:### 与动态代理混合
9569: 4371:
9570: 4372:可以使用动态代理来创建一种比装饰器更贴近混型模型的机制（查看 [类型信息](book/19-Type-Information.md) 一章中关于 Java 的动态代理如何工作的解释）。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。
9571: 4373:由于动态代理的限制，每个被混入的类都必须是某个接口的实现：
9572: 4374:
9573: 4375:```java
9574: 4376:// generics/DynamicProxyMixin.java
9575: 4377:
9576: 4378:import java.lang.reflect.*;
9577: 4379:import java.util.*;
9578: 4380:import onjava.*;
9579: 4381:import static onjava.Tuple.*;
9580: 4382:
9581: 4383:class MixinProxy implements InvocationHandler {
9582: 4384:    Map<String, Object> delegatesByMethod;
9583: 4385:    @SuppressWarnings("unchecked")
9584: 4386:    MixinProxy(Tuple2<Object, Class<?>>... pairs) {
9585: 4387:        delegatesByMethod = new HashMap<>();
9586: 4388:        for(Tuple2<Object, Class<?>> pair : pairs) {
9587: 4389:            for(Method method : pair.a2.getMethods()) {
9588: 4390:                String methodName = method.getName();
9589: 4391:                // The first interface in the map
9590: 4392:                // implements the method.
9591: 4393:                if(!delegatesByMethod.containsKey(methodName))
9592: 4394:                    delegatesByMethod.put(methodName, pair.a1);
9593: 4395:            }
9594: 4396:        }
9595: 4397:    }
9596: 4398:    @Override
9597: 4399:    public Object invoke(Object proxy, Method method,
9598: 4400:      Object[] args) throws Throwable {
9599: 4401:        String methodName = method.getName();
9600: 4402:        Object delegate = delegatesByMethod.get(methodName);
9601: 4403:        return method.invoke(delegate, args);
9602: 4404:    }
9603: 4405:    
9604: 4406:    @SuppressWarnings("unchecked")
9605: 4407:    public static Object newInstance(Tuple2... pairs) {
9606: 4408:        Class[] interfaces = new Class[pairs.length];
9607: 4409:        for(int i = 0; i < pairs.length; i++) {
9608: 4410:            interfaces[i] = (Class)pairs[i].a2;
9609: 4411:        }
9610: 4412:        ClassLoader cl = pairs[0].a1.getClass().getClassLoader();
9611: 4413:        return Proxy.newProxyInstance(cl, interfaces, new MixinProxy(pairs));
9612: 4414:    }
9613: 4415:}
9614: 4416:
9615: 4417:public class DynamicProxyMixin {
9616: 4418:    public static void main(String[] args) {
9617: 4419:        Object mixin = MixinProxy.newInstance(
9618: 4420:          tuple(new BasicImp(), Basic.class),
9619: 4421:          tuple(new TimeStampedImp(), TimeStamped.class),
9620: 4422:          tuple(new SerialNumberedImp(), SerialNumbered.class));
9621: 4423:        Basic b = (Basic)mixin;
9622: 4424:        TimeStamped t = (TimeStamped)mixin;
9623: 4425:        SerialNumbered s = (SerialNumbered)mixin;
9624: 4426:        b.set("Hello");
9625: 4427:        System.out.println(b.get());
9626: 4428:        System.out.println(t.getStamp());
9627: 4429:        System.out.println(s.getSerialNumber());
9628: 4430:    }
9629: 4431:}
9630: 4432:/* Output:
9631: 4433:Hello
9632: 4434:1494331653339
9633: 4435:1
9634: 4436:*/
9635: 4437:```
9636: 4438:
9637: 4439:因为只有动态类型而不是静态类型才包含所有的混入类型，因此这仍旧不如 C++ 的方式好，因为可以在具有这些类型的对象上调用方法之前，你被强制要求必须先将这些对象向下转型到恰当的类型。但是，它明显地更接近于真正的混型。
9638: 4440:为了让 Java 支持混型，人们已经做了大量的工作朝着这个目标努力，包括创建了至少一种附加语言（ Jam 语言），它是专门用来支持混型的。
9639: 4441:
9640: 4442:<!-- Latent Typing -->
9641: 4443:
9642: 4444:## 潜在类型机制
9643: 4445:
9644: 4446:在本章的开头介绍过这样的思想，即要编写能够尽可能广泛地应用的代码。为了实现这一点，我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处。然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码。
9645: 4447:
9646: 4448:Java 泛型看起来是向这一方向迈进了一步。当你在编写或使用只是持有对象的泛型时，这些代码将可以工作于任何类型（除了基本类型，尽管正如你所见到的，自动装箱机制可以克服这一点）。或者，换个角度讲，“持有器”泛型能够声明：“我不关心你是什么类型”。如果代码不关心它将要作用的类型，那么这种代码就可以真正地应用于任何地方，并因此而相当泛化。
9647: 4449:
9648: 4450:还是正如你所见到的，当要在泛型类型上执行操作（即调用 **Object** 方法之外的方法）时，就会产生问题。擦除强制要求指定可能会用到的泛型类型的边界，以安全地调用代码中的泛型对象上的具体方法。这是对“泛化”概念的一种明显的限制，因为必须限制你的泛型类型，使它们继承自特定的类，或者实现特定的接口。在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类或接口没有任何区别。
9649: 4451:
9650: 4452:某些编程语言提供的一种解决方案称为*潜在类型机制*或*结构化类型机制*，而更古怪的术语称为*鸭子类型机制*，即“如果它走起来像鸭子，并且叫起来也像鸭子，那么你就可以将它当作鸭子对待。”鸭子类型机制变成了一种相当流行的术语，可能是因为它不像其他的术语那样承载着历史的包袱。
9651: 4453:
9652: 4454:泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得你可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以 `speak()` 和 `sit()` 即可。”由于不要求具体类型，因此代码就可以更加泛化。
9653: 4455:
9654: 4456:潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方。
9655: 4457:
9656: 4458:支持潜在类型机制的语言包括 Python（可以从 www.Python.org 免费下载）、C++、Ruby、SmallTalk 和 Go。Python 是动态类型语言（几乎所有的类型检查都发生在运行时），而 C++ 和 Go 是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查。
9657: 4459:
9658: 4460:### pyhton 中的潜在类型
9659: 4461:
9660: 4462:如果我们将上面的描述用 Python 来表示，如下所示：
9661: 4463:
9662: 4464:```python
9663: 4465:# generics/DogsAndRobots.py
9664: 4466:
9665: 4467:class Dog:
9666: 4468:    def speak(self):
9667: 4469:        print("Arf!")
9668: 4470:    def sit(self):
9669: 4471:        print("Sitting")
9670: 4472:    def reproduce(self):
9671: 4473:        pass
9672: 4474:
9673: 4475:class Robot:
9674: 4476:    def speak(self):
9675: 4477:        print("Click!")
9676: 4478:    def sit(self):
9677: 4479:        print("Clank!")
9678: 4480:    def oilChange(self):
9679: 4481:        pass
9680: 4482:
9681: 4483:def perform(anything):
9682: 4484:    anything.speak()
9683: 4485:    anything.sit()
9684: 4486:
9685: 4487:a = Dog()
9686: 4488:b = Robot()
9687: 4489:perform(a)
9688: 4490:perform(b)
9689: 4491:
9690: 4492:output = """
9691: 4493:Arf!
9692: 4494:Sitting
9693: 4495:Click!
9694: 4496:Clank!
9695: 4497:"""
9696: 4498:```
9697: 4499:
9698: 4500:Python 使用缩进来确定作用域（因此不需要任何花括号），而冒号将表示新的作用域的开始。“**#**” 表示注释到行尾，就像Java中的 “ **//** ”。类的方法需要显式地指定 **this** 引用的等价物作为第一个参数，按惯例成为 **self** 。构造器调用不要求任何类型的“ **new** ”关键字，并且 Python 允许普通（非成员）函数，就像 `perform()` 所表明的那样。注意，在 `perform(anything)` 中，没有任何针对 **anything** 的类型，**anything** 只是一个标识符，它必须能够执行 `perform()` 期望它执行的操作，因此这里隐含着一个接口。但是你从来都不必显式地写出这个接口——它是潜在的。`perform()` 不关心其参数的类型，因此我可以向它传递任何对象，只要该对象支持  `speak()` 和 `sit()` 方法。如果传递给 `perform()` 的对象不支持这些操作，那么将会得到运行时异常。
9699: 4501:
9700: 4502:输出规定使用三重引号创建带有内嵌换行符的字符串。
9701: 4503:
9702: 4504:### C++ 中的潜在类型
9703: 4505:
9704: 4506:我们可以用 C++ 产生相同的效果：
9705: 4507:
9706: 4508:```c++
9707: 4509:// generics/DogsAndRobots.cpp
9708: 4510:
9709: 4511:#include <iostream>
9710: 4512:using namespace std;
9711: 4513:
9712: 4514:class Dog {
9713: 4515:public:
9714: 4516:    void speak() { cout << "Arf!" << endl; }
9715: 4517:    void sit() { cout << "Sitting" << endl; }
9716: 4518:    void reproduce() {}
9717: 4519:};
9718: 4520:
9719: 4521:class Robot {
9720: 4522:public:
9721: 4523:    void speak() { cout << "Click!" << endl; }
9722: 4524:    void sit() { cout << "Clank!" << endl; }
9723: 4525:    void oilChange() {}
9724: 4526:};
9725: 4527:
9726: 4528:template<class T> void perform(T anything) {
9727: 4529:    anything.speak();
9728: 4530:    anything.sit();
9729: 4531:}
9730: 4532:
9731: 4533:int main() {
9732: 4534:    Dog d;
9733: 4535:    Robot r;
9734: 4536:    perform(d);
9735: 4537:    perform(r);
9736: 4538:}
9737: 4539:/* Output:
9738: 4540:Arf!
9739: 4541:Sitting
9740: 4542:Click!
9741: 4543:Clank!
9742: 4544:*/
9743: 4545:```
9744: 4546:
9745: 4547:在 Python 和 C++ 中，**Dog** 和 **Robot** 没有任何共同的东西，只是碰巧有两个方法具有相同的签名。从类型的观点看，它们是完全不同的类型。但是，`perform()` 不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。
9746: 4548:C++ 确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给你一个错误消息（这些错误消息从历史上看是相当可怕和冗长的，是 C++ 的模版名声欠佳的主要原因）。尽管它们是在不同时期实现这一点的，C++ 在编译期，而 Python 在运行时，但是这两种语言都可以确保类型不会被误用，因此被认为是强类型的。[^5]潜在类型机制没有损害强类型机制。
9747: 4549:
9748: 4550:### Go 中的潜在类型
9749: 4551:
9750: 4552:这里用 Go 语言编写相同的程序：
9751: 4553:
9752: 4554:```go
9753: 4555:// generics/dogsandrobots.go
9754: 4556:
9755: 4557:package main
9756: 4558:import "fmt"
9757: 4559:
9758: 4560:type Dog struct {}
9759: 4561:func (this Dog) speak() { fmt.Printf("Arf!\n")}
9760: 4562:func (this Dog) sit() { fmt.Printf("Sitting\n")}
9761: 4563:func (this Dog) reproduce() {}
9762: 4564:
9763: 4565:type Robot struct {}
9764: 4566:func (this Robot) speak() { fmt.Printf("Click!\n") }
9765: 4567:func (this Robot) sit() { fmt.Printf("Clank!\n") }
9766: 4568:func (this Robot) oilChange() {}
9767: 4569:
9768: 4570:func perform(speaker interface { speak(); sit() }) {
9769: 4571:  speaker.speak();
9770: 4572:  speaker.sit();
9771: 4573:}
9772: 4574:
9773: 4575:func main() {
9774: 4576:  perform(Dog{})
9775: 4577:  perform(Robot{})
9776: 4578:}
9777: 4579:/* Output:
9778: 4580:Arf!
9779: 4581:Sitting
9780: 4582:Click!
9781: 4583:Clank!
9782: 4584:*/
9783: 4585:```
9784: 4586:
9785: 4587:Go 没有 **class** 关键字，但是可以使用上述形式创建等效的基本类：它通常不定义为类，而是定义为 **struct** ，在其中定义数据字段（此处不存在）。 对于每种方法，都以 **func** 关键字开头，然后（为了将该方法附加到您的类上）放在括号中，该括号包含对象引用，该对象引用可以是任何标识符，但是我在这里使用 **this** 来提醒您，就像在 C ++ 或 Java 中的 **this** 一样。 然后，在Go中像这样定义其余的函数。
9786: 4588:
9787: 4589:Go也没有继承关系，因此这种“面向对象的目标”形式是相对原始的，并且可能是我无法花更多的时间来学习该语言的主要原因。 但是，Go 的组成很简单。
9788: 4590:
9789: 4591:`perform()` 函数使用潜在类型：参数的确切类型并不重要，只要它包含了 `speak()` 和  `sit()` 方法即可。 该接口在此处匿名定义，内联，如 `perform()` 的参数列表所示。
9790: 4592:
9791: 4593:`main()` 证明 `perform()` 确实对其参数的确切类型不在乎，只要可以在该参数上调用 `talk()` 和 `sit()` 即可。 但是，就像 C ++ 模板函数一样，在编译时检查类型。
9792: 4594:
9793: 4595:语法 **Dog {}** 和 **Robot {}** 创建匿名的 **Dog** 和 **Robot** 结构。
9794: 4596:
9795: 4597:### java中的直接潜在类型
9796: 4598:
9797: 4599:因为泛型是在这场竞赛的后期才添加到 Java 中，因此没有任何机会可以去实现任何类型的潜在类型机制，因此 Java 没有对这种特性的支持。所以，初看起来，Java 的泛型机制比支持潜在类型机制的语言更“缺乏泛化性”。（使用擦除来实现 Java 泛型的实现有时称为第二类泛型类型）例如，在 Java 8  之前如果我们试图用 Java 实现上面 dogs-and-robots 的示例，那么就会被强制要求使用一个类或接口，并在边界表达式中指定它：
9798: 4600:
9799: 4601:```java
9800: 4602:// generics/Performs.java
9801: 4603:
9802: 4604:public interface Performs {
9803: 4605:    void speak();
9804: 4606:    void sit();
9805: 4607:}
9806: 4608:```
9807: 4609:
9808: 4610:```java
9809: 4611:// generics/DogsAndRobots.java
9810: 4612:// No (direct) latent typing in Java
9811: 4613:import typeinfo.pets.*;
9812: 4614:
9813: 4615:class PerformingDog extends Dog implements Performs {
9814: 4616:    @Override
9815: 4617:    public void speak() { System.out.println("Woof!"); }
9816: 4618:    @Override
9817: 4619:    public void sit() { System.out.println("Sitting"); }
9818: 4620:    public void reproduce() {}
9819: 4621:}
9820: 4622:
9821: 4623:class Robot implements Performs {
9822: 4624:    public void speak() { System.out.println("Click!"); }
9823: 4625:    public void sit() { System.out.println("Clank!"); }
9824: 4626:    public void oilChange() {}
9825: 4627:}
9826: 4628:
9827: 4629:class Communicate {
9828: 4630:    public static <T extends Performs>
9829: 4631:      void perform(T performer) {
9830: 4632:        performer.speak();
9831: 4633:        performer.sit();
9832: 4634:    }
9833: 4635:}
9834: 4636:
9835: 4637:public class DogsAndRobots {
9836: 4638:    public static void main(String[] args) {
9837: 4639:        Communicate.perform(new PerformingDog());
9838: 4640:        Communicate.perform(new Robot());
9839: 4641:    }
9840: 4642:}
9841: 4643:/* Output:
9842: 4644:Woof!
9843: 4645:Sitting
9844: 4646:Click!
9845: 4647:Clank!
9846: 4648:*/
9847: 4649:```
9848: 4650:
9849: 4651:但是要注意，`perform()` 不需要使用泛型来工作，它可以被简单地指定为接受一个 **Performs** 对象：
9850: 4652:
9851: 4653:```java
9852: 4654:// generics/SimpleDogsAndRobots.java
9853: 4655:// Removing the generic; code still works
9854: 4656:
9855: 4657:class CommunicateSimply {
9856: 4658:    static void perform(Performs performer) {
9857: 4659:        performer.speak();
9858: 4660:        performer.sit();
9859: 4661:    }
9860: 4662:}
9861: 4663:
9862: 4664:public class SimpleDogsAndRobots {
9863: 4665:    public static void main(String[] args) {
9864: 4666:        CommunicateSimply.perform(new PerformingDog());
9865: 4667:        CommunicateSimply.perform(new Robot());
9866: 4668:    }
9867: 4669:}
9868: 4670:/* Output:
9869: 4671:Woof!
9870: 4672:Sitting
9871: 4673:Click!
9872: 4674:Clank!
9873: 4675:*/
9874: 4676:```
9875: 4677:
9876: 4678:在本例中，泛型不是必需的，因为这些类已经被强制要求实现 **Performs** 接口。
9877: 4679:
9878: 4680:<!-- Compensating for the Lack of (Direct) Latent -->
9879: 4681:
9880: 4682:## 对缺乏潜在类型机制的补偿
9881: 4683:
9882: 4684:尽管 Java 不直接支持潜在类型机制，但是这并不意味着泛型代码不能在不同的类型层次结构之间应用。也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。
9883: 4685:
9884: 4686:### 反射
9885: 4687:
9886: 4688:可以使用的一种方式是反射，下面的 `perform()` 方法就是用了潜在类型机制：
9887: 4689:
9888: 4690:```java
9889: 4691:// generics/LatentReflection.java
9890: 4692:// Using reflection for latent typing
9891: 4693:import java.lang.reflect.*;
9892: 4694:
9893: 4695:// Does not implement Performs:
9894: 4696:class Mime {
9895: 4697:    public void walkAgainstTheWind() {}
9896: 4698:    public void sit() {
9897: 4699:        System.out.println("Pretending to sit");
9898: 4700:    }
9899: 4701:    public void pushInvisibleWalls() {}
9900: 4702:    @Override
9901: 4703:    public String toString() { return "Mime"; }
9902: 4704:}
9903: 4705:
9904: 4706:// Does not implement Performs:
9905: 4707:class SmartDog {
9906: 4708:    public void speak() { System.out.println("Woof!"); }
9907: 4709:    public void sit() { System.out.println("Sitting"); }
9908: 4710:    public void reproduce() {}
9909: 4711:}
9910: 4712:
9911: 4713:class CommunicateReflectively {
9912: 4714:    public static void perform(Object speaker) {
9913: 4715:        Class<?> spkr = speaker.getClass();
9914: 4716:        try {
9915: 4717:            try {
9916: 4718:                Method speak = spkr.getMethod("speak");
9917: 4719:                speak.invoke(speaker);
9918: 4720:            } catch(NoSuchMethodException e) {
9919: 4721:                System.out.println(speaker + " cannot speak");
9920: 4722:            }
9921: 4723:            try {
9922: 4724:                Method sit = spkr.getMethod("sit");
9923: 4725:                sit.invoke(speaker);
9924: 4726:            } catch(NoSuchMethodException e) {
9925: 4727:                System.out.println(speaker + " cannot sit");
9926: 4728:            }
9927: 4729:        } catch(SecurityException |
9928: 4730:            IllegalAccessException |
9929: 4731:            IllegalArgumentException |
9930: 4732:            InvocationTargetException e) {
9931: 4733:            throw new RuntimeException(speaker.toString(), e);
9932: 4734:        }
9933: 4735:    }
9934: 4736:}
9935: 4737:
9936: 4738:public class LatentReflection {
9937: 4739:    public static void main(String[] args) {
9938: 4740:        CommunicateReflectively.perform(new SmartDog());
9939: 4741:        CommunicateReflectively.perform(new Robot());
9940: 4742:        CommunicateReflectively.perform(new Mime());
9941: 4743:    }
9942: 4744:}
9943: 4745:/* Output:
9944: 4746:Woof!
9945: 4747:Sitting
9946: 4748:Click!
9947: 4749:Clank!
9948: 4750:Mime cannot speak
9949: 4751:Pretending to sit
9950: 4752:*/
9951: 4753:```
9952: 4754:
9953: 4755:上例中，这些类完全是彼此分离的，没有任何公共基类（除了 **Object** ）或接口。通过反射, `CommunicateReflectively.perform()` 能够动态地确定所需要的方法是否可用并调用它们。它甚至能够处理 **Mime** 只具有一个必需的方法这一事实，并能够部分实现其目标。
9954: 4756:
9955: 4757:### 将一个方法应用于序列
9956: 4758:
9957: 4759:反射提供了一些有用的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。但是有可能实现编译期类型检查和潜在类型机制吗？
9958: 4760:
9959: 4761:让我们看一个说明这个问题的示例。假设想要创建一个 `apply()` 方法，它能够将任何方法应用于某个序列中的所有对象。这种情况下使用接口不适合，因为你想要将任何方法应用于一个对象集合，而接口不可能描述任何方法。如何用 Java 来实现这个需求呢？
9960: 4762:
9961: 4763:最初，我们可以用反射来解决这个问题，由于有了 Java 的可变参数，这种方式被证明是相当优雅的：
9962: 4764:
9963: 4765:```java
9964: 4766:// generics/Apply.java
9965: 4767:
9966: 4768:import java.lang.reflect.*;
9967: 4769:import java.util.*;
9968: 4770:
9969: 4771:public class Apply {
9970: 4772:    public static <T, S extends Iterable<T>>
9971: 4773:      void apply(S seq, Method f, Object... args) {
9972: 4774:        try {
9973: 4775:            for(T t: seq)
9974: 4776:                f.invoke(t, args);
9975: 4777:        } catch(IllegalAccessException |
9976: 4778:            IllegalArgumentException |
9977: 4779:            InvocationTargetException e) {
9978: 4780:            // Failures are programmer errors
9979: 4781:            throw new RuntimeException(e);
9980: 4782:        }
9981: 4783:    }
9982: 4784:}
9983: 4785:```
9984: 4786:
9985: 4787:在 **Apply.java** 中，异常被转换为 **RuntimeException** ，因为没有多少办法可以从这种异常中恢复——在这种情况下，它们实际上代表着程序员的错误。
9986: 4788:
9987: 4789:为什么我们不只使用 Java 8 方法参考（稍后显示）而不是反射方法 **f** ？ 注意，`invoke()` 和 `apply()` 的优点是它们可以接受任意数量的参数。 在某些情况下，灵活性可能至关重要。
9988: 4790:
9989: 4791:为了测试 **Apply** ，我们首先创建一个 **Shape** 类：
9990: 4792:
9991: 4793:```java
9992: 4794:// generics/Shape.java
9993: 4795:
9994: 4796:public class Shape {
9995: 4797:    private static long counter = 0;
9996: 4798:    private final long id = counter++;
9997: 4799:    @Override
9998: 4800:    public String toString() {
9999: 4801:        return getClass().getSimpleName() + " " + id;
10000: 4802:    }
10001: 4803:    public void rotate() {
10002: 4804:        System.out.println(this + " rotate");
10003: 4805:    }
10004: 4806:    public void resize(int newSize) {
10005: 4807:        System.out.println(this + " resize " + newSize);
10006: 4808:    }
10007: 4809:}
10008: 4810:```
10009: 4811:
10010: 4812:被一个子类 **Square** 继承：
10011: 4813:
10012: 4814:```java
10013: 4815:// generics/Square.java
10014: 4816:
10015: 4817:public class Square extends Shape {}
10016: 4818:```
10017: 4819:
10018: 4820:通过这些，我们可以测试 **Apply**：
10019: 4821:
10020: 4822:```java
10021: 4823:// generics/ApplyTest.java
10022: 4824:
10023: 4825:import java.util.*;
10024: 4826:import java.util.function.*;
10025: 4827:import onjava.*;
10026: 4828:
10027: 4829:public class ApplyTest {
10028: 4830:    public static
10029: 4831:    void main(String[] args) throws Exception {
10030: 4832:        List<Shape> shapes =
10031: 4833:          Suppliers.create(ArrayList::new, Shape::new, 3);
10032: 4834:        Apply.apply(shapes, Shape.class.getMethod("rotate"));
10033: 4835:        Apply.apply(shapes, Shape.class.getMethod("resize", int.class), 7);
10034: 4836:
10035: 4837:        List<Square> squares =
10036: 4838:          Suppliers.create(ArrayList::new, Square::new, 3);
10037: 4839:        Apply.apply(squares, Shape.class.getMethod("rotate"));
10038: 4840:        Apply.apply(squares, Shape.class.getMethod("resize", int.class), 7);
10039: 4841:
10040: 4842:        Apply.apply(new FilledList<>(Shape::new, 3),
10041: 4843:          Shape.class.getMethod("rotate"));
10042: 4844:        Apply.apply(new FilledList<>(Square::new, 3),
10043: 4845:          Shape.class.getMethod("rotate"));
10044: 4846:
10045: 4847:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
10046: 4848:          new SimpleQueue<>(), SimpleQueue::add,
10047: 4849:          Shape::new, 3);
10048: 4850:        Suppliers.fill(shapeQ, SimpleQueue::add,
10049: 4851:          Square::new, 3);
10050: 4852:        Apply.apply(shapeQ, Shape.class.getMethod("rotate"));
10051: 4853:    }
10052: 4854:}
10053: 4855:/* Output:
10054: 4856:Shape 0 rotate
10055: 4857:Shape 1 rotate
10056: 4858:Shape 2 rotate
10057: 4859:Shape 0 resize 7
10058: 4860:Shape 1 resize 7
10059: 4861:Shape 2 resize 7
10060: 4862:Square 3 rotate
10061: 4863:Square 4 rotate
10062: 4864:Square 5 rotate
10063: 4865:Square 3 resize 7
10064: 4866:Square 4 resize 7
10065: 4867:Square 5 resize 7
10066: 4868:Shape 6 rotate
10067: 4869:Shape 7 rotate
10068: 4870:Shape 8 rotate
10069: 4871:Square 9 rotate
10070: 4872:Square 10 rotate
10071: 4873:Square 11 rotate
10072: 4874:Shape 12 rotate
10073: 4875:Shape 13 rotate
10074: 4876:Shape 14 rotate
10075: 4877:Square 15 rotate
10076: 4878:Square 16 rotate
10077: 4879:Square 17 rotate
10078: 4880:*/
10079: 4881:```
10080: 4882:
10081: 4883:在 **Apply** 中，我们运气很好，因为碰巧在 Java 中内建了一个由 Java 集合类库使用的 **Iterable** 接口。正由于此， `apply()` 方法可以接受任何实现了 **Iterable** 接口的事物，包括诸如 **List** 这样的所有 **Collection** 类。但是它还可以接受其他任何事物，只要能够使这些事物是 **Iterable** 的——例如，在 `main()` 中使用下面定义的 **SimpleQueue** 类：
10082: 4884:
10083: 4885:```java
10084: 4886:// generics/SimpleQueue.java
10085: 4887:
10086: 4888:// A different kind of Iterable collection
10087: 4889:import java.util.*;
10088: 4890:
10089: 4891:public class SimpleQueue<T> implements Iterable<T> {
10090: 4892:    private LinkedList<T> storage = new LinkedList<>();
10091: 4893:    public void add(T t) { storage.offer(t); }
10092: 4894:    public T get() { return storage.poll(); }
10093: 4895:    @Override
10094: 4896:    public Iterator<T> iterator() {
10095: 4897:        return storage.iterator();
10096: 4898:    }
10097: 4899:}
10098: 4900:```
10099: 4901:
10100: 4902:正如反射解决方案看起来那样优雅，我们必须观察到反射（尽管在 Java 的最新版本中得到了显着改进）通常比非反射实现要慢，因为在运行时发生了很多事情。 但它不应阻止您尝试这种解决方案，这依然是值得考虑的一点。
10101: 4903:
10102: 4904:几乎可以肯定，你会首先使用 Java 8 的函数式方法，并且只有在解决了特殊需求时才诉诸反射。 这里对 **ApplyTest.java** 进行了重写，以利用 Java 8 的流和函数工具：
10103: 4905:
10104: 4906:```java
10105: 4907:// generics/ApplyFunctional.java
10106: 4908:
10107: 4909:import java.util.*;
10108: 4910:import java.util.stream.*;
10109: 4911:import java.util.function.*;
10110: 4912:import onjava.*;
10111: 4913:
10112: 4914:public class ApplyFunctional {
10113: 4915:    public static void main(String[] args) {
10114: 4916:        Stream.of(
10115: 4917:          Stream.generate(Shape::new).limit(2),
10116: 4918:          Stream.generate(Square::new).limit(2))
10117: 4919:        .flatMap(c -> c) // flatten into one stream
10118: 4920:        .peek(Shape::rotate)
10119: 4921:        .forEach(s -> s.resize(7));
10120: 4922:
10121: 4923:        new FilledList<>(Shape::new, 2)
10122: 4924:          .forEach(Shape::rotate);
10123: 4925:        new FilledList<>(Square::new, 2)
10124: 4926:          .forEach(Shape::rotate);
10125: 4927:
10126: 4928:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
10127: 4929:          new SimpleQueue<>(), SimpleQueue::add,
10128: 4930:          Shape::new, 2);
10129: 4931:        Suppliers.fill(shapeQ, SimpleQueue::add,
10130: 4932:          Square::new, 2);
10131: 4933:        shapeQ.forEach(Shape::rotate);
10132: 4934:    }
10133: 4935:}
10134: 4936:/* Output:
10135: 4937:Shape 0 rotate
10136: 4938:Shape 0 resize 7
10137: 4939:Shape 1 rotate
10138: 4940:Shape 1 resize 7
10139: 4941:Square 2 rotate
10140: 4942:Square 2 resize 7
10141: 4943:Square 3 rotate
10142: 4944:Square 3 resize 7
10143: 4945:Shape 4 rotate
10144: 4946:Shape 5 rotate
10145: 4947:Square 6 rotate
10146: 4948:Square 7 rotate
10147: 4949:Shape 8 rotate
10148: 4950:Shape 9 rotate
10149: 4951:Square 10 rotate
10150: 4952:Square 11 rotate
10151: 4953:*/
10152: 4954:```
10153: 4955:
10154: 4956:由于使用 Java 8，因此不需要 `Apply.apply()` 。
10155: 4957:
10156: 4958:我们首先生成两个 **Stream** ： 一个是 **Shape** ，一个是 **Square** ，并将它们展平为单个流。 尽管 Java 缺少功能语言中经常出现的 `flatten()` ，但是我们可以使用 `flatMap(c-> c)` 产生相同的结果，后者使用身份映射将操作简化为“  **flatten** ”。
10157: 4959:
10158: 4960:我们使用 `peek()` 当做对 `rotate()` 的调用，因为 `peek()` 执行一个操作（此处是出于副作用），并在未更改的情况下传递对象。
10159: 4961:
10160: 4962:注意，使用 **FilledList** 和 **shapeQ** 调用 `forEach()` 比 `Apply.apply()` 代码整洁得多。 在代码简单性和可读性方面，结果比以前的方法好得多。 并且，现在也不可能从  `main()` 引发异常。
10161: 4963:
10162: 4964:<!-- Assisted Latent Typing in Java 8 -->
10163: 4965:
10164: 4966:## Java8 中的辅助潜在类型
10165: 4967:
10166: 4968:先前声明关于 Java 缺乏对潜在类型的支持在 Java 8 之前是完全正确的。但是，Java 8 中的非绑定方法引用使我们能够产生一种潜在类型的形式，以满足创建一段可工作在不相干类型上的代码。因为 Java 最初并不是如此设计，所以结果可想而知，比其他语言中要尴尬一些。但是，至少现在成为了可能，只是缺乏令人惊艳之处。
10167: 4969:
10168: 4970:我在其他地方从没遇过这种技术，因此我将其称为辅助潜在类型。
10169: 4971:
10170: 4972:我们将重写 **DogsAndRobots.java** 来演示该技术。 为使外观看起来与原始示例尽可能相似，我仅向每个原始类名添加了 **A**：
10171: 4973:
10172: 4974:```java
10173: 4975:// generics/DogsAndRobotMethodReferences.java
10174: 4976:
10175: 4977:// "Assisted Latent Typing"
10176: 4978:import typeinfo.pets.*;
10177: 4979:import java.util.function.*;
10178: 4980:
10179: 4981:class PerformingDogA extends Dog {
10180: 4982:    public void speak() { System.out.println("Woof!"); }
10181: 4983:    public void sit() { System.out.println("Sitting"); }
10182: 4984:    public void reproduce() {}
10183: 4985:}
10184: 4986:
10185: 4987:class RobotA {
10186: 4988:    public void speak() { System.out.println("Click!"); }
10187: 4989:    public void sit() { System.out.println("Clank!"); }
10188: 4990:    public void oilChange() {}
10189: 4991:}
10190: 4992:
10191: 4993:class CommunicateA {
10192: 4994:    public static <P> void perform(P performer,
10193: 4995:      Consumer<P> action1, Consumer<P> action2) {
10194: 4996:        action1.accept(performer);
10195: 4997:        action2.accept(performer);
10196: 4998:    }
10197: 4999:}
10198: 5000:
10199: 5001:public class DogsAndRobotMethodReferences {
10200: 5002:    public static void main(String[] args) {
10201: 5003:        CommunicateA.perform(new PerformingDogA(),
10202: 5004:          PerformingDogA::speak, PerformingDogA::sit);
10203: 5005:        CommunicateA.perform(new RobotA(),
10204: 5006:          RobotA::speak, RobotA::sit);
10205: 5007:        CommunicateA.perform(new Mime(),
10206: 5008:          Mime::walkAgainstTheWind,
10207: 5009:          Mime::pushInvisibleWalls);
10208: 5010:    }
10209: 5011:}
10210: 5012:/* Output:
10211: 5013:Woof!
10212: 5014:Sitting
10213: 5015:Click!
10214: 5016:Clank!
10215: 5017:*/
10216: 5018:```
10217: 5019:
10218: 5020:**PerformingDogA** 和 **RobotA** 与 **DogsAndRobots.java** 中的相同，不同之处在于它们不继承通用接口 **Performs** ，因此它们没有通用性。
10219: 5021:
10220: 5022:`CommunicateA.perform()` 在没有约束的 **P** 上生成。 只要可以使用 `Consumer <P>`，它在这里就可以是任何东西，这些 `Consumer<P>` 代表不带参数的 **P** 方法的未绑定方法引用。当您调用 **Consumer**  的 `accept()` 方法时，它将方法引用绑定到执行者对象并调用该方法。 由于 [函数式编程](book/13-Functional-Programming.md) 一章中描述的“魔术”，我们可以将任何符合签名的未绑定方法引用传递给 `CommunicateA.perform()` 。
10221: 5023:
10222: 5024:之所以称其为“辅助”，是因为您必须显式地为 `perform()` 提供要使用的方法引用。 它不能只按名称调用方法。
10223: 5025:
10224: 5026:尽管传递未绑定的方法引用似乎要花很多力气，但潜在类型的最终目标还是可以实现的。 我们创建了一个代码片段 `CommunicateA.perform()` ，该代码可用于任何具有符合签名的方法引用的类型。 请注意，这与我们看到的其他语言中的潜在类型有所不同，因为这些语言不仅需要签名以符合规范，还需要方法名称。 因此，该技术可以说产生了更多的通用代码。
10225: 5027:
10226: 5028:为了证明这一点，我还从 **LatentReflection.java** 中引入了 **Mime**。
10227: 5029:
10228: 5030:### 使用**Suppliers**类的通用方法
10229: 5031:
10230: 5032:通过辅助潜在类型，我们可以定义本章其他部分中使用的 **Suppliers** 类。 此类包含使用生成器填充 **Collection** 的工具方法。 泛化这些操作很有意义：
10231: 5033:
10232: 5034:```java
10233: 5035:// onjava/Suppliers.java
10234: 5036:
10235: 5037:// A utility to use with Suppliers
10236: 5038:package onjava;
10237: 5039:import java.util.*;
10238: 5040:import java.util.function.*;
10239: 5041:import java.util.stream.*;
10240: 5042:
10241: 5043:public class Suppliers {
10242: 5044:    // Create a collection and fill it:
10243: 5045:    public static <T, C extends Collection<T>> C
10244: 5046:      create(Supplier<C> factory, Supplier<T> gen, int n) {
10245: 5047:        return Stream.generate(gen)
10246: 5048:            .limit(n)
10247: 5049:            .collect(factory, C::add, C::addAll);
10248: 5050:    }
10249: 5051:    
10250: 5052:    // Fill an existing collection:
10251: 5053:    public static <T, C extends Collection<T>>
10252: 5054:      C fill(C coll, Supplier<T> gen, int n) {
10253: 5055:        Stream.generate(gen)
10254: 5056:            .limit(n)
10255: 5057:            .forEach(coll::add);
10256: 5058:        return coll;
10257: 5059:    }
10258: 5060:    
10259: 5061:    // Use an unbound method reference to
10260: 5062:    // produce a more general method:
10261: 5063:    public static <H, A> H fill(H holder,
10262: 5064:      BiConsumer<H, A> adder, Supplier<A> gen, int n) {
10263: 5065:        Stream.generate(gen)
10264: 5066:            .limit(n)
10265: 5067:            .forEach(a -> adder.accept(holder, a));
10266: 5068:        return holder;
10267: 5069:    }
10268: 5070:}
10269: 5071:```
10270: 5072:
10271: 5073:`create()` 为你创建一个新的 **Collection** 子类型，而 `fill()` 的第一个版本将元素放入 **Collection** 的现有子类型中。 请注意，还会返回传入的容器的确切类型，因此不会丢失类型信息。[^6]
10272: 5074:
10273: 5075:前两种方法一般都受约束，只能与 **Collection** 子类型一起使用。`fill()` 的第二个版本适用于任何类型的 **holder** 。 它需要一个附加参数：未绑定方法引用 `adder. fill()` ，使用辅助潜在类型来使其与任何具有添加元素方法的 **holder** 类型一起使用。因为此未绑定方法 **adder** 必须带有一个参数（要添加到 **holder** 的元素），所以 **adder** 必须是 `BiConsumer <H，A>` ，其中 **H** 是要绑定到的 **holder** 对象的类型，而 **A** 是要被添加的绑定元素类型。 对 `accept()` 的调用将使用参数 a 调用对象 **holder** 上的未绑定方法 **holder**。
10274: 5076:
10275: 5077:在一个稍作模拟的测试中对 **Suppliers** 工具程序进行了测试，该仿真还使用了本章前面定义的 **RandomList** ：
10276: 5078:
10277: 5079:```java
10278: 5080:// generics/BankTeller.java
10279: 5081:
10280: 5082:// A very simple bank teller simulation
10281: 5083:import java.util.*;
10282: 5084:import onjava.*;
10283: 5085:
10284: 5086:class Customer {
10285: 5087:    private static long counter = 1;
10286: 5088:    private final long id = counter++;
10287: 5089:    @Override
10288: 5090:    public String toString() {
10289: 5091:        return "Customer " + id;
10290: 5092:    }
10291: 5093:}
10292: 5094:
10293: 5095:class Teller {
10294: 5096:    private static long counter = 1;
10295: 5097:    private final long id = counter++;
10296: 5098:    @Override
10297: 5099:    public String toString() {
10298: 5100:        return "Teller " + id;
10299: 5101:    }
10300: 5102:}
10301: 5103:
10302: 5104:class Bank {
10303: 5105:    private List<BankTeller> tellers =
10304: 5106:        new ArrayList<>();
10305: 5107:    public void put(BankTeller bt) {
10306: 5108:        tellers.add(bt);
10307: 5109:    }
10308: 5110:}
10309: 5111:
10310: 5112:public class BankTeller {
10311: 5113:    public static void serve(Teller t, Customer c) {
10312: 5114:        System.out.println(t + " serves " + c);
10313: 5115:    }
10314: 5116:    public static void main(String[] args) {
10315: 5117:        // Demonstrate create():
10316: 5118:        RandomList<Teller> tellers =
10317: 5119:            Suppliers.create(
10318: 5120:            RandomList::new, Teller::new, 4);
10319: 5121:        // Demonstrate fill():
10320: 5122:        List<Customer> customers = Suppliers.fill(
10321: 5123:            new ArrayList<>(), Customer::new, 12);
10322: 5124:        customers.forEach(c ->
10323: 5125:            serve(tellers.select(), c));
10324: 5126:        // Demonstrate assisted latent typing:
10325: 5127:        Bank bank = Suppliers.fill(
10326: 5128:            new Bank(), Bank::put, BankTeller::new, 3);
10327: 5129:        // Can also use second version of fill():
10328: 5130:        List<Customer> customers2 = Suppliers.fill(
10329: 5131:            new ArrayList<>(),
10330: 5132:            List::add, Customer::new, 12);
10331: 5133:    }
10332: 5134:}
10333: 5135:/* Output:
10334: 5136:Teller 3 serves Customer 1
10335: 5137:Teller 2 serves Customer 2
10336: 5138:Teller 3 serves Customer 3
10337: 5139:Teller 1 serves Customer 4
10338: 5140:Teller 1 serves Customer 5
10339: 5141:Teller 3 serves Customer 6
10340: 5142:Teller 1 serves Customer 7
10341: 5143:Teller 2 serves Customer 8
10342: 5144:Teller 3 serves Customer 9
10343: 5145:Teller 3 serves Customer 10
10344: 5146:Teller 2 serves Customer 11
10345: 5147:Teller 4 serves Customer 12
10346: 5148:*/
10347: 5149:```
10348: 5150:
10349: 5151:可以看到 `create()` 生成一个新的 **Collection** 对象，而 `fill()` 添加到现有 **Collection** 中。第二个版本`fill()` 显示，它不仅与无关的新类型 **Bank** 一起使用，还能与 **List** 一起使用。因此，从技术上讲，`fill()` 的第一个版本在技术上不是必需的，但在使用 **Collection** 时提供了较短的语法。
10350: 5152:
10351: 5153:<!-- Summary: Is Casting Really So Bad? -->
10352: 5154:
10353: 5155:## 总结：类型转换真的如此之糟吗？
10354: 5156:
10355: 5157:自从 C++ 模版出现以来，我就一直在致力于解释它，我可能比大多数人都更早地提出了下面的论点。直到最近，我才停下来，去思考这个论点到底在多少时间内是有效的——我将要描述的问题到底有多少次可以穿越障碍得以解决。
10356: 5158:
10357: 5159:这个论点就是：使用泛型类型机制的最吸引人的地方，就是在使用集合类的地方，这些类包括诸如各种 **List** 、各种 **Set** 、各种 **Map** 等你在 [集合](book/12-Collections.md) 和 [附录：集合主题](book/Appendix-Collection-Topics.md) 这两章所见。在 Java 5 之前，当你将一个对象放置到集合中时，这个对象就会被向上转型为 **Object** ，因此你会丢失类型信息。当你想要将这个对象从集合中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。我用的示例是持有 **Cat** 的 **List** （这个示例的一种使用苹果和桔子的变体在 [集合](book/12-Collections.md) 章节的开头展示过）。如果没有 Java 5 泛型版本的集合，你放到容集里和从集合中取回的都是 **Object** 。因此，我们很可能会将一个 **Dog** 放置到 **Cat** 的 **List** 中。
10358: 5160:
10359: 5161:但是，泛型出现之前的 Java 并不会让你误用放入到集合中的对象。如果将一个 **Dog** 扔到 **Cat** 的集合中，并且试图将这个集合中的所有东西都当作 **Cat** 处理，那么当你从这个 **Cat** 集合中取回那个 **Dog** 引用，并试图将其转型为 **Cat** 时，就会得到一个 **RuntimeException** 。你仍旧可以发现问题，但是是在运行时而非编译期发现它的。
10360: 5162:
10361: 5163:在本书以前的版本中，我曾经说过：
10362: 5164:
10363: 5165:> 这不止令人恼火，它还可能会产生难以发现的缺陷。如果这个程序的某个部分（或数个部分）向集合中插入了对象，并且通过异常，你在程序的另一个独立的部分中发现有不良对象被放置到了集合中，那么必须发现这个不良插入到底是在何处发生的。
10364: 5166:
10365: 5167:但是，随着对这个论点的进一步检查，我开始怀疑它了。首先，这会多么频繁地发生呢？我记得这类事情从未发生在我身上，并且当我在会议上询问其他人时，我也从来没有听说过有人碰上过。另一本书使用了一个称为 **files** 的 list 示例，它包含 **String** 对象。在这个示例中，向 **files** 中添加一个 **File** 对象看起来相当自然，因此这个对象的名字可能叫 **fileNames** 更好。无论 Java 提供了多少类型检查，仍旧可能会写出晦涩的程序，而编写差劲儿的程序即便可以编译，它仍旧是编写差劲儿的程序。可能大多数人都会使用命名良好的集合，例如 **cats** ，因为它们可以向试图添加非 **Cat** 对象的程序员提供可视的警告。并且即便这类事情发生了，它真正又能潜伏多久呢？只要你开始用真实数据来运行测试，就会非常快地看到异常。
10366: 5168:
10367: 5169:有一位作者甚至断言，这样的缺陷将“*潜伏数年*”。但是我不记得有任何大量的相关报告，来说明人们在查找“狗在猫列表中”这类缺陷时困难重重，或者是说明人们会非常频繁地产生这种错误。然而，你将在 [多线程编程](book/24-Concurrent-Programming.md) 章节中看到，在使用线程时，出现那些可能看起来极罕见的缺陷，是很寻常并容易发生的事，而且，对于到底出了什么错，这些缺陷只能给你一个很模糊的概念。因此，对于泛型是添加到 Java 中的非常显著和相当复杂的特性这一点，“狗在猫列表中”这个论据真的能够成为它的理由吗？
10368: 5170:我相信被称为*泛型*的通用语言特性（并非必须是其在 Java 中的特定实现）的目的在于可表达性，而不仅仅是为了创建类型安全的集合。类型安全的集合是能够创建更通用代码这一能力所带来的副作用。
10369: 5171:因此，即便“狗在猫列表中”这个论据经常被用来证明泛型是必要的，但是它仍旧是有问题的。就像我在本章开头声称的，我不相信这就是泛型这个概念真正的含义。相反，泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。正如你在本章中看到的，编写真正泛化的“持有器”类（ Java 的容器就是这种类）相当简单，但是编写出能够操作其泛型类型的泛化代码就需要额外的努力了，这些努力需要类创建者和类消费者共同付出，他们必须理解这些代码的概念和实现。这些额外的努力会增加使用这种特性的难度，并可能会因此而使其在某些场合缺乏可应用性，而在这些场合中，它可能会带来附加的价值。
10370: 5172:
10371: 5173:还要注意到，因为泛型是后来添加到 Java 中，而不是从一开始就设计到这种语言中的，所以某些容器无法达到它们应该具备的健壮性。例如，观察一下 **Map** ，在特定的方法 `containsKey(Object key) `和 `get(Object key)` 中就包含这类情况。如果这些类是使用在它们之前就存在的泛型设计的，那么这些方法将会使用参数化类型而不是 **Object** ，因此也就可以提供这些泛型假设会提供的编译期检查。例如，在 C++ 的 **map** 中，键的类型总是在编译期检查的。
10372: 5174:
10373: 5175:有一件事很明显：在一种语言已经被广泛应用之后，在其较新的版本中引入任何种类的泛型机制，都会是一项非常非常棘手的任务，并且是一项不付出艰辛就无法完成的任务。在 C++ 中，模版是在其最初的 ISO 版本中就引入的（即便如此，也引发了阵痛，因为在第一个标准 C++ 出现之前，有很多非模版版本在使用），因此实际上模版一直都是这种语言的一部分。在 Java 中，泛型是在这种语言首次发布大约 10 年之后才引入的，因此向泛型迁移的问题特别多，并且对泛型的设计产生了明显的影响。其结果就是，程序员将承受这些痛苦，而这一切都是由于 Java 设计者在设计 1.0 版本时所表现出来的短视造成的。当 Java 最初被创建时，它的设计者们当然了解 C++ 的模版，他们甚至考虑将其囊括到 Java 语言中，但是出于这样或那样的原因，他们决定将模版排除在外（其迹象就是他们过于匆忙）。因此， Java 语言和使用它的程序员都将承受这些痛苦。只有时间将会说明 Java 的泛型方式对这种语言所造成的最终影响。
10374: 5176:某些语言，已经融入了更简洁、影响更小的方式，来实现参数化类型。我们不可能不去想象这样的语言将会成为 Java 的继任者，因为它们采用的方式，与 C++ 通过 C 来实现的方式相同：按原样使用它，然后对其进行改进。
10375: 5177:
10376: 5178:## 进阶阅读
10377: 5179:
10378: 5180:泛型的入门文档是 《Generics in the Java Programming Language》，作者是 Gilad Bracha，可以从 http://java.oracle.com 获取。
10379: 5181:
10380: 5182:Angelika Langer 的《Java Generics FAQs》是一份非常有帮助的资料，可以从 http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html 获取。
10381: 5183:
10382: 5184:你可以从 《Adding Wildcards to the Java Programming Language》中学到更多关于通配符的知识，作者是 Torgerson、Ernst、Hansen、von der Ahe、Bracha 和 Gafter，地址是 http://www.jot.fm/issues/issue_2004_12/article5。
10383: 5185:
10384: 5186:Neal After 对于 Java 问题（尤其是擦除）的看法可以从这里找到：http://www.infoq.com/articles/neal-gafter-on-java。
10385: 5187:
10386: 5188:[^1]: 在编写本章期间，Angelika Langer的 Java 泛型常见问题解答以及她的其他著作（与Klaus Kreft一起）是非常宝贵的。
10387: 5189:[^2]: [http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html](http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html)
10388: 5190:[^3]: 参见本章章末引文。
10389: 5191:[^4]: 注意，一些编程环境，如 Eclipse 和 IntelliJ IDEA，将会自动生成委托代码。
10390: 5192:[^5]: 因为可以使用转型，有效地禁止了类型系统，一些人就认为 C++ 是弱类型，但这太极端了。一种可能更好的说法是 C++ 是有一道暗门的强类型语言。
10391: 5193:[^6]: 我再次从 Brian Goetz 那获得帮助。
10392: 5194:
10393: 5195:<!-- 分页 -->
10394: 5196:
10395: 5197:<div style="page-break-after: always;"></div>
10396: 
10397: 1:[TOC]
10398: 2:
10399: 3:<!-- Generics -->
10400: 4:
10401: 5:# 第二十章 泛型
10402: 6:
10403: 7:> 普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。
10404: 8:
10405: 9:多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。除了 `final` 类（或只提供私有构造函数的类）任何类型都可被扩展，所以大部分时候这种灵活性是自带的。
10406: 10:
10407: 11:拘泥于单一的继承体系太过局限，因为只有继承体系中的对象才能适用基类作为参数的方法中。如果方法以接口而不是类作为参数，限制就宽松多了，只要实现了接口就可以。这给予调用方一种选项，通过调整现有的类来实现接口，满足方法参数要求。接口可以突破继承体系的限制。
10408: 12:
10409: 13:即便是接口也还是有诸多限制。一旦指定了接口，它就要求你的代码必须使用特定的接口。而我们希望编写更通用的代码，能够适用“非特定的类型”，而不是一个具体的接口或类。
10410: 14:
10411: 15:这就是泛型的概念，是 Java 5 的重大变化之一。泛型实现了*参数化类型*，这样你编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。随后你会发现 Java 中泛型的实现并没有那么“泛”，你可能会质疑“泛型”这个词是否合适用来描述这一功能。
10412: 16:
10413: 17:如果你从未接触过参数化类型机制，你会发现泛型对 Java 语言确实是个很有益的补充。在你实例化一个类型参数时，编译器会负责转型并确保类型的正确性。这是一大进步。
10414: 18:
10415: 19:然而，如果你了解其他语言（例如 C++ ）的参数化机制，你会发现，Java 泛型并不能满足所有的预期。使用别人创建好的泛型相对容易，但是创建自己的泛型时，就会遇到很多意料之外的麻烦。
10416: 20:
10417: 21:这并不是说 Java 泛型毫无用处。在很多情况下，它可以使代码更直接更优雅。不过，如果你见识过那种实现了更纯粹的泛型的编程语言，那么，Java 可能会令你失望。本章会介绍 Java 泛型的优点与局限。我会解释 Java 的泛型是如何发展成现在这样的，希望能够帮助你更有效地使用这个特性。[^1]
10418: 22:
10419: 23:### 与 C++ 的比较
10420: 24:
10421: 25:Java 的设计者曾说过，这门语言的灵感主要来自 C++ 。尽管如此，学习 Java 时基本不用参考 C++ 。
10422: 26:
10423: 27:但是，Java 中的泛型需要与 C++ 进行对比，理由有两个：首先，理解 C++ *模板*（泛型的主要灵感来源，包括基本语法）的某些特性，有助于理解泛型的基础理念。同时，非常重要的一点是，你可以了解 Java 泛型的局限是什么，以及为什么会有这些局限。最终的目标是明确 Java 泛型的边界，让你成为一个程序高手。只有知道了某个技术不能做什么，你才能更好地做到所能做的（部分原因是，不必浪费时间在死胡同里）。
10424: 28:
10425: 29:第二个原因是，在 Java 社区中，大家普遍对 C++ 模板有一种误解，而这种误解可能会令你在理解泛型的意图时产生偏差。
10426: 30:
10427: 31:因此，本章中会介绍少量 C++ 模板的例子，仅当它们确实可以加深理解时才会引入。
10428: 32:
10429: 33:<!-- Simple Generics -->
10430: 34:
10431: 35:## 简单泛型
10432: 36:
10433: 37:促成泛型出现的最主要的动机之一是为了创建*集合类*，参见 [集合](book/12-Collections.md) 章节。集合用于存放要使用到的对象。数组也是如此，不过集合比数组更加灵活，功能更丰富。几乎所有程序在运行过程中都会涉及到一组对象，因此集合是可复用性最高的类库之一。
10434: 38:
10435: 39:我们先看一个只能持有单个对象的类。这个类可以明确指定其持有的对象的类型：
10436: 40:
10437: 41:```java
10438: 42:// generics/Holder1.java
10439: 43:
10440: 44:class Automobile {}
10441: 45:
10442: 46:public class Holder1 {
10443: 47:    private Automobile a;
10444: 48:    public Holder1(Automobile a) { this.a = a; }
10445: 49:    Automobile get() { return a; }
10446: 50:}
10447: 51:```
10448: 52:
10449: 53:这个类的可复用性不高，它无法持有其他类型的对象。我们可不希望为碰到的每个类型都编写一个新的类。
10450: 54:
10451: 55:在 Java 5 之前，我们可以让这个类直接持有 `Object` 类型的对象：
10452: 56:
10453: 57:```java
10454: 58:// generics/ObjectHolder.java
10455: 59:
10456: 60:public class ObjectHolder {
10457: 61:    private Object a;
10458: 62:    public ObjectHolder(Object a) { this.a = a; }
10459: 63:    public void set(Object a) { this.a = a; }
10460: 64:    public Object get() { return a; }
10461: 65:    
10462: 66:    public static void main(String[] args) {
10463: 67:        ObjectHolder h2 = new ObjectHolder(new Automobile());
10464: 68:        Automobile a = (Automobile)h2.get();
10465: 69:        h2.set("Not an Automobile");
10466: 70:        String s = (String)h2.get();
10467: 71:        h2.set(1); // 自动装箱为 Integer
10468: 72:        Integer x = (Integer)h2.get();
10469: 73:    }
10470: 74:}
10471: 75:```
10472: 76:
10473: 77:现在，`ObjectHolder` 可以持有任何类型的对象，在上面的示例中，一个 `ObjectHolder` 先后持有了三种不同类型的对象。
10474: 78:
10475: 79:一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。
10476: 80:
10477: 81:因此，与其使用 `Object` ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用*类型参数*，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，`T` 就是类型参数：
10478: 82:
10479: 83:```java
10480: 84:// generics/GenericHolder.java
10481: 85:
10482: 86:public class GenericHolder<T> {
10483: 87:    private T a;
10484: 88:    public GenericHolder() {}
10485: 89:    public void set(T a) { this.a = a; }
10486: 90:    public T get() { return a; }
10487: 91:    
10488: 92:    public static void main(String[] args) {
10489: 93:        GenericHolder<Automobile> h3 = new GenericHolder<Automobile>();
10490: 94:        h3.set(new Automobile()); // 此处有类型校验
10491: 95:        Automobile a = h3.get();  // 无需类型转换
10492: 96:        //- h3.set("Not an Automobile"); // 报错
10493: 97:        //- h3.set(1);  // 报错
10494: 98:    }
10495: 99:}
10496: 100:```
10497: 101:
10498: 102:创建 `GenericHolder` 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 `main()` 中那样使用。然后，你就只能在 `GenericHolder` 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当你调用 `get()` 取值时，直接就是正确的类型。
10499: 103:
10500: 104:这就是 Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。
10501: 105:
10502: 106:你可能注意到 `h3` 的定义非常繁复。在 `=` 左边有 `GenericHolder<Automobile>`, 右边又重复了一次。在 Java 5 中，这种写法被解释成“必要的”，但在 Java 7 中设计者修正了这个问题（新的简写语法随后成为备受欢迎的特性）。以下是简写的例子：
10503: 107:
10504: 108:```java
10505: 109:// generics/Diamond.java
10506: 110:
10507: 111:class Bob {}
10508: 112:
10509: 113:public class Diamond<T> {
10510: 114:    public static void main(String[] args) {
10511: 115:        GenericHolder<Bob> h3 = new GenericHolder<>();
10512: 116:        h3.set(new Bob());
10513: 117:    }
10514: 118:}
10515: 119:```
10516: 120:
10517: 121:注意，在 `h3` 的定义处，`=` 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。在本书剩余部分都会使用这种语法。
10518: 122:
10519: 123:一般来说，你可以认为泛型和其他类型差不多，只不过它们碰巧有类型参数罢了。在使用泛型时，你只需要指定它们的名称和类型参数列表即可。
10520: 124:
10521: 125:### 一个元组类库
10522: 126:
10523: 127:有时一个方法需要能返回多个对象。而 **return** 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得了编译时的类型安全。
10524: 128:
10525: 129:这个概念称为*元组*，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 *数据传输对象* 或 *信使* ）。
10526: 130:
10527: 131:通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组：
10528: 132:
10529: 133:```java
10530: 134:// onjava/Tuple2.java
10531: 135:package onjava;
10532: 136:
10533: 137:public class Tuple2<A, B> {
10534: 138:    public final A a1;
10535: 139:    public final B a2;
10536: 140:    public Tuple2(A a, B b) { a1 = a; a2 = b; }
10537: 141:    public String rep() { return a1 + ", " + a2; }
10538: 142:  
10539: 143:    @Override
10540: 144:    public String toString() {
10541: 145:        return "(" + rep() + ")";
10542: 146:    }
10543: 147:}
10544: 148:```
10545: 149:
10546: 150:构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。
10547: 151:
10548: 152:初次阅读上面的代码时，你可能认为这违反了 Java 编程的封装原则。`a1` 和 `a2` 应该声明为 **private**，然后提供 `getFirst()` 和 `getSecond()` 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取 `a1` 和 `a2` 然后对它们执行任何操作，但无法对 `a1` 和 `a2` 重新赋值。例子中的 `final` 可以实现同样的效果，并且更为简洁明了。
10549: 153:
10550: 154:另一种设计思路是允许元组的用户给 `a1` 和 `a2` 重新赋值。然而，采用上例中的形式无疑更加安全，如果用户想存储不同的元素，就会强制他们创建新的 `Tuple2` 对象。
10551: 155:
10552: 156:我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了：
10553: 157:
10554: 158:```java
10555: 159:// onjava/Tuple3.java
10556: 160:package onjava;
10557: 161:
10558: 162:public class Tuple3<A, B, C> extends Tuple2<A, B> {
10559: 163:    public final C a3;
10560: 164:    public Tuple3(A a, B b, C c) {
10561: 165:        super(a, b);
10562: 166:        a3 = c;
10563: 167:    }
10564: 168:    
10565: 169:    @Override
10566: 170:    public String rep() {
10567: 171:        return super.rep() + ", " + a3;
10568: 172:    }
10569: 173:}
10570: 174:
10571: 175:// onjava/Tuple4.java
10572: 176:package onjava;
10573: 177:
10574: 178:public class Tuple4<A, B, C, D>
10575: 179:  extends Tuple3<A, B, C> {
10576: 180:    public final D a4;
10577: 181:    public Tuple4(A a, B b, C c, D d) {
10578: 182:        super(a, b, c);
10579: 183:        a4 = d;
10580: 184:    }
10581: 185:    
10582: 186:    @Override
10583: 187:    public String rep() {
10584: 188:        return super.rep() + ", " + a4;
10585: 189:    }
10586: 190:}
10587: 191:
10588: 192:// onjava/Tuple5.java
10589: 193:package onjava;
10590: 194:
10591: 195:public class Tuple5<A, B, C, D, E>
10592: 196:  extends Tuple4<A, B, C, D> {
10593: 197:    public final E a5;
10594: 198:    public Tuple5(A a, B b, C c, D d, E e) {
10595: 199:        super(a, b, c, d);
10596: 200:        a5 = e;
10597: 201:    }
10598: 202:    
10599: 203:    @Override
10600: 204:    public String rep() {
10601: 205:        return super.rep() + ", " + a5;
10602: 206:    }
10603: 207:}
10604: 208:```
10605: 209:
10606: 210:演示需要，再定义两个类：
10607: 211:
10608: 212:```java
10609: 213:// generics/Amphibian.java
10610: 214:public class Amphibian {}
10611: 215:
10612: 216:// generics/Vehicle.java
10613: 217:public class Vehicle {}
10614: 218:```
10615: 219:
10616: 220:使用元组时，你只需要定义一个长度适合的元组，将其作为返回值即可。注意下面例子中方法的返回类型：
10617: 221:
10618: 222:```java
10619: 223:// generics/TupleTest.java
10620: 224:import onjava.*;
10621: 225:
10622: 226:public class TupleTest {
10623: 227:    static Tuple2<String, Integer> f() {
10624: 228:        // 47 自动装箱为 Integer
10625: 229:        return new Tuple2<>("hi", 47);
10626: 230:    }
10627: 231:  
10628: 232:    static Tuple3<Amphibian, String, Integer> g() {
10629: 233:        return new Tuple3<>(new Amphibian(), "hi", 47);
10630: 234:    }
10631: 235:  
10632: 236:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
10633: 237:        return new Tuple4<>(new Vehicle(), new Amphibian(), "hi", 47);
10634: 238:    }
10635: 239:  
10636: 240:    static Tuple5<Vehicle, Amphibian, String, Integer, Double> k() {
10637: 241:        return new Tuple5<>(new Vehicle(), new Amphibian(), "hi", 47, 11.1);
10638: 242:    }
10639: 243:  
10640: 244:    public static void main(String[] args) {
10641: 245:        Tuple2<String, Integer> ttsi = f();
10642: 246:        System.out.println(ttsi);
10643: 247:        // ttsi.a1 = "there"; // 编译错误，因为 final 不能重新赋值
10644: 248:        System.out.println(g());
10645: 249:        System.out.println(h());
10646: 250:        System.out.println(k());
10647: 251:    }
10648: 252:}
10649: 253:
10650: 254:/* 输出：
10651: 255: (hi, 47)
10652: 256: (Amphibian@1540e19d, hi, 47)
10653: 257: (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47)
10654: 258: (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1)
10655: 259: */
10656: 260:```
10657: 261:
10658: 262:有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。
10659: 263:
10660: 264:通过 `ttsi.a1 = "there"` 语句的报错，我们可以看出，**final** 声明确实可以确保 **public** 字段在对象被构造出来之后就不能重新赋值了。
10661: 265:
10662: 266:在上面的程序中，`new` 表达式有些啰嗦。本章稍后会介绍，如何利用 *泛型方法* 简化它们。
10663: 267:
10664: 268:### 一个堆栈类
10665: 269:
10666: 270:接下来我们看一个稍微复杂一点的例子：堆栈。在 [集合](book/12-Collections.md) 一章中，我们用 `LinkedList` 实现了 `onjava.Stack` 类。在那个例子中，`LinkedList` 本身已经具备了创建堆栈所需的方法。`Stack` 是通过两个泛型类 `Stack<T>` 和 `LinkedList<T>` 的组合来创建。我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。
10667: 271:
10668: 272:这次我们不用 `LinkedList` 来实现自己的内部链式存储机制。
10669: 273:
10670: 274:```java
10671: 275:// generics/LinkedStack.java
10672: 276:// 用链式结构实现的堆栈
10673: 277:
10674: 278:public class LinkedStack<T> {
10675: 279:    private static class Node<U> {
10676: 280:        U item;
10677: 281:        Node<U> next;
10678: 282:    
10679: 283:        Node() { item = null; next = null; }
10680: 284:        
10681: 285:        Node(U item, Node<U> next) {
10682: 286:            this.item = item;
10683: 287:            this.next = next;
10684: 288:        }
10685: 289:    
10686: 290:        boolean end() {
10687: 291:            return item == null && next == null;
10688: 292:        }
10689: 293:    }
10690: 294:  
10691: 295:    private Node<T> top = new Node<>();  // 栈顶
10692: 296:  
10693: 297:    public void push(T item) {
10694: 298:        top = new Node<>(item, top);
10695: 299:    }
10696: 300:  
10697: 301:    public T pop() {
10698: 302:        T result = top.item;
10699: 303:        if (!top.end()) {
10700: 304:            top = top.next;
10701: 305:        }
10702: 306:        return result;
10703: 307:    }
10704: 308:  
10705: 309:    public static void main(String[] args) {
10706: 310:        LinkedStack<String> lss = new LinkedStack<>();
10707: 311:        for (String s : "Phasers on stun!".split(" ")) {
10708: 312:            lss.push(s);
10709: 313:        }
10710: 314:        String s;
10711: 315:        while ((s = lss.pop()) != null) {
10712: 316:            System.out.println(s);
10713: 317:        }
10714: 318:    }
10715: 319:}
10716: 320:```
10717: 321:
10718: 322:输出结果：
10719: 323:
10720: 324:```java
10721: 325:stun!
10722: 326:on
10723: 327:Phasers
10724: 328:```
10725: 329:
10726: 330:内部类 `Node` 也是一个泛型，它拥有自己的类型参数。
10727: 331:
10728: 332:这个例子使用了一个 *末端标识* (end sentinel) 来判断栈何时为空。这个末端标识是在构造 `LinkedStack` 时创建的。然后，每次调用 `push()` 就会创建一个 `Node<T>` 对象，并将其链接到前一个 `Node<T>` 对象。当你调用 `pop()` 方法时，总是返回 `top.item`，然后丢弃当前 `top` 所指向的 `Node<T>`，并将 `top` 指向下一个 `Node<T>`，除非到达末端标识，这时就不能再移动 `top` 了。如果已经到达末端，程序还继续调用 `pop()` 方法，它只能得到 `null`，说明栈已经空了。
10729: 333:
10730: 334:### RandomList
10731: 335:
10732: 336:作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 `select()` 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型：
10733: 337:
10734: 338:```java
10735: 339:// generics/RandomList.java
10736: 340:import java.util.*;
10737: 341:import java.util.stream.*;
10738: 342:
10739: 343:public class RandomList<T> extends ArrayList<T> {
10740: 344:    private Random rand = new Random(47);
10741: 345:  
10742: 346:    public T select() {
10743: 347:        return get(rand.nextInt(size()));
10744: 348:    }
10745: 349:  
10746: 350:    public static void main(String[] args) {
10747: 351:        RandomList<String> rs = new RandomList<>();
10748: 352:        Arrays.stream("The quick brown fox jumped over the lazy brown dog".split(" ")).forEach(rs::add);
10749: 353:        IntStream.range(0, 11).forEach(i -> 
10750: 354:            System.out.print(rs.select() + " "));
10751: 355:    }
10752: 356:}
10753: 357:```
10754: 358:
10755: 359:输出结果：
10756: 360:
10757: 361:```java
10758: 362:brown over fox quick quick dog brown The brown lazy brown
10759: 363:```
10760: 364:
10761: 365:`RandomList` 继承了 `ArrayList` 的所有方法。本例中只添加了 `select()` 这个方法。
10762: 366:
10763: 367:<!-- Generic Interfaces -->
10764: 368:
10765: 369:## 泛型接口
10766: 370:
10767: 371:泛型也可以应用于接口。例如 *生成器*，这是一种专门负责创建对象的类。实际上，这是 *工厂方法* 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。
10768: 372:
10769: 373:一般而言，一个生成器只定义一个方法，用于创建对象。例如 `java.util.function` 类库中的 `Supplier` 就是一个生成器，调用其 `get()` 获取对象。`get()` 是泛型方法，返回值为类型参数 `T`。
10770: 374:
10771: 375:为了演示 `Supplier`，我们需要定义几个类。下面是个咖啡相关的继承体系：
10772: 376:
10773: 377:```java
10774: 378:// generics/coffee/Coffee.java
10775: 379:package generics.coffee;
10776: 380:
10777: 381:public class Coffee {
10778: 382:    private static long counter = 0;
10779: 383:    private final long id = counter++;
10780: 384:  
10781: 385:    @Override
10782: 386:    public String toString() {
10783: 387:        return getClass().getSimpleName() + " " + id;
10784: 388:    }
10785: 389:}
10786: 390:
10787: 391:
10788: 392:// generics/coffee/Latte.java
10789: 393:package generics.coffee;
10790: 394:public class Latte extends Coffee {}
10791: 395:
10792: 396:
10793: 397:// generics/coffee/Mocha.java
10794: 398:package generics.coffee;
10795: 399:public class Mocha extends Coffee {}
10796: 400:
10797: 401:
10798: 402:// generics/coffee/Cappuccino.java
10799: 403:package generics.coffee;
10800: 404:public class Cappuccino extends Coffee {}
10801: 405:
10802: 406:
10803: 407:// generics/coffee/Americano.java
10804: 408:package generics.coffee;
10805: 409:public class Americano extends Coffee {}
10806: 410:
10807: 411:
10808: 412:// generics/coffee/Breve.java
10809: 413:package generics.coffee;
10810: 414:public class Breve extends Coffee {}
10811: 415:```
10812: 416:
10813: 417:现在，我们可以编写一个类，实现 `Supplier<Coffee>` 接口，它能够随机生成不同类型的 `Coffee` 对象：
10814: 418:
10815: 419:```java
10816: 420:// generics/coffee/CoffeeSupplier.java
10817: 421:// {java generics.coffee.CoffeeSupplier}
10818: 422:package generics.coffee;
10819: 423:import java.util.*;
10820: 424:import java.util.function.*;
10821: 425:import java.util.stream.*;
10822: 426:
10823: 427:public class CoffeeSupplier
10824: 428:implements Supplier<Coffee>, Iterable<Coffee> {
10825: 429:    private Class<?>[] types = { Latte.class, Mocha.class, 
10826: 430:        Cappuccino.class, Americano.class, Breve.class };
10827: 431:    private static Random rand = new Random(47);
10828: 432:  
10829: 433:    public CoffeeSupplier() {}
10830: 434:    // For iteration:
10831: 435:    private int size = 0;
10832: 436:    public CoffeeSupplier(int sz) { size = sz; }
10833: 437:  
10834: 438:    @Override
10835: 439:    public Coffee get() {
10836: 440:        try {
10837: 441:            return (Coffee) types[rand.nextInt(types.length)].newInstance();
10838: 442:        } catch (InstantiationException | IllegalAccessException e) {
10839: 443:            throw new RuntimeException(e);
10840: 444:        }
10841: 445:    }
10842: 446:  
10843: 447:    class CoffeeIterator implements Iterator<Coffee> {
10844: 448:        int count = size;
10845: 449:        @Override
10846: 450:        public boolean hasNext() { return count > 0; }
10847: 451:        @Override
10848: 452:        public Coffee next() {
10849: 453:            count--;
10850: 454:            return CoffeeSupplier.this.get();
10851: 455:        }
10852: 456:        @Override
10853: 457:        public void remove() {
10854: 458:            throw new UnsupportedOperationException();
10855: 459:        }
10856: 460:    }
10857: 461:  
10858: 462:    @Override
10859: 463:    public Iterator<Coffee> iterator() {
10860: 464:        return new CoffeeIterator();
10861: 465:    }
10862: 466:  
10863: 467:    public static void main(String[] args) {
10864: 468:        Stream.generate(new CoffeeSupplier())
10865: 469:              .limit(5)
10866: 470:              .forEach(System.out::println);
10867: 471:        for (Coffee c : new CoffeeSupplier(5)) {
10868: 472:            System.out.println(c);
10869: 473:        }
10870: 474:    }
10871: 475:}
10872: 476:```
10873: 477:
10874: 478:输出结果：
10875: 479:
10876: 480:```java
10877: 481:Americano 0
10878: 482:Latte 1
10879: 483:Americano 2
10880: 484:Mocha 3
10881: 485:Mocha 4
10882: 486:Breve 5
10883: 487:Americano 6
10884: 488:Latte 7
10885: 489:Cappuccino 8
10886: 490:Cappuccino 9
10887: 491:```
10888: 492:
10889: 493:参数化的 `Supplier` 接口确保 `get()` 返回值是参数的类型。`CoffeeSupplier` 同时还实现了 `Iterable` 接口，所以能用于 *for-in* 语句。不过，它还需要知道何时终止循环，这正是第二个构造函数的作用。
10890: 494:
10891: 495:下面是另一个实现 `Supplier<T>` 接口的例子，它负责生成 Fibonacci 数列：
10892: 496:
10893: 497:```java
10894: 498:// generics/Fibonacci.java
10895: 499:// Generate a Fibonacci sequence
10896: 500:import java.util.function.*;
10897: 501:import java.util.stream.*;
10898: 502:
10899: 503:public class Fibonacci implements Supplier<Integer> {
10900: 504:    private int count = 0;
10901: 505:    @Override
10902: 506:    public Integer get() { return fib(count++); }
10903: 507:  
10904: 508:    private int fib(int n) {
10905: 509:        if(n < 2) return 1;
10906: 510:        return fib(n-2) + fib(n-1);
10907: 511:    }
10908: 512:  
10909: 513:    public static void main(String[] args) {
10910: 514:        Stream.generate(new Fibonacci())
10911: 515:              .limit(18)
10912: 516:              .map(n -> n + " ")
10913: 517:              .forEach(System.out::print);
10914: 518:    }
10915: 519:}
10916: 520:```
10917: 521:
10918: 522:输出结果：
10919: 523:
10920: 524:```java
10921: 525:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
10922: 526:```
10923: 527:
10924: 528:虽然我们在 `Fibonacci` 类的里里外外使用的都是 `int` 类型，但是其参数类型却是 `Integer`。这个例子引出了 Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备自动装箱和拆箱的功能，可以很方便地在基本类型和相应的包装类之间进行转换。通过这个例子中 `Fibonacci` 类对 `int` 的使用，我们已经看到了这种效果。
10925: 529:
10926: 530:如果还想更进一步，编写一个实现了 `Iterable` 的 `Fibnoacci` 生成器。我们的一个选择是重写这个类，令其实现 `Iterable` 接口。不过，你并不是总能拥有源代码的控制权，并且，除非必须这么做，否则，我们也不愿意重写一个类。而且我们还有另一种选择，就是创建一个 *适配器* (Adapter) 来实现所需的接口，我们在前面介绍过这个设计模式。
10927: 531:
10928: 532:有多种方法可以实现适配器。例如，可以通过继承来创建适配器类：
10929: 533:
10930: 534:```java
10931: 535:// generics/IterableFibonacci.java
10932: 536:// Adapt the Fibonacci class to make it Iterable
10933: 537:import java.util.*;
10934: 538:
10935: 539:public class IterableFibonacci
10936: 540:extends Fibonacci implements Iterable<Integer> {
10937: 541:    private int n;
10938: 542:    public IterableFibonacci(int count) { n = count; }
10939: 543:  
10940: 544:    @Override
10941: 545:    public Iterator<Integer> iterator() {
10942: 546:        return new Iterator<Integer>() {
10943: 547:            @Override
10944: 548:            public boolean hasNext() { return n > 0; }
10945: 549:            @Override
10946: 550:            public Integer next() {
10947: 551:                n--;
10948: 552:                return IterableFibonacci.this.get();
10949: 553:            }
10950: 554:            @Override
10951: 555:            public void remove() { // Not implemented
10952: 556:                throw new UnsupportedOperationException();
10953: 557:            }
10954: 558:        };
10955: 559:    }
10956: 560:  
10957: 561:    public static void main(String[] args) {
10958: 562:        for(int i : new IterableFibonacci(18))
10959: 563:            System.out.print(i + " ");
10960: 564:    }
10961: 565:}
10962: 566:```
10963: 567:
10964: 568:输出结果：
10965: 569:
10966: 570:```java
10967: 571:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
10968: 572:```
10969: 573:
10970: 574:在 *for-in* 语句中使用 `IterableFibonacci`，必须在构造函数中提供一个边界值，这样 `hasNext()` 才知道何时返回 **false**，结束循环。
10971: 575:
10972: 576:<!-- Generic Methods -->
10973: 577:
10974: 578:## 泛型方法
10975: 579:
10976: 580:到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。
10977: 581:
10978: 582:泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。
10979: 583:
10980: 584:如果方法是 **static** 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型类型参数，则它必须是泛型方法。
10981: 585:
10982: 586:要定义泛型方法，请将泛型参数列表放置在返回值之前，如下所示：
10983: 587:
10984: 588:```java
10985: 589:// generics/GenericMethods.java
10986: 590:
10987: 591:public class GenericMethods {
10988: 592:    public <T> void f(T x) {
10989: 593:        System.out.println(x.getClass().getName());
10990: 594:    }
10991: 595:
10992: 596:    public static void main(String[] args) {
10993: 597:        GenericMethods gm = new GenericMethods();
10994: 598:        gm.f("");
10995: 599:        gm.f(1);
10996: 600:        gm.f(1.0);
10997: 601:        gm.f(1.0F);
10998: 602:        gm.f('c');
10999: 603:        gm.f(gm);
11000: 604:    }
11001: 605:}
11002: 606:/* Output:
11003: 607:java.lang.String
11004: 608:java.lang.Integer
11005: 609:java.lang.Double
11006: 610:java.lang.Float
11007: 611:java.lang.Character
11008: 612:GenericMethods
11009: 613:*/
11010: 614:```
11011: 615:
11012: 616:尽管可以同时对类及其方法进行参数化，但这里未将 **GenericMethods** 类参数化。只有方法 `f()` 具有类型参数，该参数由方法返回类型之前的参数列表指示。
11013: 617:
11014: 618:对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 *类型参数推断*。因此，对 `f()` 的调用看起来像普通的方法调用，并且 `f()` 看起来像被重载了无数次一样。它甚至会接受 **GenericMethods** 类型的参数。
11015: 619:
11016: 620:如果使用基本类型调用 `f()` ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。
11017: 621:
11018: 622:<!-- Varargs and Generic Methods -->
11019: 623:
11020: 624:### 变长参数和泛型方法
11021: 625:
11022: 626:泛型方法和变长参数列表可以很好地共存：
11023: 627:
11024: 628:```java
11025: 629:// generics/GenericVarargs.java
11026: 630:
11027: 631:import java.util.ArrayList;
11028: 632:import java.util.List;
11029: 633:
11030: 634:public class GenericVarargs {
11031: 635:    @SafeVarargs
11032: 636:    public static <T> List<T> makeList(T... args) {
11033: 637:        List<T> result = new ArrayList<>();
11034: 638:        for (T item : args)
11035: 639:            result.add(item);
11036: 640:        return result;
11037: 641:    }
11038: 642:
11039: 643:    public static void main(String[] args) {
11040: 644:        List<String> ls = makeList("A");
11041: 645:        System.out.println(ls);
11042: 646:        ls = makeList("A", "B", "C");
11043: 647:        System.out.println(ls);
11044: 648:        ls = makeList(
11045: 649:                "ABCDEFFHIJKLMNOPQRSTUVWXYZ".split(""));
11046: 650:        System.out.println(ls);
11047: 651:    }
11048: 652:}
11049: 653:/* Output:
11050: 654:[A]
11051: 655:[A, B, C]
11052: 656:[A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R,
11053: 657:S, T, U, V, W, X, Y, Z]
11054: 658:*/
11055: 659:```
11056: 660:
11057: 661:此处显示的 `makeList()` 方法产生的功能与标准库的 `java.util.Arrays.asList()` 方法相同。
11058: 662:
11059: 663:`@SafeVarargs` 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。
11060: 664:
11061: 665:<!-- A General-Purpose Supplier -->
11062: 666:
11063: 667:### 一个泛型的 Supplier
11064: 668:
11065: 669:这是一个为任意具有无参构造方法的类生成 **Supplier** 的类。为了减少键入，它还包括一个用于生成 **BasicSupplier** 的泛型方法：
11066: 670:
11067: 671:```java
11068: 672:// onjava/BasicSupplier.java
11069: 673:// Supplier from a class with a no-arg constructor
11070: 674:package onjava;
11071: 675:
11072: 676:import java.util.function.Supplier;
11073: 677:
11074: 678:public class BasicSupplier<T> implements Supplier<T> {
11075: 679:    private Class<T> type;
11076: 680:
11077: 681:    public BasicSupplier(Class<T> type) {
11078: 682:        this.type = type;
11079: 683:    }
11080: 684:
11081: 685:    @Override
11082: 686:    public T get() {
11083: 687:        try {
11084: 688:            // Assumes type is a public class:
11085: 689:            return type.newInstance();
11086: 690:        } catch (InstantiationException |
11087: 691:                IllegalAccessException e) {
11088: 692:            throw new RuntimeException(e);
11089: 693:        }
11090: 694:    }
11091: 695:
11092: 696:    // Produce a default Supplier from a type token:
11093: 697:    public static <T> Supplier<T> create(Class<T> type) {
11094: 698:        return new BasicSupplier<>(type);
11095: 699:    }
11096: 700:}
11097: 701:```
11098: 702:
11099: 703:此类提供了产生以下对象的基本实现：
11100: 704:
11101: 705:1. 是 **public** 的。 因为 **BasicSupplier** 在单独的包中，所以相关的类必须具有 **public** 权限，而不仅仅是包级访问权限。
11102: 706:
11103: 707:2. 具有无参构造方法。要创建一个这样的 **BasicSupplier** 对象，请调用 `create()` 方法，并将要生成类型的类型令牌传递给它。通用的 `create()` 方法提供了 `BasicSupplier.create(MyType.class)` 这种较简洁的语法来代替较笨拙的 `new BasicSupplier <MyType>(MyType.class)`。
11104: 708:
11105: 709:例如，这是一个具有无参构造方法的简单类：
11106: 710:
11107: 711:```java
11108: 712:// generics/CountedObject.java
11109: 713:
11110: 714:public class CountedObject {
11111: 715:    private static long counter = 0;
11112: 716:    private final long id = counter++;
11113: 717:
11114: 718:    public long id() {
11115: 719:        return id;
11116: 720:    }
11117: 721:
11118: 722:    @Override
11119: 723:    public String toString() {
11120: 724:        return "CountedObject " + id;
11121: 725:    }
11122: 726:}
11123: 727:```
11124: 728:
11125: 729:**CountedObject** 类可以跟踪自身创建了多少个实例，并通过 `toString()` 报告这些实例的数量。 **BasicSupplier** 可以轻松地为 **CountedObject** 创建 **Supplier**：
11126: 730:
11127: 731:```java
11128: 732:  // generics/BasicSupplierDemo.java
11129: 733:
11130: 734:import onjava.BasicSupplier;
11131: 735:
11132: 736:import java.util.stream.Stream;
11133: 737:
11134: 738:public class BasicSupplierDemo {
11135: 739:    public static void main(String[] args) {
11136: 740:        Stream.generate(
11137: 741:                BasicSupplier.create(CountedObject.class))
11138: 742:                .limit(5)
11139: 743:                .forEach(System.out::println);
11140: 744:    }
11141: 745:}
11142: 746:/* Output:
11143: 747:CountedObject 0
11144: 748:CountedObject 1
11145: 749:CountedObject 2
11146: 750:CountedObject 3
11147: 751:CountedObject 4
11148: 752:*/
11149: 753:```
11150: 754:
11151: 755:泛型方法减少了产生 **Supplier** 对象所需的代码量。 Java 泛型强制传递 **Class** 对象，以便在 `create()` 方法中将其用于类型推断。
11152: 756:
11153: 757:<!-- Simplifying Tuple Use -->
11154: 758:
11155: 759:### 简化元组的使用
11156: 760:
11157: 761:使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库。在这里，我们使用重载的静态方法创建元组：
11158: 762:
11159: 763:```java
11160: 764:// onjava/Tuple.java
11161: 765:// Tuple library using type argument inference
11162: 766:package onjava;
11163: 767:
11164: 768:public class Tuple {
11165: 769:    public static <A, B> Tuple2<A, B> tuple(A a, B b) {
11166: 770:        return new Tuple2<>(a, b);
11167: 771:    }
11168: 772:
11169: 773:    public static <A, B, C> Tuple3<A, B, C>
11170: 774:    tuple(A a, B b, C c) {
11171: 775:        return new Tuple3<>(a, b, c);
11172: 776:    }
11173: 777:
11174: 778:    public static <A, B, C, D> Tuple4<A, B, C, D>
11175: 779:    tuple(A a, B b, C c, D d) {
11176: 780:        return new Tuple4<>(a, b, c, d);
11177: 781:    }
11178: 782:
11179: 783:    public static <A, B, C, D, E>
11180: 784:    Tuple5<A, B, C, D, E> tuple(A a, B b, C c, D d, E e) {
11181: 785:        return new Tuple5<>(a, b, c, d, e);
11182: 786:    }
11183: 787:}
11184: 788:```
11185: 789:
11186: 790:我们修改 **TupleTest.java** 来测试 **Tuple.java** :
11187: 791:
11188: 792:```java
11189: 793:// generics/TupleTest2.java
11190: 794:
11191: 795:import onjava.Tuple2;
11192: 796:import onjava.Tuple3;
11193: 797:import onjava.Tuple4;
11194: 798:import onjava.Tuple5;
11195: 799:
11196: 800:import static onjava.Tuple.tuple;
11197: 801:
11198: 802:public class TupleTest2 {
11199: 803:    static Tuple2<String, Integer> f() {
11200: 804:        return tuple("hi", 47);
11201: 805:    }
11202: 806:
11203: 807:    static Tuple2 f2() {
11204: 808:        return tuple("hi", 47);
11205: 809:    }
11206: 810:
11207: 811:    static Tuple3<Amphibian, String, Integer> g() {
11208: 812:        return tuple(new Amphibian(), "hi", 47);
11209: 813:    }
11210: 814:
11211: 815:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
11212: 816:        return tuple(
11213: 817:                new Vehicle(), new Amphibian(), "hi", 47);
11214: 818:    }
11215: 819:
11216: 820:    static Tuple5<Vehicle, Amphibian,
11217: 821:            String, Integer, Double> k() {
11218: 822:        return tuple(new Vehicle(), new Amphibian(),
11219: 823:                "hi", 47, 11.1);
11220: 824:    }
11221: 825:
11222: 826:    public static void main(String[] args) {
11223: 827:        Tuple2<String, Integer> ttsi = f();
11224: 828:        System.out.println(ttsi);
11225: 829:        System.out.println(f2());
11226: 830:        System.out.println(g());
11227: 831:        System.out.println(h());
11228: 832:        System.out.println(k());
11229: 833:    }
11230: 834:}
11231: 835:/* Output:
11232: 836:(hi, 47)
11233: 837:(hi, 47)
11234: 838:(Amphibian@14ae5a5, hi, 47)
11235: 839:(Vehicle@135fbaa4, Amphibian@45ee12a7, hi, 47)
11236: 840:(Vehicle@4b67cf4d, Amphibian@7ea987ac, hi, 47, 11.1)
11237: 841:*/
11238: 842:```
11239: 843:
11240: 844:请注意，`f()` 返回一个参数化的 **Tuple2** 对象，而 `f2()` 返回一个未参数化的 **Tuple2** 对象。编译器不会在这里警告 `f2()` ，因为返回值未以参数化方式使用。从某种意义上说，它被“向上转型”为一个未参数化的 **Tuple2** 。 但是，如果尝试将 `f2()` 的结果放入到参数化的 **Tuple2** 中，则编译器将发出警告。
11241: 845:
11242: 846:<!-- A Set Utility -->
11243: 847:
11244: 848:### 一个 Set 工具
11245: 849:
11246: 850:对于泛型方法的另一个示例，请考虑由 **Set** 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法：
11247: 851:
11248: 852:```java
11249: 853:// onjava/Sets.java
11250: 854:
11251: 855:package onjava;
11252: 856:
11253: 857:import java.util.HashSet;
11254: 858:import java.util.Set;
11255: 859:
11256: 860:public class Sets {
11257: 861:    public static <T> Set<T> union(Set<T> a, Set<T> b) {
11258: 862:        Set<T> result = new HashSet<>(a);
11259: 863:        result.addAll(b);
11260: 864:        return result;
11261: 865:    }
11262: 866:
11263: 867:    public static <T>
11264: 868:    Set<T> intersection(Set<T> a, Set<T> b) {
11265: 869:        Set<T> result = new HashSet<>(a);
11266: 870:        result.retainAll(b);
11267: 871:        return result;
11268: 872:    }
11269: 873:
11270: 874:    // Subtract subset from superset:
11271: 875:    public static <T> Set<T>
11272: 876:    difference(Set<T> superset, Set<T> subset) {
11273: 877:        Set<T> result = new HashSet<>(superset);
11274: 878:        result.removeAll(subset);
11275: 879:        return result;
11276: 880:    }
11277: 881:
11278: 882:    // Reflexive--everything not in the intersection:
11279: 883:    public static <T> Set<T> complement(Set<T> a, Set<T> b) {
11280: 884:        return difference(union(a, b), intersection(a, b));
11281: 885:    }
11282: 886:}
11283: 887:```
11284: 888:
11285: 889:前三个方法通过将第一个参数的引用复制到新的 **HashSet** 对象中来复制第一个参数，因此不会直接修改参数集合。因此，返回值是一个新的 **Set** 对象。
11286: 890:
11287: 891:这四种方法代表数学集合操作： `union()` 返回一个包含两个参数并集的 **Set** ， `intersection()` 返回一个包含两个参数集合交集的 **Set** ， `difference()` 从 **superset** 中减去 **subset** 的元素 ，而 `complement()` 返回所有不在交集中的元素的 **Set**。作为显示这些方法效果的简单示例的一部分，下面是一个包含不同水彩名称的 **enum** ：
11288: 892:
11289: 893:```java
11290: 894:// generics/watercolors/Watercolors.java
11291: 895:
11292: 896:package watercolors;
11293: 897:
11294: 898:public enum Watercolors {
11295: 899:    ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW,
11296: 900:    ORANGE, BRILLIANT_RED, CRIMSON, MAGENTA,
11297: 901:    ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE,
11298: 902:    PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE,
11299: 903:    PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN,
11300: 904:    YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
11301: 905:    BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK
11302: 906:}
11303: 907:```
11304: 908:
11305: 909:为了方便起见（不必全限定所有名称），将其静态导入到以下示例中。本示例使用 **EnumSet** 轻松从 **enum** 中创建 **Set** 。（可以在[第二十二章 枚举](book/22-Enumerations.md)一章中了解有关 **EnumSet** 的更多信息。）在这里，静态方法 `EnumSet.range()` 要求提供所要在结果 **Set** 中创建的元素范围的第一个和最后一个元素：
11306: 910:
11307: 911:```java
11308: 912:// generics/WatercolorSets.java
11309: 913:
11310: 914:import watercolors.*;
11311: 915:
11312: 916:import java.util.EnumSet;
11313: 917:import java.util.Set;
11314: 918:
11315: 919:import static watercolors.Watercolors.*;
11316: 920:import static onjava.Sets.*;
11317: 921:
11318: 922:public class WatercolorSets {
11319: 923:    public static void main(String[] args) {
11320: 924:        Set<Watercolors> set1 =
11321: 925:                EnumSet.range(BRILLIANT_RED, VIRIDIAN_HUE);
11322: 926:        Set<Watercolors> set2 =
11323: 927:                EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER);
11324: 928:        System.out.println("set1: " + set1);
11325: 929:        System.out.println("set2: " + set2);
11326: 930:        System.out.println(
11327: 931:                "union(set1, set2): " + union(set1, set2));
11328: 932:        Set<Watercolors> subset = intersection(set1, set2);
11329: 933:        System.out.println(
11330: 934:                "intersection(set1, set2): " + subset);
11331: 935:        System.out.println("difference(set1, subset): " +
11332: 936:                difference(set1, subset));
11333: 937:        System.out.println("difference(set2, subset): " +
11334: 938:                difference(set2, subset));
11335: 939:        System.out.println("complement(set1, set2): " +
11336: 940:                complement(set1, set2));
11337: 941:    }
11338: 942:}
11339: 943:/* Output:
11340: 944:set1: [BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER,
11341: 945:VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
11342: 946:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE]
11343: 947:set2: [CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
11344: 948:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE,
11345: 949:SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
11346: 950:BURNT_UMBER]
11347: 951:union(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
11348: 952:YELLOW_OCHRE, MAGENTA, SAP_GREEN, CERULEAN_BLUE_HUE,
11349: 953:ULTRAMARINE, VIRIDIAN_HUE, VIOLET, RAW_UMBER,
11350: 954:ROSE_MADDER, PERMANENT_GREEN, BURNT_UMBER,
11351: 955:PHTHALO_BLUE, CRIMSON, COBALT_BLUE_HUE]
11352: 956:intersection(set1, set2): [PERMANENT_GREEN,
11353: 957:CERULEAN_BLUE_HUE, ULTRAMARINE, VIRIDIAN_HUE,
11354: 958:PHTHALO_BLUE, COBALT_BLUE_HUE]
11355: 959:difference(set1, subset): [BRILLIANT_RED, MAGENTA,
11356: 960:VIOLET, CRIMSON, ROSE_MADDER]
11357: 961:difference(set2, subset): [BURNT_SIENNA, YELLOW_OCHRE,
11358: 962:BURNT_UMBER, SAP_GREEN, RAW_UMBER]
11359: 963:complement(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
11360: 964:YELLOW_OCHRE, MAGENTA, SAP_GREEN, VIOLET, RAW_UMBER,
11361: 965:ROSE_MADDER, BURNT_UMBER, CRIMSON]
11362: 966:*/
11363: 967:```
11364: 968:
11365: 969:接下来的例子使用 `Sets.difference()` 方法来展示 **java.util** 包中各种 **Collection** 和 **Map** 类之间的方法差异：
11366: 970:
11367: 971:```java
11368: 972:// onjava/CollectionMethodDifferences.java
11369: 973:// {java onjava.CollectionMethodDifferences}
11370: 974:
11371: 975:package onjava;
11372: 976:
11373: 977:import java.lang.reflect.Method;
11374: 978:import java.util.*;
11375: 979:import java.util.stream.Collectors;
11376: 980:
11377: 981:public class CollectionMethodDifferences {
11378: 982:    static Set<String> methodSet(Class<?> type) {
11379: 983:        return Arrays.stream(type.getMethods())
11380: 984:                .map(Method::getName)
11381: 985:                .collect(Collectors.toCollection(TreeSet::new));
11382: 986:    }
11383: 987:
11384: 988:    static void interfaces(Class<?> type) {
11385: 989:        System.out.print("Interfaces in " +
11386: 990:                type.getSimpleName() + ": ");
11387: 991:        System.out.println(
11388: 992:                Arrays.stream(type.getInterfaces())
11389: 993:                        .map(Class::getSimpleName)
11390: 994:                        .collect(Collectors.toList()));
11391: 995:    }
11392: 996:
11393: 997:    static Set<String> object = methodSet(Object.class);
11394: 998:
11395: 999:    static {
11396: 1000:        object.add("clone");
11397: 1001:    }
11398: 1002:
11399: 1003:    static void
11400: 1004:    difference(Class<?> superset, Class<?> subset) {
11401: 1005:        System.out.print(superset.getSimpleName() +
11402: 1006:                " extends " + subset.getSimpleName() +
11403: 1007:                ", adds: ");
11404: 1008:        Set<String> comp = Sets.difference(
11405: 1009:                methodSet(superset), methodSet(subset));
11406: 1010:        comp.removeAll(object); // Ignore 'Object' methods
11407: 1011:        System.out.println(comp);
11408: 1012:        interfaces(superset);
11409: 1013:    }
11410: 1014:
11411: 1015:    public static void main(String[] args) {
11412: 1016:        System.out.println("Collection: " +
11413: 1017:                methodSet(Collection.class));
11414: 1018:        interfaces(Collection.class);
11415: 1019:        difference(Set.class, Collection.class);
11416: 1020:        difference(HashSet.class, Set.class);
11417: 1021:        difference(LinkedHashSet.class, HashSet.class);
11418: 1022:        difference(TreeSet.class, Set.class);
11419: 1023:        difference(List.class, Collection.class);
11420: 1024:        difference(ArrayList.class, List.class);
11421: 1025:        difference(LinkedList.class, List.class);
11422: 1026:        difference(Queue.class, Collection.class);
11423: 1027:        difference(PriorityQueue.class, Queue.class);
11424: 1028:        System.out.println("Map: " + methodSet(Map.class));
11425: 1029:        difference(HashMap.class, Map.class);
11426: 1030:        difference(LinkedHashMap.class, HashMap.class);
11427: 1031:        difference(SortedMap.class, Map.class);
11428: 1032:        difference(TreeMap.class, Map.class);
11429: 1033:    }
11430: 1034:}
11431: 1035:/* Output:
11432: 1036:Collection: [add, addAll, clear, contains, containsAll,
11433: 1037:equals, forEach, hashCode, isEmpty, iterator,
11434: 1038:parallelStream, remove, removeAll, removeIf, retainAll,
11435: 1039:size, spliterator, stream, toArray]
11436: 1040:Interfaces in Collection: [Iterable]
11437: 1041:Set extends Collection, adds: []
11438: 1042:Interfaces in Set: [Collection]
11439: 1043:HashSet extends Set, adds: []
11440: 1044:Interfaces in HashSet: [Set, Cloneable, Serializable]
11441: 1045:LinkedHashSet extends HashSet, adds: []
11442: 1046:Interfaces in LinkedHashSet: [Set, Cloneable,
11443: 1047:Serializable]
11444: 1048:TreeSet extends Set, adds: [headSet,
11445: 1049:descendingIterator, descendingSet, pollLast, subSet,
11446: 1050:floor, tailSet, ceiling, last, lower, comparator,
11447: 1051:pollFirst, first, higher]
11448: 1052:Interfaces in TreeSet: [NavigableSet, Cloneable,
11449: 1053:Serializable]
11450: 1054:List extends Collection, adds: [replaceAll, get,
11451: 1055:indexOf, subList, set, sort, lastIndexOf, listIterator]
11452: 1056:Interfaces in List: [Collection]
11453: 1057:ArrayList extends List, adds: [trimToSize,
11454: 1058:ensureCapacity]
11455: 1059:Interfaces in ArrayList: [List, RandomAccess,
11456: 1060:Cloneable, Serializable]
11457: 1061:LinkedList extends List, adds: [offerFirst, poll,
11458: 1062:getLast, offer, getFirst, removeFirst, element,
11459: 1063:removeLastOccurrence, peekFirst, peekLast, push,
11460: 1064:pollFirst, removeFirstOccurrence, descendingIterator,
11461: 1065:pollLast, removeLast, pop, addLast, peek, offerLast,
11462: 1066:addFirst]
11463: 1067:Interfaces in LinkedList: [List, Deque, Cloneable,
11464: 1068:Serializable]
11465: 1069:Queue extends Collection, adds: [poll, peek, offer,
11466: 1070:element]
11467: 1071:Interfaces in Queue: [Collection]
11468: 1072:PriorityQueue extends Queue, adds: [comparator]
11469: 1073:Interfaces in PriorityQueue: [Serializable]
11470: 1074:Map: [clear, compute, computeIfAbsent,
11471: 1075:computeIfPresent, containsKey, containsValue, entrySet,
11472: 1076:equals, forEach, get, getOrDefault, hashCode, isEmpty,
11473: 1077:keySet, merge, put, putAll, putIfAbsent, remove,
11474: 1078:replace, replaceAll, size, values]
11475: 1079:HashMap extends Map, adds: []
11476: 1080:Interfaces in HashMap: [Map, Cloneable, Serializable]
11477: 1081:LinkedHashMap extends HashMap, adds: []
11478: 1082:Interfaces in LinkedHashMap: [Map]
11479: 1083:SortedMap extends Map, adds: [lastKey, subMap,
11480: 1084:comparator, firstKey, headMap, tailMap]
11481: 1085:Interfaces in SortedMap: [Map]
11482: 1086:TreeMap extends Map, adds: [descendingKeySet,
11483: 1087:navigableKeySet, higherEntry, higherKey, floorKey,
11484: 1088:subMap, ceilingKey, pollLastEntry, firstKey, lowerKey,
11485: 1089:headMap, tailMap, lowerEntry, ceilingEntry,
11486: 1090:descendingMap, pollFirstEntry, lastKey, firstEntry,
11487: 1091:floorEntry, comparator, lastEntry]
11488: 1092:Interfaces in TreeMap: [NavigableMap, Cloneable,
11489: 1093:Serializable]
11490: 1094:*/
11491: 1095:```
11492: 1096:
11493: 1097:在第十二章 [集合的本章小结](book/12-Collections.md#本章小结) 部分将会用到这里的输出结果。
11494: 1098:
11495: 1099:<!-- Building Complex Models -->
11496: 1100:
11497: 1101:## 构建复杂模型
11498: 1102:
11499: 1103:泛型的一个重要好处是能够简单安全地创建复杂模型。例如，我们可以轻松地创建一个元组列表：
11500: 1104:
11501: 1105:```java
11502: 1106:// generics/TupleList.java
11503: 1107:// Combining generic types to make complex generic types
11504: 1108:
11505: 1109:import onjava.Tuple4;
11506: 1110:
11507: 1111:import java.util.ArrayList;
11508: 1112:
11509: 1113:public class TupleList<A, B, C, D>
11510: 1114:        extends ArrayList<Tuple4<A, B, C, D>> {
11511: 1115:    public static void main(String[] args) {
11512: 1116:        TupleList<Vehicle, Amphibian, String, Integer> tl =
11513: 1117:                new TupleList<>();
11514: 1118:        tl.add(TupleTest2.h());
11515: 1119:        tl.add(TupleTest2.h());
11516: 1120:        tl.forEach(System.out::println);
11517: 1121:    }
11518: 1122:}
11519: 1123:/* Output:
11520: 1124:(Vehicle@7cca494b, Amphibian@7ba4f24f, hi, 47)
11521: 1125:(Vehicle@3b9a45b3, Amphibian@7699a589, hi, 47)
11522: 1126:*/
11523: 1127:```
11524: 1128:
11525: 1129:这将产生一个功能强大的数据结构，而无需太多代码。
11526: 1130:
11527: 1131:下面是第二个例子。每个类都是组成块，总体包含很多个块。在这里，该模型是一个具有过道，货架和产品的零售商店：
11528: 1132:
11529: 1133:```java
11530: 1134:// generics/Store.java
11531: 1135:// Building a complex model using generic collections
11532: 1136:
11533: 1137:import onjava.Suppliers;
11534: 1138:
11535: 1139:import java.util.ArrayList;
11536: 1140:import java.util.Random;
11537: 1141:import java.util.function.Supplier;
11538: 1142:
11539: 1143:class Product {
11540: 1144:    private final int id;
11541: 1145:    private String description;
11542: 1146:    private double price;
11543: 1147:
11544: 1148:    Product(int idNumber, String descr, double price) {
11545: 1149:        id = idNumber;
11546: 1150:        description = descr;
11547: 1151:        this.price = price;
11548: 1152:        System.out.println(toString());
11549: 1153:    }
11550: 1154:
11551: 1155:    @Override
11552: 1156:    public String toString() {
11553: 1157:        return id + ": " + description +
11554: 1158:                ", price: $" + price;
11555: 1159:    }
11556: 1160:
11557: 1161:    public void priceChange(double change) {
11558: 1162:        price += change;
11559: 1163:    }
11560: 1164:
11561: 1165:    public static Supplier<Product> generator =
11562: 1166:            new Supplier<Product>() {
11563: 1167:                private Random rand = new Random(47);
11564: 1168:
11565: 1169:                @Override
11566: 1170:                public Product get() {
11567: 1171:                    return new Product(rand.nextInt(1000), "Test",
11568: 1172:                            Math.round(
11569: 1173:                                    rand.nextDouble() * 1000.0) + 0.99);
11570: 1174:                }
11571: 1175:            };
11572: 1176:}
11573: 1177:
11574: 1178:class Shelf extends ArrayList<Product> {
11575: 1179:    Shelf(int nProducts) {
11576: 1180:        Suppliers.fill(this, Product.generator, nProducts);
11577: 1181:    }
11578: 1182:}
11579: 1183:
11580: 1184:class Aisle extends ArrayList<Shelf> {
11581: 1185:    Aisle(int nShelves, int nProducts) {
11582: 1186:        for (int i = 0; i < nShelves; i++)
11583: 1187:            add(new Shelf(nProducts));
11584: 1188:    }
11585: 1189:}
11586: 1190:
11587: 1191:class CheckoutStand {
11588: 1192:}
11589: 1193:
11590: 1194:class Office {
11591: 1195:}
11592: 1196:
11593: 1197:public class Store extends ArrayList<Aisle> {
11594: 1198:    private ArrayList<CheckoutStand> checkouts =
11595: 1199:            new ArrayList<>();
11596: 1200:    private Office office = new Office();
11597: 1201:
11598: 1202:    public Store(
11599: 1203:            int nAisles, int nShelves, int nProducts) {
11600: 1204:        for (int i = 0; i < nAisles; i++)
11601: 1205:            add(new Aisle(nShelves, nProducts));
11602: 1206:    }
11603: 1207:
11604: 1208:    @Override
11605: 1209:    public String toString() {
11606: 1210:        StringBuilder result = new StringBuilder();
11607: 1211:        for (Aisle a : this)
11608: 1212:            for (Shelf s : a)
11609: 1213:                for (Product p : s) {
11610: 1214:                    result.append(p);
11611: 1215:                    result.append("\n");
11612: 1216:                }
11613: 1217:        return result.toString();
11614: 1218:    }
11615: 1219:
11616: 1220:    public static void main(String[] args) {
11617: 1221:        System.out.println(new Store(5, 4, 3));
11618: 1222:    }
11619: 1223:}
11620: 1224:/* Output: (First 8 Lines)
11621: 1225:258: Test, price: $400.99
11622: 1226:861: Test, price: $160.99
11623: 1227:868: Test, price: $417.99
11624: 1228:207: Test, price: $268.99
11625: 1229:551: Test, price: $114.99
11626: 1230:278: Test, price: $804.99
11627: 1231:520: Test, price: $554.99
11628: 1232:140: Test, price: $530.99
11629: 1233:                  ...
11630: 1234:*/
11631: 1235:```
11632: 1236:
11633: 1237:`Store.toString()` 显示了结果：尽管有复杂的层次结构，但多层的集合仍然是类型安全的和可管理的。令人印象深刻的是，组装这样的模型并不需要耗费过多精力。
11634: 1238:
11635: 1239:**Shelf** 使用 `Suppliers.fill()` 这个实用程序，该实用程序接受 **Collection** （第一个参数），并使用 **Supplier** （第二个参数），以元素的数量为 **n** （第三个参数）来填充它。 **Suppliers** 类将会在本章末尾定义，其中的方法都是在执行某种填充操作，并在本章的其他示例中使用。
11636: 1240:
11637: 1241:<!-- The Mystery of Erasure -->
11638: 1242:
11639: 1243:## 泛型擦除
11640: 1244:
11641: 1245:当你开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的。例如，尽管可以说  `ArrayList.class`，但不能说成 `ArrayList<Integer>.class`。考虑下面的情况：
11642: 1246:
11643: 1247:```java
11644: 1248:// generics/ErasedTypeEquivalence.java
11645: 1249:
11646: 1250:import java.util.*;
11647: 1251:
11648: 1252:public class ErasedTypeEquivalence {
11649: 1253:    
11650: 1254:    public static void main(String[] args) {
11651: 1255:        Class c1 = new ArrayList<String>().getClass();
11652: 1256:        Class c2 = new ArrayList<Integer>().getClass();
11653: 1257:        System.out.println(c1 == c2);
11654: 1258:    }
11655: 1259:    
11656: 1260:}
11657: 1261:/* Output:
11658: 1262:true
11659: 1263:*/
11660: 1264:```
11661: 1265:
11662: 1266:`ArrayList<String>` 和 `ArrayList<Integer>` 应该是不同的类型。不同的类型会有不同的行为。例如，如果尝试向 `ArrayList<String>` 中放入一个 `Integer`，所得到的行为（失败）和向 `ArrayList<Integer>` 中放入一个 `Integer` 所得到的行为（成功）完全不同。然而上面的程序认为它们是相同的类型。
11663: 1267:
11664: 1268:下面的例子是对该谜题的补充：
11665: 1269:
11666: 1270:```java
11667: 1271:// generics/LostInformation.java
11668: 1272:
11669: 1273:import java.util.*;
11670: 1274:
11671: 1275:class Frob {}
11672: 1276:class Fnorkle {}
11673: 1277:class Quark<Q> {}
11674: 1278:
11675: 1279:class Particle<POSITION, MOMENTUM> {}
11676: 1280:
11677: 1281:public class LostInformation {
11678: 1282:
11679: 1283:    public static void main(String[] args) {
11680: 1284:        List<Frob> list = new ArrayList<>();
11681: 1285:        Map<Frob, Fnorkle> map = new HashMap<>();
11682: 1286:        Quark<Fnorkle> quark = new Quark<>();
11683: 1287:        Particle<Long, Double> p = new Particle<>();
11684: 1288:        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));
11685: 1289:        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));
11686: 1290:        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));
11687: 1291:        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));
11688: 1292:    }
11689: 1293:
11690: 1294:}
11691: 1295:/* Output:
11692: 1296:[E]
11693: 1297:[K,V]
11694: 1298:[Q]
11695: 1299:[POSITION,MOMENTUM]
11696: 1300:*/
11697: 1301:```
11698: 1302:
11699: 1303:根据 JDK 文档，**Class.getTypeParameters()** “返回一个 **TypeVariable** 对象数组，表示泛型声明中声明的类型参数...” 这暗示你可以发现这些参数类型。但是正如上例中输出所示，你只能看到用作参数占位符的标识符，这并非有用的信息。
11700: 1304:
11701: 1305:残酷的现实是：
11702: 1306:
11703: 1307:在泛型代码内部，无法获取任何有关泛型参数类型的信息。
11704: 1308:
11705: 1309:因此，你可以知道如类型参数标识符和泛型边界这些信息，但无法得知实际的类型参数从而用来创建特定的实例。如果你曾是 C++ 程序员，那么这个事实会让你很沮丧，在使用 Java 泛型工作时，它是必须处理的最基本的问题。
11706: 1310:
11707: 1311:Java 泛型是使用擦除实现的。这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此，`List<String>` 和 `List<Integer>` 在运行时实际上是相同的类型。它们都被擦除成原生类型 `List`。
11708: 1312:
11709: 1313:理解擦除并知道如何处理它，是你在学习 Java 泛型时面临的最大障碍之一。这也是本节将要探讨的内容。
11710: 1314:
11711: 1315:### C++ 的方式
11712: 1316:
11713: 1317:下面是使用模版的 C++ 示例。你会看到类型参数的语法十分相似，因为 Java 是受 C++ 启发的：
11714: 1318:
11715: 1319:```c++
11716: 1320:// generics/Templates.cpp
11717: 1321:
11718: 1322:#include <iostream>
11719: 1323:using namespace std;
11720: 1324:
11721: 1325:template<class T> class Manipulator {
11722: 1326:    T obj;
11723: 1327:public:
11724: 1328:    Manipulator(T x) { obj = x; }
11725: 1329:    void manipulate() { obj.f(); }
11726: 1330:};
11727: 1331:
11728: 1332:class HasF {
11729: 1333:public:
11730: 1334:    void f() { cout << "HasF::f()" << endl; }
11731: 1335:};
11732: 1336:
11733: 1337:int main() {
11734: 1338:    HasF hf;
11735: 1339:    Manipulator<HasF> manipulator(hf);
11736: 1340:    manipulator.manipulate();
11737: 1341:}
11738: 1342:/* Output:
11739: 1343:HasF::f()
11740: 1344:*/
11741: 1345:```
11742: 1346:
11743: 1347:**Manipulator** 类存储了一个 **T** 类型的对象。`manipulate()` 方法会调用 **obj** 上的 `f()` 方法。它是如何知道类型参数 **T** 中存在 `f()` 方法的呢？C++ 编译器会在你实例化模版时进行检查，所以在 `Manipulator<HasF>` 实例化的那一刻，它看到 **HasF** 中含有一个方法 `f()`。如果情况并非如此，你就会得到一个编译期错误，保持类型安全。
11744: 1348:
11745: 1349:用 C++ 编写这种代码很简单，因为当模版被实例化时，模版代码就知道模版参数的类型。Java 泛型就不同了。下面是 **HasF** 的 Java 版本：
11746: 1350:
11747: 1351:```java
11748: 1352:// generics/HasF.java
11749: 1353:
11750: 1354:public class HasF {
11751: 1355:    public void f() {
11752: 1356:        System.out.println("HasF.f()");
11753: 1357:    }
11754: 1358:}
11755: 1359:```
11756: 1360:
11757: 1361:如果我们将示例的其余代码用 Java 实现，就不会通过编译：
11758: 1362:
11759: 1363:```java
11760: 1364:// generics/Manipulation.java
11761: 1365:// {WillNotCompile}
11762: 1366:
11763: 1367:class Manipulator<T> {
11764: 1368:    private T obj;
11765: 1369:    
11766: 1370:    Manipulator(T x) {
11767: 1371:        obj = x;
11768: 1372:    }
11769: 1373:    
11770: 1374:    // Error: cannot find symbol: method f():
11771: 1375:    public void manipulate() {
11772: 1376:        obj.f();
11773: 1377:    }
11774: 1378:}
11775: 1379:
11776: 1380:public class Manipulation {
11777: 1381:	public static void main(String[] args) {
11778: 1382:        HasF hf = new HasF();
11779: 1383:        Manipulator<HasF> manipulator = new Manipulator<>(hf);
11780: 1384:        manipulator.manipulate();
11781: 1385:    }
11782: 1386:}
11783: 1387:```
11784: 1388:
11785: 1389:因为擦除，Java 编译器无法将 `manipulate()` 方法必须能调用 **obj** 的 `f()` 方法这一需求映射到 HasF 具有 `f()` 方法这个事实上。为了调用 `f()`，我们必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。这里重用了 **extends** 关键字。由于有了边界，下面的代码就能通过编译：
11786: 1390:
11787: 1391:```java
11788: 1392:public class Manipulator2<T extends HasF> {
11789: 1393:    private T obj;
11790: 1394:
11791: 1395:    Manipulator2(T x) {
11792: 1396:        obj = x;
11793: 1397:    }
11794: 1398:
11795: 1399:    public void manipulate() {
11796: 1400:        obj.f();
11797: 1401:    }
11798: 1402:}
11799: 1403:```
11800: 1404:
11801: 1405:边界 `<T extends HasF>` 声明 T 必须是 HasF 类型或其子类。如果情况确实如此，就可以安全地在 **obj** 上调用 `f()` 方法。
11802: 1406:
11803: 1407:我们说泛型类型参数会擦除到它的第一个边界（可能有多个边界，稍后你将看到）。我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的示例，**T** 擦除到了 **HasF**，就像在类的声明中用 **HasF** 替换了 **T** 一样。
11804: 1408:
11805: 1409:你可能正确地观察到了泛型在 **Manipulator2.java** 中没有贡献任何事。你可以很轻松地自己去执行擦除，生成没有泛型的类：
11806: 1410:
11807: 1411:```java
11808: 1412:// generics/Manipulator3.java
11809: 1413:
11810: 1414:class Manipulator3 {
11811: 1415:    private HasF obj;
11812: 1416:    
11813: 1417:    Manipulator3(HasF x) {
11814: 1418:        obj = x;
11815: 1419:    }
11816: 1420:    
11817: 1421:    public void manipulate() {
11818: 1422:        obj.f();
11819: 1423:    }
11820: 1424:}
11821: 1425:```
11822: 1426:
11823: 1427:这提出了很重要的一点：泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用。因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换更加复杂。但是，不能因此认为使用 `<T extends HasF>` 形式就是有缺陷的。例如，如果某个类有一个返回 **T** 的方法，那么泛型就有所帮助，因为它们之后将返回确切的类型：
11824: 1428:
11825: 1429:```java
11826: 1430:// generics/ReturnGenericType.java
11827: 1431:
11828: 1432:public class ReturnGenericType<T extends HasF> {
11829: 1433:    private T obj;
11830: 1434:    
11831: 1435:    ReturnGenericType(T x) {
11832: 1436:        obj = x;
11833: 1437:    }
11834: 1438:    
11835: 1439:    public T get() {
11836: 1440:        return obj;
11837: 1441:    }
11838: 1442:}
11839: 1443:```
11840: 1444:
11841: 1445:你必须查看所有的代码，从而确定代码是否复杂到必须使用泛型的程度。
11842: 1446:
11843: 1447:我们将在本章稍后看到有关边界的更多细节。
11844: 1448:
11845: 1449:### 迁移兼容性
11846: 1450:
11847: 1451:为了减少潜在的关于擦除的困惑，你必须清楚地认识到这不是一个语言特性。它是 Java 实现泛型的一种妥协，因为泛型不是 Java 语言出现时就有的，所以就有了这种妥协。它会使你痛苦，因此你需要尽早习惯它并了解为什么它会这样。
11848: 1452:
11849: 1453:如果 Java 1.0 就含有泛型的话，那么这个特性就不会使用擦除来实现——它会使用具体化，保持参数类型为第一类实体，因此你就能在类型参数上执行基于类型的语言操作和反射操作。本章稍后你会看到，擦除减少了泛型的泛化性。泛型在 Java 中仍然是有用的，只是不如它们本来设想的那么有用，而原因就是擦除。
11850: 1454:
11851: 1455:在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文使用泛型类型。泛型类型只有在静态类型检测期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如， `List<T>` 这样的类型注解会被擦除为 **List**，普通的类型变量在未指定边界的情况下会被擦除为 **Object**。
11852: 1456:
11853: 1457:擦除的核心动机是你可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称为“迁移兼容性”。在理想情况下，所有事物将在指定的某天被泛化。在现实中，即使程序员只编写泛型代码，他们也必须处理 Java 5 之前编写的非泛型类库。这些类库的作者可能从没想过要泛化他们的代码，或许他们可能刚刚开始接触泛型。
11854: 1458:
11855: 1459:因此 Java 泛型不仅必须支持向后兼容性——现有的代码和类文件仍然合法，继续保持之前的含义——而且还必须支持迁移兼容性，使得类库能按照它们自己的步调变为泛型，当某个类库变为泛型时，不会破坏依赖于它的代码和应用。在确定了这个目标后，Java 设计者们和从事此问题相关工作的各个团队决策认为擦除是唯一可行的解决方案。擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。
11856: 1460:
11857: 1461:例如，假设一个应用使用了两个类库 **X** 和 **Y**，**Y** 使用了类库 **Z**。随着 Java 5 的出现，这个应用和这些类库的创建者最终可能希望迁移到泛型上。但是当进行迁移时，它们有着不同的动机和限制。为了实现迁移兼容性，每个类库与应用必须与其他所有的部分是否使用泛型无关。因此，它们不能探测其他类库是否使用了泛型。因此，某个特定的类库使用了泛型这样的证据必须被”擦除“。
11858: 1462:
11859: 1463:如果没有某种类型的迁移途径，所有已经构建了很长时间的类库就需要与希望迁移到 Java 泛型上的开发者们说再见了。类库毫无争议是编程语言的一部分，对生产效率有着极大的影响，所以这种代码无法接受。擦除是否是最佳的或唯一的迁移途径，还待时间来证明。
11860: 1464:
11861: 1465:### 擦除的问题
11862: 1466:
11863: 1467:因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。擦除允许你继续使用现有的非泛型客户端代码，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会骤然破坏所有现有的代码。
11864: 1468:
11865: 1469:擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作中，例如转型、**instanceof** 操作和 **new** 表达式。因为所有关于参数的类型信息都丢失了，当你在编写泛型代码时，必须时刻提醒自己，你只是看起来拥有有关参数的类型信息而已。
11866: 1470:
11867: 1471:考虑如下的代码段：
11868: 1472:
11869: 1473:```java
11870: 1474:class Foo<T> {
11871: 1475:    T var;
11872: 1476:}
11873: 1477:```
11874: 1478:
11875: 1479:看上去当你创建一个 **Foo** 实例时：
11876: 1480:
11877: 1481:```java
11878: 1482:Foo<Cat> f = new Foo<>();
11879: 1483:```
11880: 1484:
11881: 1485:**class** **Foo** 中的代码应该知道现在工作于 **Cat** 之上。泛型语法也在强烈暗示整个类中所有 T 出现的地方都被替换，就像在 C++ 中一样。但是事实并非如此，当你在编写这个类的代码时，必须提醒自己：“不，这只是一个 **Object**“。
11882: 1486:
11883: 1487:另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管你可能希望这样：
11884: 1488:
11885: 1489:```java
11886: 1490:// generics/ErasureAndInheritance.java
11887: 1491:
11888: 1492:class GenericBase<T> {
11889: 1493:    private T element;
11890: 1494:    
11891: 1495:    public void set(T arg) {
11892: 1496:        element = arg;
11893: 1497:    }
11894: 1498:    
11895: 1499:    public T get() {
11896: 1500:        return element;
11897: 1501:    }
11898: 1502:}
11899: 1503:
11900: 1504:class Derived1<T> extends GenericBase<T> {}
11901: 1505:
11902: 1506:class Derived2 extends GenericBase {} // No warning
11903: 1507:
11904: 1508:// class Derived3 extends GenericBase<?> {}
11905: 1509:// Strange error:
11906: 1510:// unexpected type
11907: 1511:// required: class or interface without bounds
11908: 1512:public class ErasureAndInteritance {
11909: 1513:    @SuppressWarnings("unchecked")
11910: 1514:    public static void main(String[] args) {
11911: 1515:        Derived2 d2 = new Derived2();
11912: 1516:        Object obj = d2.get();
11913: 1517:        d2.set(obj); // Warning here!
11914: 1518:    }
11915: 1519:}
11916: 1520:```
11917: 1521:
11918: 1522:**Derived2** 继承自 **GenericBase**，但是没有任何类型参数，编译器没有发出任何警告。直到调用 `set()` 方法时才出现警告。
11919: 1523:
11920: 1524:为了关闭警告，Java 提供了一个注解，我们可以在列表中看到它：
11921: 1525:
11922: 1526:```java
11923: 1527:@SuppressWarnings("unchecked")
11924: 1528:```
11925: 1529:
11926: 1530:这个注解放置在产生警告的方法上，而不是整个类上。当你要关闭警告时，最好尽可能地“聚焦”，这样就不会因为过于宽泛地关闭警告，而导致意外地遮蔽掉真正的问题。
11927: 1531:
11928: 1532:可以推断，**Derived3** 产生的错误意味着编译器期望得到一个原生基类。
11929: 1533:
11930: 1534:当你希望将类型参数不仅仅当作 Object 处理时，就需要付出额外努力来管理边界，并且与在 C++、Ada 和 Eiffel 这样的语言中获得参数化类型相比，你需要付出多得多的努力来获得少得多的回报。这并不是说，对于大多数的编程问题而言，这些语言通常都会比 Java 更得心应手，只是说它们的参数化类型机制相比 Java 更灵活、更强大。
11931: 1535:
11932: 1536:### 边界处的动作
11933: 1537:
11934: 1538:因为擦除，我发现了泛型最令人困惑的方面是可以表示没有任何意义的事物。例如：
11935: 1539:
11936: 1540:```java
11937: 1541:// generics/ArrayMaker.java
11938: 1542:
11939: 1543:import java.lang.reflect.*;
11940: 1544:import java.util.*;
11941: 1545:
11942: 1546:public class ArrayMaker<T> {
11943: 1547:    private Class<T> kind;
11944: 1548:
11945: 1549:    public ArrayMaker(Class<T> kind) {
11946: 1550:        this.kind = kind;
11947: 1551:    }
11948: 1552:
11949: 1553:    @SuppressWarnings("unchecked")
11950: 1554:    T[] create(int size) {
11951: 1555:        return (T[]) Array.newInstance(kind, size);
11952: 1556:    }
11953: 1557:
11954: 1558:    public static void main(String[] args) {
11955: 1559:        ArrayMaker<String> stringMaker = new ArrayMaker<>(String.class);
11956: 1560:        String[] stringArray = stringMaker.create(9);
11957: 1561:        System.out.println(Arrays.toString(stringArray));
11958: 1562:    }
11959: 1563:}
11960: 1564:/* Output
11961: 1565:[null,null,null,null,null,null,null,null,null]
11962: 1566:*/
11963: 1567:```
11964: 1568:
11965: 1569:即使 **kind** 被存储为 `Class<T>`，擦除也意味着它实际被存储为没有任何参数的 **Class**。因此，当你在使用它时，例如创建数组，`Array.newInstance()` 实际上并未拥有 **kind** 所蕴含的类型信息。所以它不会产生具体的结果，因而必须转型，这会产生一条令你无法满意的警告。
11966: 1570:
11967: 1571:注意，对于在泛型中创建数组，使用 `Array.newInstance()` 是推荐的方式。
11968: 1572:
11969: 1573:如果我们创建一个集合而不是数组，情况就不同了：
11970: 1574:
11971: 1575:```java
11972: 1576:// generics/ListMaker.java
11973: 1577:
11974: 1578:import java.util.*;
11975: 1579:
11976: 1580:public class ListMaker<T> {
11977: 1581:    List<T> create() {
11978: 1582:        return new ArrayList<>();
11979: 1583:    }
11980: 1584:    
11981: 1585:    public static void main(String[] args) {
11982: 1586:        ListMaker<String> stringMaker = new ListMaker<>();
11983: 1587:        List<String> stringList = stringMaker.create();
11984: 1588:    }
11985: 1589:}
11986: 1590:```
11987: 1591:
11988: 1592:编译器不会给出任何警告，尽管我们知道（从擦除中）在 `create()` 内部的 `new ArrayList<>()` 中的 `<T>` 被移除了——在运行时，类内部没有任何 `<T>`，因此这看起来毫无意义。但是如果你遵从这种思路，并将这个表达式改为 `new ArrayList()`，编译器就会发出警告。
11989: 1593:
11990: 1594:本例中这么做真的毫无意义吗？如果在创建 **List** 的同时向其中放入一些对象呢，像这样：
11991: 1595:
11992: 1596:```java
11993: 1597:// generics/FilledList.java
11994: 1598:
11995: 1599:import java.util.*;
11996: 1600:import java.util.function.*;
11997: 1601:import onjava.*;
11998: 1602:
11999: 1603:public class FilledList<T> extends ArrayList<T> {
12000: 1604:    FilledList(Supplier<T> gen, int size) {
12001: 1605:        Suppliers.fill(this, gen, size);
12002: 1606:    }
12003: 1607:    
12004: 1608:    public FilledList(T t, int size) {
12005: 1609:        for (int i = 0; i < size; i++) {
12006: 1610:            this.add(t);
12007: 1611:        }
12008: 1612:    }
12009: 1613:    
12010: 1614:    public static void main(String[] args) {
12011: 1615:        List<String> list = new FilledList<>("Hello", 4);
12012: 1616:        System.out.println(list);
12013: 1617:        // Supplier version:
12014: 1618:        List<Integer> ilist = new FilledList<>(() -> 47, 4);
12015: 1619:        System.out.println(ilist);
12016: 1620:    }
12017: 1621:}
12018: 1622:/* Output:
12019: 1623:[Hello,Hello,Hello,Hello]
12020: 1624:[47,47,47,47]
12021: 1625:*/
12022: 1626:```
12023: 1627:
12024: 1628:即使编译器无法得知 `add()` 中的 **T** 的任何信息，但它仍可以在编译期确保你放入 **FilledList** 中的对象是 **T** 类型。因此，即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。
12025: 1629:
12026: 1630:因为擦除移除了方法体中的类型信息，所以在运行时的问题就是*边界*：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。
12027: 1631:
12028: 1632:考虑如下这段非泛型示例：
12029: 1633:
12030: 1634:```java
12031: 1635:// generics/SimpleHolder.java
12032: 1636:
12033: 1637:public class SimpleHolder {
12034: 1638:    private Object obj;
12035: 1639:    
12036: 1640:    public void set(Object obj) {
12037: 1641:        this.obj = obj;
12038: 1642:    }
12039: 1643:    
12040: 1644:    public Object get() {
12041: 1645:        return obj;
12042: 1646:    }
12043: 1647:    
12044: 1648:    public static void main(String[] args) {
12045: 1649:        SimpleHolder holder = new SimpleHolder();
12046: 1650:        holder.set("Item");
12047: 1651:        String s = (String) holder.get();
12048: 1652:    }
12049: 1653:}
12050: 1654:```
12051: 1655:
12052: 1656:如果用 **javap -c SimpleHolder** 反编译这个类，会得到如下内容（经过编辑）：
12053: 1657:
12054: 1658:```java
12055: 1659:public void set(java.lang.Object);
12056: 1660:   0: aload_0
12057: 1661:   1: aload_1
12058: 1662:   2: putfield #2; // Field obj:Object;
12059: 1663:   5: return
12060: 1664:    
12061: 1665:public java.lang.Object get();
12062: 1666:   0: aload_0
12063: 1667:   1: getfield #2; // Field obj:Object;
12064: 1668:   4: areturn
12065: 1669:    
12066: 1670:public static void main(java.lang.String[]);
12067: 1671:   0: new #3; // class SimpleHolder
12068: 1672:   3: dup
12069: 1673:   4: invokespecial #4; // Method "<init>":()V
12070: 1674:   7: astore_1
12071: 1675:   8: aload_1
12072: 1676:   9: ldc #5; // String Item
12073: 1677:   11: invokevirtual #6; // Method set:(Object;)V
12074: 1678:   14: aload_1
12075: 1679:   15: invokevirtual #7; // Method get:()Object;
12076: 1680:   18: checkcast #8; // class java/lang/String
12077: 1681:   21: astore_2
12078: 1682:   22: return
12079: 1683:```
12080: 1684:
12081: 1685:`set()` 和 `get()` 方法存储和产生值，转型在调用 `get()` 时接受检查。
12082: 1686:
12083: 1687:现在将泛型融入上例代码中：
12084: 1688:
12085: 1689:```java
12086: 1690:// generics/GenericHolder2.java
12087: 1691:
12088: 1692:public class GenericHolder2<T> {
12089: 1693:    private T obj;
12090: 1694:
12091: 1695:    public void set(T obj) {
12092: 1696:        this.obj = obj;
12093: 1697:    }
12094: 1698:
12095: 1699:    public T get() {
12096: 1700:        return obj;
12097: 1701:    }
12098: 1702:
12099: 1703:    public static void main(String[] args) {
12100: 1704:        GenericHolder2<String> holder =  new GenericHolder2<>();
12101: 1705:        holder.set("Item");
12102: 1706:        String s = holder.get();
12103: 1707:    }
12104: 1708:}
12105: 1709:```
12106: 1710:
12107: 1711:从 `get()` 返回后的转型消失了，但是我们还知道传递给 `set()` 的值在编译期会被检查。下面是相关的字节码：
12108: 1712:
12109: 1713:```java
12110: 1714:public void set(java.lang.Object);
12111: 1715:   0: aload_0
12112: 1716:   1: aload_1
12113: 1717:   2: putfield #2; // Field obj:Object;
12114: 1718:   5: return
12115: 1719:       
12116: 1720:public java.lang.Object get();
12117: 1721:   0: aload_0
12118: 1722:   1: getfield #2; // Field obj:Object;
12119: 1723:   4: areturn
12120: 1724:       
12121: 1725:public static void main(java.lang.String[]);
12122: 1726:   0: new #3; // class GenericHolder2
12123: 1727:   3: dup
12124: 1728:   4: invokespecial #4; // Method "<init>":()V
12125: 1729:   7: astore_1
12126: 1730:   8: aload_1
12127: 1731:   9: ldc #5; // String Item
12128: 1732:   11: invokevirtual #6; // Method set:(Object;)V
12129: 1733:   14: aload_1
12130: 1734:   15: invokevirtual #7; // Method get:()Object;
12131: 1735:   18: checkcast #8; // class java/lang/String
12132: 1736:   21: astore_2
12133: 1737:   22: return
12134: 1738:```
12135: 1739:
12136: 1740:所产生的字节码是相同的。对进入 `set()` 的类型进行检查是不需要的，因为这将由编译器执行。而对 `get()` 返回的值进行转型仍然是需要的，只不过不需要你来操作，它由编译器自动插入，这样你就不用编写（阅读）杂乱的代码。
12137: 1741:
12138: 1742:`get()` 和 `set()` 产生了相同的字节码，这就告诉我们泛型的所有动作都发生在边界处——对入参的编译器检查和对返回值的转型。这有助于澄清对擦除的困惑，记住：“边界就是动作发生的地方”。
12139: 1743:
12140: 1744:<!-- Compensating for Erasure -->
12141: 1745:
12142: 1746:## 补偿擦除
12143: 1747:
12144: 1748:因为擦除，我们将失去执行泛型代码中某些操作的能力。无法在运行时知道确切类型：
12145: 1749:
12146: 1750:```java
12147: 1751:// generics/Erased.java
12148: 1752:// {WillNotCompile}
12149: 1753:
12150: 1754:public class Erased<T> {
12151: 1755:    private final int SIZE = 100;
12152: 1756:
12153: 1757:    public void f(Object arg) {
12154: 1758:        // error: illegal generic type for instanceof
12155: 1759:        if (arg instanceof T) {
12156: 1760:        }
12157: 1761:        // error: unexpected type
12158: 1762:        T var = new T();
12159: 1763:        // error: generic array creation
12160: 1764:        T[] array = new T[SIZE];
12161: 1765:        // warning: [unchecked] unchecked cast
12162: 1766:        T[] array = (T[]) new Object[SIZE];
12163: 1767:
12164: 1768:    }
12165: 1769:}
12166: 1770:```
12167: 1771:
12168: 1772:有时，我们可以对这些问题进行编程，但是有时必须通过引入类型标签来补偿擦除。这意味着为所需的类型显式传递一个 **Class** 对象，以在类型表达式中使用它。
12169: 1773:
12170: 1774:例如，由于擦除了类型信息，因此在上一个程序中尝试使用 **instanceof** 将会失败。类型标签可以使用动态 `isInstance()` ：
12171: 1775:
12172: 1776:```java
12173: 1777:// generics/ClassTypeCapture.java
12174: 1778:
12175: 1779:class Building {
12176: 1780:}
12177: 1781:
12178: 1782:class House extends Building {
12179: 1783:}
12180: 1784:
12181: 1785:public class ClassTypeCapture<T> {
12182: 1786:    Class<T> kind;
12183: 1787:
12184: 1788:    public ClassTypeCapture(Class<T> kind) {
12185: 1789:        this.kind = kind;
12186: 1790:    }
12187: 1791:
12188: 1792:    public boolean f(Object arg) {
12189: 1793:        return kind.isInstance(arg);
12190: 1794:    }
12191: 1795:
12192: 1796:    public static void main(String[] args) {
12193: 1797:        ClassTypeCapture<Building> ctt1 =
12194: 1798:                new ClassTypeCapture<>(Building.class);
12195: 1799:        System.out.println(ctt1.f(new Building()));
12196: 1800:        System.out.println(ctt1.f(new House()));
12197: 1801:        ClassTypeCapture<House> ctt2 =
12198: 1802:                new ClassTypeCapture<>(House.class);
12199: 1803:        System.out.println(ctt2.f(new Building()));
12200: 1804:        System.out.println(ctt2.f(new House()));
12201: 1805:    }
12202: 1806:}
12203: 1807:/* Output:
12204: 1808:true
12205: 1809:true
12206: 1810:false
12207: 1811:true
12208: 1812:*/
12209: 1813:```
12210: 1814:
12211: 1815:编译器来保证类型标签与泛型参数相匹配。
12212: 1816:
12213: 1817:<!-- Creating Instances of Types -->
12214: 1818:
12215: 1819:### 创建类型的实例
12216: 1820:
12217: 1821:试图在 **Erased.java** 中 `new T()` 是行不通的，部分原因是由于擦除，部分原因是编译器无法验证 **T** 是否具有默认（无参）构造函数。但是在 C++ 中，此操作自然，直接且安全（在编译时检查）：
12218: 1822:
12219: 1823:```C++
12220: 1824:// generics/InstantiateGenericType.cpp
12221: 1825:// C++, not Java!
12222: 1826:
12223: 1827:template<class T> class Foo {
12224: 1828:  T x; // Create a field of type T
12225: 1829:  T* y; // Pointer to T
12226: 1830:public:
12227: 1831:  // Initialize the pointer:
12228: 1832:  Foo() { y = new T(); }
12229: 1833:};
12230: 1834:
12231: 1835:class Bar {};
12232: 1836:
12233: 1837:int main() {
12234: 1838:  Foo<Bar> fb;
12235: 1839:  Foo<int> fi; // ... and it works with primitives
12236: 1840:}
12237: 1841:```
12238: 1842:
12239: 1843:Java 中的解决方案是传入一个工厂对象，并使用该对象创建新实例。方便的工厂对象只是 **Class** 对象，因此，如果使用类型标记，则可以使用 `newInstance()` 创建该类型的新对象：
12240: 1844:
12241: 1845:```java
12242: 1846:// generics/InstantiateGenericType.java
12243: 1847:
12244: 1848:import java.util.function.Supplier;
12245: 1849:
12246: 1850:class ClassAsFactory<T> implements Supplier<T> {
12247: 1851:    Class<T> kind;
12248: 1852:
12249: 1853:    ClassAsFactory(Class<T> kind) {
12250: 1854:        this.kind = kind;
12251: 1855:    }
12252: 1856:
12253: 1857:    @Override
12254: 1858:    public T get() {
12255: 1859:        try {
12256: 1860:            return kind.newInstance();
12257: 1861:        } catch (InstantiationException |
12258: 1862:                IllegalAccessException e) {
12259: 1863:            throw new RuntimeException(e);
12260: 1864:        }
12261: 1865:    }
12262: 1866:}
12263: 1867:
12264: 1868:class Employee {
12265: 1869:    @Override
12266: 1870:    public String toString() {
12267: 1871:        return "Employee";
12268: 1872:    }
12269: 1873:}
12270: 1874:
12271: 1875:public class InstantiateGenericType {
12272: 1876:    public static void main(String[] args) {
12273: 1877:        ClassAsFactory<Employee> fe =
12274: 1878:                new ClassAsFactory<>(Employee.class);
12275: 1879:        System.out.println(fe.get());
12276: 1880:        ClassAsFactory<Integer> fi =
12277: 1881:                new ClassAsFactory<>(Integer.class);
12278: 1882:        try {
12279: 1883:            System.out.println(fi.get());
12280: 1884:        } catch (Exception e) {
12281: 1885:            System.out.println(e.getMessage());
12282: 1886:        }
12283: 1887:    }
12284: 1888:}
12285: 1889:/* Output:
12286: 1890:Employee
12287: 1891:java.lang.InstantiationException: java.lang.Integer
12288: 1892:*/
12289: 1893:```
12290: 1894:
12291: 1895:这样可以编译，但对于 `ClassAsFactory<Integer>` 会失败，这是因为 **Integer** 没有无参构造函数。由于错误不是在编译时捕获的，因此语言创建者不赞成这种方法。他们建议使用显式工厂（**Supplier**）并约束类型，以便只有实现该工厂的类可以这样创建对象。这是创建工厂的两种不同方法：
12292: 1896:
12293: 1897:```java
12294: 1898:// generics/FactoryConstraint.java
12295: 1899:
12296: 1900:import onjava.Suppliers;
12297: 1901:
12298: 1902:import java.util.ArrayList;
12299: 1903:import java.util.List;
12300: 1904:import java.util.function.Supplier;
12301: 1905:
12302: 1906:class IntegerFactory implements Supplier<Integer> {
12303: 1907:    private int i = 0;
12304: 1908:
12305: 1909:    @Override
12306: 1910:    public Integer get() {
12307: 1911:        return ++i;
12308: 1912:    }
12309: 1913:}
12310: 1914:
12311: 1915:class Widget {
12312: 1916:    private int id;
12313: 1917:
12314: 1918:    Widget(int n) {
12315: 1919:        id = n;
12316: 1920:    }
12317: 1921:
12318: 1922:    @Override
12319: 1923:    public String toString() {
12320: 1924:        return "Widget " + id;
12321: 1925:    }
12322: 1926:
12323: 1927:    public static
12324: 1928:    class Factory implements Supplier<Widget> {
12325: 1929:        private int i = 0;
12326: 1930:
12327: 1931:        @Override
12328: 1932:        public Widget get() {
12329: 1933:            return new Widget(++i);
12330: 1934:        }
12331: 1935:    }
12332: 1936:}
12333: 1937:
12334: 1938:class Fudge {
12335: 1939:    private static int count = 1;
12336: 1940:    private int n = count++;
12337: 1941:
12338: 1942:    @Override
12339: 1943:    public String toString() {
12340: 1944:        return "Fudge " + n;
12341: 1945:    }
12342: 1946:}
12343: 1947:
12344: 1948:class Foo2<T> {
12345: 1949:    private List<T> x = new ArrayList<>();
12346: 1950:
12347: 1951:    Foo2(Supplier<T> factory) {
12348: 1952:        Suppliers.fill(x, factory, 5);
12349: 1953:    }
12350: 1954:
12351: 1955:    @Override
12352: 1956:    public String toString() {
12353: 1957:        return x.toString();
12354: 1958:    }
12355: 1959:}
12356: 1960:
12357: 1961:public class FactoryConstraint {
12358: 1962:    public static void main(String[] args) {
12359: 1963:        System.out.println(
12360: 1964:                new Foo2<>(new IntegerFactory()));
12361: 1965:        System.out.println(
12362: 1966:                new Foo2<>(new Widget.Factory()));
12363: 1967:        System.out.println(
12364: 1968:                new Foo2<>(Fudge::new));
12365: 1969:    }
12366: 1970:}
12367: 1971:/* Output:
12368: 1972:[1, 2, 3, 4, 5]
12369: 1973:[Widget 1, Widget 2, Widget 3, Widget 4, Widget 5]
12370: 1974:[Fudge 1, Fudge 2, Fudge 3, Fudge 4, Fudge 5]
12371: 1975:*/
12372: 1976:```
12373: 1977:
12374: 1978:**IntegerFactory** 本身就是通过实现 `Supplier<Integer>` 的工厂。 **Widget** 包含一个内部类，它是一个工厂。还要注意，**Fudge** 并没有做任何类似于工厂的操作，并且传递 `Fudge::new` 仍然会产生工厂行为，因为编译器将对函数方法 `::new` 的调用转换为对 `get()` 的调用。
12375: 1979:
12376: 1980:另一种方法是模板方法设计模式。在以下示例中，`create()` 是模板方法，在子类中被重写以生成该类型的对象：
12377: 1981:
12378: 1982:```java
12379: 1983:// generics/CreatorGeneric.java
12380: 1984:
12381: 1985:abstract class GenericWithCreate<T> {
12382: 1986:    final T element;
12383: 1987:
12384: 1988:    GenericWithCreate() {
12385: 1989:        element = create();
12386: 1990:    }
12387: 1991:
12388: 1992:    abstract T create();
12389: 1993:}
12390: 1994:
12391: 1995:class X {
12392: 1996:}
12393: 1997:
12394: 1998:class XCreator extends GenericWithCreate<X> {
12395: 1999:    @Override
12396: 2000:    X create() {
12397: 2001:        return new X();
12398: 2002:    }
12399: 2003:
12400: 2004:    void f() {
12401: 2005:        System.out.println(
12402: 2006:                element.getClass().getSimpleName());
12403: 2007:    }
12404: 2008:}
12405: 2009:
12406: 2010:public class CreatorGeneric {
12407: 2011:    public static void main(String[] args) {
12408: 2012:        XCreator xc = new XCreator();
12409: 2013:        xc.f();
12410: 2014:    }
12411: 2015:}
12412: 2016:/* Output:
12413: 2017:X
12414: 2018:*/
12415: 2019:```
12416: 2020:
12417: 2021:**GenericWithCreate** 包含 `element` 字段，并通过无参构造函数强制其初始化，该构造函数又调用抽象的 `create()` 方法。这种创建方式可以在子类中定义，同时建立 **T** 的类型。
12418: 2022:
12419: 2023:<!-- Arrays of Generics -->
12420: 2024:
12421: 2025:### 泛型数组
12422: 2026:
12423: 2027:正如在 **Erased.java** 中所看到的，我们无法创建泛型数组。通用解决方案是在试图创建泛型数组的时候使用 **ArrayList** ：
12424: 2028:
12425: 2029:```java
12426: 2030:// generics/ListOfGenerics.java
12427: 2031:
12428: 2032:import java.util.ArrayList;
12429: 2033:import java.util.List;
12430: 2034:
12431: 2035:public class ListOfGenerics<T> {
12432: 2036:    private List<T> array = new ArrayList<>();
12433: 2037:
12434: 2038:    public void add(T item) {
12435: 2039:        array.add(item);
12436: 2040:    }
12437: 2041:
12438: 2042:    public T get(int index) {
12439: 2043:        return array.get(index);
12440: 2044:    }
12441: 2045:}
12442: 2046:```
12443: 2047:
12444: 2048:这样做可以获得数组的行为，并且还具有泛型提供的编译时类型安全性。
12445: 2049:
12446: 2050:有时，仍然会创建泛型类型的数组（例如， **ArrayList** 在内部使用数组）。可以通过使编译器满意的方式定义对数组的通用引用：
12447: 2051:
12448: 2052:```java
12449: 2053:// generics/ArrayOfGenericReference.java
12450: 2054:
12451: 2055:class Generic<T> {
12452: 2056:}
12453: 2057:
12454: 2058:public class ArrayOfGenericReference {
12455: 2059:    static Generic<Integer>[] gia;
12456: 2060:}
12457: 2061:```
12458: 2062:
12459: 2063:编译器接受此操作而不产生警告。但是我们永远无法创建具有该确切类型（包括类型参数）的数组，因此有点令人困惑。由于所有数组，无论它们持有什么类型，都具有相同的结构（每个数组插槽的大小和数组布局），因此似乎可以创建一个 **Object** 数组并将其转换为所需的数组类型。实际上，这确实可以编译，但是会产生 **ClassCastException** ：
12460: 2064:
12461: 2065:```java
12462: 2066:// generics/ArrayOfGeneric.java
12463: 2067:
12464: 2068:public class ArrayOfGeneric {
12465: 2069:    static final int SIZE = 100;
12466: 2070:    static Generic<Integer>[] gia;
12467: 2071:
12468: 2072:    @SuppressWarnings("unchecked")
12469: 2073:    public static void main(String[] args) {
12470: 2074:        try {
12471: 2075:            gia = (Generic<Integer>[]) new Object[SIZE];
12472: 2076:        } catch (ClassCastException e) {
12473: 2077:            System.out.println(e.getMessage());
12474: 2078:        }
12475: 2079:        // Runtime type is the raw (erased) type:
12476: 2080:        gia = (Generic<Integer>[]) new Generic[SIZE];
12477: 2081:        System.out.println(gia.getClass().getSimpleName());
12478: 2082:        gia[0] = new Generic<>();
12479: 2083:        //- gia[1] = new Object(); // Compile-time error
12480: 2084:        // Discovers type mismatch at compile time:
12481: 2085:        //- gia[2] = new Generic<Double>();
12482: 2086:    }
12483: 2087:}
12484: 2088:/* Output:
12485: 2089:[Ljava.lang.Object; cannot be cast to [LGeneric;
12486: 2090:Generic[]
12487: 2091:*/
12488: 2092:```
12489: 2093:
12490: 2094:问题在于数组会跟踪其实际类型，而该类型是在创建数组时建立的。因此，即使 `gia` 被强制转换为 `Generic<Integer>[]` ，该信息也仅在编译时存在（并且没有 **@SuppressWarnings** 注解，将会收到有关该强制转换的警告）。在运行时，它仍然是一个 **Object** 数组，这会引起问题。成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换。
12491: 2095:
12492: 2096:让我们看一个更复杂的示例。考虑一个包装数组的简单泛型包装器：
12493: 2097:
12494: 2098:```java
12495: 2099:// generics/GenericArray.java
12496: 2100:
12497: 2101:public class GenericArray<T> {
12498: 2102:    private T[] array;
12499: 2103:
12500: 2104:    @SuppressWarnings("unchecked")
12501: 2105:    public GenericArray(int sz) {
12502: 2106:        array = (T[]) new Object[sz];
12503: 2107:    }
12504: 2108:
12505: 2109:    public void put(int index, T item) {
12506: 2110:        array[index] = item;
12507: 2111:    }
12508: 2112:
12509: 2113:    public T get(int index) {
12510: 2114:        return array[index];
12511: 2115:    }
12512: 2116:
12513: 2117:    // Method that exposes the underlying representation:
12514: 2118:    public T[] rep() {
12515: 2119:        return array;
12516: 2120:    }
12517: 2121:
12518: 2122:    public static void main(String[] args) {
12519: 2123:        GenericArray<Integer> gai = new GenericArray<>(10);
12520: 2124:        try {
12521: 2125:            Integer[] ia = gai.rep();
12522: 2126:        } catch (ClassCastException e) {
12523: 2127:            System.out.println(e.getMessage());
12524: 2128:        }
12525: 2129:        // This is OK:
12526: 2130:        Object[] oa = gai.rep();
12527: 2131:    }
12528: 2132:}
12529: 2133:/* Output:
12530: 2134:[Ljava.lang.Object; cannot be cast to
12531: 2135:[Ljava.lang.Integer;
12532: 2136:*/
12533: 2137:```
12534: 2138:
12535: 2139:和以前一样，我们不能说 `T[] array = new T[sz]` ，所以我们创建了一个 **Object** 数组并将其强制转换。
12536: 2140:
12537: 2141:`rep()` 方法返回一个 `T[]` ，在主方法中它应该是 `gai` 的 `Integer[]`，但是如果调用它并尝试将结果转换为 `Integer[]` 引用，则会得到 **ClassCastException** ，这再次是因为实际的运行时类型为 `Object[]` 。
12538: 2142:
12539: 2143:如果再注释掉 **@SuppressWarnings** 注解后编译 **GenericArray.java** ，则编译器会产生警告：
12540: 2144:
12541: 2145:```java
12542: 2146:GenericArray.java uses unchecked or unsafe operations.
12543: 2147:Recompile with -Xlint:unchecked for details.
12544: 2148:```
12545: 2149:
12546: 2150:在这里，我们收到了一个警告，我们认为这是有关强制转换的。
12547: 2151:
12548: 2152:但是要真正确定，请使用 `-Xlint：unchecked` 进行编译：
12549: 2153:
12550: 2154:```java
12551: 2155:GenericArray.java:7: warning: [unchecked] unchecked cast    array = (T[])new Object[sz];                 ^  required: T[]  found:    Object[]  where T is a type-variable:    T extends Object declared in class GenericArray 1 warning
12552: 2156:```
12553: 2157:
12554: 2158:确实是在抱怨那个强制转换。由于警告会变成噪音，因此，一旦我们确认预期会出现特定警告，我们可以做的最好的办法就是使用 **@SuppressWarnings** 将其关闭。这样，当警告确实出现时，我们将进行实际调查。
12555: 2159:
12556: 2160:由于擦除，数组的运行时类型只能是 `Object[]` 。 如果我们立即将其转换为 `T[]` ，则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。因此，最好在集合中使用 `Object[]` ，并在使用数组元素时向 **T** 添加强制类型转换。让我们来看看在 **GenericArray.java** 示例中会是怎么样的：
12557: 2161:
12558: 2162:```java
12559: 2163:// generics/GenericArray2.java
12560: 2164:
12561: 2165:public class GenericArray2<T> {
12562: 2166:    private Object[] array;
12563: 2167:
12564: 2168:    public GenericArray2(int sz) {
12565: 2169:        array = new Object[sz];
12566: 2170:    }
12567: 2171:
12568: 2172:    public void put(int index, T item) {
12569: 2173:        array[index] = item;
12570: 2174:    }
12571: 2175:
12572: 2176:    @SuppressWarnings("unchecked")
12573: 2177:    public T get(int index) {
12574: 2178:        return (T) array[index];
12575: 2179:    }
12576: 2180:
12577: 2181:    @SuppressWarnings("unchecked")
12578: 2182:    public T[] rep() {
12579: 2183:        return (T[]) array; // Unchecked cast
12580: 2184:    }
12581: 2185:
12582: 2186:    public static void main(String[] args) {
12583: 2187:        GenericArray2<Integer> gai =
12584: 2188:                new GenericArray2<>(10);
12585: 2189:        for (int i = 0; i < 10; i++)
12586: 2190:            gai.put(i, i);
12587: 2191:        for (int i = 0; i < 10; i++)
12588: 2192:            System.out.print(gai.get(i) + " ");
12589: 2193:        System.out.println();
12590: 2194:        try {
12591: 2195:            Integer[] ia = gai.rep();
12592: 2196:        } catch (Exception e) {
12593: 2197:            System.out.println(e);
12594: 2198:        }
12595: 2199:    }
12596: 2200:}
12597: 2201:/* Output:
12598: 2202:0 1 2 3 4 5 6 7 8 9
12599: 2203:java.lang.ClassCastException: [Ljava.lang.Object;
12600: 2204:cannot be cast to [Ljava.lang.Integer;
12601: 2205:*/
12602: 2206:```
12603: 2207:
12604: 2208:最初，看起来并没有太大不同，只是转换的位置移动了。没有 **@SuppressWarnings** 注解，仍然会收到“unchecked”警告。但是，内部表示现在是 `Object[]` 而不是 `T[]` 。 调用 `get()` 时，它将对象强制转换为 **T** ，实际上这是正确的类型，因此很安全。但是，如果调用 `rep()` ，它将再次尝试将 `Object[]` 强制转换为 `T[]` ，但仍然不正确，并在编译时生成警告，并在运行时生成异常。因此，无法破坏基础数组的类型，该基础数组只能是 `Object[]` 。在内部将数组视为 `Object[]` 而不是 `T[]` 的优点是，我们不太可能会忘记数组的运行时类型并意外地引入了bug，尽管大多数（也许是全部）此类错误会在运行时被迅速检测到。
12605: 2209:
12606: 2210:对于新代码，请传入类型标记。在这种情况下，**GenericArray** 如下所示：
12607: 2211:
12608: 2212:```java
12609: 2213:// generics/GenericArrayWithTypeToken.java
12610: 2214:
12611: 2215:import java.lang.reflect.Array;
12612: 2216:
12613: 2217:public class GenericArrayWithTypeToken<T> {
12614: 2218:    private T[] array;
12615: 2219:
12616: 2220:    @SuppressWarnings("unchecked")
12617: 2221:    public GenericArrayWithTypeToken(Class<T> type, int sz) {
12618: 2222:        array = (T[]) Array.newInstance(type, sz);
12619: 2223:    }
12620: 2224:
12621: 2225:    public void put(int index, T item) {
12622: 2226:        array[index] = item;
12623: 2227:    }
12624: 2228:
12625: 2229:    public T get(int index) {
12626: 2230:        return array[index];
12627: 2231:    }
12628: 2232:
12629: 2233:    // Expose the underlying representation:
12630: 2234:    public T[] rep() {
12631: 2235:        return array;
12632: 2236:    }
12633: 2237:
12634: 2238:    public static void main(String[] args) {
12635: 2239:        GenericArrayWithTypeToken<Integer> gai =
12636: 2240:                new GenericArrayWithTypeToken<>(
12637: 2241:                        Integer.class, 10);
12638: 2242:        // This now works:
12639: 2243:        Integer[] ia = gai.rep();
12640: 2244:    }
12641: 2245:}
12642: 2246:```
12643: 2247:
12644: 2248:类型标记 **Class\<T\>** 被传递到构造函数中以从擦除中恢复，因此尽管必须使用 **@SuppressWarnings** 关闭来自强制类型转换的警告，但我们仍可以创建所需的实际数组类型。一旦获得了实际的类型，就可以返回它并产生所需的结果，如在主方法中看到的那样。数组的运行时类型是确切的类型 `T[]` 。
12645: 2249:
12646: 2250:不幸的是，如果查看 Java 标准库中的源代码，你会发现到处都有从 **Object** 数组到参数化类型的转换。例如，这是**ArrayList** 中，复制一个 **Collection** 的构造函数，这里为了简化，去除了源码中对此不重要的代码：
12647: 2251:
12648: 2252:```java
12649: 2253:public ArrayList(Collection c) {
12650: 2254:  size = c.size();
12651: 2255:  elementData = (E[])new Object[size];
12652: 2256:  c.toArray(elementData);
12653: 2257:}
12654: 2258:```
12655: 2259:
12656: 2260:如果你浏览 **ArrayList.java** 的代码，将会发现很多此类强制转换。当我们编译它时会发生什么？
12657: 2261:
12658: 2262:```java
12659: 2263:Note: ArrayList.java uses unchecked or unsafe operations
12660: 2264:Note: Recompile with -Xlint:unchecked for details.
12661: 2265:```
12662: 2266:
12663: 2267:果然，标准库会产生很多警告。如果你使用过 C 语言，尤其是使用 ANSI C 之前的语言，你会记住警告的特殊效果：发现警告后，可以忽略它们。因此，除非程序员必须对其进行处理，否则最好不要从编译器发出任何类型的消息。
12664: 2268:
12665: 2269:Neal Gafter（Java 5 的主要开发人员之一）在他的博客中[^2]指出，他在重写 Java 库时是很随意、马虎的，我们不应该像他那样做。Neal 还指出，他在不破坏现有接口的情况下无法修复某些 Java 库代码。因此，即使在 Java 库源代码中出现了一些习惯用法，它们也不一定是正确的做法。当查看库代码时，我们不能认为这就是要在自己代码中必须遵循的示例。
12666: 2270:
12667: 2271:请注意，在 Java 文献中推荐使用类型标记技术，例如 Gilad Bracha 的论文《Generics in the Java Programming Language》[^3]，他指出：“例如，这种用法已广泛用于新的 API 中以处理注解。” 我发现此技术在人们对于舒适度的看法方面存在一些不一致之处；有些人强烈喜欢本章前面介绍的工厂方法。
12668: 2272:
12669: 2273:<!-- Bounds -->
12670: 2274:
12671: 2275:## 边界
12672: 2276:
12673: 2277:*边界*（bounds）在本章的前面进行了简要介绍。边界允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法。
12674: 2278:
12675: 2279:由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 **Object** 可用的方法。但是，如果将该参数限制为某类型的子集，则可以调用该子集中的方法。为了应用约束，Java 泛型使用了 `extends` 关键字。
12676: 2280:
12677: 2281:重要的是要理解，当用于限定泛型类型时，`extends` 的含义与通常的意义截然不同。此示例展示边界的基础应用：
12678: 2282:
12679: 2283:```java
12680: 2284:// generics/BasicBounds.java
12681: 2285:
12682: 2286:interface HasColor {
12683: 2287:    java.awt.Color getColor();
12684: 2288:}
12685: 2289:
12686: 2290:class WithColor<T extends HasColor> {
12687: 2291:    T item;
12688: 2292:
12689: 2293:    WithColor(T item) {
12690: 2294:        this.item = item;
12691: 2295:    }
12692: 2296:
12693: 2297:    T getItem() {
12694: 2298:        return item;
12695: 2299:    }
12696: 2300:
12697: 2301:    // The bound allows you to call a method:
12698: 2302:    java.awt.Color color() {
12699: 2303:        return item.getColor();
12700: 2304:    }
12701: 2305:}
12702: 2306:
12703: 2307:class Coord {
12704: 2308:    public int x, y, z;
12705: 2309:}
12706: 2310:
12707: 2311:// This fails. Class must be first, then interfaces:
12708: 2312:// class WithColorCoord<T extends HasColor & Coord> {
12709: 2313:
12710: 2314:// Multiple bounds:
12711: 2315:class WithColorCoord<T extends Coord & HasColor> {
12712: 2316:    T item;
12713: 2317:
12714: 2318:    WithColorCoord(T item) {
12715: 2319:        this.item = item;
12716: 2320:    }
12717: 2321:
12718: 2322:    T getItem() {
12719: 2323:        return item;
12720: 2324:    }
12721: 2325:
12722: 2326:    java.awt.Color color() {
12723: 2327:        return item.getColor();
12724: 2328:    }
12725: 2329:
12726: 2330:    int getX() {
12727: 2331:        return item.x;
12728: 2332:    }
12729: 2333:
12730: 2334:    int getY() {
12731: 2335:        return item.y;
12732: 2336:    }
12733: 2337:
12734: 2338:    int getZ() {
12735: 2339:        return item.z;
12736: 2340:    }
12737: 2341:}
12738: 2342:
12739: 2343:interface Weight {
12740: 2344:    int weight();
12741: 2345:}
12742: 2346:
12743: 2347:// As with inheritance, you can have only one
12744: 2348:// concrete class but multiple interfaces:
12745: 2349:class Solid<T extends Coord & HasColor & Weight> {
12746: 2350:    T item;
12747: 2351:
12748: 2352:    Solid(T item) {
12749: 2353:        this.item = item;
12750: 2354:    }
12751: 2355:
12752: 2356:    T getItem() {
12753: 2357:        return item;
12754: 2358:    }
12755: 2359:
12756: 2360:    java.awt.Color color() {
12757: 2361:        return item.getColor();
12758: 2362:    }
12759: 2363:
12760: 2364:    int getX() {
12761: 2365:        return item.x;
12762: 2366:    }
12763: 2367:
12764: 2368:    int getY() {
12765: 2369:        return item.y;
12766: 2370:    }
12767: 2371:
12768: 2372:    int getZ() {
12769: 2373:        return item.z;
12770: 2374:    }
12771: 2375:
12772: 2376:    int weight() {
12773: 2377:        return item.weight();
12774: 2378:    }
12775: 2379:}
12776: 2380:
12777: 2381:class Bounded
12778: 2382:        extends Coord implements HasColor, Weight {
12779: 2383:    @Override
12780: 2384:    public java.awt.Color getColor() {
12781: 2385:        return null;
12782: 2386:    }
12783: 2387:
12784: 2388:    @Override
12785: 2389:    public int weight() {
12786: 2390:        return 0;
12787: 2391:    }
12788: 2392:}
12789: 2393:
12790: 2394:public class BasicBounds {
12791: 2395:    public static void main(String[] args) {
12792: 2396:        Solid<Bounded> solid =
12793: 2397:                new Solid<>(new Bounded());
12794: 2398:        solid.color();
12795: 2399:        solid.getY();
12796: 2400:        solid.weight();
12797: 2401:    }
12798: 2402:}
12799: 2403:```
12800: 2404:
12801: 2405:你可能会观察到 **BasicBounds.java** 中似乎包含一些冗余，它们可以通过继承来消除。在这里，每个继承级别还添加了边界约束：
12802: 2406:
12803: 2407:```java
12804: 2408:// generics/InheritBounds.java
12805: 2409:
12806: 2410:class HoldItem<T> {
12807: 2411:    T item;
12808: 2412:
12809: 2413:    HoldItem(T item) {
12810: 2414:        this.item = item;
12811: 2415:    }
12812: 2416:
12813: 2417:    T getItem() {
12814: 2418:        return item;
12815: 2419:    }
12816: 2420:}
12817: 2421:
12818: 2422:class WithColor2<T extends HasColor>
12819: 2423:        extends HoldItem<T> {
12820: 2424:    WithColor2(T item) {
12821: 2425:        super(item);
12822: 2426:    }
12823: 2427:
12824: 2428:    java.awt.Color color() {
12825: 2429:        return item.getColor();
12826: 2430:    }
12827: 2431:}
12828: 2432:
12829: 2433:class WithColorCoord2<T extends Coord & HasColor>
12830: 2434:        extends WithColor2<T> {
12831: 2435:    WithColorCoord2(T item) {
12832: 2436:        super(item);
12833: 2437:    }
12834: 2438:
12835: 2439:    int getX() {
12836: 2440:        return item.x;
12837: 2441:    }
12838: 2442:
12839: 2443:    int getY() {
12840: 2444:        return item.y;
12841: 2445:    }
12842: 2446:
12843: 2447:    int getZ() {
12844: 2448:        return item.z;
12845: 2449:    }
12846: 2450:}
12847: 2451:
12848: 2452:class Solid2<T extends Coord & HasColor & Weight>
12849: 2453:        extends WithColorCoord2<T> {
12850: 2454:    Solid2(T item) {
12851: 2455:        super(item);
12852: 2456:    }
12853: 2457:
12854: 2458:    int weight() {
12855: 2459:        return item.weight();
12856: 2460:    }
12857: 2461:}
12858: 2462:
12859: 2463:public class InheritBounds {
12860: 2464:    public static void main(String[] args) {
12861: 2465:        Solid2<Bounded> solid2 =
12862: 2466:                new Solid2<>(new Bounded());
12863: 2467:        solid2.color();
12864: 2468:        solid2.getY();
12865: 2469:        solid2.weight();
12866: 2470:    }
12867: 2471:}
12868: 2472:```
12869: 2473:
12870: 2474:**HoldItem** 拥有一个对象，因此此行为将继承到 **WithColor2** 中，这也需要其参数符合 **HasColor**。 **WithColorCoord2** 和 **Solid2** 进一步扩展了层次结构，并在每个级别添加了边界。现在，这些方法已被继承，并且在每个类中不再重复。
12871: 2475:
12872: 2476:这是一个具有更多层次的示例：
12873: 2477:
12874: 2478:```java
12875: 2479:// generics/EpicBattle.java
12876: 2480:// Bounds in Java generics
12877: 2481:
12878: 2482:import java.util.List;
12879: 2483:
12880: 2484:interface SuperPower {
12881: 2485:}
12882: 2486:
12883: 2487:interface XRayVision extends SuperPower {
12884: 2488:    void seeThroughWalls();
12885: 2489:}
12886: 2490:
12887: 2491:interface SuperHearing extends SuperPower {
12888: 2492:    void hearSubtleNoises();
12889: 2493:}
12890: 2494:
12891: 2495:interface SuperSmell extends SuperPower {
12892: 2496:    void trackBySmell();
12893: 2497:}
12894: 2498:
12895: 2499:class SuperHero<POWER extends SuperPower> {
12896: 2500:    POWER power;
12897: 2501:
12898: 2502:    SuperHero(POWER power) {
12899: 2503:        this.power = power;
12900: 2504:    }
12901: 2505:
12902: 2506:    POWER getPower() {
12903: 2507:        return power;
12904: 2508:    }
12905: 2509:}
12906: 2510:
12907: 2511:class SuperSleuth<POWER extends XRayVision>
12908: 2512:        extends SuperHero<POWER> {
12909: 2513:    SuperSleuth(POWER power) {
12910: 2514:        super(power);
12911: 2515:    }
12912: 2516:
12913: 2517:    void see() {
12914: 2518:        power.seeThroughWalls();
12915: 2519:    }
12916: 2520:}
12917: 2521:
12918: 2522:class
12919: 2523:CanineHero<POWER extends SuperHearing & SuperSmell>
12920: 2524:        extends SuperHero<POWER> {
12921: 2525:    CanineHero(POWER power) {
12922: 2526:        super(power);
12923: 2527:    }
12924: 2528:
12925: 2529:    void hear() {
12926: 2530:        power.hearSubtleNoises();
12927: 2531:    }
12928: 2532:
12929: 2533:    void smell() {
12930: 2534:        power.trackBySmell();
12931: 2535:    }
12932: 2536:}
12933: 2537:
12934: 2538:class SuperHearSmell
12935: 2539:        implements SuperHearing, SuperSmell {
12936: 2540:    @Override
12937: 2541:    public void hearSubtleNoises() {
12938: 2542:    }
12939: 2543:
12940: 2544:    @Override
12941: 2545:    public void trackBySmell() {
12942: 2546:    }
12943: 2547:}
12944: 2548:
12945: 2549:class DogPerson extends CanineHero<SuperHearSmell> {
12946: 2550:    DogPerson() {
12947: 2551:        super(new SuperHearSmell());
12948: 2552:    }
12949: 2553:}
12950: 2554:
12951: 2555:public class EpicBattle {
12952: 2556:    // Bounds in generic methods:
12953: 2557:    static <POWER extends SuperHearing>
12954: 2558:    void useSuperHearing(SuperHero<POWER> hero) {
12955: 2559:        hero.getPower().hearSubtleNoises();
12956: 2560:    }
12957: 2561:
12958: 2562:    static <POWER extends SuperHearing & SuperSmell>
12959: 2563:    void superFind(SuperHero<POWER> hero) {
12960: 2564:        hero.getPower().hearSubtleNoises();
12961: 2565:        hero.getPower().trackBySmell();
12962: 2566:    }
12963: 2567:
12964: 2568:    public static void main(String[] args) {
12965: 2569:        DogPerson dogPerson = new DogPerson();
12966: 2570:        useSuperHearing(dogPerson);
12967: 2571:        superFind(dogPerson);
12968: 2572:        // You can do this:
12969: 2573:        List<? extends SuperHearing> audioPeople;
12970: 2574:        // But you can't do this:
12971: 2575:        // List<? extends SuperHearing & SuperSmell> dogPs;
12972: 2576:    }
12973: 2577:}
12974: 2578:```
12975: 2579:
12976: 2580:接下来将要研究的通配符将会把范围限制在单个类型。
12977: 2581:
12978: 2582:<!-- Wildcards -->
12979: 2583:
12980: 2584:## 通配符
12981: 2585:
12982: 2586:你已经在 [集合](book/12-Collections.md) 章节中看到了一些简单示例使用了通配符——在泛型参数表达式中的问号，在 [类型信息](book/19-Type-Information.md) 一章中这种示例更多。本节将更深入地探讨这个特性。
12983: 2587:
12984: 2588:我们的起始示例要展示数组的一种特殊行为：你可以将派生类的数组赋值给基类的引用：
12985: 2589:
12986: 2590:```java
12987: 2591:// generics/CovariantArrays.java
12988: 2592:
12989: 2593:class Fruit {}
12990: 2594:
12991: 2595:class Apple extends Fruit {}
12992: 2596:
12993: 2597:class Jonathan extends Apple {}
12994: 2598:
12995: 2599:class Orange extends Fruit {}
12996: 2600:
12997: 2601:public class CovariantArrays {
12998: 2602:    
12999: 2603:    public static void main(String[] args) {
13000: 2604:        Fruit[] fruit = new Apple[10];
13001: 2605:        fruit[0] = new Apple(); // OK
13002: 2606:        fruit[1] = new Jonathan(); // OK
13003: 2607:        // Runtime type is Apple[], not Fruit[] or Orange[]:
13004: 2608:        try {
13005: 2609:            // Compiler allows you to add Fruit:
13006: 2610:            fruit[0] = new Fruit(); // ArrayStoreException
13007: 2611:        } catch (Exception e) {
13008: 2612:            System.out.println(e);
13009: 2613:        }
13010: 2614:        try {
13011: 2615:            // Compiler allows you to add Oranges:
13012: 2616:            fruit[0] = new Orange(); // ArrayStoreException
13013: 2617:        } catch (Exception e) {
13014: 2618:            System.out.println(e);
13015: 2619:        }
13016: 2620:    }
13017: 2621:}
13018: 2622:/* Output:
13019: 2623:java.lang.ArrayStoreException: Fruit
13020: 2624:java.lang.ArrayStoreException: Orange
13021: 2625:```
13022: 2626:
13023: 2627:`main()` 中的第一行创建了 **Apple** 数组，并赋值给一个 **Fruit** 数组引用。这是有意义的，因为 **Apple** 也是一种 **Fruit**，因此 **Apple** 数组应该也是一个 **Fruit** 数组。
13024: 2628:
13025: 2629:但是，如果实际的数组类型是 **Apple[]**，你可以在其中放置 **Apple** 或 **Apple** 的子类型，这在编译期和运行时都可以工作。但是你也可以在数组中放置 **Fruit** 对象。这对编译器来说是有意义的，因为它有一个 **Fruit[]** 引用——它有什么理由不允许将 **Fruit** 对象或任何从 **Fruit** 继承出来的对象（比如 **Orange**），放置到这个数组中呢？因此在编译期，这是允许的。然而，运行时的数组机制知道它处理的是 **Apple[]**，因此会在向数组中放置异构类型时抛出异常。
13026: 2630:
13027: 2631:向上转型用在这里不合适。你真正在做的是将一个数组赋值给另一个数组。数组的行为是持有其他对象，这里只是因为我们能够向上转型而已，所以很明显，数组对象可以保留有关它们包含的对象类型的规则。看起来就像数组对它们持有的对象是有意识的，因此在编译期检查和运行时检查之间，你不能滥用它们。
13028: 2632:
13029: 2633:数组的这种赋值并不是那么可怕，因为在运行时你可以发现插入了错误的类型。但是泛型的主要目标之一是将这种错误检测移到编译期。所以当我们试图使用泛型集合代替数组时，会发生什么呢？
13030: 2634:
13031: 2635:```java
13032: 2636:// generics/NonCovariantGenerics.java
13033: 2637:// {WillNotCompile}
13034: 2638:
13035: 2639:import java.util.*;
13036: 2640:
13037: 2641:public class NonCovariantGenerics {
13038: 2642:    // Compile Error: incompatible types:
13039: 2643:    List<Fruit> flist = new ArrayList<Apple>();
13040: 2644:}
13041: 2645:```
13042: 2646:
13043: 2647:尽管你在首次阅读这段代码时会认为“不能将一个 **Apple** 集合赋值给一个 **Fruit** 集合”。记住，泛型不仅仅是关于集合，它真正要表达的是“不能把一个涉及 **Apple** 的泛型赋值给一个涉及 **Fruit** 的泛型”。如果像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及到的集合，那么它可能会留下一些余地。但是它不知道任何有关这方面的信息，因此它拒绝向上转型。然而实际上这也不是向上转型—— **Apple** 的 **List** 不是 **Fruit** 的 **List**。**Apple** 的 **List** 将持有 **Apple** 和 **Apple** 的子类型，**Fruit** 的 **List** 将持有任何类型的 **Fruit**。是的，这包括 **Apple**，但是它不是一个 **Apple** 的 **List**，它仍然是 **Fruit** 的 **List**。**Apple** 的 **List** 在类型上不等价于 **Fruit** 的 **List**，即使 **Apple** 是一种 **Fruit** 类型。
13044: 2648:
13045: 2649:真正的问题是我们在讨论的集合类型，而不是集合持有对象的类型。与数组不同，泛型没有内建的协变类型。这是因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查，但是在使用泛型时，编译器和运行时系统不知道你想用类型做什么，以及应该采用什么规则。
13046: 2650:
13047: 2651:但是，有时你想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。
13048: 2652:
13049: 2653:```java
13050: 2654:// generics/GenericsAndCovariance.java
13051: 2655:
13052: 2656:import java.util.*;
13053: 2657:
13054: 2658:public class GenericsAndCovariance {
13055: 2659:    
13056: 2660:    public static void main(String[] args) {
13057: 2661:        // Wildcards allow covariance:
13058: 2662:        List<? extends Fruit> flist = new ArrayList<>();
13059: 2663:        // Compile Error: can't add any type of object:
13060: 2664:        // flist.add(new Apple());
13061: 2665:        // flist.add(new Fruit());
13062: 2666:        // flist.add(new Object());
13063: 2667:        flist.add(null); // Legal but uninteresting
13064: 2668:        // We know it returns at least Fruit:
13065: 2669:        Fruit f = flist.get(0);
13066: 2670:    }
13067: 2671:    
13068: 2672:}
13069: 2673:```
13070: 2674:
13071: 2675:**flist** 的类型现在是 `List<? extends Fruit>`，你可以读作“一个具有任何从 **Fruit** 继承的类型的列表”。然而，这实际上并不意味着这个 **List** 将持有任何类型的 **Fruit**。通配符引用的是明确的类型，因此它意味着“某种 **flist** 引用没有指定的具体类型”。因此这个被赋值的 **List** 必须持有诸如 **Fruit** 或 **Apple** 这样的指定类型，但是为了向上转型为 **Fruit**，这个类型是什么没人在意。
13072: 2676:
13073: 2677:**List** 必须持有一种具体的 **Fruit** 或 **Fruit** 的子类型，但是如果你不关心具体的类型是什么，那么你能对这样的 **List** 做什么呢？如果不知道 **List** 中持有的对象是什么类型，你怎能保证安全地向其中添加对象呢？就像在 **CovariantArrays.java** 中向上转型一样，你不能，除非编译器而不是运行时系统可以阻止这种操作的发生。你很快就会发现这个问题。
13074: 2678:
13075: 2679:你可能认为事情开始变得有点走极端了，因为现在你甚至不能向刚刚声明过将持有 **Apple** 对象的 **List** 中放入一个 **Apple** 对象。是的，但编译器并不知道这一点。`List<? extends Fruit>` 可能合法地指向一个 `List<Orange>`。一旦执行这种类型的向上转型，你就丢失了向其中传递任何对象的能力，甚至传递 **Object** 也不行。
13076: 2680:
13077: 2681:另一方面，如果你调用了一个返回 **Fruit** 的方法，则是安全的，因为你知道这个 **List** 中的任何对象至少具有 **Fruit** 类型，因此编译器允许这么做。
13078: 2682:
13079: 2683:### 编译器有多聪明
13080: 2684:
13081: 2685:现在你可能会猜想自己不能去调用任何接受参数的方法，但是考虑下面的代码：
13082: 2686:
13083: 2687:```java
13084: 2688:// generics/CompilerIntelligence.java
13085: 2689:
13086: 2690:import java.util.*;
13087: 2691:
13088: 2692:public class CompilerIntelligence {
13089: 2693:    
13090: 2694:    public static void main(String[] args) {
13091: 2695:        List<? extends Fruit> flist = Arrays.asList(new Apple());
13092: 2696:        Apple a = (Apple) flist.get(0); // No warning
13093: 2697:        flist.contains(new Apple()); // Argument is 'Object'
13094: 2698:        flist.indexOf(new Apple()); // Argument is 'Object'
13095: 2699:    }
13096: 2700:    
13097: 2701:}
13098: 2702:```
13099: 2703:
13100: 2704:这里对 `contains()` 和 `indexOf()` 的调用接受 **Apple** 对象作为参数，执行没问题。这是否意味着编译器实际上会检查代码，以查看是否有某个特定的方法修改了它的对象？
13101: 2705:
13102: 2706:通过查看 **ArrayList** 的文档，我们发现编译器没有那么聪明。尽管 `add()` 接受一个泛型参数类型的参数，但 `contains()` 和 `indexOf()` 接受的参数类型是 **Object**。因此当你指定一个 `ArrayList<? extends Fruit>` 时，`add()` 的参数就变成了"**? extends Fruit**"。从这个描述中，编译器无法得知这里需要 **Fruit** 的哪个具体子类型，因此它不会接受任何类型的 **Fruit**。如果你先把 **Apple** 向上转型为 **Fruit**，也没有关系——编译器仅仅会拒绝调用像 `add()` 这样参数列表中涉及通配符的方法。
13103: 2707:
13104: 2708:`contains()` 和 `indexOf()` 的参数类型是 **Object**，不涉及通配符，所以编译器允许调用它们。这意味着将由泛型类的设计者来决定哪些调用是“安全的”，并使用 **Object** 类作为它们的参数类型。为了禁止对类型中使用了通配符的方法调用，需要在参数列表中使用类型参数。
13105: 2709:
13106: 2710:下面展示一个简单的 **Holder** 类：
13107: 2711:
13108: 2712:```java
13109: 2713:// generics/Holder.java
13110: 2714:
13111: 2715:public class Holder<T> {
13112: 2716:
13113: 2717:    private T value;
13114: 2718:
13115: 2719:    public Holder() {}
13116: 2720:
13117: 2721:    public Holder(T val) {
13118: 2722:        value = val;
13119: 2723:    }
13120: 2724:
13121: 2725:    public void set(T val) {
13122: 2726:        value = val;
13123: 2727:    }
13124: 2728:
13125: 2729:    public T get() {
13126: 2730:        return value;
13127: 2731:    }
13128: 2732:
13129: 2733:    @Override
13130: 2734:    public boolean equals(Object o) {
13131: 2735:        return o instanceof Holder && Objects.equals(value, ((Holder) o).value);
13132: 2736:    }
13133: 2737:
13134: 2738:    @Override
13135: 2739:    public int hashCode() {
13136: 2740:        return Objects.hashCode(value);
13137: 2741:    }
13138: 2742:
13139: 2743:    public static void main(String[] args) {
13140: 2744:        Holder<Apple> apple = new Holder<>(new Apple());
13141: 2745:        Apple d = apple.get();
13142: 2746:        apple.set(d);
13143: 2747:        // Holder<Fruit> fruit = apple; // Cannot upcast
13144: 2748:        Holder<? extends Fruit> fruit = apple; // OK
13145: 2749:        Fruit p = fruit.get();
13146: 2750:        d = (Apple) fruit.get();
13147: 2751:        try {
13148: 2752:            Orange c = (Orange) fruit.get(); // No warning
13149: 2753:        } catch (Exception e) {
13150: 2754:            System.out.println(e);
13151: 2755:        }
13152: 2756:        // fruit.set(new Apple()); // Cannot call set()
13153: 2757:        // fruit.set(new Fruit()); // Cannot call set()
13154: 2758:        System.out.println(fruit.equals(d)); // OK
13155: 2759:    }
13156: 2760:}
13157: 2761:/* Output
13158: 2762:java.lang.ClassCastException: Apple cannot be cast to Orange
13159: 2763:false
13160: 2764:*/
13161: 2765:```
13162: 2766:
13163: 2767:**Holder** 有一个接受 **T** 类型对象的 `set()` 方法，一个返回 T 对象的 `get()` 方法和一个接受 Object 对象的 `equals()` 方法。正如你所见，如果创建了一个 `Holder<Apple>`，就不能将其向上转型为 `Holder<Fruit>`，但是可以向上转型为 `Holder<? extends Fruit>`。如果调用 `get()`，只能返回一个 **Fruit**——这就是在给定“任何扩展自 **Fruit** 的对象”这一边界后，它所能知道的一切了。如果你知道更多的信息，就可以将其转型到某种具体的 **Fruit** 而不会导致任何警告，但是存在得到 **ClassCastException** 的风险。`set()` 方法不能工作在 **Apple** 和 **Fruit** 上，因为 `set()` 的参数也是"**? extends Fruit**"，意味着它可以是任何事物，编译器无法验证“任何事物”的类型安全性。
13164: 2768:
13165: 2769:但是，`equals()` 方法可以正常工作，因为它接受的参数是 **Object** 而不是 **T** 类型。因此，编译器只关注传递进来和要返回的对象类型。它不会分析代码，以查看是否执行了任何实际的写入和读取操作。
13166: 2770:
13167: 2771:Java 7 引入了 **java.util.Objects** 库，使创建 `equals()` 和 `hashCode()` 方法变得更加容易，当然还有很多其他功能。`equals()` 方法的标准形式参考 [附录：理解 equals 和 hashCode 方法](book/Appendix-Understanding-equals-and-hashCode) 一章。
13168: 2772:
13169: 2773:### 逆变
13170: 2774:
13171: 2775:还可以走另外一条路，即使用超类型通配符。这里，可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 `<？super MyClass>` ，或者甚至使用类型参数： `<？super T>`（尽管你不能对泛型参数给出一个超类型边界；即不能声明 `<T super MyClass>` ）。这使得你可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，就可以向 **Collection** 写入了：
13172: 2776:
13173: 2777:```java
13174: 2778:// generics/SuperTypeWildcards.java
13175: 2779:import java.util.*;
13176: 2780:public class SuperTypeWildcards {
13177: 2781:    static void writeTo(List<? super Apple> apples) {
13178: 2782:        apples.add(new Apple());
13179: 2783:        apples.add(new Jonathan());
13180: 2784:        // apples.add(new Fruit()); // Error
13181: 2785:    }
13182: 2786:}
13183: 2787:```
13184: 2788:
13185: 2789:参数 **apples** 是 **Apple** 的某种基类型的 **List**，这样你就知道向其中添加 **Apple** 或 **Apple** 的子类型是安全的。但是因为 **Apple** 是下界，所以你知道向这样的 **List** 中添加 **Fruit** 是不安全的，因为这将使这个 **List** 敞开口子，从而可以向其中添加非 **Apple** 类型的对象，而这是违反静态类型安全的。
13186: 2790:下面的示例复习了一下逆变和通配符的的使用：
13187: 2791:
13188: 2792:```java
13189: 2793:// generics/GenericReading.java
13190: 2794:import java.util.*;
13191: 2795:
13192: 2796:public class GenericReading {
13193: 2797:    static List<Apple> apples = Arrays.asList(new Apple());
13194: 2798:    static List<Fruit> fruit = Arrays.asList(new Fruit());
13195: 2799:    
13196: 2800:    static <T> T readExact(List<T> list) {
13197: 2801:        return list.get(0);
13198: 2802:    }
13199: 2803:    
13200: 2804:    // A static method adapts to each call:
13201: 2805:    static void f1() {
13202: 2806:        Apple a = readExact(apples);
13203: 2807:        Fruit f = readExact(fruit);
13204: 2808:        f = readExact(apples);
13205: 2809:    }
13206: 2810:    
13207: 2811:    // A class type is established
13208: 2812:    // when the class is instantiated:
13209: 2813:    static class Reader<T> {
13210: 2814:        T readExact(List<T> list) { 
13211: 2815:            return list.get(0); 
13212: 2816:        }
13213: 2817:    }
13214: 2818:    
13215: 2819:    static void f2() {
13216: 2820:        Reader<Fruit> fruitReader = new Reader<>();
13217: 2821:        Fruit f = fruitReader.readExact(fruit);
13218: 2822:        //- Fruit a = fruitReader.readExact(apples);
13219: 2823:        // error: incompatible types: List<Apple>
13220: 2824:        // cannot be converted to List<Fruit>
13221: 2825:    }
13222: 2826:    
13223: 2827:    static class CovariantReader<T> {
13224: 2828:        T readCovariant(List<? extends T> list) {
13225: 2829:            return list.get(0);
13226: 2830:        }
13227: 2831:    }
13228: 2832:    
13229: 2833:    static void f3() {
13230: 2834:        CovariantReader<Fruit> fruitReader = new CovariantReader<>();
13231: 2835:        Fruit f = fruitReader.readCovariant(fruit);
13232: 2836:        Fruit a = fruitReader.readCovariant(apples);
13233: 2837:    }
13234: 2838:    
13235: 2839:    public static void main(String[] args) {
13236: 2840:        f1(); 
13237: 2841:        f2(); 
13238: 2842:        f3();
13239: 2843:    }
13240: 2844:}
13241: 2845:```
13242: 2846:
13243: 2847:`readExact()` 方法使用了精确的类型。如果使用这个没有任何通配符的精确类型，就可以向 **List** 中写入和读取这个精确类型。另外，对于返回值，静态的泛型方法 `readExact()` 可以有效地“适应”每个方法调用，并能够从 `List<Apple>` 中返回一个 **Apple** ，从 `List<Fruit>` 中返回一个 **Fruit** ，就像在 `f1()` 中看到的那样。因此，如果可以摆脱静态泛型方法，那么在读取时就不需要协变类型了。
13244: 2848:然而对于泛型类来说，当你创建这个类的实例时，就要为这个类确定参数。就像在 `f2()` 中看到的，**fruitReader** 实例可以从 `List<Fruit>` 中读取一个 **Fruit** ，因为这就是它的确切类型。但是 `List<Apple>` 也应该产生 **Fruit** 对象，而 **fruitReader** 不允许这么做。
13245: 2849:为了修正这个问题，`CovariantReader.readCovariant()` 方法将接受 `List<？extends T>` ，因此，从这个列表中读取一个 **T** 是安全的（你知道在这个列表中的所有对象至少是一个 **T** ，并且可能是从 T 导出的某种对象）。在 `f3()` 中，你可以看到现在可以从 `List<Apple>` 中读取 **Fruit** 了。
13246: 2850:
13247: 2851:### 无界通配符
13248: 2852:
13249: 2853:无界通配符 `<?>` 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器初看起来是支持这种判断的：
13250: 2854:
13251: 2855:```java
13252: 2856:// generics/UnboundedWildcards1.java
13253: 2857:import java.util.*;
13254: 2858:
13255: 2859:public class UnboundedWildcards1 {
13256: 2860:    static List list1;
13257: 2861:    static List<?> list2;
13258: 2862:    static List<? extends Object> list3;
13259: 2863:  
13260: 2864:    static void assign1(List list) {
13261: 2865:        list1 = list;
13262: 2866:        list2 = list;
13263: 2867:        //- list3 = list;
13264: 2868:        // warning: [unchecked] unchecked conversion
13265: 2869:        // list3 = list;
13266: 2870:        //         ^
13267: 2871:        // required: List<? extends Object>
13268: 2872:        // found:    List
13269: 2873:    }
13270: 2874:    
13271: 2875:    static void assign2(List<?> list) {
13272: 2876:        list1 = list;
13273: 2877:        list2 = list;
13274: 2878:        list3 = list;
13275: 2879:    }
13276: 2880:    
13277: 2881:    static void assign3(List<? extends Object> list) {
13278: 2882:        list1 = list;
13279: 2883:        list2 = list;
13280: 2884:        list3 = list;
13281: 2885:    }
13282: 2886:    
13283: 2887:    public static void main(String[] args) {
13284: 2888:        assign1(new ArrayList());
13285: 2889:        assign2(new ArrayList());
13286: 2890:        //- assign3(new ArrayList());
13287: 2891:        // warning: [unchecked] unchecked method invocation:
13288: 2892:        // method assign3 in class UnboundedWildcards1
13289: 2893:        // is applied to given types
13290: 2894:        // assign3(new ArrayList());
13291: 2895:        //        ^
13292: 2896:        // required: List<? extends Object>
13293: 2897:        // found: ArrayList
13294: 2898:        // warning: [unchecked] unchecked conversion
13295: 2899:        // assign3(new ArrayList());
13296: 2900:        //         ^
13297: 2901:        // required: List<? extends Object>
13298: 2902:        // found:    ArrayList
13299: 2903:        // 2 warnings
13300: 2904:        assign1(new ArrayList<>());
13301: 2905:        assign2(new ArrayList<>());
13302: 2906:        assign3(new ArrayList<>());
13303: 2907:        // Both forms are acceptable as List<?>:
13304: 2908:        List<?> wildList = new ArrayList();
13305: 2909:        wildList = new ArrayList<>();
13306: 2910:        assign1(wildList);
13307: 2911:        assign2(wildList);
13308: 2912:        assign3(wildList);
13309: 2913:    }
13310: 2914:}
13311: 2915:```
13312: 2916:
13313: 2917:有很多情况都和你在这里看到的情况类似，即编译器很少关心使用的是原生类型还是 `<?>` 。在这些情况中，`<?>` 可以被认为是一种装饰，但是它仍旧是很有价值的，因为，实际上它是在声明：“我是想用 Java 的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型。”
13314: 2918:第二个示例展示了无界通配符的一个重要应用。当你在处理多个泛型参数时，有时允许一个参数可以是任何类型，同时为其他参数确定某种特定类型的这种能力会显得很重要：
13315: 2919:
13316: 2920:```java
13317: 2921:// generics/UnboundedWildcards2.java
13318: 2922:import java.util.*;
13319: 2923:
13320: 2924:public class UnboundedWildcards2 {
13321: 2925:    static Map map1;
13322: 2926:    static Map<?,?> map2;
13323: 2927:    static Map<String,?> map3;
13324: 2928:  
13325: 2929:    static void assign1(Map map) { 
13326: 2930:        map1 = map; 
13327: 2931:    }
13328: 2932:    
13329: 2933:    static void assign2(Map<?,?> map) { 
13330: 2934:        map2 = map; 
13331: 2935:    }
13332: 2936:    
13333: 2937:    static void assign3(Map<String,?> map) { 
13334: 2938:        map3 = map; 
13335: 2939:    }
13336: 2940:    
13337: 2941:    public static void main(String[] args) {
13338: 2942:        assign1(new HashMap());
13339: 2943:        assign2(new HashMap());
13340: 2944:        //- assign3(new HashMap());
13341: 2945:        // warning: [unchecked] unchecked method invocation:
13342: 2946:        // method assign3 in class UnboundedWildcards2
13343: 2947:        // is applied to given types
13344: 2948:        //     assign3(new HashMap());
13345: 2949:        //            ^
13346: 2950:        //   required: Map<String,?>
13347: 2951:        //   found: HashMap
13348: 2952:        // warning: [unchecked] unchecked conversion
13349: 2953:        //     assign3(new HashMap());
13350: 2954:        //             ^
13351: 2955:        //   required: Map<String,?>
13352: 2956:        //   found:    HashMap
13353: 2957:        // 2 warnings
13354: 2958:        assign1(new HashMap<>());
13355: 2959:        assign2(new HashMap<>());
13356: 2960:        assign3(new HashMap<>());
13357: 2961:    }
13358: 2962:}
13359: 2963:```
13360: 2964:
13361: 2965:但是，当你拥有的全都是无界通配符时，就像在 `Map<?,?>` 中看到的那样，编译器看起来就无法将其与原生 **Map** 区分开了。另外， **UnboundedWildcards1.java** 展示了编译器处理  `List<?>` 和 `List<? extends Object>` 是不同的。
13362: 2966:令人困惑的是，编译器并非总是关注像 `List` 和 `List<?>` 之间的这种差异，因此它们看起来就像是相同的事物。事实上，因为泛型参数擦除到它的第一个边界，因此 `List<?>` 看起来等价于 `List<Object>` ，而 **List** 实际上也是 `List<Object>` ——除非这些语句都不为真。**List** 实际上表示“持有任何 **Object** 类型的原生 **List** ”，而 `List<?>` 表示“具有某种特定类型的非原生 **List** ，只是我们不知道类型是什么。”
13363: 2967:编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？下面的示例使用了前面定义的 `Holder<T>` 类，它包含接受 **Holder** 作为参数的各种方法，但是它们具有不同的形式：作为原生类型，具有具体的类型参数以及具有无界通配符参数：
13364: 2968:
13365: 2969:```java
13366: 2970:// generics/Wildcards.java
13367: 2971:// Exploring the meaning of wildcards
13368: 2972:
13369: 2973:public class Wildcards {
13370: 2974:    // Raw argument:
13371: 2975:    static void rawArgs(Holder holder, Object arg) {
13372: 2976:        //- holder.set(arg);
13373: 2977:        // warning: [unchecked] unchecked call to set(T)
13374: 2978:        // as a member of the raw type Holder
13375: 2979:        //     holder.set(arg);
13376: 2980:        //               ^
13377: 2981:        //   where T is a type-variable:
13378: 2982:        //     T extends Object declared in class Holder
13379: 2983:        // 1 warning
13380: 2984:
13381: 2985:        // Can't do this; don't have any 'T':
13382: 2986:        // T t = holder.get();
13383: 2987:
13384: 2988:        // OK, but type information is lost:
13385: 2989:        Object obj = holder.get();
13386: 2990:    }
13387: 2991:    
13388: 2992:    // Like rawArgs(), but errors instead of warnings:
13389: 2993:    static void unboundedArg(Holder<?> holder, Object arg) {
13390: 2994:        //- holder.set(arg);
13391: 2995:        // error: method set in class Holder<T>
13392: 2996:        // cannot be applied to given types;
13393: 2997:        //     holder.set(arg);
13394: 2998:        //           ^
13395: 2999:        //   required: CAP#1
13396: 3000:        //   found: Object
13397: 3001:        //   reason: argument mismatch;
13398: 3002:        //     Object cannot be converted to CAP#1
13399: 3003:        //   where T is a type-variable:
13400: 3004:        //     T extends Object declared in class Holder
13401: 3005:        //   where CAP#1 is a fresh type-variable:
13402: 3006:        //     CAP#1 extends Object from capture of ?
13403: 3007:        // 1 error
13404: 3008:
13405: 3009:        // Can't do this; don't have any 'T':
13406: 3010:        // T t = holder.get();
13407: 3011:
13408: 3012:        // OK, but type information is lost:
13409: 3013:        Object obj = holder.get();
13410: 3014:    }
13411: 3015:    
13412: 3016:    static <T> T exact1(Holder<T> holder) {
13413: 3017:        return holder.get();
13414: 3018:    }
13415: 3019:    
13416: 3020:    static <T> T exact2(Holder<T> holder, T arg) {
13417: 3021:        holder.set(arg);
13418: 3022:        return holder.get();
13419: 3023:    }
13420: 3024:    
13421: 3025:    static <T> T wildSubtype(Holder<? extends T> holder, T arg) {
13422: 3026:        //- holder.set(arg);
13423: 3027:        // error: method set in class Holder<T#2>
13424: 3028:        // cannot be applied to given types;
13425: 3029:        //     holder.set(arg);
13426: 3030:        //           ^
13427: 3031:        //   required: CAP#1
13428: 3032:        //   found: T#1
13429: 3033:        //   reason: argument mismatch;
13430: 3034:        //     T#1 cannot be converted to CAP#1
13431: 3035:        //   where T#1,T#2 are type-variables:
13432: 3036:        //     T#1 extends Object declared in method
13433: 3037:        //     <T#1>wildSubtype(Holder<? extends T#1>,T#1)
13434: 3038:        //     T#2 extends Object declared in class Holder
13435: 3039:        //   where CAP#1 is a fresh type-variable:
13436: 3040:        //     CAP#1 extends T#1 from
13437: 3041:        //       capture of ? extends T#1
13438: 3042:        // 1 error
13439: 3043:        return holder.get();
13440: 3044:    }
13441: 3045:    
13442: 3046:    static <T> void wildSupertype(Holder<? super T> holder, T arg) {
13443: 3047:        holder.set(arg);
13444: 3048:        //- T t = holder.get();
13445: 3049:        // error: incompatible types:
13446: 3050:        // CAP#1 cannot be converted to T
13447: 3051:        //     T t = holder.get();
13448: 3052:        //                     ^
13449: 3053:        //   where T is a type-variable:
13450: 3054:        //     T extends Object declared in method
13451: 3055:        //       <T>wildSupertype(Holder<? super T>,T)
13452: 3056:        //   where CAP#1 is a fresh type-variable:
13453: 3057:        //     CAP#1 extends Object super:
13454: 3058:        //       T from capture of ? super T
13455: 3059:        // 1 error
13456: 3060:
13457: 3061:        // OK, but type information is lost:
13458: 3062:        Object obj = holder.get();
13459: 3063:    }
13460: 3064:    
13461: 3065:    public static void main(String[] args) {
13462: 3066:        Holder raw = new Holder<>();
13463: 3067:        // Or:
13464: 3068:        raw = new Holder();
13465: 3069:        Holder<Long> qualified = new Holder<>();
13466: 3070:        Holder<?> unbounded = new Holder<>();
13467: 3071:        Holder<? extends Long> bounded = new Holder<>();
13468: 3072:        Long lng = 1L;
13469: 3073:
13470: 3074:        rawArgs(raw, lng);
13471: 3075:        rawArgs(qualified, lng);
13472: 3076:        rawArgs(unbounded, lng);
13473: 3077:        rawArgs(bounded, lng);
13474: 3078:
13475: 3079:        unboundedArg(raw, lng);
13476: 3080:        unboundedArg(qualified, lng);
13477: 3081:        unboundedArg(unbounded, lng);
13478: 3082:        unboundedArg(bounded, lng);
13479: 3083:
13480: 3084:        //- Object r1 = exact1(raw);
13481: 3085:        // warning: [unchecked] unchecked method invocation:
13482: 3086:        // method exact1 in class Wildcards is applied
13483: 3087:        // to given types
13484: 3088:        //      Object r1 = exact1(raw);
13485: 3089:        //                        ^
13486: 3090:        //   required: Holder<T>
13487: 3091:        //   found: Holder
13488: 3092:        //   where T is a type-variable:
13489: 3093:        //     T extends Object declared in
13490: 3094:        //     method <T>exact1(Holder<T>)
13491: 3095:        // warning: [unchecked] unchecked conversion
13492: 3096:        //      Object r1 = exact1(raw);
13493: 3097:        //                         ^
13494: 3098:        //   required: Holder<T>
13495: 3099:        //   found:    Holder
13496: 3100:        //   where T is a type-variable:
13497: 3101:        //     T extends Object declared in
13498: 3102:        //     method <T>exact1(Holder<T>)
13499: 3103:        // 2 warnings
13500: 3104:
13501: 3105:        Long r2 = exact1(qualified);
13502: 3106:        Object r3 = exact1(unbounded); // Must return Object
13503: 3107:        Long r4 = exact1(bounded);
13504: 3108:
13505: 3109:        //- Long r5 = exact2(raw, lng);
13506: 3110:        // warning: [unchecked] unchecked method invocation:
13507: 3111:        // method exact2 in class Wildcards is
13508: 3112:        // applied to given types
13509: 3113:        //     Long r5 = exact2(raw, lng);
13510: 3114:        //                     ^
13511: 3115:        //   required: Holder<T>,T
13512: 3116:        //   found: Holder,Long
13513: 3117:        //   where T is a type-variable:
13514: 3118:        //     T extends Object declared in
13515: 3119:        //       method <T>exact2(Holder<T>,T)
13516: 3120:        // warning: [unchecked] unchecked conversion
13517: 3121:        //     Long r5 = exact2(raw, lng);
13518: 3122:        //                      ^
13519: 3123:        //   required: Holder<T>
13520: 3124:        //   found:    Holder
13521: 3125:        //   where T is a type-variable:
13522: 3126:        //     T extends Object declared in
13523: 3127:        //       method <T>exact2(Holder<T>,T)
13524: 3128:        // 2 warnings
13525: 3129:
13526: 3130:        Long r6 = exact2(qualified, lng);
13527: 3131:
13528: 3132:        //- Long r7 = exact2(unbounded, lng);
13529: 3133:        // error: method exact2 in class Wildcards
13530: 3134:        // cannot be applied to given types;
13531: 3135:        //     Long r7 = exact2(unbounded, lng);
13532: 3136:        //               ^
13533: 3137:        //   required: Holder<T>,T
13534: 3138:        //   found: Holder<CAP#1>,Long
13535: 3139:        //   reason: inference variable T has
13536: 3140:        //     incompatible bounds
13537: 3141:        //     equality constraints: CAP#1
13538: 3142:        //     lower bounds: Long
13539: 3143:        //   where T is a type-variable:
13540: 3144:        //     T extends Object declared in
13541: 3145:        //       method <T>exact2(Holder<T>,T)
13542: 3146:        //   where CAP#1 is a fresh type-variable:
13543: 3147:        //     CAP#1 extends Object from capture of ?
13544: 3148:        // 1 error
13545: 3149:
13546: 3150:        //- Long r8 = exact2(bounded, lng);
13547: 3151:        // error: method exact2 in class Wildcards
13548: 3152:        // cannot be applied to given types;
13549: 3153:        //      Long r8 = exact2(bounded, lng);
13550: 3154:        //                ^
13551: 3155:        //   required: Holder<T>,T
13552: 3156:        //   found: Holder<CAP#1>,Long
13553: 3157:        //   reason: inference variable T
13554: 3158:        //     has incompatible bounds
13555: 3159:        //     equality constraints: CAP#1
13556: 3160:        //     lower bounds: Long
13557: 3161:        //   where T is a type-variable:
13558: 3162:        //     T extends Object declared in
13559: 3163:        //       method <T>exact2(Holder<T>,T)
13560: 3164:        //   where CAP#1 is a fresh type-variable:
13561: 3165:        //     CAP#1 extends Long from
13562: 3166:        //       capture of ? extends Long
13563: 3167:        // 1 error
13564: 3168:
13565: 3169:        //- Long r9 = wildSubtype(raw, lng);
13566: 3170:        // warning: [unchecked] unchecked method invocation:
13567: 3171:        // method wildSubtype in class Wildcards
13568: 3172:        // is applied to given types
13569: 3173:        //     Long r9 = wildSubtype(raw, lng);
13570: 3174:        //                          ^
13571: 3175:        //   required: Holder<? extends T>,T
13572: 3176:        //   found: Holder,Long
13573: 3177:        //   where T is a type-variable:
13574: 3178:        //     T extends Object declared in
13575: 3179:        //     method <T>wildSubtype(Holder<? extends T>,T)
13576: 3180:        // warning: [unchecked] unchecked conversion
13577: 3181:        //     Long r9 = wildSubtype(raw, lng);
13578: 3182:        //                           ^
13579: 3183:        //   required: Holder<? extends T>
13580: 3184:        //   found:    Holder
13581: 3185:        //   where T is a type-variable:
13582: 3186:        //     T extends Object declared in
13583: 3187:        //     method <T>wildSubtype(Holder<? extends T>,T)
13584: 3188:        // 2 warnings
13585: 3189:
13586: 3190:        Long r10 = wildSubtype(qualified, lng);
13587: 3191:        // OK, but can only return Object:
13588: 3192:        Object r11 = wildSubtype(unbounded, lng);
13589: 3193:        Long r12 = wildSubtype(bounded, lng);
13590: 3194:
13591: 3195:        //- wildSupertype(raw, lng);
13592: 3196:        // warning: [unchecked] unchecked method invocation:
13593: 3197:        //   method wildSupertype in class Wildcards
13594: 3198:        //   is applied to given types
13595: 3199:        //     wildSupertype(raw, lng);
13596: 3200:        //                  ^
13597: 3201:        //   required: Holder<? super T>,T
13598: 3202:        //   found: Holder,Long
13599: 3203:        //   where T is a type-variable:
13600: 3204:        //     T extends Object declared in
13601: 3205:        //     method <T>wildSupertype(Holder<? super T>,T)
13602: 3206:        // warning: [unchecked] unchecked conversion
13603: 3207:        //     wildSupertype(raw, lng);
13604: 3208:        //                   ^
13605: 3209:        //   required: Holder<? super T>
13606: 3210:        //   found:    Holder
13607: 3211:        //   where T is a type-variable:
13608: 3212:        //     T extends Object declared in
13609: 3213:        //     method <T>wildSupertype(Holder<? super T>,T)
13610: 3214:        // 2 warnings
13611: 3215:
13612: 3216:        wildSupertype(qualified, lng);
13613: 3217:
13614: 3218:        //- wildSupertype(unbounded, lng);
13615: 3219:        // error: method wildSupertype in class Wildcards
13616: 3220:        // cannot be applied to given types;
13617: 3221:        //     wildSupertype(unbounded, lng);
13618: 3222:        //     ^
13619: 3223:        //   required: Holder<? super T>,T
13620: 3224:        //   found: Holder<CAP#1>,Long
13621: 3225:        //   reason: cannot infer type-variable(s) T
13622: 3226:        //     (argument mismatch; Holder<CAP#1>
13623: 3227:        //     cannot be converted to Holder<? super T>)
13624: 3228:        //   where T is a type-variable:
13625: 3229:        //     T extends Object declared in
13626: 3230:        //     method <T>wildSupertype(Holder<? super T>,T)
13627: 3231:        //   where CAP#1 is a fresh type-variable:
13628: 3232:        //     CAP#1 extends Object from capture of ?
13629: 3233:        // 1 error
13630: 3234:
13631: 3235:        //- wildSupertype(bounded, lng);
13632: 3236:        // error: method wildSupertype in class Wildcards
13633: 3237:        // cannot be applied to given types;
13634: 3238:        //     wildSupertype(bounded, lng);
13635: 3239:        //     ^
13636: 3240:        //   required: Holder<? super T>,T
13637: 3241:        //   found: Holder<CAP#1>,Long
13638: 3242:        //   reason: cannot infer type-variable(s) T
13639: 3243:        //     (argument mismatch; Holder<CAP#1>
13640: 3244:        //     cannot be converted to Holder<? super T>)
13641: 3245:        //   where T is a type-variable:
13642: 3246:        //     T extends Object declared in
13643: 3247:        //     method <T>wildSupertype(Holder<? super T>,T)
13644: 3248:        //   where CAP#1 is a fresh type-variable:
13645: 3249:        //     CAP#1 extends Long from capture of
13646: 3250:        //     ? extends Long
13647: 3251:        // 1 error
13648: 3252:    }
13649: 3253:}
13650: 3254:```
13651: 3255:
13652: 3256:在 `rawArgs()` 中，编译器知道 `Holder` 是一个泛型类型，因此即使它在这里被表示成一个原生类型，编译器仍旧知道向 `set()` 传递一个 **Object** 是不安全的。由于它是原生类型，你可以将任何类型的对象传递给 `set()` ，而这个对象将被向上转型为 **Object** 。因此无论何时，只要使用了原生类型，都会放弃编译期检查。对 `get()` 的调用说明了相同的问题：没有任何 **T** 类型的对象，因此结果只能是一个 **Object**。
13653: 3257:人们很自然地会开始考虑原生 `Holder` 与 `Holder<?>` 是大致相同的事物。但是 `unboundedArg()` 强调它们是不同的——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，因为原生 **Holder** 将持有任何类型的组合，而 `Holder<?>` 将持有具有某种具体类型的同构集合，因此不能只是向其中传递 **Object** 。
13654: 3258:在 `exact1()` 和 `exact2()` 中，你可以看到使用了确切的泛型参数——没有任何通配符。你将看到，`exact2()`与 `exact1()` 具有不同的限制，因为它有额外的参数。
13655: 3259:在 `wildSubtype()` 中，在 **Holder** 类型上的限制被放松为包括持有任何扩展自 **T** 的对象的 **Holder** 。这还是意味着如果 T 是 **Fruit** ，那么 `holder` 可以是 `Holder<Apple>` ，这是合法的。为了防止将 **Orange** 放置到 `Holder<Apple>` 中，对 `set()` 的调用（或者对任何接受这个类型参数为参数的方法的调用）都是不允许的。但是，你仍旧知道任何来自 `Holder<？extends Fruit>` 的对象至少是 **Fruit** ，因此 `get()` （或者任何将产生具有这个类型参数的返回值的方法）都是允许的。
13656: 3260:`wildSupertype()` 展示了超类型通配符，这个方法展示了与 `wildSubtype()` 相反的行为：`holder` 可以是持有任何 T 的基类型的容器。因此， `set()` 可以接受 **T** ，因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是 **T** ）。但是，尝试着调用 `get()` 是没有用的，因为由 `holder` 持有的类型可以是任何超类型，因此唯一安全的类型就是 **Object** 。
13657: 3261:这个示例还展示了对于在 `unbounded()` 中使用无界通配符能够做什么不能做什么所做出的限制：因为你没有 **T**，所以你不能将 `set()` 或 `get()` 作用于 **T** 上。
13658: 3262:
13659: 3263:在 `main()` 方法中你看到了某些方法在接受某些类型的参数时没有报错和警告。为了迁移兼容性，`rawArgs()`  将接受所有 **Holder** 的不同变体，而不会产生警告。`unboundedArg()` 方法也可以接受相同的所有类型，尽管如前所述，它在方法体内部处理这些类型的方式并不相同。
13660: 3264:
13661: 3265:如果向接受“确切”泛型类型（没有通配符）的方法传递一个原生 **Holder** 引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息。如果向 `exact1()` 传递一个无界引用，就不会有任何可以确定返回类型的类型信息。
13662: 3266:可以看到，`exact2()` 具有最多的限制，因为它希望精确地得到一个 `Holder<T>` ，以及一个具有类型 **T** 的参数，正由于此，它将产生错误或警告，除非提供确切的参数。有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决于是否想要从泛型参数中返回类型确定的返回值（就像在 `wildSubtype()` 中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在 `wildSupertype()` 中看到的那样）。
13663: 3267:因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合你的需求的方法。
13664: 3268:
13665: 3269:### 捕获转换
13666: 3270:
13667: 3271:有一种特殊情况需要使用 `<?>` 而不是原生类型。如果向一个使用 `<?>` 的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。下面的示例演示了这种技术，它被称为捕获转换，因为未指定的通配符类型被捕获，并被转换为确切类型。这里，有关警告的注释只有在 `@SuppressWarnings` 注解被移除之后才能起作用：
13668: 3272:
13669: 3273:```java
13670: 3274:// generics/CaptureConversion.java
13671: 3275:
13672: 3276:public class CaptureConversion {
13673: 3277:    static <T> void f1(Holder<T> holder) {
13674: 3278:        T t = holder.get();
13675: 3279:        System.out.println(t.getClass().getSimpleName());
13676: 3280:    }
13677: 3281:  
13678: 3282:    static void f2(Holder<?> holder) {
13679: 3283:        f1(holder); // Call with captured type
13680: 3284:    }
13681: 3285:    
13682: 3286:    @SuppressWarnings("unchecked")
13683: 3287:    public static void main(String[] args) {
13684: 3288:        Holder raw = new Holder<>(1);
13685: 3289:        f1(raw);
13686: 3290:        // warning: [unchecked] unchecked method invocation:
13687: 3291:        // method f1 in class CaptureConversion
13688: 3292:        // is applied to given types
13689: 3293:        //     f1(raw);
13690: 3294:        //       ^
13691: 3295:        //   required: Holder<T>
13692: 3296:        //   found: Holder
13693: 3297:        //   where T is a type-variable:
13694: 3298:        //     T extends Object declared in
13695: 3299:        //     method <T>f1(Holder<T>)
13696: 3300:        // warning: [unchecked] unchecked conversion
13697: 3301:        //     f1(raw);
13698: 3302:        //        ^
13699: 3303:        //   required: Holder<T>
13700: 3304:        //   found:    Holder
13701: 3305:        //   where T is a type-variable:
13702: 3306:        //     T extends Object declared in
13703: 3307:        //     method <T>f1(Holder<T>)
13704: 3308:        // 2 warnings
13705: 3309:        f2(raw); // No warnings
13706: 3310:        
13707: 3311:        Holder rawBasic = new Holder();
13708: 3312:        rawBasic.set(new Object());
13709: 3313:        // warning: [unchecked] unchecked call to set(T)
13710: 3314:        // as a member of the raw type Holder
13711: 3315:        //     rawBasic.set(new Object());
13712: 3316:        //                 ^
13713: 3317:        //   where T is a type-variable:
13714: 3318:        //     T extends Object declared in class Holder
13715: 3319:        // 1 warning
13716: 3320:        f2(rawBasic); // No warnings
13717: 3321:        
13718: 3322:        // Upcast to Holder<?>, still figures it out:
13719: 3323:        Holder<?> wildcarded = new Holder<>(1.0);
13720: 3324:        f2(wildcarded);
13721: 3325:    }
13722: 3326:}
13723: 3327:/* Output:
13724: 3328:Integer
13725: 3329:Integer
13726: 3330:Object
13727: 3331:Double
13728: 3332:*/
13729: 3333:```
13730: 3334:
13731: 3335:`f1()` 中的类型参数都是确切的，没有通配符或边界。在 `f2()` 中，**Holder** 参数是一个无界通配符，因此它看起来是未知的。但是，在 `f2()` 中调用了 `f1()`，而 `f1()` 需要一个已知参数。这里所发生的是：在调用 `f2()` 的过程中捕获了参数类型，并在调用 `f1()` 时使用了这种类型。
13732: 3336:你可能想知道这项技术是否可以用于写入，但是这要求在传递 `Holder<?>` 时同时传递一个具体类型。捕获转换只有在这样的情况下可以工作：即在方法内部，你需要使用确切的类型。注意，不能从 `f2()` 中返回 **T**，因为 **T** 对于 `f2()` 来说是未知的。捕获转换十分有趣，但是非常受限。
13733: 3337:
13734: 3338:<!-- Issues -->
13735: 3339:
13736: 3340:## 问题
13737: 3341:
13738: 3342:本节将阐述在使用 Java 泛型时会出现的各类问题。
13739: 3343:
13740: 3344:### 任何基本类型都不能作为类型参数
13741: 3345:
13742: 3346:正如本章早先提到的，Java 泛型的限制之一是不能将基本类型用作类型参数。因此，不能创建  `ArrayList<int>` 之类的东西。
13743: 3347:解决方法是使用基本类型的包装器类以及自动装箱机制。如果创建一个 `ArrayList<Integer>`，并将基本类型 **int** 应用于这个集合，那么你将发现自动装箱机制将自动地实现 **int** 到 **Integer** 的双向转换——因此，这几乎就像是有一个 `ArrayList<int>` 一样：
13744: 3348:
13745: 3349:```java
13746: 3350:// generics/ListOfInt.java
13747: 3351:// Autoboxing compensates for the inability
13748: 3352:// to use primitives in generics
13749: 3353:import java.util.*;
13750: 3354:import java.util.stream.*;
13751: 3355:
13752: 3356:public class ListOfInt {
13753: 3357:    public static void main(String[] args) {
13754: 3358:        List<Integer> li = IntStream.range(38, 48)
13755: 3359:            .boxed() // Converts ints to Integers
13756: 3360:            .collect(Collectors.toList());
13757: 3361:        System.out.println(li);
13758: 3362:    }
13759: 3363:}
13760: 3364:/* Output:
13761: 3365:[38, 39, 40, 41, 42, 43, 44, 45, 46, 47]
13762: 3366:*/
13763: 3367:```
13764: 3368:
13765: 3369:通常，这种解决方案工作得很好——能够成功地存储和读取 **int**，自动装箱隐藏了转换的过程。但是如果性能成为问题的话，就需要使用专门为基本类型适配的特殊版本的集合；一个开源版本的实现是 **org.apache.commons.collections.primitives**。
13766: 3370:下面是另外一种方式，它可以创建持有 **Byte** 的 **Set**：
13767: 3371:
13768: 3372:```java
13769: 3373:// generics/ByteSet.java
13770: 3374:import java.util.*;
13771: 3375:
13772: 3376:public class ByteSet {
13773: 3377:    Byte[] possibles = { 1,2,3,4,5,6,7,8,9 };
13774: 3378:    Set<Byte> mySet = new HashSet<>(Arrays.asList(possibles));
13775: 3379:    // But you can't do this:
13776: 3380:    // Set<Byte> mySet2 = new HashSet<>(
13777: 3381:    // Arrays.<Byte>asList(1,2,3,4,5,6,7,8,9));
13778: 3382:}
13779: 3383:```
13780: 3384:
13781: 3385:自动装箱机制解决了一些问题，但并没有解决所有问题。
13782: 3386:
13783: 3387:在下面的示例中，**FillArray** 接口包含一些通用方法，这些方法使用 **Supplier** 来用对象填充数组（这使得类泛型在本例中无法工作，因为这个方法是静态的）。**Supplier** 实现来自 [数组](book/21-Arrays.md) 一章,并且在 `main()` 中，可以看到 `FillArray.fill()` 使用对象填充了数组：
13784: 3388:
13785: 3389:```java
13786: 3390:// generics/PrimitiveGenericTest.java
13787: 3391:import onjava.*;
13788: 3392:import java.util.*;
13789: 3393:import java.util.function.*;
13790: 3394:
13791: 3395:// Fill an array using a generator:
13792: 3396:interface FillArray {
13793: 3397:    static <T> T[] fill(T[] a, Supplier<T> gen) {
13794: 3398:        Arrays.setAll(a, n -> gen.get());
13795: 3399:        return a;
13796: 3400:    }
13797: 3401:    
13798: 3402:    static int[] fill(int[] a, IntSupplier gen) {
13799: 3403:        Arrays.setAll(a, n -> gen.getAsInt());
13800: 3404:        return a;
13801: 3405:    }
13802: 3406:    
13803: 3407:    static long[] fill(long[] a, LongSupplier gen) {
13804: 3408:        Arrays.setAll(a, n -> gen.getAsLong());
13805: 3409:        return a;
13806: 3410:    }
13807: 3411:    
13808: 3412:    static double[] fill(double[] a, DoubleSupplier gen) {
13809: 3413:        Arrays.setAll(a, n -> gen.getAsDouble());
13810: 3414:        return a;
13811: 3415:    }
13812: 3416:}
13813: 3417:
13814: 3418:public class PrimitiveGenericTest {
13815: 3419:    public static void main(String[] args) {
13816: 3420:        String[] strings = FillArray.fill(
13817: 3421:            new String[5], new Rand.String(9));
13818: 3422:        System.out.println(Arrays.toString(strings));
13819: 3423:        int[] integers = FillArray.fill(
13820: 3424:            new int[9], new Rand.Pint());
13821: 3425:        System.out.println(Arrays.toString(integers));
13822: 3426:    }
13823: 3427:}
13824: 3428:/* Output:
13825: 3429:[btpenpccu, xszgvgmei, nneeloztd, vewcippcy, gpoalkljl]
13826: 3430:[635, 8737, 3941, 4720, 6177, 8479, 6656, 3768, 4948]
13827: 3431:*/
13828: 3432:```
13829: 3433:
13830: 3434:自动装箱不适用于数组，因此我们必须创建 `FillArray.fill()` 的重载版本，或创建产生 **Wrapped** 输出的生成器。 **FillArray** 仅比 `java.util.Arrays.setAll()` 有用一点，因为它返回填充的数组。
13831: 3435:
13832: 3436:### 实现参数化接口
13833: 3437:
13834: 3438:一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。下面是产生这种冲突的情况：
13835: 3439:
13836: 3440:```java
13837: 3441:// generics/MultipleInterfaceVariants.java
13838: 3442:// {WillNotCompile}
13839: 3443:package generics;
13840: 3444:
13841: 3445:interface Payable<T> {}
13842: 3446:
13843: 3447:class Employee implements Payable<Employee> {}
13844: 3448:
13845: 3449:class Hourly extends Employee implements Payable<Hourly> {}
13846: 3450:```
13847: 3451:
13848: 3452:**Hourly** 不能编译，因为擦除会将  `Payable<Employe>` 和 `Payable<Hourly>` 简化为相同的类 **Payable**，这样，上面的代码就意味着在重复两次地实现相同的接口。十分有趣的是，如果从 **Payable** 的两种用法中都移除掉泛型参数（就像编译器在擦除阶段所做的那样）这段代码就可以编译。
13849: 3453:
13850: 3454:在使用某些更基本的 Java 接口，例如 `Comparable<T>` 时，这个问题可能会变得十分令人恼火，就像你在本节稍后看到的那样。
13851: 3455:
13852: 3456:### 转型和警告
13853: 3457:
13854: 3458:使用带有泛型类型参数的转型或 **instanceof** 不会有任何效果。下面的集合在内部将各个值存储为 **Object**，并在获取这些值时，再将它们转型回 **T**：
13855: 3459:
13856: 3460:```java
13857: 3461:// generics/GenericCast.java
13858: 3462:import java.util.*;
13859: 3463:import java.util.stream.*;
13860: 3464:
13861: 3465:class FixedSizeStack<T> {
13862: 3466:    private final int size;
13863: 3467:    private Object[] storage;
13864: 3468:    private int index = 0;
13865: 3469:    
13866: 3470:    FixedSizeStack(int size) {
13867: 3471:        this.size = size;
13868: 3472:        storage = new Object[size];
13869: 3473:    }
13870: 3474:    
13871: 3475:    public void push(T item) {
13872: 3476:        if(index < size)
13873: 3477:            storage[index++] = item;
13874: 3478:    }
13875: 3479:    
13876: 3480:    @SuppressWarnings("unchecked")
13877: 3481:    public T pop() {
13878: 3482:        return index == 0 ? null : (T)storage[--index];
13879: 3483:    }
13880: 3484:    
13881: 3485:    @SuppressWarnings("unchecked")
13882: 3486:    Stream<T> stream() {
13883: 3487:        return (Stream<T>)Arrays.stream(storage);
13884: 3488:    }
13885: 3489:}
13886: 3490:
13887: 3491:public class GenericCast {
13888: 3492:    static String[] letters = "ABCDEFGHIJKLMNOPQRS".split("");
13889: 3493:  
13890: 3494:    public static void main(String[] args) {
13891: 3495:        FixedSizeStack<String> strings =
13892: 3496:            new FixedSizeStack<>(letters.length);
13893: 3497:        Arrays.stream("ABCDEFGHIJKLMNOPQRS".split(""))
13894: 3498:            .forEach(strings::push);
13895: 3499:        System.out.println(strings.pop());
13896: 3500:        strings.stream()
13897: 3501:            .map(s -> s + " ")
13898: 3502:            .forEach(System.out::print);
13899: 3503:    }
13900: 3504:}
13901: 3505:/* Output:
13902: 3506:S
13903: 3507:A B C D E F G H I J K L M N O P Q R S
13904: 3508:*/
13905: 3509:```
13906: 3510:
13907: 3511:如果没有 **@SuppressWarnings** 注解，编译器将对 `pop()` 产生 “unchecked cast” 警告。由于擦除的原因，编译器无法知道这个转型是否是安全的，并且 `pop()` 方法实际上并没有执行任何转型。
13908: 3512:这是因为，**T** 被擦除到它的第一个边界，默认情况下是 **Object** ，因此 `pop()` 实际上只是将 **Object** 转型为 **Object**。
13909: 3513:有时，泛型没有消除对转型的需要，这就会由编译器产生警告，而这个警告是不恰当的。例如：
13910: 3514:
13911: 3515:```java
13912: 3516:// generics/NeedCasting.java
13913: 3517:import java.io.*;
13914: 3518:import java.util.*;
13915: 3519:
13916: 3520:public class NeedCasting {
13917: 3521:    @SuppressWarnings("unchecked")
13918: 3522:    public void f(String[] args) throws Exception {
13919: 3523:        ObjectInputStream in = new ObjectInputStream(
13920: 3524:            new FileInputStream(args[0]));
13921: 3525:        List<Widget> shapes = (List<Widget>)in.readObject();
13922: 3526:    }
13923: 3527:}
13924: 3528:```
13925: 3529:
13926: 3530:正如你将在 [附录：对象序列化](book/Appendix-Object-Serialization.md) 中学到的那样，`readObject()` 无法知道它正在读取的是什么，因此它返回的是必须转型的对象。但是当注释掉 **@SuppressWarnings** 注解并编译这个程序时，就会得到下面的警告。
13927: 3531:
13928: 3532:```
13929: 3533:NeedCasting.java uses unchecked or unsafe operations.
13930: 3534:Recompile with -Xlint:unchecked for details.
13931: 3535:
13932: 3536:And if you follow the instructions and recompile with  -
13933: 3537:Xlint:unchecked :(如果遵循这条指示，使用-Xlint:unchecked来重新编译：)
13934: 3538:
13935: 3539:NeedCasting.java:10: warning: [unchecked] unchecked cast
13936: 3540:    List<Widget> shapes = (List<Widget>)in.readObject();
13937: 3541:    required: List<Widget>
13938: 3542:    found: Object
13939: 3543:1 warning
13940: 3544:```
13941: 3545:
13942: 3546:你会被强制要求转型，但是又被告知不应该转型。为了解决这个问题，必须使用 Java 5 引入的新的转型形式，即通过泛型类来转型：
13943: 3547:
13944: 3548:```java
13945: 3549:// generics/ClassCasting.java
13946: 3550:import java.io.*;
13947: 3551:import java.util.*;
13948: 3552:
13949: 3553:public class ClassCasting {
13950: 3554:    @SuppressWarnings("unchecked")
13951: 3555:    public void f(String[] args) throws Exception {
13952: 3556:        ObjectInputStream in = new ObjectInputStream(
13953: 3557:            new FileInputStream(args[0]));
13954: 3558:        // Won't Compile:
13955: 3559:        //    List<Widget> lw1 =
13956: 3560:        //    List<>.class.cast(in.readObject());
13957: 3561:        List<Widget> lw2 = List.class.cast(in.readObject());
13958: 3562:    }
13959: 3563:}
13960: 3564:```
13961: 3565:
13962: 3566:但是，不能转型到实际类型（ `List<Widget>` ）。也就是说，不能声明：
13963: 3567:
13964: 3568:```
13965: 3569:List<Widget>.class.cast(in.readobject())
13966: 3570:```
13967: 3571:
13968: 3572:甚至当你添加一个像下面这样的另一个转型时：
13969: 3573:
13970: 3574:```
13971: 3575:(List<Widget>)List.class.cast(in.readobject())
13972: 3576:```
13973: 3577:
13974: 3578:仍旧会得到一个警告。
13975: 3579:
13976: 3580:### 重载
13977: 3581:
13978: 3582:下面的程序是不能编译的，即使它看起来是合理的：
13979: 3583:
13980: 3584:```java
13981: 3585:// generics/UseList.java
13982: 3586:// {WillNotCompile}
13983: 3587:import java.util.*;
13984: 3588:
13985: 3589:public class UseList<W, T> {
13986: 3590:    void f(List<T> v) {}
13987: 3591:    void f(List<W> v) {}
13988: 3592:}
13989: 3593:```
13990: 3594:
13991: 3595:因为擦除，所以重载方法产生了相同的类型签名。
13992: 3596:
13993: 3597:因而，当擦除后的参数不能产生唯一的参数列表时，你必须提供不同的方法名：
13994: 3598:
13995: 3599:```java
13996: 3600:// generics/UseList2.java
13997: 3601:
13998: 3602:import java.util.*;
13999: 3603:
14000: 3604:public class UseList2<W, T> {
14001: 3605:    void f1(List<T> v) {}
14002: 3606:    void f2(List<W> v) {}
14003: 3607:}
14004: 3608:```
14005: 3609:
14006: 3610:幸运的是，编译器可以检测到这类问题。
14007: 3611:
14008: 3612:### 基类劫持接口
14009: 3613:
14010: 3614:假设你有一个实现了 **Comparable** 接口的 **Pet** 类：
14011: 3615:
14012: 3616:```java
14013: 3617:// generics/ComparablePet.java
14014: 3618:
14015: 3619:public class ComparablePet implements Comparable<ComparablePet> {
14016: 3620:    @Override
14017: 3621:    public int compareTo(ComparablePet o) {
14018: 3622:        return 0;
14019: 3623:    }
14020: 3624:}
14021: 3625:```
14022: 3626:
14023: 3627:尝试缩小 **ComparablePet** 子类的比较类型是有意义的。例如，**Cat** 类可以与其他的 **Cat** 比较：
14024: 3628:
14025: 3629:```java
14026: 3630:// generics/HijackedInterface.java
14027: 3631:// {WillNotCompile}
14028: 3632:
14029: 3633:class Cat extends ComparablePet implements Comparable<Cat> {
14030: 3634:    // error: Comparable cannot be inherited with
14031: 3635:    // different arguments: <Cat> and <ComparablePet>
14032: 3636:    // class Cat
14033: 3637:    // ^
14034: 3638:    // 1 error
14035: 3639:    public int compareTo(Cat arg) {
14036: 3640:        return 0;
14037: 3641:    }
14038: 3642:}
14039: 3643:```
14040: 3644:
14041: 3645:不幸的是，这不能工作。一旦 **Comparable** 的类型参数设置为 **ComparablePet**，其他的实现类只能比较 **ComparablePet**：
14042: 3646:
14043: 3647:```java
14044: 3648:// generics/RestrictedComparablePets.java
14045: 3649:
14046: 3650:public class Hamster extends ComparablePet implements Comparable<ComparablePet> {
14047: 3651:
14048: 3652:    @Override
14049: 3653:    public int compareTo(ComparablePet arg) {
14050: 3654:        return 0;
14051: 3655:    }
14052: 3656:}
14053: 3657:// Or just:
14054: 3658:class Gecko extends ComparablePet {
14055: 3659:    public int compareTo(ComparablePet arg) {
14056: 3660:        return 0;
14057: 3661:    }
14058: 3662:}
14059: 3663:```
14060: 3664:
14061: 3665:**Hamster** 显示了重新实现 **ComparablePet** 中相同的接口是可能的，只要接口完全相同，包括参数类型。然而正如 **Gecko** 中所示，这与直接覆写基类的方法完全相同。
14062: 3666:
14063: 3667:<!-- Self-Bounded Types -->
14064: 3668:
14065: 3669:## 自限定的类型
14066: 3670:
14067: 3671:在 Java 泛型中，有一个似乎经常性出现的惯用法，它相当令人费解：
14068: 3672:
14069: 3673:```java
14070: 3674:class SelfBounded<T extends SelfBounded<T>> { // ...
14071: 3675:```
14072: 3676:
14073: 3677:这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。**SelfBounded** 类接受泛型参数 **T**，而 **T** 由一个边界类限定，这个边界就是拥有 **T** 作为其参数的 **SelfBounded**。
14074: 3678:
14075: 3679:当你首次看到它时，很难去解析它，它强调的是当 **extends** 关键字用于边界与用来创建子类明显是不同的。
14076: 3680:
14077: 3681:### 古怪的循环泛型
14078: 3682:
14079: 3683:为了理解自限定类型的含义，我们从这个惯用法的一个简单版本入手，它没有自限定的边界。
14080: 3684:
14081: 3685:不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类。也就是说，可以声明：
14082: 3686:
14083: 3687:```java
14084: 3688:// generics/CuriouslyRecurringGeneric.java
14085: 3689:
14086: 3690:class GenericType<T> {}
14087: 3691:
14088: 3692:public class CuriouslyRecurringGeneric
14089: 3693:  extends GenericType<CuriouslyRecurringGeneric> {}
14090: 3694:```
14091: 3695:
14092: 3696:这可以按照 Jim Coplien 在 C++ 中的*古怪的循环模版模式*的命名方式，称为古怪的循环泛型（CRG）。“古怪的循环”是指类相当古怪地出现在它自己的基类中这一事实。
14093: 3697:为了理解其含义，努力大声说：“我在创建一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为其参数。”当给出导出类的名字时，这个泛型基类能够实现什么呢？好吧，Java 中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为其参数和返回类型的基类。它还能将导出类型用作其域类型，尽管这些将被擦除为 **Object** 的类型。下面是表示了这种情况的一个泛型类：
14094: 3698:
14095: 3699:```java
14096: 3700:// generics/BasicHolder.java
14097: 3701:
14098: 3702:public class BasicHolder<T> {
14099: 3703:    T element;
14100: 3704:    void set(T arg) { element = arg; }
14101: 3705:    T get() { return element; }
14102: 3706:    void f() {
14103: 3707:        System.out.println(element.getClass().getSimpleName());
14104: 3708:    }
14105: 3709:}
14106: 3710:```
14107: 3711:
14108: 3712:这是一个普通的泛型类型，它的一些方法将接受和产生具有其参数类型的对象，还有一个方法在其存储的域上执行操作（尽管只是在这个域上执行 **Object** 操作）。
14109: 3713:我们可以在一个古怪的循环泛型中使用 **BasicHolder**：
14110: 3714:
14111: 3715:```java
14112: 3716:// generics/CRGWithBasicHolder.java
14113: 3717:
14114: 3718:class Subtype extends BasicHolder<Subtype> {}
14115: 3719:
14116: 3720:public class CRGWithBasicHolder {
14117: 3721:    public static void main(String[] args) {
14118: 3722:        Subtype st1 = new Subtype(), st2 = new Subtype();
14119: 3723:        st1.set(st2);
14120: 3724:        Subtype st3 = st1.get();
14121: 3725:        st1.f();
14122: 3726:    }
14123: 3727:}
14124: 3728:/* Output:
14125: 3729:Subtype
14126: 3730:*/
14127: 3731:```
14128: 3732:
14129: 3733:注意，这里有些东西很重要：新类 **Subtype** 接受的参数和返回的值具有 **Subtype** 类型而不仅仅是基类 **BasicHolder** 类型。这就是 CRG 的本质：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型。也就是说，在所产生的类中将使用确切类型而不是基类型。因此，在**Subtype** 中，传递给 `set()` 的参数和从 `get()` 返回的类型都是确切的 **Subtype**。
14130: 3734:
14131: 3735:### 自限定
14132: 3736:
14133: 3737:**BasicHolder** 可以使用任何类型作为其泛型参数，就像下面看到的那样：
14134: 3738:
14135: 3739:```java
14136: 3740:// generics/Unconstrained.java
14137: 3741:// (c)2017 MindView LLC: see Copyright.txt
14138: 3742:// We make no guarantees that this code is fit for any purpose.
14139: 3743:// Visit http://OnJava8.com for more book information.
14140: 3744:
14141: 3745:class Other {}
14142: 3746:class BasicOther extends BasicHolder<Other> {}
14143: 3747:
14144: 3748:public class Unconstrained {
14145: 3749:    public static void main(String[] args) {
14146: 3750:        BasicOther b = new BasicOther();
14147: 3751:        BasicOther b2 = new BasicOther();
14148: 3752:        b.set(new Other());
14149: 3753:        Other other = b.get();
14150: 3754:        b.f();
14151: 3755:    }
14152: 3756:}
14153: 3757:/* Output:
14154: 3758:Other
14155: 3759:*/
14156: 3760:```
14157: 3761:
14158: 3762:限定将采取额外的步骤，强制泛型当作其自身的边界参数来使用。观察所产生的类可以如何使用以及不可以如何使用：
14159: 3763:
14160: 3764:```java
14161: 3765:// generics/SelfBounding.java
14162: 3766:
14163: 3767:class SelfBounded<T extends SelfBounded<T>> {
14164: 3768:    T element;
14165: 3769:    SelfBounded<T> set(T arg) {
14166: 3770:        element = arg;
14167: 3771:        return this;
14168: 3772:    }
14169: 3773:    T get() { return element; }
14170: 3774:}
14171: 3775:
14172: 3776:class A extends SelfBounded<A> {}
14173: 3777:class B extends SelfBounded<A> {} // Also OK
14174: 3778:
14175: 3779:class C extends SelfBounded<C> {
14176: 3780:    C setAndGet(C arg) { 
14177: 3781:        set(arg); 
14178: 3782:        return get();
14179: 3783:    }
14180: 3784:}
14181: 3785:
14182: 3786:class D {}
14183: 3787:// Can't do this:
14184: 3788:// class E extends SelfBounded<D> {}
14185: 3789:// Compile error:
14186: 3790://   Type parameter D is not within its bound
14187: 3791:
14188: 3792:// Alas, you can do this, so you cannot force the idiom:
14189: 3793:class F extends SelfBounded {}
14190: 3794:
14191: 3795:public class SelfBounding {
14192: 3796:    public static void main(String[] args) {
14193: 3797:        A a = new A();
14194: 3798:        a.set(new A());
14195: 3799:        a = a.set(new A()).get();
14196: 3800:        a = a.get();
14197: 3801:        C c = new C();
14198: 3802:        c = c.setAndGet(new C());
14199: 3803:    }
14200: 3804:}
14201: 3805:```
14202: 3806:
14203: 3807:自限定所做的，就是要求在继承关系中，像下面这样使用这个类：
14204: 3808:
14205: 3809:```java
14206: 3810:class A extends SelfBounded<A>{}
14207: 3811:```
14208: 3812:
14209: 3813:这会强制要求将正在定义的类当作参数传递给基类。
14210: 3814:
14211: 3815:自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。正如你在 B 类的定义中所看到的，还可以从使用了另一个 **SelfBounded** 参数的 **SelfBounded** 中导出，尽管在 **A** 类看到的用法看起来是主要的用法。对定义 **E** 的尝试说明不能使用不是 **SelfBounded** 的类型参数。
14212: 3816:遗憾的是， **F** 可以编译，不会有任何警告，因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型。
14213: 3817:注意，可以移除自限定这个限制，这样所有的类仍旧是可以编译的，但是 **E** 也会因此而变得可编译：
14214: 3818:
14215: 3819:```java
14216: 3820:// generics/NotSelfBounded.java
14217: 3821:
14218: 3822:public class NotSelfBounded<T> {
14219: 3823:    T element;
14220: 3824:    NotSelfBounded<T> set(T arg) {
14221: 3825:        element = arg;
14222: 3826:        return this;
14223: 3827:    }
14224: 3828:    T get() { return element; }
14225: 3829:} 
14226: 3830:
14227: 3831:class A2 extends NotSelfBounded<A2> {}
14228: 3832:class B2 extends NotSelfBounded<A2> {}
14229: 3833:
14230: 3834:class C2 extends NotSelfBounded<C2> {
14231: 3835:    C2 setAndGet(C2 arg) { 
14232: 3836:        set(arg); 
14233: 3837:        return get(); 
14234: 3838:    }
14235: 3839:}
14236: 3840:
14237: 3841:class D2 {}
14238: 3842:// Now this is OK:
14239: 3843:class E2 extends NotSelfBounded<D2> {}
14240: 3844:```
14241: 3845:
14242: 3846:因此很明显，自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。这会强制要求使用这个类的每个人都要遵循这种形式。
14243: 3847:还可以将自限定用于泛型方法：
14244: 3848:
14245: 3849:```java
14246: 3850:// generics/SelfBoundingMethods.java
14247: 3851:// (c)2017 MindView LLC: see Copyright.txt
14248: 3852:// We make no guarantees that this code is fit for any purpose.
14249: 3853:// Visit http://OnJava8.com for more book information.
14250: 3854:
14251: 3855:public class SelfBoundingMethods {
14252: 3856:    static <T extends SelfBounded<T>> T f(T arg) {
14253: 3857:        return arg.set(arg).get();
14254: 3858:    }
14255: 3859:    
14256: 3860:    public static void main(String[] args) {
14257: 3861:        A a = f(new A());
14258: 3862:    }
14259: 3863:}
14260: 3864:```
14261: 3865:
14262: 3866:这可以防止这个方法被应用于除上述形式的自限定参数之外的任何事物上。
14263: 3867:
14264: 3868:### 参数协变
14265: 3869:
14266: 3870:自限定类型的价值在于它们可以产生*协变参数类型*——方法参数类型会随子类而变化。
14267: 3871:
14268: 3872:尽管自限定类型还可以产生与子类类型相同的返回类型，但是这并不十分重要，因为*协变返回类型*是在 Java 5 引入：
14269: 3873:
14270: 3874:```java
14271: 3875:// generics/CovariantReturnTypes.java
14272: 3876:
14273: 3877:class Base {}
14274: 3878:class Derived extends Base {}
14275: 3879:
14276: 3880:interface OrdinaryGetter {
14277: 3881:    Base get();
14278: 3882:}
14279: 3883:
14280: 3884:interface DerivedGetter extends OrdinaryGetter {
14281: 3885:    // Overridden method return type can vary:
14282: 3886:    @Override
14283: 3887:    Derived get();
14284: 3888:}
14285: 3889:
14286: 3890:public class CovariantReturnTypes {
14287: 3891:    void test(DerivedGetter d) {
14288: 3892:        Derived d2 = d.get();
14289: 3893:    }
14290: 3894:}
14291: 3895:```
14292: 3896:
14293: 3897:**DerivedGetter** 中的 `get()` 方法覆盖了 **OrdinaryGetter** 中的 `get()` ，并返回了一个从 `OrdinaryGetter.get()` 的返回类型中导出的类型。尽管这是完全合乎逻辑的事情（导出类方法应该能够返回比它覆盖的基类方法更具体的类型）但是这在早先的 Java 版本中是不合法的。
14294: 3898:
14295: 3899:自限定泛型事实上将产生确切的导出类型作为其返回值，就像在 `get()` 中所看到的一样：
14296: 3900:
14297: 3901:```java
14298: 3902:// generics/GenericsAndReturnTypes.java
14299: 3903:
14300: 3904:interface GenericGetter<T extends GenericGetter<T>> {
14301: 3905:    T get();
14302: 3906:}
14303: 3907:
14304: 3908:interface Getter extends GenericGetter<Getter> {}
14305: 3909:
14306: 3910:public class GenericsAndReturnTypes {
14307: 3911:    void test(Getter g) {
14308: 3912:        Getter result = g.get();
14309: 3913:        GenericGetter gg = g.get(); // Also the base type
14310: 3914:    }
14311: 3915:}
14312: 3916:```
14313: 3917:
14314: 3918:注意，这段代码不能编译，除非是使用囊括了协变返回类型的 Java 5。
14315: 3919:
14316: 3920:然而，在非泛型代码中，参数类型不能随子类型发生变化：
14317: 3921:
14318: 3922:```java
14319: 3923:// generics/OrdinaryArguments.java
14320: 3924:
14321: 3925:class OrdinarySetter {
14322: 3926:    void set(Base base) {
14323: 3927:        System.out.println("OrdinarySetter.set(Base)");
14324: 3928:    }
14325: 3929:}
14326: 3930:
14327: 3931:class DerivedSetter extends OrdinarySetter {
14328: 3932:    void set(Derived derived) {
14329: 3933:        System.out.println("DerivedSetter.set(Derived)");
14330: 3934:    }
14331: 3935:}
14332: 3936:
14333: 3937:public class OrdinaryArguments {
14334: 3938:    public static void main(String[] args) {
14335: 3939:        Base base = new Base();
14336: 3940:        Derived derived = new Derived();
14337: 3941:        DerivedSetter ds = new DerivedSetter();
14338: 3942:        ds.set(derived);
14339: 3943:        // Compiles--overloaded, not overridden!:
14340: 3944:        ds.set(base);
14341: 3945:    }
14342: 3946:}
14343: 3947:/* Output:
14344: 3948:DerivedSetter.set(Derived)
14345: 3949:OrdinarySetter.set(Base)
14346: 3950:*/
14347: 3951:```
14348: 3952:
14349: 3953:`set(derived)` 和 `set(base)` 都是合法的，因此 `DerivedSetter.set()` 没有覆盖 `OrdinarySetter.set()` ，而是重载了这个方法。从输出中可以看到，在 **DerivedSetter** 中有两个方法，因此基类版本仍旧是可用的，因此可以证明它被重载过。
14350: 3954:但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类型而不是基类型为参数：
14351: 3955:
14352: 3956:```java
14353: 3957:// generics/SelfBoundingAndCovariantArguments.java
14354: 3958:
14355: 3959:interface SelfBoundSetter<T extends SelfBoundSetter<T>> {
14356: 3960:    void set(T arg);
14357: 3961:}
14358: 3962:
14359: 3963:interface Setter extends SelfBoundSetter<Setter> {}
14360: 3964:
14361: 3965:public class SelfBoundingAndCovariantArguments {
14362: 3966:    void
14363: 3967:    testA(Setter s1, Setter s2, SelfBoundSetter sbs) {
14364: 3968:        s1.set(s2);
14365: 3969:        //- s1.set(sbs);
14366: 3970:        // error: method set in interface SelfBoundSetter<T>
14367: 3971:        // cannot be applied to given types;
14368: 3972:        //     s1.set(sbs);
14369: 3973:        //       ^
14370: 3974:        //   required: Setter
14371: 3975:        //   found: SelfBoundSetter
14372: 3976:        //   reason: argument mismatch;
14373: 3977:        // SelfBoundSetter cannot be converted to Setter
14374: 3978:        //   where T is a type-variable:
14375: 3979:        //     T extends SelfBoundSetter<T> declared in
14376: 3980:        //     interface SelfBoundSetter
14377: 3981:        // 1 error
14378: 3982:    }
14379: 3983:}
14380: 3984:```
14381: 3985:
14382: 3986:编译器不能识别将基类型当作参数传递给 `set()` 的尝试，因为没有任何方法具有这样的签名。实际上，这个参数已经被覆盖。
14383: 3987:如果不使用自限定类型，普通的继承机制就会介入，而你将能够重载，就像在非泛型的情况下一样：
14384: 3988:
14385: 3989:```java
14386: 3990:// generics/PlainGenericInheritance.java
14387: 3991:
14388: 3992:class GenericSetter<T> { // Not self-bounded
14389: 3993:    void set(T arg) {
14390: 3994:        System.out.println("GenericSetter.set(Base)");
14391: 3995:    }
14392: 3996:}
14393: 3997:
14394: 3998:class DerivedGS extends GenericSetter<Base> {
14395: 3999:    void set(Derived derived) {
14396: 4000:        System.out.println("DerivedGS.set(Derived)");
14397: 4001:    }
14398: 4002:}
14399: 4003:
14400: 4004:public class PlainGenericInheritance {
14401: 4005:    public static void main(String[] args) {
14402: 4006:        Base base = new Base();
14403: 4007:        Derived derived = new Derived();
14404: 4008:        DerivedGS dgs = new DerivedGS();
14405: 4009:        dgs.set(derived);
14406: 4010:        dgs.set(base); // Overloaded, not overridden!
14407: 4011:    }
14408: 4012:}
14409: 4013:/* Output:
14410: 4014:DerivedGS.set(Derived)
14411: 4015:GenericSetter.set(Base)
14412: 4016:*/
14413: 4017:```
14414: 4018:
14415: 4019:这段代码在模仿 **OrdinaryArguments.java**；在那个示例中，**DerivedSetter** 继承自包含一个 `set(Base)` 的**OrdinarySetter** 。而这里，**DerivedGS** 继承自泛型创建的也包含有一个 `set(Base)`的 `GenericSetter<Base>`。就像 **OrdinaryArguments.java** 一样，你可以从输出中看到， **DerivedGS** 包含两个  `set()` 的重载版本。如果不使用自限定，将重载参数类型。如果使用了自限定，只能获得方法的一个版本，它将接受确切的参数类型。
14416: 4020:
14417: 4021:<!-- Dynamic Type Safety -->
14418: 4022:
14419: 4023:## 动态类型安全
14420: 4024:
14421: 4025:因为可以向 Java 5 之前的代码传递泛型集合，所以旧式代码仍旧有可能会破坏你的集合。Java 5 的 **java.util.Collections** 中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：静态方法 `checkedCollection()` 、`checkedList()`、 `checkedMap()` 、 `checkedSet()` 、`checkedSortedMap()`和 `checkedSortedSet()`。这些方法每一个都会将你希望动态检查的集合当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。
14422: 4026:
14423: 4027:受检查的集合在你试图插入类型不正确的对象时抛出 **ClassCastException** ，这与泛型之前的（原生）集合形成了对比，对于后者来说，当你将对象从集合中取出时，才会通知你出现了问题。在后一种情况中，你知道存在问题，但是不知道罪魁祸首在哪里，如果使用受检查的集合，就可以发现谁在试图插入不良对象。
14424: 4028:让我们用受检查的集合来看看“将猫插入到狗列表中”这个问题。这里，`oldStyleMethod()` 表示遗留代码，因为它接受的是原生的 **List** ，而 **@SuppressWarnings（“unchecked”）** 注解对于压制所产生的警告是必需的：
14425: 4029:
14426: 4030:```java
14427: 4031:// generics/CheckedList.java
14428: 4032:// Using Collection.checkedList()
14429: 4033:import typeinfo.pets.*;
14430: 4034:import java.util.*;
14431: 4035:
14432: 4036:public class CheckedList {
14433: 4037:    @SuppressWarnings("unchecked")
14434: 4038:    static void oldStyleMethod(List probablyDogs) {
14435: 4039:        probablyDogs.add(new Cat());
14436: 4040:    }
14437: 4041:    
14438: 4042:    public static void main(String[] args) {
14439: 4043:        List<Dog> dogs1 = new ArrayList<>();
14440: 4044:        oldStyleMethod(dogs1); // Quietly accepts a Cat
14441: 4045:        List<Dog> dogs2 = Collections.checkedList(
14442: 4046:            new ArrayList<>(), Dog.class);
14443: 4047:        try {
14444: 4048:            oldStyleMethod(dogs2); // Throws an exception
14445: 4049:        } catch(Exception e) {
14446: 4050:            System.out.println("Expected: " + e);
14447: 4051:        }
14448: 4052:        // Derived types work fine:
14449: 4053:        List<Pet> pets = Collections.checkedList(
14450: 4054:            new ArrayList<>(), Pet.class);
14451: 4055:        pets.add(new Dog());
14452: 4056:        pets.add(new Cat());
14453: 4057:    }
14454: 4058:}
14455: 4059:/* Output:
14456: 4060:Expected: java.lang.ClassCastException: Attempt to
14457: 4061:insert class typeinfo.pets.Cat element into collection
14458: 4062:with element type class typeinfo.pets.Dog
14459: 4063:*/
14460: 4064:```
14461: 4065:
14462: 4066:运行这个程序时，你会发现插入一个 **Cat** 对于 **dogs1** 来说没有任何问题，而 **dogs2** 立即会在这个错误类型的插入操作上抛出一个异常。还可以看到，将导出类型的对象放置到将要检查基类型的受检查容器中是没有问题的。
14463: 4067:
14464: 4068:<!-- Exceptions -->
14465: 4069:
14466: 4070:## 泛型异常
14467: 4071:
14468: 4072:由于擦除的原因，**catch** 语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承自 **Throwable**（这将进一步阻止你去定义不能捕获的泛型异常）。
14469: 4073:但是，类型参数可能会在一个方法的 **throws** 子句中用到。这使得你可以编写随检查型异常类型变化的泛型代码：
14470: 4074:
14471: 4075:```java
14472: 4076:// generics/ThrowGenericException.java
14473: 4077:
14474: 4078:import java.util.*;
14475: 4079:
14476: 4080:interface Processor<T, E extends Exception> {
14477: 4081:    void process(List<T> resultCollector) throws E;
14478: 4082:}
14479: 4083:
14480: 4084:class ProcessRunner<T, E extends Exception>
14481: 4085:extends ArrayList<Processor<T, E>> {
14482: 4086:    List<T> processAll() throws E {
14483: 4087:        List<T> resultCollector = new ArrayList<>();
14484: 4088:        for(Processor<T, E> processor : this)
14485: 4089:            processor.process(resultCollector);
14486: 4090:        return resultCollector;
14487: 4091:    }
14488: 4092:}
14489: 4093:
14490: 4094:class Failure1 extends Exception {}
14491: 4095:
14492: 4096:class Processor1
14493: 4097:implements Processor<String, Failure1> {
14494: 4098:    static int count = 3;
14495: 4099:    @Override
14496: 4100:    public void process(List<String> resultCollector)
14497: 4101:    throws Failure1 {
14498: 4102:        if(count-- > 1)
14499: 4103:            resultCollector.add("Hep!");
14500: 4104:        else
14501: 4105:            resultCollector.add("Ho!");
14502: 4106:        if(count < 0)
14503: 4107:            throw new Failure1();
14504: 4108:    }
14505: 4109:}
14506: 4110:
14507: 4111:class Failure2 extends Exception {}
14508: 4112:
14509: 4113:class Processor2
14510: 4114:implements Processor<Integer, Failure2> {
14511: 4115:    static int count = 2;
14512: 4116:    @Override
14513: 4117:    public void process(List<Integer> resultCollector)
14514: 4118:    throws Failure2 {
14515: 4119:        if(count-- == 0)
14516: 4120:            resultCollector.add(47);
14517: 4121:        else {
14518: 4122:            resultCollector.add(11);
14519: 4123:        }
14520: 4124:        if(count < 0)
14521: 4125:            throw new Failure2();
14522: 4126:    }
14523: 4127:}
14524: 4128:
14525: 4129:public class ThrowGenericException {
14526: 4130:    public static void main(String[] args) {
14527: 4131:        ProcessRunner<String, Failure1> runner =
14528: 4132:            new ProcessRunner<>();
14529: 4133:        for(int i = 0; i < 3; i++)
14530: 4134:            runner.add(new Processor1());
14531: 4135:        try {
14532: 4136:            System.out.println(runner.processAll());
14533: 4137:        } catch(Failure1 e) {
14534: 4138:            System.out.println(e);
14535: 4139:        }
14536: 4140:
14537: 4141:        ProcessRunner<Integer, Failure2> runner2 =
14538: 4142:            new ProcessRunner<>();
14539: 4143:        for(int i = 0; i < 3; i++)
14540: 4144:            runner2.add(new Processor2());
14541: 4145:        try {
14542: 4146:            System.out.println(runner2.processAll());
14543: 4147:        } catch(Failure2 e) {
14544: 4148:            System.out.println(e);
14545: 4149:        }
14546: 4150:    }
14547: 4151:}
14548: 4152:/* Output:
14549: 4153:[Hep!, Hep!, Ho!]
14550: 4154:Failure2
14551: 4155:*/
14552: 4156:```
14553: 4157:
14554: 4158:**Processor** 执行 `process()` 方法，并且可能会抛出具有类型 **E** 的异常。`process()` 的结果存储在 `List<T>resultCollector` 中（这被称为*收集参数*）。**ProcessRunner** 有一个 `processAll()` 方法，它会在所持有的每个 **Process** 对象执行，并返回 **resultCollector** 。
14555: 4159:如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出这种泛化的代码。
14556: 4160:
14557: 4161:<!-- Mixins -->
14558: 4162:
14559: 4163:## 混型
14560: 4164:
14561: 4165:术语*混型*随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是你最后的手段，它将使组装多个类变得简单易行。
14562: 4166:混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点*面向切面编程* （AOP） 的味道，而切面经常被建议用来解决混型问题。
14563: 4167:
14564: 4168:### C++ 中的混型
14565: 4169:
14566: 4170:在 C++ 中，使用多重继承的最大理由，就是为了使用混型。但是，对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为混型就是继承自其类型参数的类。在 C++ 中，可以很容易地创建混型，因为 C++ 能够记住其模版参数的类型。
14567: 4171:下面是一个 C++ 示例，它有两个混型类型：一个使得你可以在每个对象中混入拥有一个时间戳这样的属性，而另一个可以混入一个序列号。
14568: 4172:
14569: 4173:```c++
14570: 4174:// generics/Mixins.cpp
14571: 4175:
14572: 4176:#include <string>
14573: 4177:#include <ctime>
14574: 4178:#include <iostream>
14575: 4179:using namespace std;
14576: 4180:
14577: 4181:template<class T> class TimeStamped : public T {
14578: 4182:    long timeStamp;
14579: 4183:public:
14580: 4184:    TimeStamped() { timeStamp = time(0); }
14581: 4185:    long getStamp() { return timeStamp; }
14582: 4186:};
14583: 4187:
14584: 4188:template<class T> class SerialNumbered : public T {
14585: 4189:    long serialNumber;
14586: 4190:    static long counter;
14587: 4191:public:
14588: 4192:    SerialNumbered() { serialNumber = counter++; }
14589: 4193:    long getSerialNumber() { return serialNumber; }
14590: 4194:};
14591: 4195:
14592: 4196:// Define and initialize the static storage:
14593: 4197:template<class T> long SerialNumbered<T>::counter = 1;
14594: 4198:
14595: 4199:class Basic {
14596: 4200:    string value;
14597: 4201:public:
14598: 4202:    void set(string val) { value = val; }
14599: 4203:    string get() { return value; }
14600: 4204:};
14601: 4205:
14602: 4206:int main() {
14603: 4207:    TimeStamped<SerialNumbered<Basic>> mixin1, mixin2;
14604: 4208:    mixin1.set("test string 1");
14605: 4209:    mixin2.set("test string 2");
14606: 4210:    cout << mixin1.get() << " " << mixin1.getStamp() <<
14607: 4211:      " " << mixin1.getSerialNumber() << endl;
14608: 4212:    cout << mixin2.get() << " " << mixin2.getStamp() <<
14609: 4213:      " " << mixin2.getSerialNumber() << endl;
14610: 4214:}
14611: 4215:/* Output:
14612: 4216:test string 1 1452987605 1
14613: 4217:test string 2 1452987605 2
14614: 4218:*/
14615: 4219:```
14616: 4220:
14617: 4221:在 `main()` 中， **mixin1** 和 **mixin2** 所产生的类型拥有所混入类型的所有方法。可以将混型看作是一种功能，它可以将现有类映射到新的子类上。注意，使用这种技术来创建一个混型是多么的轻而易举。基本上，只需要声明“这就是我想要的”，紧跟着它就发生了：
14618: 4222:
14619: 4223:```c++
14620: 4224:TimeStamped<SerialNumbered<Basic>> mixin1，mixin2；
14621: 4225:```
14622: 4226:
14623: 4227:遗憾的是，Java 泛型不允许这样。擦除会忘记基类类型，因此
14624: 4228:
14625: 4229:>  泛型类不能直接继承自一个泛型参数
14626: 4230:
14627: 4231:这突显了许多我在 Java 语言设计决策（以及与这些功能一起发布）中遇到的一大问题：处理一件事很有希望，但是当您实际尝试做一些有趣的事情时，您会发现自己做不到。
14628: 4232:
14629: 4233:### 与接口混合
14630: 4234:
14631: 4235:一种更常见的推荐解决方案是使用接口来产生混型效果，就像下面这样：
14632: 4236:
14633: 4237:```java
14634: 4238:// generics/Mixins.java
14635: 4239:
14636: 4240:import java.util.*;
14637: 4241:
14638: 4242:interface TimeStamped { long getStamp(); }
14639: 4243:
14640: 4244:class TimeStampedImp implements TimeStamped {
14641: 4245:    private final long timeStamp;
14642: 4246:    TimeStampedImp() {
14643: 4247:        timeStamp = new Date().getTime();
14644: 4248:    }
14645: 4249:    @Override
14646: 4250:    public long getStamp() { return timeStamp; }
14647: 4251:}
14648: 4252:
14649: 4253:interface SerialNumbered { long getSerialNumber(); }
14650: 4254:
14651: 4255:class SerialNumberedImp implements SerialNumbered {
14652: 4256:    private static long counter = 1;
14653: 4257:    private final long serialNumber = counter++;
14654: 4258:    @Override
14655: 4259:    public long getSerialNumber() { return serialNumber; }
14656: 4260:}
14657: 4261:
14658: 4262:interface Basic {
14659: 4263:    void set(String val);
14660: 4264:    String get();
14661: 4265:}
14662: 4266:
14663: 4267:class BasicImp implements Basic {
14664: 4268:    private String value;
14665: 4269:    @Override
14666: 4270:    public void set(String val) { value = val; }
14667: 4271:    @Override
14668: 4272:    public String get() { return value; }
14669: 4273:}
14670: 4274:
14671: 4275:class Mixin extends BasicImp
14672: 4276:implements TimeStamped, SerialNumbered {
14673: 4277:    private TimeStamped timeStamp = new TimeStampedImp();
14674: 4278:    private SerialNumbered serialNumber =
14675: 4279:        new SerialNumberedImp();
14676: 4280:    @Override
14677: 4281:    public long getStamp() {
14678: 4282:        return timeStamp.getStamp();
14679: 4283:    }
14680: 4284:    @Override
14681: 4285:    public long getSerialNumber() {
14682: 4286:        return serialNumber.getSerialNumber();
14683: 4287:    }
14684: 4288:}
14685: 4289:
14686: 4290:public class Mixins {
14687: 4291:    public static void main(String[] args) {
14688: 4292:        Mixin mixin1 = new Mixin(), mixin2 = new Mixin();
14689: 4293:        mixin1.set("test string 1");
14690: 4294:        mixin2.set("test string 2");
14691: 4295:        System.out.println(mixin1.get() + " " +
14692: 4296:            mixin1.getStamp() +  " " + mixin1.getSerialNumber());
14693: 4297:        System.out.println(mixin2.get() + " " +
14694: 4298:            mixin2.getStamp() +  " " + mixin2.getSerialNumber());
14695: 4299:    }
14696: 4300:}
14697: 4301:/* Output:
14698: 4302:test string 1 1494331663026 1
14699: 4303:test string 2 1494331663027 2
14700: 4304:*/
14701: 4305:```
14702: 4306:
14703: 4307:**Mixin** 类基本上是在使用*委托*，因此每个混入类型都要求在 **Mixin** 中有一个相应的域，而你必须在 **Mixin** 中编写所有必需的方法，将方法调用转发给恰当的对象。这个示例使用了非常简单的类，但是当使用更复杂的混型时，代码数量会急速增加。[^4]
14704: 4308:
14705: 4309:### 使用装饰器模式
14706: 4310:
14707: 4311:当你观察混型的使用方式时，就会发现混型概念好像与*装饰器*设计模式关系很近。装饰器经常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的。
14708: 4312:装饰器模式使用分层对象来动态透明地向单个对象中添加责任。装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。某些事物是可装饰的，可以通过将其他类包装在这个可装饰对象的四周，来将功能分层。这使得对装饰器的使用是透明的——无论对象是否被装饰，你都拥有一个可以向对象发送的公共消息集。装饰类也可以添加新方法，但是正如你所见，这将是受限的。
14709: 4313:装饰器是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。
14710: 4314:前面的示例可以被改写为使用装饰器：
14711: 4315:
14712: 4316:```java
14713: 4317:// generics/decorator/Decoration.java
14714: 4318:
14715: 4319:// {java generics.decorator.Decoration}
14716: 4320:package generics.decorator;
14717: 4321:import java.util.*;
14718: 4322:
14719: 4323:class Basic {
14720: 4324:    private String value;
14721: 4325:    public void set(String val) { value = val; }
14722: 4326:    public String get() { return value; }
14723: 4327:}
14724: 4328:
14725: 4329:class Decorator extends Basic {
14726: 4330:    protected Basic basic;
14727: 4331:    Decorator(Basic basic) { this.basic = basic; }
14728: 4332:    @Override
14729: 4333:    public void set(String val) { basic.set(val); }
14730: 4334:    @Override
14731: 4335:    public String get() { return basic.get(); }
14732: 4336:}
14733: 4337:
14734: 4338:class TimeStamped extends Decorator {
14735: 4339:    private final long timeStamp;
14736: 4340:    TimeStamped(Basic basic) {
14737: 4341:        super(basic);
14738: 4342:        timeStamp = new Date().getTime();
14739: 4343:    }
14740: 4344:    public long getStamp() { return timeStamp; }
14741: 4345:}
14742: 4346:
14743: 4347:class SerialNumbered extends Decorator {
14744: 4348:    private static long counter = 1;
14745: 4349:    private final long serialNumber = counter++;
14746: 4350:    SerialNumbered(Basic basic) { super(basic); }
14747: 4351:    public long getSerialNumber() { return serialNumber; }
14748: 4352:}
14749: 4353:
14750: 4354:public class Decoration {
14751: 4355:    public static void main(String[] args) {
14752: 4356:        TimeStamped t = new TimeStamped(new Basic());
14753: 4357:        TimeStamped t2 = new TimeStamped(
14754: 4358:            new SerialNumbered(new Basic()));
14755: 4359:        //- t2.getSerialNumber(); // Not available
14756: 4360:        SerialNumbered s = new SerialNumbered(new Basic());
14757: 4361:        SerialNumbered s2 = new SerialNumbered(
14758: 4362:            new TimeStamped(new Basic()));
14759: 4363:        //- s2.getStamp(); // Not available
14760: 4364:  }
14761: 4365:}
14762: 4366:```
14763: 4367:
14764: 4368:产生自泛型的类包含所有感兴趣的方法，但是由使用装饰器所产生的对象类型是最后被装饰的类型。也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。因此，装饰器只是对由混型提出的问题的一种局限的解决方案。
14765: 4369:
14766: 4370:### 与动态代理混合
14767: 4371:
14768: 4372:可以使用动态代理来创建一种比装饰器更贴近混型模型的机制（查看 [类型信息](book/19-Type-Information.md) 一章中关于 Java 的动态代理如何工作的解释）。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。
14769: 4373:由于动态代理的限制，每个被混入的类都必须是某个接口的实现：
14770: 4374:
14771: 4375:```java
14772: 4376:// generics/DynamicProxyMixin.java
14773: 4377:
14774: 4378:import java.lang.reflect.*;
14775: 4379:import java.util.*;
14776: 4380:import onjava.*;
14777: 4381:import static onjava.Tuple.*;
14778: 4382:
14779: 4383:class MixinProxy implements InvocationHandler {
14780: 4384:    Map<String, Object> delegatesByMethod;
14781: 4385:    @SuppressWarnings("unchecked")
14782: 4386:    MixinProxy(Tuple2<Object, Class<?>>... pairs) {
14783: 4387:        delegatesByMethod = new HashMap<>();
14784: 4388:        for(Tuple2<Object, Class<?>> pair : pairs) {
14785: 4389:            for(Method method : pair.a2.getMethods()) {
14786: 4390:                String methodName = method.getName();
14787: 4391:                // The first interface in the map
14788: 4392:                // implements the method.
14789: 4393:                if(!delegatesByMethod.containsKey(methodName))
14790: 4394:                    delegatesByMethod.put(methodName, pair.a1);
14791: 4395:            }
14792: 4396:        }
14793: 4397:    }
14794: 4398:    @Override
14795: 4399:    public Object invoke(Object proxy, Method method,
14796: 4400:      Object[] args) throws Throwable {
14797: 4401:        String methodName = method.getName();
14798: 4402:        Object delegate = delegatesByMethod.get(methodName);
14799: 4403:        return method.invoke(delegate, args);
14800: 4404:    }
14801: 4405:    
14802: 4406:    @SuppressWarnings("unchecked")
14803: 4407:    public static Object newInstance(Tuple2... pairs) {
14804: 4408:        Class[] interfaces = new Class[pairs.length];
14805: 4409:        for(int i = 0; i < pairs.length; i++) {
14806: 4410:            interfaces[i] = (Class)pairs[i].a2;
14807: 4411:        }
14808: 4412:        ClassLoader cl = pairs[0].a1.getClass().getClassLoader();
14809: 4413:        return Proxy.newProxyInstance(cl, interfaces, new MixinProxy(pairs));
14810: 4414:    }
14811: 4415:}
14812: 4416:
14813: 4417:public class DynamicProxyMixin {
14814: 4418:    public static void main(String[] args) {
14815: 4419:        Object mixin = MixinProxy.newInstance(
14816: 4420:          tuple(new BasicImp(), Basic.class),
14817: 4421:          tuple(new TimeStampedImp(), TimeStamped.class),
14818: 4422:          tuple(new SerialNumberedImp(), SerialNumbered.class));
14819: 4423:        Basic b = (Basic)mixin;
14820: 4424:        TimeStamped t = (TimeStamped)mixin;
14821: 4425:        SerialNumbered s = (SerialNumbered)mixin;
14822: 4426:        b.set("Hello");
14823: 4427:        System.out.println(b.get());
14824: 4428:        System.out.println(t.getStamp());
14825: 4429:        System.out.println(s.getSerialNumber());
14826: 4430:    }
14827: 4431:}
14828: 4432:/* Output:
14829: 4433:Hello
14830: 4434:1494331653339
14831: 4435:1
14832: 4436:*/
14833: 4437:```
14834: 4438:
14835: 4439:因为只有动态类型而不是静态类型才包含所有的混入类型，因此这仍旧不如 C++ 的方式好，因为可以在具有这些类型的对象上调用方法之前，你被强制要求必须先将这些对象向下转型到恰当的类型。但是，它明显地更接近于真正的混型。
14836: 4440:为了让 Java 支持混型，人们已经做了大量的工作朝着这个目标努力，包括创建了至少一种附加语言（ Jam 语言），它是专门用来支持混型的。
14837: 4441:
14838: 4442:<!-- Latent Typing -->
14839: 4443:
14840: 4444:## 潜在类型机制
14841: 4445:
14842: 4446:在本章的开头介绍过这样的思想，即要编写能够尽可能广泛地应用的代码。为了实现这一点，我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处。然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码。
14843: 4447:
14844: 4448:Java 泛型看起来是向这一方向迈进了一步。当你在编写或使用只是持有对象的泛型时，这些代码将可以工作于任何类型（除了基本类型，尽管正如你所见到的，自动装箱机制可以克服这一点）。或者，换个角度讲，“持有器”泛型能够声明：“我不关心你是什么类型”。如果代码不关心它将要作用的类型，那么这种代码就可以真正地应用于任何地方，并因此而相当泛化。
14845: 4449:
14846: 4450:还是正如你所见到的，当要在泛型类型上执行操作（即调用 **Object** 方法之外的方法）时，就会产生问题。擦除强制要求指定可能会用到的泛型类型的边界，以安全地调用代码中的泛型对象上的具体方法。这是对“泛化”概念的一种明显的限制，因为必须限制你的泛型类型，使它们继承自特定的类，或者实现特定的接口。在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类或接口没有任何区别。
14847: 4451:
14848: 4452:某些编程语言提供的一种解决方案称为*潜在类型机制*或*结构化类型机制*，而更古怪的术语称为*鸭子类型机制*，即“如果它走起来像鸭子，并且叫起来也像鸭子，那么你就可以将它当作鸭子对待。”鸭子类型机制变成了一种相当流行的术语，可能是因为它不像其他的术语那样承载着历史的包袱。
14849: 4453:
14850: 4454:泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得你可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以 `speak()` 和 `sit()` 即可。”由于不要求具体类型，因此代码就可以更加泛化。
14851: 4455:
14852: 4456:潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方。
14853: 4457:
14854: 4458:支持潜在类型机制的语言包括 Python（可以从 www.Python.org 免费下载）、C++、Ruby、SmallTalk 和 Go。Python 是动态类型语言（几乎所有的类型检查都发生在运行时），而 C++ 和 Go 是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查。
14855: 4459:
14856: 4460:### pyhton 中的潜在类型
14857: 4461:
14858: 4462:如果我们将上面的描述用 Python 来表示，如下所示：
14859: 4463:
14860: 4464:```python
14861: 4465:# generics/DogsAndRobots.py
14862: 4466:
14863: 4467:class Dog:
14864: 4468:    def speak(self):
14865: 4469:        print("Arf!")
14866: 4470:    def sit(self):
14867: 4471:        print("Sitting")
14868: 4472:    def reproduce(self):
14869: 4473:        pass
14870: 4474:
14871: 4475:class Robot:
14872: 4476:    def speak(self):
14873: 4477:        print("Click!")
14874: 4478:    def sit(self):
14875: 4479:        print("Clank!")
14876: 4480:    def oilChange(self):
14877: 4481:        pass
14878: 4482:
14879: 4483:def perform(anything):
14880: 4484:    anything.speak()
14881: 4485:    anything.sit()
14882: 4486:
14883: 4487:a = Dog()
14884: 4488:b = Robot()
14885: 4489:perform(a)
14886: 4490:perform(b)
14887: 4491:
14888: 4492:output = """
14889: 4493:Arf!
14890: 4494:Sitting
14891: 4495:Click!
14892: 4496:Clank!
14893: 4497:"""
14894: 4498:```
14895: 4499:
14896: 4500:Python 使用缩进来确定作用域（因此不需要任何花括号），而冒号将表示新的作用域的开始。“**#**” 表示注释到行尾，就像Java中的 “ **//** ”。类的方法需要显式地指定 **this** 引用的等价物作为第一个参数，按惯例成为 **self** 。构造器调用不要求任何类型的“ **new** ”关键字，并且 Python 允许普通（非成员）函数，就像 `perform()` 所表明的那样。注意，在 `perform(anything)` 中，没有任何针对 **anything** 的类型，**anything** 只是一个标识符，它必须能够执行 `perform()` 期望它执行的操作，因此这里隐含着一个接口。但是你从来都不必显式地写出这个接口——它是潜在的。`perform()` 不关心其参数的类型，因此我可以向它传递任何对象，只要该对象支持  `speak()` 和 `sit()` 方法。如果传递给 `perform()` 的对象不支持这些操作，那么将会得到运行时异常。
14897: 4501:
14898: 4502:输出规定使用三重引号创建带有内嵌换行符的字符串。
14899: 4503:
14900: 4504:### C++ 中的潜在类型
14901: 4505:
14902: 4506:我们可以用 C++ 产生相同的效果：
14903: 4507:
14904: 4508:```c++
14905: 4509:// generics/DogsAndRobots.cpp
14906: 4510:
14907: 4511:#include <iostream>
14908: 4512:using namespace std;
14909: 4513:
14910: 4514:class Dog {
14911: 4515:public:
14912: 4516:    void speak() { cout << "Arf!" << endl; }
14913: 4517:    void sit() { cout << "Sitting" << endl; }
14914: 4518:    void reproduce() {}
14915: 4519:};
14916: 4520:
14917: 4521:class Robot {
14918: 4522:public:
14919: 4523:    void speak() { cout << "Click!" << endl; }
14920: 4524:    void sit() { cout << "Clank!" << endl; }
14921: 4525:    void oilChange() {}
14922: 4526:};
14923: 4527:
14924: 4528:template<class T> void perform(T anything) {
14925: 4529:    anything.speak();
14926: 4530:    anything.sit();
14927: 4531:}
14928: 4532:
14929: 4533:int main() {
14930: 4534:    Dog d;
14931: 4535:    Robot r;
14932: 4536:    perform(d);
14933: 4537:    perform(r);
14934: 4538:}
14935: 4539:/* Output:
14936: 4540:Arf!
14937: 4541:Sitting
14938: 4542:Click!
14939: 4543:Clank!
14940: 4544:*/
14941: 4545:```
14942: 4546:
14943: 4547:在 Python 和 C++ 中，**Dog** 和 **Robot** 没有任何共同的东西，只是碰巧有两个方法具有相同的签名。从类型的观点看，它们是完全不同的类型。但是，`perform()` 不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。
14944: 4548:C++ 确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给你一个错误消息（这些错误消息从历史上看是相当可怕和冗长的，是 C++ 的模版名声欠佳的主要原因）。尽管它们是在不同时期实现这一点的，C++ 在编译期，而 Python 在运行时，但是这两种语言都可以确保类型不会被误用，因此被认为是强类型的。[^5]潜在类型机制没有损害强类型机制。
14945: 4549:
14946: 4550:### Go 中的潜在类型
14947: 4551:
14948: 4552:这里用 Go 语言编写相同的程序：
14949: 4553:
14950: 4554:```go
14951: 4555:// generics/dogsandrobots.go
14952: 4556:
14953: 4557:package main
14954: 4558:import "fmt"
14955: 4559:
14956: 4560:type Dog struct {}
14957: 4561:func (this Dog) speak() { fmt.Printf("Arf!\n")}
14958: 4562:func (this Dog) sit() { fmt.Printf("Sitting\n")}
14959: 4563:func (this Dog) reproduce() {}
14960: 4564:
14961: 4565:type Robot struct {}
14962: 4566:func (this Robot) speak() { fmt.Printf("Click!\n") }
14963: 4567:func (this Robot) sit() { fmt.Printf("Clank!\n") }
14964: 4568:func (this Robot) oilChange() {}
14965: 4569:
14966: 4570:func perform(speaker interface { speak(); sit() }) {
14967: 4571:  speaker.speak();
14968: 4572:  speaker.sit();
14969: 4573:}
14970: 4574:
14971: 4575:func main() {
14972: 4576:  perform(Dog{})
14973: 4577:  perform(Robot{})
14974: 4578:}
14975: 4579:/* Output:
14976: 4580:Arf!
14977: 4581:Sitting
14978: 4582:Click!
14979: 4583:Clank!
14980: 4584:*/
14981: 4585:```
14982: 4586:
14983: 4587:Go 没有 **class** 关键字，但是可以使用上述形式创建等效的基本类：它通常不定义为类，而是定义为 **struct** ，在其中定义数据字段（此处不存在）。 对于每种方法，都以 **func** 关键字开头，然后（为了将该方法附加到您的类上）放在括号中，该括号包含对象引用，该对象引用可以是任何标识符，但是我在这里使用 **this** 来提醒您，就像在 C ++ 或 Java 中的 **this** 一样。 然后，在Go中像这样定义其余的函数。
14984: 4588:
14985: 4589:Go也没有继承关系，因此这种“面向对象的目标”形式是相对原始的，并且可能是我无法花更多的时间来学习该语言的主要原因。 但是，Go 的组成很简单。
14986: 4590:
14987: 4591:`perform()` 函数使用潜在类型：参数的确切类型并不重要，只要它包含了 `speak()` 和  `sit()` 方法即可。 该接口在此处匿名定义，内联，如 `perform()` 的参数列表所示。
14988: 4592:
14989: 4593:`main()` 证明 `perform()` 确实对其参数的确切类型不在乎，只要可以在该参数上调用 `talk()` 和 `sit()` 即可。 但是，就像 C ++ 模板函数一样，在编译时检查类型。
14990: 4594:
14991: 4595:语法 **Dog {}** 和 **Robot {}** 创建匿名的 **Dog** 和 **Robot** 结构。
14992: 4596:
14993: 4597:### java中的直接潜在类型
14994: 4598:
14995: 4599:因为泛型是在这场竞赛的后期才添加到 Java 中，因此没有任何机会可以去实现任何类型的潜在类型机制，因此 Java 没有对这种特性的支持。所以，初看起来，Java 的泛型机制比支持潜在类型机制的语言更“缺乏泛化性”。（使用擦除来实现 Java 泛型的实现有时称为第二类泛型类型）例如，在 Java 8  之前如果我们试图用 Java 实现上面 dogs-and-robots 的示例，那么就会被强制要求使用一个类或接口，并在边界表达式中指定它：
14996: 4600:
14997: 4601:```java
14998: 4602:// generics/Performs.java
14999: 4603:
15000: 4604:public interface Performs {
15001: 4605:    void speak();
15002: 4606:    void sit();
15003: 4607:}
15004: 4608:```
15005: 4609:
15006: 4610:```java
15007: 4611:// generics/DogsAndRobots.java
15008: 4612:// No (direct) latent typing in Java
15009: 4613:import typeinfo.pets.*;
15010: 4614:
15011: 4615:class PerformingDog extends Dog implements Performs {
15012: 4616:    @Override
15013: 4617:    public void speak() { System.out.println("Woof!"); }
15014: 4618:    @Override
15015: 4619:    public void sit() { System.out.println("Sitting"); }
15016: 4620:    public void reproduce() {}
15017: 4621:}
15018: 4622:
15019: 4623:class Robot implements Performs {
15020: 4624:    public void speak() { System.out.println("Click!"); }
15021: 4625:    public void sit() { System.out.println("Clank!"); }
15022: 4626:    public void oilChange() {}
15023: 4627:}
15024: 4628:
15025: 4629:class Communicate {
15026: 4630:    public static <T extends Performs>
15027: 4631:      void perform(T performer) {
15028: 4632:        performer.speak();
15029: 4633:        performer.sit();
15030: 4634:    }
15031: 4635:}
15032: 4636:
15033: 4637:public class DogsAndRobots {
15034: 4638:    public static void main(String[] args) {
15035: 4639:        Communicate.perform(new PerformingDog());
15036: 4640:        Communicate.perform(new Robot());
15037: 4641:    }
15038: 4642:}
15039: 4643:/* Output:
15040: 4644:Woof!
15041: 4645:Sitting
15042: 4646:Click!
15043: 4647:Clank!
15044: 4648:*/
15045: 4649:```
15046: 4650:
15047: 4651:但是要注意，`perform()` 不需要使用泛型来工作，它可以被简单地指定为接受一个 **Performs** 对象：
15048: 4652:
15049: 4653:```java
15050: 4654:// generics/SimpleDogsAndRobots.java
15051: 4655:// Removing the generic; code still works
15052: 4656:
15053: 4657:class CommunicateSimply {
15054: 4658:    static void perform(Performs performer) {
15055: 4659:        performer.speak();
15056: 4660:        performer.sit();
15057: 4661:    }
15058: 4662:}
15059: 4663:
15060: 4664:public class SimpleDogsAndRobots {
15061: 4665:    public static void main(String[] args) {
15062: 4666:        CommunicateSimply.perform(new PerformingDog());
15063: 4667:        CommunicateSimply.perform(new Robot());
15064: 4668:    }
15065: 4669:}
15066: 4670:/* Output:
15067: 4671:Woof!
15068: 4672:Sitting
15069: 4673:Click!
15070: 4674:Clank!
15071: 4675:*/
15072: 4676:```
15073: 4677:
15074: 4678:在本例中，泛型不是必需的，因为这些类已经被强制要求实现 **Performs** 接口。
15075: 4679:
15076: 4680:<!-- Compensating for the Lack of (Direct) Latent -->
15077: 4681:
15078: 4682:## 对缺乏潜在类型机制的补偿
15079: 4683:
15080: 4684:尽管 Java 不直接支持潜在类型机制，但是这并不意味着泛型代码不能在不同的类型层次结构之间应用。也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。
15081: 4685:
15082: 4686:### 反射
15083: 4687:
15084: 4688:可以使用的一种方式是反射，下面的 `perform()` 方法就是用了潜在类型机制：
15085: 4689:
15086: 4690:```java
15087: 4691:// generics/LatentReflection.java
15088: 4692:// Using reflection for latent typing
15089: 4693:import java.lang.reflect.*;
15090: 4694:
15091: 4695:// Does not implement Performs:
15092: 4696:class Mime {
15093: 4697:    public void walkAgainstTheWind() {}
15094: 4698:    public void sit() {
15095: 4699:        System.out.println("Pretending to sit");
15096: 4700:    }
15097: 4701:    public void pushInvisibleWalls() {}
15098: 4702:    @Override
15099: 4703:    public String toString() { return "Mime"; }
15100: 4704:}
15101: 4705:
15102: 4706:// Does not implement Performs:
15103: 4707:class SmartDog {
15104: 4708:    public void speak() { System.out.println("Woof!"); }
15105: 4709:    public void sit() { System.out.println("Sitting"); }
15106: 4710:    public void reproduce() {}
15107: 4711:}
15108: 4712:
15109: 4713:class CommunicateReflectively {
15110: 4714:    public static void perform(Object speaker) {
15111: 4715:        Class<?> spkr = speaker.getClass();
15112: 4716:        try {
15113: 4717:            try {
15114: 4718:                Method speak = spkr.getMethod("speak");
15115: 4719:                speak.invoke(speaker);
15116: 4720:            } catch(NoSuchMethodException e) {
15117: 4721:                System.out.println(speaker + " cannot speak");
15118: 4722:            }
15119: 4723:            try {
15120: 4724:                Method sit = spkr.getMethod("sit");
15121: 4725:                sit.invoke(speaker);
15122: 4726:            } catch(NoSuchMethodException e) {
15123: 4727:                System.out.println(speaker + " cannot sit");
15124: 4728:            }
15125: 4729:        } catch(SecurityException |
15126: 4730:            IllegalAccessException |
15127: 4731:            IllegalArgumentException |
15128: 4732:            InvocationTargetException e) {
15129: 4733:            throw new RuntimeException(speaker.toString(), e);
15130: 4734:        }
15131: 4735:    }
15132: 4736:}
15133: 4737:
15134: 4738:public class LatentReflection {
15135: 4739:    public static void main(String[] args) {
15136: 4740:        CommunicateReflectively.perform(new SmartDog());
15137: 4741:        CommunicateReflectively.perform(new Robot());
15138: 4742:        CommunicateReflectively.perform(new Mime());
15139: 4743:    }
15140: 4744:}
15141: 4745:/* Output:
15142: 4746:Woof!
15143: 4747:Sitting
15144: 4748:Click!
15145: 4749:Clank!
15146: 4750:Mime cannot speak
15147: 4751:Pretending to sit
15148: 4752:*/
15149: 4753:```
15150: 4754:
15151: 4755:上例中，这些类完全是彼此分离的，没有任何公共基类（除了 **Object** ）或接口。通过反射, `CommunicateReflectively.perform()` 能够动态地确定所需要的方法是否可用并调用它们。它甚至能够处理 **Mime** 只具有一个必需的方法这一事实，并能够部分实现其目标。
15152: 4756:
15153: 4757:### 将一个方法应用于序列
15154: 4758:
15155: 4759:反射提供了一些有用的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。但是有可能实现编译期类型检查和潜在类型机制吗？
15156: 4760:
15157: 4761:让我们看一个说明这个问题的示例。假设想要创建一个 `apply()` 方法，它能够将任何方法应用于某个序列中的所有对象。这种情况下使用接口不适合，因为你想要将任何方法应用于一个对象集合，而接口不可能描述任何方法。如何用 Java 来实现这个需求呢？
15158: 4762:
15159: 4763:最初，我们可以用反射来解决这个问题，由于有了 Java 的可变参数，这种方式被证明是相当优雅的：
15160: 4764:
15161: 4765:```java
15162: 4766:// generics/Apply.java
15163: 4767:
15164: 4768:import java.lang.reflect.*;
15165: 4769:import java.util.*;
15166: 4770:
15167: 4771:public class Apply {
15168: 4772:    public static <T, S extends Iterable<T>>
15169: 4773:      void apply(S seq, Method f, Object... args) {
15170: 4774:        try {
15171: 4775:            for(T t: seq)
15172: 4776:                f.invoke(t, args);
15173: 4777:        } catch(IllegalAccessException |
15174: 4778:            IllegalArgumentException |
15175: 4779:            InvocationTargetException e) {
15176: 4780:            // Failures are programmer errors
15177: 4781:            throw new RuntimeException(e);
15178: 4782:        }
15179: 4783:    }
15180: 4784:}
15181: 4785:```
15182: 4786:
15183: 4787:在 **Apply.java** 中，异常被转换为 **RuntimeException** ，因为没有多少办法可以从这种异常中恢复——在这种情况下，它们实际上代表着程序员的错误。
15184: 4788:
15185: 4789:为什么我们不只使用 Java 8 方法参考（稍后显示）而不是反射方法 **f** ？ 注意，`invoke()` 和 `apply()` 的优点是它们可以接受任意数量的参数。 在某些情况下，灵活性可能至关重要。
15186: 4790:
15187: 4791:为了测试 **Apply** ，我们首先创建一个 **Shape** 类：
15188: 4792:
15189: 4793:```java
15190: 4794:// generics/Shape.java
15191: 4795:
15192: 4796:public class Shape {
15193: 4797:    private static long counter = 0;
15194: 4798:    private final long id = counter++;
15195: 4799:    @Override
15196: 4800:    public String toString() {
15197: 4801:        return getClass().getSimpleName() + " " + id;
15198: 4802:    }
15199: 4803:    public void rotate() {
15200: 4804:        System.out.println(this + " rotate");
15201: 4805:    }
15202: 4806:    public void resize(int newSize) {
15203: 4807:        System.out.println(this + " resize " + newSize);
15204: 4808:    }
15205: 4809:}
15206: 4810:```
15207: 4811:
15208: 4812:被一个子类 **Square** 继承：
15209: 4813:
15210: 4814:```java
15211: 4815:// generics/Square.java
15212: 4816:
15213: 4817:public class Square extends Shape {}
15214: 4818:```
15215: 4819:
15216: 4820:通过这些，我们可以测试 **Apply**：
15217: 4821:
15218: 4822:```java
15219: 4823:// generics/ApplyTest.java
15220: 4824:
15221: 4825:import java.util.*;
15222: 4826:import java.util.function.*;
15223: 4827:import onjava.*;
15224: 4828:
15225: 4829:public class ApplyTest {
15226: 4830:    public static
15227: 4831:    void main(String[] args) throws Exception {
15228: 4832:        List<Shape> shapes =
15229: 4833:          Suppliers.create(ArrayList::new, Shape::new, 3);
15230: 4834:        Apply.apply(shapes, Shape.class.getMethod("rotate"));
15231: 4835:        Apply.apply(shapes, Shape.class.getMethod("resize", int.class), 7);
15232: 4836:
15233: 4837:        List<Square> squares =
15234: 4838:          Suppliers.create(ArrayList::new, Square::new, 3);
15235: 4839:        Apply.apply(squares, Shape.class.getMethod("rotate"));
15236: 4840:        Apply.apply(squares, Shape.class.getMethod("resize", int.class), 7);
15237: 4841:
15238: 4842:        Apply.apply(new FilledList<>(Shape::new, 3),
15239: 4843:          Shape.class.getMethod("rotate"));
15240: 4844:        Apply.apply(new FilledList<>(Square::new, 3),
15241: 4845:          Shape.class.getMethod("rotate"));
15242: 4846:
15243: 4847:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
15244: 4848:          new SimpleQueue<>(), SimpleQueue::add,
15245: 4849:          Shape::new, 3);
15246: 4850:        Suppliers.fill(shapeQ, SimpleQueue::add,
15247: 4851:          Square::new, 3);
15248: 4852:        Apply.apply(shapeQ, Shape.class.getMethod("rotate"));
15249: 4853:    }
15250: 4854:}
15251: 4855:/* Output:
15252: 4856:Shape 0 rotate
15253: 4857:Shape 1 rotate
15254: 4858:Shape 2 rotate
15255: 4859:Shape 0 resize 7
15256: 4860:Shape 1 resize 7
15257: 4861:Shape 2 resize 7
15258: 4862:Square 3 rotate
15259: 4863:Square 4 rotate
15260: 4864:Square 5 rotate
15261: 4865:Square 3 resize 7
15262: 4866:Square 4 resize 7
15263: 4867:Square 5 resize 7
15264: 4868:Shape 6 rotate
15265: 4869:Shape 7 rotate
15266: 4870:Shape 8 rotate
15267: 4871:Square 9 rotate
15268: 4872:Square 10 rotate
15269: 4873:Square 11 rotate
15270: 4874:Shape 12 rotate
15271: 4875:Shape 13 rotate
15272: 4876:Shape 14 rotate
15273: 4877:Square 15 rotate
15274: 4878:Square 16 rotate
15275: 4879:Square 17 rotate
15276: 4880:*/
15277: 4881:```
15278: 4882:
15279: 4883:在 **Apply** 中，我们运气很好，因为碰巧在 Java 中内建了一个由 Java 集合类库使用的 **Iterable** 接口。正由于此， `apply()` 方法可以接受任何实现了 **Iterable** 接口的事物，包括诸如 **List** 这样的所有 **Collection** 类。但是它还可以接受其他任何事物，只要能够使这些事物是 **Iterable** 的——例如，在 `main()` 中使用下面定义的 **SimpleQueue** 类：
15280: 4884:
15281: 4885:```java
15282: 4886:// generics/SimpleQueue.java
15283: 4887:
15284: 4888:// A different kind of Iterable collection
15285: 4889:import java.util.*;
15286: 4890:
15287: 4891:public class SimpleQueue<T> implements Iterable<T> {
15288: 4892:    private LinkedList<T> storage = new LinkedList<>();
15289: 4893:    public void add(T t) { storage.offer(t); }
15290: 4894:    public T get() { return storage.poll(); }
15291: 4895:    @Override
15292: 4896:    public Iterator<T> iterator() {
15293: 4897:        return storage.iterator();
15294: 4898:    }
15295: 4899:}
15296: 4900:```
15297: 4901:
15298: 4902:正如反射解决方案看起来那样优雅，我们必须观察到反射（尽管在 Java 的最新版本中得到了显着改进）通常比非反射实现要慢，因为在运行时发生了很多事情。 但它不应阻止您尝试这种解决方案，这依然是值得考虑的一点。
15299: 4903:
15300: 4904:几乎可以肯定，你会首先使用 Java 8 的函数式方法，并且只有在解决了特殊需求时才诉诸反射。 这里对 **ApplyTest.java** 进行了重写，以利用 Java 8 的流和函数工具：
15301: 4905:
15302: 4906:```java
15303: 4907:// generics/ApplyFunctional.java
15304: 4908:
15305: 4909:import java.util.*;
15306: 4910:import java.util.stream.*;
15307: 4911:import java.util.function.*;
15308: 4912:import onjava.*;
15309: 4913:
15310: 4914:public class ApplyFunctional {
15311: 4915:    public static void main(String[] args) {
15312: 4916:        Stream.of(
15313: 4917:          Stream.generate(Shape::new).limit(2),
15314: 4918:          Stream.generate(Square::new).limit(2))
15315: 4919:        .flatMap(c -> c) // flatten into one stream
15316: 4920:        .peek(Shape::rotate)
15317: 4921:        .forEach(s -> s.resize(7));
15318: 4922:
15319: 4923:        new FilledList<>(Shape::new, 2)
15320: 4924:          .forEach(Shape::rotate);
15321: 4925:        new FilledList<>(Square::new, 2)
15322: 4926:          .forEach(Shape::rotate);
15323: 4927:
15324: 4928:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
15325: 4929:          new SimpleQueue<>(), SimpleQueue::add,
15326: 4930:          Shape::new, 2);
15327: 4931:        Suppliers.fill(shapeQ, SimpleQueue::add,
15328: 4932:          Square::new, 2);
15329: 4933:        shapeQ.forEach(Shape::rotate);
15330: 4934:    }
15331: 4935:}
15332: 4936:/* Output:
15333: 4937:Shape 0 rotate
15334: 4938:Shape 0 resize 7
15335: 4939:Shape 1 rotate
15336: 4940:Shape 1 resize 7
15337: 4941:Square 2 rotate
15338: 4942:Square 2 resize 7
15339: 4943:Square 3 rotate
15340: 4944:Square 3 resize 7
15341: 4945:Shape 4 rotate
15342: 4946:Shape 5 rotate
15343: 4947:Square 6 rotate
15344: 4948:Square 7 rotate
15345: 4949:Shape 8 rotate
15346: 4950:Shape 9 rotate
15347: 4951:Square 10 rotate
15348: 4952:Square 11 rotate
15349: 4953:*/
15350: 4954:```
15351: 4955:
15352: 4956:由于使用 Java 8，因此不需要 `Apply.apply()` 。
15353: 4957:
15354: 4958:我们首先生成两个 **Stream** ： 一个是 **Shape** ，一个是 **Square** ，并将它们展平为单个流。 尽管 Java 缺少功能语言中经常出现的 `flatten()` ，但是我们可以使用 `flatMap(c-> c)` 产生相同的结果，后者使用身份映射将操作简化为“  **flatten** ”。
15355: 4959:
15356: 4960:我们使用 `peek()` 当做对 `rotate()` 的调用，因为 `peek()` 执行一个操作（此处是出于副作用），并在未更改的情况下传递对象。
15357: 4961:
15358: 4962:注意，使用 **FilledList** 和 **shapeQ** 调用 `forEach()` 比 `Apply.apply()` 代码整洁得多。 在代码简单性和可读性方面，结果比以前的方法好得多。 并且，现在也不可能从  `main()` 引发异常。
15359: 4963:
15360: 4964:<!-- Assisted Latent Typing in Java 8 -->
15361: 4965:
15362: 4966:## Java8 中的辅助潜在类型
15363: 4967:
15364: 4968:先前声明关于 Java 缺乏对潜在类型的支持在 Java 8 之前是完全正确的。但是，Java 8 中的非绑定方法引用使我们能够产生一种潜在类型的形式，以满足创建一段可工作在不相干类型上的代码。因为 Java 最初并不是如此设计，所以结果可想而知，比其他语言中要尴尬一些。但是，至少现在成为了可能，只是缺乏令人惊艳之处。
15365: 4969:
15366: 4970:我在其他地方从没遇过这种技术，因此我将其称为辅助潜在类型。
15367: 4971:
15368: 4972:我们将重写 **DogsAndRobots.java** 来演示该技术。 为使外观看起来与原始示例尽可能相似，我仅向每个原始类名添加了 **A**：
15369: 4973:
15370: 4974:```java
15371: 4975:// generics/DogsAndRobotMethodReferences.java
15372: 4976:
15373: 4977:// "Assisted Latent Typing"
15374: 4978:import typeinfo.pets.*;
15375: 4979:import java.util.function.*;
15376: 4980:
15377: 4981:class PerformingDogA extends Dog {
15378: 4982:    public void speak() { System.out.println("Woof!"); }
15379: 4983:    public void sit() { System.out.println("Sitting"); }
15380: 4984:    public void reproduce() {}
15381: 4985:}
15382: 4986:
15383: 4987:class RobotA {
15384: 4988:    public void speak() { System.out.println("Click!"); }
15385: 4989:    public void sit() { System.out.println("Clank!"); }
15386: 4990:    public void oilChange() {}
15387: 4991:}
15388: 4992:
15389: 4993:class CommunicateA {
15390: 4994:    public static <P> void perform(P performer,
15391: 4995:      Consumer<P> action1, Consumer<P> action2) {
15392: 4996:        action1.accept(performer);
15393: 4997:        action2.accept(performer);
15394: 4998:    }
15395: 4999:}
15396: 5000:
15397: 5001:public class DogsAndRobotMethodReferences {
15398: 5002:    public static void main(String[] args) {
15399: 5003:        CommunicateA.perform(new PerformingDogA(),
15400: 5004:          PerformingDogA::speak, PerformingDogA::sit);
15401: 5005:        CommunicateA.perform(new RobotA(),
15402: 5006:          RobotA::speak, RobotA::sit);
15403: 5007:        CommunicateA.perform(new Mime(),
15404: 5008:          Mime::walkAgainstTheWind,
15405: 5009:          Mime::pushInvisibleWalls);
15406: 5010:    }
15407: 5011:}
15408: 5012:/* Output:
15409: 5013:Woof!
15410: 5014:Sitting
15411: 5015:Click!
15412: 5016:Clank!
15413: 5017:*/
15414: 5018:```
15415: 5019:
15416: 5020:**PerformingDogA** 和 **RobotA** 与 **DogsAndRobots.java** 中的相同，不同之处在于它们不继承通用接口 **Performs** ，因此它们没有通用性。
15417: 5021:
15418: 5022:`CommunicateA.perform()` 在没有约束的 **P** 上生成。 只要可以使用 `Consumer <P>`，它在这里就可以是任何东西，这些 `Consumer<P>` 代表不带参数的 **P** 方法的未绑定方法引用。当您调用 **Consumer**  的 `accept()` 方法时，它将方法引用绑定到执行者对象并调用该方法。 由于 [函数式编程](book/13-Functional-Programming.md) 一章中描述的“魔术”，我们可以将任何符合签名的未绑定方法引用传递给 `CommunicateA.perform()` 。
15419: 5023:
15420: 5024:之所以称其为“辅助”，是因为您必须显式地为 `perform()` 提供要使用的方法引用。 它不能只按名称调用方法。
15421: 5025:
15422: 5026:尽管传递未绑定的方法引用似乎要花很多力气，但潜在类型的最终目标还是可以实现的。 我们创建了一个代码片段 `CommunicateA.perform()` ，该代码可用于任何具有符合签名的方法引用的类型。 请注意，这与我们看到的其他语言中的潜在类型有所不同，因为这些语言不仅需要签名以符合规范，还需要方法名称。 因此，该技术可以说产生了更多的通用代码。
15423: 5027:
15424: 5028:为了证明这一点，我还从 **LatentReflection.java** 中引入了 **Mime**。
15425: 5029:
15426: 5030:### 使用**Suppliers**类的通用方法
15427: 5031:
15428: 5032:通过辅助潜在类型，我们可以定义本章其他部分中使用的 **Suppliers** 类。 此类包含使用生成器填充 **Collection** 的工具方法。 泛化这些操作很有意义：
15429: 5033:
15430: 5034:```java
15431: 5035:// onjava/Suppliers.java
15432: 5036:
15433: 5037:// A utility to use with Suppliers
15434: 5038:package onjava;
15435: 5039:import java.util.*;
15436: 5040:import java.util.function.*;
15437: 5041:import java.util.stream.*;
15438: 5042:
15439: 5043:public class Suppliers {
15440: 5044:    // Create a collection and fill it:
15441: 5045:    public static <T, C extends Collection<T>> C
15442: 5046:      create(Supplier<C> factory, Supplier<T> gen, int n) {
15443: 5047:        return Stream.generate(gen)
15444: 5048:            .limit(n)
15445: 5049:            .collect(factory, C::add, C::addAll);
15446: 5050:    }
15447: 5051:    
15448: 5052:    // Fill an existing collection:
15449: 5053:    public static <T, C extends Collection<T>>
15450: 5054:      C fill(C coll, Supplier<T> gen, int n) {
15451: 5055:        Stream.generate(gen)
15452: 5056:            .limit(n)
15453: 5057:            .forEach(coll::add);
15454: 5058:        return coll;
15455: 5059:    }
15456: 5060:    
15457: 5061:    // Use an unbound method reference to
15458: 5062:    // produce a more general method:
15459: 5063:    public static <H, A> H fill(H holder,
15460: 5064:      BiConsumer<H, A> adder, Supplier<A> gen, int n) {
15461: 5065:        Stream.generate(gen)
15462: 5066:            .limit(n)
15463: 5067:            .forEach(a -> adder.accept(holder, a));
15464: 5068:        return holder;
15465: 5069:    }
15466: 5070:}
15467: 5071:```
15468: 5072:
15469: 5073:`create()` 为你创建一个新的 **Collection** 子类型，而 `fill()` 的第一个版本将元素放入 **Collection** 的现有子类型中。 请注意，还会返回传入的容器的确切类型，因此不会丢失类型信息。[^6]
15470: 5074:
15471: 5075:前两种方法一般都受约束，只能与 **Collection** 子类型一起使用。`fill()` 的第二个版本适用于任何类型的 **holder** 。 它需要一个附加参数：未绑定方法引用 `adder. fill()` ，使用辅助潜在类型来使其与任何具有添加元素方法的 **holder** 类型一起使用。因为此未绑定方法 **adder** 必须带有一个参数（要添加到 **holder** 的元素），所以 **adder** 必须是 `BiConsumer <H，A>` ，其中 **H** 是要绑定到的 **holder** 对象的类型，而 **A** 是要被添加的绑定元素类型。 对 `accept()` 的调用将使用参数 a 调用对象 **holder** 上的未绑定方法 **holder**。
15472: 5076:
15473: 5077:在一个稍作模拟的测试中对 **Suppliers** 工具程序进行了测试，该仿真还使用了本章前面定义的 **RandomList** ：
15474: 5078:
15475: 5079:```java
15476: 5080:// generics/BankTeller.java
15477: 5081:
15478: 5082:// A very simple bank teller simulation
15479: 5083:import java.util.*;
15480: 5084:import onjava.*;
15481: 5085:
15482: 5086:class Customer {
15483: 5087:    private static long counter = 1;
15484: 5088:    private final long id = counter++;
15485: 5089:    @Override
15486: 5090:    public String toString() {
15487: 5091:        return "Customer " + id;
15488: 5092:    }
15489: 5093:}
15490: 5094:
15491: 5095:class Teller {
15492: 5096:    private static long counter = 1;
15493: 5097:    private final long id = counter++;
15494: 5098:    @Override
15495: 5099:    public String toString() {
15496: 5100:        return "Teller " + id;
15497: 5101:    }
15498: 5102:}
15499: 5103:
15500: 5104:class Bank {
15501: 5105:    private List<BankTeller> tellers =
15502: 5106:        new ArrayList<>();
15503: 5107:    public void put(BankTeller bt) {
15504: 5108:        tellers.add(bt);
15505: 5109:    }
15506: 5110:}
15507: 5111:
15508: 5112:public class BankTeller {
15509: 5113:    public static void serve(Teller t, Customer c) {
15510: 5114:        System.out.println(t + " serves " + c);
15511: 5115:    }
15512: 5116:    public static void main(String[] args) {
15513: 5117:        // Demonstrate create():
15514: 5118:        RandomList<Teller> tellers =
15515: 5119:            Suppliers.create(
15516: 5120:            RandomList::new, Teller::new, 4);
15517: 5121:        // Demonstrate fill():
15518: 5122:        List<Customer> customers = Suppliers.fill(
15519: 5123:            new ArrayList<>(), Customer::new, 12);
15520: 5124:        customers.forEach(c ->
15521: 5125:            serve(tellers.select(), c));
15522: 5126:        // Demonstrate assisted latent typing:
15523: 5127:        Bank bank = Suppliers.fill(
15524: 5128:            new Bank(), Bank::put, BankTeller::new, 3);
15525: 5129:        // Can also use second version of fill():
15526: 5130:        List<Customer> customers2 = Suppliers.fill(
15527: 5131:            new ArrayList<>(),
15528: 5132:            List::add, Customer::new, 12);
15529: 5133:    }
15530: 5134:}
15531: 5135:/* Output:
15532: 5136:Teller 3 serves Customer 1
15533: 5137:Teller 2 serves Customer 2
15534: 5138:Teller 3 serves Customer 3
15535: 5139:Teller 1 serves Customer 4
15536: 5140:Teller 1 serves Customer 5
15537: 5141:Teller 3 serves Customer 6
15538: 5142:Teller 1 serves Customer 7
15539: 5143:Teller 2 serves Customer 8
15540: 5144:Teller 3 serves Customer 9
15541: 5145:Teller 3 serves Customer 10
15542: 5146:Teller 2 serves Customer 11
15543: 5147:Teller 4 serves Customer 12
15544: 5148:*/
15545: 5149:```
15546: 5150:
15547: 5151:可以看到 `create()` 生成一个新的 **Collection** 对象，而 `fill()` 添加到现有 **Collection** 中。第二个版本`fill()` 显示，它不仅与无关的新类型 **Bank** 一起使用，还能与 **List** 一起使用。因此，从技术上讲，`fill()` 的第一个版本在技术上不是必需的，但在使用 **Collection** 时提供了较短的语法。
15548: 5152:
15549: 5153:<!-- Summary: Is Casting Really So Bad? -->
15550: 5154:
15551: 5155:## 总结：类型转换真的如此之糟吗？
15552: 5156:
15553: 5157:自从 C++ 模版出现以来，我就一直在致力于解释它，我可能比大多数人都更早地提出了下面的论点。直到最近，我才停下来，去思考这个论点到底在多少时间内是有效的——我将要描述的问题到底有多少次可以穿越障碍得以解决。
15554: 5158:
15555: 5159:这个论点就是：使用泛型类型机制的最吸引人的地方，就是在使用集合类的地方，这些类包括诸如各种 **List** 、各种 **Set** 、各种 **Map** 等你在 [集合](book/12-Collections.md) 和 [附录：集合主题](book/Appendix-Collection-Topics.md) 这两章所见。在 Java 5 之前，当你将一个对象放置到集合中时，这个对象就会被向上转型为 **Object** ，因此你会丢失类型信息。当你想要将这个对象从集合中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。我用的示例是持有 **Cat** 的 **List** （这个示例的一种使用苹果和桔子的变体在 [集合](book/12-Collections.md) 章节的开头展示过）。如果没有 Java 5 泛型版本的集合，你放到容集里和从集合中取回的都是 **Object** 。因此，我们很可能会将一个 **Dog** 放置到 **Cat** 的 **List** 中。
15556: 5160:
15557: 5161:但是，泛型出现之前的 Java 并不会让你误用放入到集合中的对象。如果将一个 **Dog** 扔到 **Cat** 的集合中，并且试图将这个集合中的所有东西都当作 **Cat** 处理，那么当你从这个 **Cat** 集合中取回那个 **Dog** 引用，并试图将其转型为 **Cat** 时，就会得到一个 **RuntimeException** 。你仍旧可以发现问题，但是是在运行时而非编译期发现它的。
15558: 5162:
15559: 5163:在本书以前的版本中，我曾经说过：
15560: 5164:
15561: 5165:> 这不止令人恼火，它还可能会产生难以发现的缺陷。如果这个程序的某个部分（或数个部分）向集合中插入了对象，并且通过异常，你在程序的另一个独立的部分中发现有不良对象被放置到了集合中，那么必须发现这个不良插入到底是在何处发生的。
15562: 5166:
15563: 5167:但是，随着对这个论点的进一步检查，我开始怀疑它了。首先，这会多么频繁地发生呢？我记得这类事情从未发生在我身上，并且当我在会议上询问其他人时，我也从来没有听说过有人碰上过。另一本书使用了一个称为 **files** 的 list 示例，它包含 **String** 对象。在这个示例中，向 **files** 中添加一个 **File** 对象看起来相当自然，因此这个对象的名字可能叫 **fileNames** 更好。无论 Java 提供了多少类型检查，仍旧可能会写出晦涩的程序，而编写差劲儿的程序即便可以编译，它仍旧是编写差劲儿的程序。可能大多数人都会使用命名良好的集合，例如 **cats** ，因为它们可以向试图添加非 **Cat** 对象的程序员提供可视的警告。并且即便这类事情发生了，它真正又能潜伏多久呢？只要你开始用真实数据来运行测试，就会非常快地看到异常。
15564: 5168:
15565: 5169:有一位作者甚至断言，这样的缺陷将“*潜伏数年*”。但是我不记得有任何大量的相关报告，来说明人们在查找“狗在猫列表中”这类缺陷时困难重重，或者是说明人们会非常频繁地产生这种错误。然而，你将在 [多线程编程](book/24-Concurrent-Programming.md) 章节中看到，在使用线程时，出现那些可能看起来极罕见的缺陷，是很寻常并容易发生的事，而且，对于到底出了什么错，这些缺陷只能给你一个很模糊的概念。因此，对于泛型是添加到 Java 中的非常显著和相当复杂的特性这一点，“狗在猫列表中”这个论据真的能够成为它的理由吗？
15566: 5170:我相信被称为*泛型*的通用语言特性（并非必须是其在 Java 中的特定实现）的目的在于可表达性，而不仅仅是为了创建类型安全的集合。类型安全的集合是能够创建更通用代码这一能力所带来的副作用。
15567: 5171:因此，即便“狗在猫列表中”这个论据经常被用来证明泛型是必要的，但是它仍旧是有问题的。就像我在本章开头声称的，我不相信这就是泛型这个概念真正的含义。相反，泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。正如你在本章中看到的，编写真正泛化的“持有器”类（ Java 的容器就是这种类）相当简单，但是编写出能够操作其泛型类型的泛化代码就需要额外的努力了，这些努力需要类创建者和类消费者共同付出，他们必须理解这些代码的概念和实现。这些额外的努力会增加使用这种特性的难度，并可能会因此而使其在某些场合缺乏可应用性，而在这些场合中，它可能会带来附加的价值。
15568: 5172:
15569: 5173:还要注意到，因为泛型是后来添加到 Java 中，而不是从一开始就设计到这种语言中的，所以某些容器无法达到它们应该具备的健壮性。例如，观察一下 **Map** ，在特定的方法 `containsKey(Object key) `和 `get(Object key)` 中就包含这类情况。如果这些类是使用在它们之前就存在的泛型设计的，那么这些方法将会使用参数化类型而不是 **Object** ，因此也就可以提供这些泛型假设会提供的编译期检查。例如，在 C++ 的 **map** 中，键的类型总是在编译期检查的。
15570: 5174:
15571: 5175:有一件事很明显：在一种语言已经被广泛应用之后，在其较新的版本中引入任何种类的泛型机制，都会是一项非常非常棘手的任务，并且是一项不付出艰辛就无法完成的任务。在 C++ 中，模版是在其最初的 ISO 版本中就引入的（即便如此，也引发了阵痛，因为在第一个标准 C++ 出现之前，有很多非模版版本在使用），因此实际上模版一直都是这种语言的一部分。在 Java 中，泛型是在这种语言首次发布大约 10 年之后才引入的，因此向泛型迁移的问题特别多，并且对泛型的设计产生了明显的影响。其结果就是，程序员将承受这些痛苦，而这一切都是由于 Java 设计者在设计 1.0 版本时所表现出来的短视造成的。当 Java 最初被创建时，它的设计者们当然了解 C++ 的模版，他们甚至考虑将其囊括到 Java 语言中，但是出于这样或那样的原因，他们决定将模版排除在外（其迹象就是他们过于匆忙）。因此， Java 语言和使用它的程序员都将承受这些痛苦。只有时间将会说明 Java 的泛型方式对这种语言所造成的最终影响。
15572: 5176:某些语言，已经融入了更简洁、影响更小的方式，来实现参数化类型。我们不可能不去想象这样的语言将会成为 Java 的继任者，因为它们采用的方式，与 C++ 通过 C 来实现的方式相同：按原样使用它，然后对其进行改进。
15573: 5177:
15574: 5178:## 进阶阅读
15575: 5179:
15576: 5180:泛型的入门文档是 《Generics in the Java Programming Language》，作者是 Gilad Bracha，可以从 http://java.oracle.com 获取。
15577: 5181:
15578: 5182:Angelika Langer 的《Java Generics FAQs》是一份非常有帮助的资料，可以从 http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html 获取。
15579: 5183:
15580: 5184:你可以从 《Adding Wildcards to the Java Programming Language》中学到更多关于通配符的知识，作者是 Torgerson、Ernst、Hansen、von der Ahe、Bracha 和 Gafter，地址是 http://www.jot.fm/issues/issue_2004_12/article5。
15581: 5185:
15582: 5186:Neal After 对于 Java 问题（尤其是擦除）的看法可以从这里找到：http://www.infoq.com/articles/neal-gafter-on-java。
15583: 5187:
15584: 5188:[^1]: 在编写本章期间，Angelika Langer的 Java 泛型常见问题解答以及她的其他著作（与Klaus Kreft一起）是非常宝贵的。
15585: 5189:[^2]: [http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html](http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html)
15586: 5190:[^3]: 参见本章章末引文。
15587: 5191:[^4]: 注意，一些编程环境，如 Eclipse 和 IntelliJ IDEA，将会自动生成委托代码。
15588: 5192:[^5]: 因为可以使用转型，有效地禁止了类型系统，一些人就认为 C++ 是弱类型，但这太极端了。一种可能更好的说法是 C++ 是有一道暗门的强类型语言。
15589: 5193:[^6]: 我再次从 Brian Goetz 那获得帮助。
15590: 5194:
15591: 5195:<!-- 分页 -->
15592: 5196:
15593: 5197:<div style="page-break-after: always;"></div>
15594: 
15595: 1:[TOC]
15596: 2:
15597: 3:<!-- Generics -->
15598: 4:
15599: 5:# 第二十章 泛型
15600: 6:
15601: 7:> 普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。
15602: 8:
15603: 9:多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。除了 `final` 类（或只提供私有构造函数的类）任何类型都可被扩展，所以大部分时候这种灵活性是自带的。
15604: 10:
15605: 11:拘泥于单一的继承体系太过局限，因为只有继承体系中的对象才能适用基类作为参数的方法中。如果方法以接口而不是类作为参数，限制就宽松多了，只要实现了接口就可以。这给予调用方一种选项，通过调整现有的类来实现接口，满足方法参数要求。接口可以突破继承体系的限制。
15606: 12:
15607: 13:即便是接口也还是有诸多限制。一旦指定了接口，它就要求你的代码必须使用特定的接口。而我们希望编写更通用的代码，能够适用“非特定的类型”，而不是一个具体的接口或类。
15608: 14:
15609: 15:这就是泛型的概念，是 Java 5 的重大变化之一。泛型实现了*参数化类型*，这样你编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。随后你会发现 Java 中泛型的实现并没有那么“泛”，你可能会质疑“泛型”这个词是否合适用来描述这一功能。
15610: 16:
15611: 17:如果你从未接触过参数化类型机制，你会发现泛型对 Java 语言确实是个很有益的补充。在你实例化一个类型参数时，编译器会负责转型并确保类型的正确性。这是一大进步。
15612: 18:
15613: 19:然而，如果你了解其他语言（例如 C++ ）的参数化机制，你会发现，Java 泛型并不能满足所有的预期。使用别人创建好的泛型相对容易，但是创建自己的泛型时，就会遇到很多意料之外的麻烦。
15614: 20:
15615: 21:这并不是说 Java 泛型毫无用处。在很多情况下，它可以使代码更直接更优雅。不过，如果你见识过那种实现了更纯粹的泛型的编程语言，那么，Java 可能会令你失望。本章会介绍 Java 泛型的优点与局限。我会解释 Java 的泛型是如何发展成现在这样的，希望能够帮助你更有效地使用这个特性。[^1]
15616: 22:
15617: 23:### 与 C++ 的比较
15618: 24:
15619: 25:Java 的设计者曾说过，这门语言的灵感主要来自 C++ 。尽管如此，学习 Java 时基本不用参考 C++ 。
15620: 26:
15621: 27:但是，Java 中的泛型需要与 C++ 进行对比，理由有两个：首先，理解 C++ *模板*（泛型的主要灵感来源，包括基本语法）的某些特性，有助于理解泛型的基础理念。同时，非常重要的一点是，你可以了解 Java 泛型的局限是什么，以及为什么会有这些局限。最终的目标是明确 Java 泛型的边界，让你成为一个程序高手。只有知道了某个技术不能做什么，你才能更好地做到所能做的（部分原因是，不必浪费时间在死胡同里）。
15622: 28:
15623: 29:第二个原因是，在 Java 社区中，大家普遍对 C++ 模板有一种误解，而这种误解可能会令你在理解泛型的意图时产生偏差。
15624: 30:
15625: 31:因此，本章中会介绍少量 C++ 模板的例子，仅当它们确实可以加深理解时才会引入。
15626: 32:
15627: 33:<!-- Simple Generics -->
15628: 34:
15629: 35:## 简单泛型
15630: 36:
15631: 37:促成泛型出现的最主要的动机之一是为了创建*集合类*，参见 [集合](book/12-Collections.md) 章节。集合用于存放要使用到的对象。数组也是如此，不过集合比数组更加灵活，功能更丰富。几乎所有程序在运行过程中都会涉及到一组对象，因此集合是可复用性最高的类库之一。
15632: 38:
15633: 39:我们先看一个只能持有单个对象的类。这个类可以明确指定其持有的对象的类型：
15634: 40:
15635: 41:```java
15636: 42:// generics/Holder1.java
15637: 43:
15638: 44:class Automobile {}
15639: 45:
15640: 46:public class Holder1 {
15641: 47:    private Automobile a;
15642: 48:    public Holder1(Automobile a) { this.a = a; }
15643: 49:    Automobile get() { return a; }
15644: 50:}
15645: 51:```
15646: 52:
15647: 53:这个类的可复用性不高，它无法持有其他类型的对象。我们可不希望为碰到的每个类型都编写一个新的类。
15648: 54:
15649: 55:在 Java 5 之前，我们可以让这个类直接持有 `Object` 类型的对象：
15650: 56:
15651: 57:```java
15652: 58:// generics/ObjectHolder.java
15653: 59:
15654: 60:public class ObjectHolder {
15655: 61:    private Object a;
15656: 62:    public ObjectHolder(Object a) { this.a = a; }
15657: 63:    public void set(Object a) { this.a = a; }
15658: 64:    public Object get() { return a; }
15659: 65:    
15660: 66:    public static void main(String[] args) {
15661: 67:        ObjectHolder h2 = new ObjectHolder(new Automobile());
15662: 68:        Automobile a = (Automobile)h2.get();
15663: 69:        h2.set("Not an Automobile");
15664: 70:        String s = (String)h2.get();
15665: 71:        h2.set(1); // 自动装箱为 Integer
15666: 72:        Integer x = (Integer)h2.get();
15667: 73:    }
15668: 74:}
15669: 75:```
15670: 76:
15671: 77:现在，`ObjectHolder` 可以持有任何类型的对象，在上面的示例中，一个 `ObjectHolder` 先后持有了三种不同类型的对象。
15672: 78:
15673: 79:一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。
15674: 80:
15675: 81:因此，与其使用 `Object` ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用*类型参数*，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，`T` 就是类型参数：
15676: 82:
15677: 83:```java
15678: 84:// generics/GenericHolder.java
15679: 85:
15680: 86:public class GenericHolder<T> {
15681: 87:    private T a;
15682: 88:    public GenericHolder() {}
15683: 89:    public void set(T a) { this.a = a; }
15684: 90:    public T get() { return a; }
15685: 91:    
15686: 92:    public static void main(String[] args) {
15687: 93:        GenericHolder<Automobile> h3 = new GenericHolder<Automobile>();
15688: 94:        h3.set(new Automobile()); // 此处有类型校验
15689: 95:        Automobile a = h3.get();  // 无需类型转换
15690: 96:        //- h3.set("Not an Automobile"); // 报错
15691: 97:        //- h3.set(1);  // 报错
15692: 98:    }
15693: 99:}
15694: 100:```
15695: 101:
15696: 102:创建 `GenericHolder` 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 `main()` 中那样使用。然后，你就只能在 `GenericHolder` 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当你调用 `get()` 取值时，直接就是正确的类型。
15697: 103:
15698: 104:这就是 Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。
15699: 105:
15700: 106:你可能注意到 `h3` 的定义非常繁复。在 `=` 左边有 `GenericHolder<Automobile>`, 右边又重复了一次。在 Java 5 中，这种写法被解释成“必要的”，但在 Java 7 中设计者修正了这个问题（新的简写语法随后成为备受欢迎的特性）。以下是简写的例子：
15701: 107:
15702: 108:```java
15703: 109:// generics/Diamond.java
15704: 110:
15705: 111:class Bob {}
15706: 112:
15707: 113:public class Diamond<T> {
15708: 114:    public static void main(String[] args) {
15709: 115:        GenericHolder<Bob> h3 = new GenericHolder<>();
15710: 116:        h3.set(new Bob());
15711: 117:    }
15712: 118:}
15713: 119:```
15714: 120:
15715: 121:注意，在 `h3` 的定义处，`=` 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。在本书剩余部分都会使用这种语法。
15716: 122:
15717: 123:一般来说，你可以认为泛型和其他类型差不多，只不过它们碰巧有类型参数罢了。在使用泛型时，你只需要指定它们的名称和类型参数列表即可。
15718: 124:
15719: 125:### 一个元组类库
15720: 126:
15721: 127:有时一个方法需要能返回多个对象。而 **return** 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得了编译时的类型安全。
15722: 128:
15723: 129:这个概念称为*元组*，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 *数据传输对象* 或 *信使* ）。
15724: 130:
15725: 131:通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组：
15726: 132:
15727: 133:```java
15728: 134:// onjava/Tuple2.java
15729: 135:package onjava;
15730: 136:
15731: 137:public class Tuple2<A, B> {
15732: 138:    public final A a1;
15733: 139:    public final B a2;
15734: 140:    public Tuple2(A a, B b) { a1 = a; a2 = b; }
15735: 141:    public String rep() { return a1 + ", " + a2; }
15736: 142:  
15737: 143:    @Override
15738: 144:    public String toString() {
15739: 145:        return "(" + rep() + ")";
15740: 146:    }
15741: 147:}
15742: 148:```
15743: 149:
15744: 150:构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。
15745: 151:
15746: 152:初次阅读上面的代码时，你可能认为这违反了 Java 编程的封装原则。`a1` 和 `a2` 应该声明为 **private**，然后提供 `getFirst()` 和 `getSecond()` 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取 `a1` 和 `a2` 然后对它们执行任何操作，但无法对 `a1` 和 `a2` 重新赋值。例子中的 `final` 可以实现同样的效果，并且更为简洁明了。
15747: 153:
15748: 154:另一种设计思路是允许元组的用户给 `a1` 和 `a2` 重新赋值。然而，采用上例中的形式无疑更加安全，如果用户想存储不同的元素，就会强制他们创建新的 `Tuple2` 对象。
15749: 155:
15750: 156:我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了：
15751: 157:
15752: 158:```java
15753: 159:// onjava/Tuple3.java
15754: 160:package onjava;
15755: 161:
15756: 162:public class Tuple3<A, B, C> extends Tuple2<A, B> {
15757: 163:    public final C a3;
15758: 164:    public Tuple3(A a, B b, C c) {
15759: 165:        super(a, b);
15760: 166:        a3 = c;
15761: 167:    }
15762: 168:    
15763: 169:    @Override
15764: 170:    public String rep() {
15765: 171:        return super.rep() + ", " + a3;
15766: 172:    }
15767: 173:}
15768: 174:
15769: 175:// onjava/Tuple4.java
15770: 176:package onjava;
15771: 177:
15772: 178:public class Tuple4<A, B, C, D>
15773: 179:  extends Tuple3<A, B, C> {
15774: 180:    public final D a4;
15775: 181:    public Tuple4(A a, B b, C c, D d) {
15776: 182:        super(a, b, c);
15777: 183:        a4 = d;
15778: 184:    }
15779: 185:    
15780: 186:    @Override
15781: 187:    public String rep() {
15782: 188:        return super.rep() + ", " + a4;
15783: 189:    }
15784: 190:}
15785: 191:
15786: 192:// onjava/Tuple5.java
15787: 193:package onjava;
15788: 194:
15789: 195:public class Tuple5<A, B, C, D, E>
15790: 196:  extends Tuple4<A, B, C, D> {
15791: 197:    public final E a5;
15792: 198:    public Tuple5(A a, B b, C c, D d, E e) {
15793: 199:        super(a, b, c, d);
15794: 200:        a5 = e;
15795: 201:    }
15796: 202:    
15797: 203:    @Override
15798: 204:    public String rep() {
15799: 205:        return super.rep() + ", " + a5;
15800: 206:    }
15801: 207:}
15802: 208:```
15803: 209:
15804: 210:演示需要，再定义两个类：
15805: 211:
15806: 212:```java
15807: 213:// generics/Amphibian.java
15808: 214:public class Amphibian {}
15809: 215:
15810: 216:// generics/Vehicle.java
15811: 217:public class Vehicle {}
15812: 218:```
15813: 219:
15814: 220:使用元组时，你只需要定义一个长度适合的元组，将其作为返回值即可。注意下面例子中方法的返回类型：
15815: 221:
15816: 222:```java
15817: 223:// generics/TupleTest.java
15818: 224:import onjava.*;
15819: 225:
15820: 226:public class TupleTest {
15821: 227:    static Tuple2<String, Integer> f() {
15822: 228:        // 47 自动装箱为 Integer
15823: 229:        return new Tuple2<>("hi", 47);
15824: 230:    }
15825: 231:  
15826: 232:    static Tuple3<Amphibian, String, Integer> g() {
15827: 233:        return new Tuple3<>(new Amphibian(), "hi", 47);
15828: 234:    }
15829: 235:  
15830: 236:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
15831: 237:        return new Tuple4<>(new Vehicle(), new Amphibian(), "hi", 47);
15832: 238:    }
15833: 239:  
15834: 240:    static Tuple5<Vehicle, Amphibian, String, Integer, Double> k() {
15835: 241:        return new Tuple5<>(new Vehicle(), new Amphibian(), "hi", 47, 11.1);
15836: 242:    }
15837: 243:  
15838: 244:    public static void main(String[] args) {
15839: 245:        Tuple2<String, Integer> ttsi = f();
15840: 246:        System.out.println(ttsi);
15841: 247:        // ttsi.a1 = "there"; // 编译错误，因为 final 不能重新赋值
15842: 248:        System.out.println(g());
15843: 249:        System.out.println(h());
15844: 250:        System.out.println(k());
15845: 251:    }
15846: 252:}
15847: 253:
15848: 254:/* 输出：
15849: 255: (hi, 47)
15850: 256: (Amphibian@1540e19d, hi, 47)
15851: 257: (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47)
15852: 258: (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1)
15853: 259: */
15854: 260:```
15855: 261:
15856: 262:有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。
15857: 263:
15858: 264:通过 `ttsi.a1 = "there"` 语句的报错，我们可以看出，**final** 声明确实可以确保 **public** 字段在对象被构造出来之后就不能重新赋值了。
15859: 265:
15860: 266:在上面的程序中，`new` 表达式有些啰嗦。本章稍后会介绍，如何利用 *泛型方法* 简化它们。
15861: 267:
15862: 268:### 一个堆栈类
15863: 269:
15864: 270:接下来我们看一个稍微复杂一点的例子：堆栈。在 [集合](book/12-Collections.md) 一章中，我们用 `LinkedList` 实现了 `onjava.Stack` 类。在那个例子中，`LinkedList` 本身已经具备了创建堆栈所需的方法。`Stack` 是通过两个泛型类 `Stack<T>` 和 `LinkedList<T>` 的组合来创建。我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。
15865: 271:
15866: 272:这次我们不用 `LinkedList` 来实现自己的内部链式存储机制。
15867: 273:
15868: 274:```java
15869: 275:// generics/LinkedStack.java
15870: 276:// 用链式结构实现的堆栈
15871: 277:
15872: 278:public class LinkedStack<T> {
15873: 279:    private static class Node<U> {
15874: 280:        U item;
15875: 281:        Node<U> next;
15876: 282:    
15877: 283:        Node() { item = null; next = null; }
15878: 284:        
15879: 285:        Node(U item, Node<U> next) {
15880: 286:            this.item = item;
15881: 287:            this.next = next;
15882: 288:        }
15883: 289:    
15884: 290:        boolean end() {
15885: 291:            return item == null && next == null;
15886: 292:        }
15887: 293:    }
15888: 294:  
15889: 295:    private Node<T> top = new Node<>();  // 栈顶
15890: 296:  
15891: 297:    public void push(T item) {
15892: 298:        top = new Node<>(item, top);
15893: 299:    }
15894: 300:  
15895: 301:    public T pop() {
15896: 302:        T result = top.item;
15897: 303:        if (!top.end()) {
15898: 304:            top = top.next;
15899: 305:        }
15900: 306:        return result;
15901: 307:    }
15902: 308:  
15903: 309:    public static void main(String[] args) {
15904: 310:        LinkedStack<String> lss = new LinkedStack<>();
15905: 311:        for (String s : "Phasers on stun!".split(" ")) {
15906: 312:            lss.push(s);
15907: 313:        }
15908: 314:        String s;
15909: 315:        while ((s = lss.pop()) != null) {
15910: 316:            System.out.println(s);
15911: 317:        }
15912: 318:    }
15913: 319:}
15914: 320:```
15915: 321:
15916: 322:输出结果：
15917: 323:
15918: 324:```java
15919: 325:stun!
15920: 326:on
15921: 327:Phasers
15922: 328:```
15923: 329:
15924: 330:内部类 `Node` 也是一个泛型，它拥有自己的类型参数。
15925: 331:
15926: 332:这个例子使用了一个 *末端标识* (end sentinel) 来判断栈何时为空。这个末端标识是在构造 `LinkedStack` 时创建的。然后，每次调用 `push()` 就会创建一个 `Node<T>` 对象，并将其链接到前一个 `Node<T>` 对象。当你调用 `pop()` 方法时，总是返回 `top.item`，然后丢弃当前 `top` 所指向的 `Node<T>`，并将 `top` 指向下一个 `Node<T>`，除非到达末端标识，这时就不能再移动 `top` 了。如果已经到达末端，程序还继续调用 `pop()` 方法，它只能得到 `null`，说明栈已经空了。
15927: 333:
15928: 334:### RandomList
15929: 335:
15930: 336:作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 `select()` 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型：
15931: 337:
15932: 338:```java
15933: 339:// generics/RandomList.java
15934: 340:import java.util.*;
15935: 341:import java.util.stream.*;
15936: 342:
15937: 343:public class RandomList<T> extends ArrayList<T> {
15938: 344:    private Random rand = new Random(47);
15939: 345:  
15940: 346:    public T select() {
15941: 347:        return get(rand.nextInt(size()));
15942: 348:    }
15943: 349:  
15944: 350:    public static void main(String[] args) {
15945: 351:        RandomList<String> rs = new RandomList<>();
15946: 352:        Arrays.stream("The quick brown fox jumped over the lazy brown dog".split(" ")).forEach(rs::add);
15947: 353:        IntStream.range(0, 11).forEach(i -> 
15948: 354:            System.out.print(rs.select() + " "));
15949: 355:    }
15950: 356:}
15951: 357:```
15952: 358:
15953: 359:输出结果：
15954: 360:
15955: 361:```java
15956: 362:brown over fox quick quick dog brown The brown lazy brown
15957: 363:```
15958: 364:
15959: 365:`RandomList` 继承了 `ArrayList` 的所有方法。本例中只添加了 `select()` 这个方法。
15960: 366:
15961: 367:<!-- Generic Interfaces -->
15962: 368:
15963: 369:## 泛型接口
15964: 370:
15965: 371:泛型也可以应用于接口。例如 *生成器*，这是一种专门负责创建对象的类。实际上，这是 *工厂方法* 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。
15966: 372:
15967: 373:一般而言，一个生成器只定义一个方法，用于创建对象。例如 `java.util.function` 类库中的 `Supplier` 就是一个生成器，调用其 `get()` 获取对象。`get()` 是泛型方法，返回值为类型参数 `T`。
15968: 374:
15969: 375:为了演示 `Supplier`，我们需要定义几个类。下面是个咖啡相关的继承体系：
15970: 376:
15971: 377:```java
15972: 378:// generics/coffee/Coffee.java
15973: 379:package generics.coffee;
15974: 380:
15975: 381:public class Coffee {
15976: 382:    private static long counter = 0;
15977: 383:    private final long id = counter++;
15978: 384:  
15979: 385:    @Override
15980: 386:    public String toString() {
15981: 387:        return getClass().getSimpleName() + " " + id;
15982: 388:    }
15983: 389:}
15984: 390:
15985: 391:
15986: 392:// generics/coffee/Latte.java
15987: 393:package generics.coffee;
15988: 394:public class Latte extends Coffee {}
15989: 395:
15990: 396:
15991: 397:// generics/coffee/Mocha.java
15992: 398:package generics.coffee;
15993: 399:public class Mocha extends Coffee {}
15994: 400:
15995: 401:
15996: 402:// generics/coffee/Cappuccino.java
15997: 403:package generics.coffee;
15998: 404:public class Cappuccino extends Coffee {}
15999: 405:
16000: 406:
16001: 407:// generics/coffee/Americano.java
16002: 408:package generics.coffee;
16003: 409:public class Americano extends Coffee {}
16004: 410:
16005: 411:
16006: 412:// generics/coffee/Breve.java
16007: 413:package generics.coffee;
16008: 414:public class Breve extends Coffee {}
16009: 415:```
16010: 416:
16011: 417:现在，我们可以编写一个类，实现 `Supplier<Coffee>` 接口，它能够随机生成不同类型的 `Coffee` 对象：
16012: 418:
16013: 419:```java
16014: 420:// generics/coffee/CoffeeSupplier.java
16015: 421:// {java generics.coffee.CoffeeSupplier}
16016: 422:package generics.coffee;
16017: 423:import java.util.*;
16018: 424:import java.util.function.*;
16019: 425:import java.util.stream.*;
16020: 426:
16021: 427:public class CoffeeSupplier
16022: 428:implements Supplier<Coffee>, Iterable<Coffee> {
16023: 429:    private Class<?>[] types = { Latte.class, Mocha.class, 
16024: 430:        Cappuccino.class, Americano.class, Breve.class };
16025: 431:    private static Random rand = new Random(47);
16026: 432:  
16027: 433:    public CoffeeSupplier() {}
16028: 434:    // For iteration:
16029: 435:    private int size = 0;
16030: 436:    public CoffeeSupplier(int sz) { size = sz; }
16031: 437:  
16032: 438:    @Override
16033: 439:    public Coffee get() {
16034: 440:        try {
16035: 441:            return (Coffee) types[rand.nextInt(types.length)].newInstance();
16036: 442:        } catch (InstantiationException | IllegalAccessException e) {
16037: 443:            throw new RuntimeException(e);
16038: 444:        }
16039: 445:    }
16040: 446:  
16041: 447:    class CoffeeIterator implements Iterator<Coffee> {
16042: 448:        int count = size;
16043: 449:        @Override
16044: 450:        public boolean hasNext() { return count > 0; }
16045: 451:        @Override
16046: 452:        public Coffee next() {
16047: 453:            count--;
16048: 454:            return CoffeeSupplier.this.get();
16049: 455:        }
16050: 456:        @Override
16051: 457:        public void remove() {
16052: 458:            throw new UnsupportedOperationException();
16053: 459:        }
16054: 460:    }
16055: 461:  
16056: 462:    @Override
16057: 463:    public Iterator<Coffee> iterator() {
16058: 464:        return new CoffeeIterator();
16059: 465:    }
16060: 466:  
16061: 467:    public static void main(String[] args) {
16062: 468:        Stream.generate(new CoffeeSupplier())
16063: 469:              .limit(5)
16064: 470:              .forEach(System.out::println);
16065: 471:        for (Coffee c : new CoffeeSupplier(5)) {
16066: 472:            System.out.println(c);
16067: 473:        }
16068: 474:    }
16069: 475:}
16070: 476:```
16071: 477:
16072: 478:输出结果：
16073: 479:
16074: 480:```java
16075: 481:Americano 0
16076: 482:Latte 1
16077: 483:Americano 2
16078: 484:Mocha 3
16079: 485:Mocha 4
16080: 486:Breve 5
16081: 487:Americano 6
16082: 488:Latte 7
16083: 489:Cappuccino 8
16084: 490:Cappuccino 9
16085: 491:```
16086: 492:
16087: 493:参数化的 `Supplier` 接口确保 `get()` 返回值是参数的类型。`CoffeeSupplier` 同时还实现了 `Iterable` 接口，所以能用于 *for-in* 语句。不过，它还需要知道何时终止循环，这正是第二个构造函数的作用。
16088: 494:
16089: 495:下面是另一个实现 `Supplier<T>` 接口的例子，它负责生成 Fibonacci 数列：
16090: 496:
16091: 497:```java
16092: 498:// generics/Fibonacci.java
16093: 499:// Generate a Fibonacci sequence
16094: 500:import java.util.function.*;
16095: 501:import java.util.stream.*;
16096: 502:
16097: 503:public class Fibonacci implements Supplier<Integer> {
16098: 504:    private int count = 0;
16099: 505:    @Override
16100: 506:    public Integer get() { return fib(count++); }
16101: 507:  
16102: 508:    private int fib(int n) {
16103: 509:        if(n < 2) return 1;
16104: 510:        return fib(n-2) + fib(n-1);
16105: 511:    }
16106: 512:  
16107: 513:    public static void main(String[] args) {
16108: 514:        Stream.generate(new Fibonacci())
16109: 515:              .limit(18)
16110: 516:              .map(n -> n + " ")
16111: 517:              .forEach(System.out::print);
16112: 518:    }
16113: 519:}
16114: 520:```
16115: 521:
16116: 522:输出结果：
16117: 523:
16118: 524:```java
16119: 525:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
16120: 526:```
16121: 527:
16122: 528:虽然我们在 `Fibonacci` 类的里里外外使用的都是 `int` 类型，但是其参数类型却是 `Integer`。这个例子引出了 Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备自动装箱和拆箱的功能，可以很方便地在基本类型和相应的包装类之间进行转换。通过这个例子中 `Fibonacci` 类对 `int` 的使用，我们已经看到了这种效果。
16123: 529:
16124: 530:如果还想更进一步，编写一个实现了 `Iterable` 的 `Fibnoacci` 生成器。我们的一个选择是重写这个类，令其实现 `Iterable` 接口。不过，你并不是总能拥有源代码的控制权，并且，除非必须这么做，否则，我们也不愿意重写一个类。而且我们还有另一种选择，就是创建一个 *适配器* (Adapter) 来实现所需的接口，我们在前面介绍过这个设计模式。
16125: 531:
16126: 532:有多种方法可以实现适配器。例如，可以通过继承来创建适配器类：
16127: 533:
16128: 534:```java
16129: 535:// generics/IterableFibonacci.java
16130: 536:// Adapt the Fibonacci class to make it Iterable
16131: 537:import java.util.*;
16132: 538:
16133: 539:public class IterableFibonacci
16134: 540:extends Fibonacci implements Iterable<Integer> {
16135: 541:    private int n;
16136: 542:    public IterableFibonacci(int count) { n = count; }
16137: 543:  
16138: 544:    @Override
16139: 545:    public Iterator<Integer> iterator() {
16140: 546:        return new Iterator<Integer>() {
16141: 547:            @Override
16142: 548:            public boolean hasNext() { return n > 0; }
16143: 549:            @Override
16144: 550:            public Integer next() {
16145: 551:                n--;
16146: 552:                return IterableFibonacci.this.get();
16147: 553:            }
16148: 554:            @Override
16149: 555:            public void remove() { // Not implemented
16150: 556:                throw new UnsupportedOperationException();
16151: 557:            }
16152: 558:        };
16153: 559:    }
16154: 560:  
16155: 561:    public static void main(String[] args) {
16156: 562:        for(int i : new IterableFibonacci(18))
16157: 563:            System.out.print(i + " ");
16158: 564:    }
16159: 565:}
16160: 566:```
16161: 567:
16162: 568:输出结果：
16163: 569:
16164: 570:```java
16165: 571:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
16166: 572:```
16167: 573:
16168: 574:在 *for-in* 语句中使用 `IterableFibonacci`，必须在构造函数中提供一个边界值，这样 `hasNext()` 才知道何时返回 **false**，结束循环。
16169: 575:
16170: 576:<!-- Generic Methods -->
16171: 577:
16172: 578:## 泛型方法
16173: 579:
16174: 580:到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。
16175: 581:
16176: 582:泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。
16177: 583:
16178: 584:如果方法是 **static** 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型类型参数，则它必须是泛型方法。
16179: 585:
16180: 586:要定义泛型方法，请将泛型参数列表放置在返回值之前，如下所示：
16181: 587:
16182: 588:```java
16183: 589:// generics/GenericMethods.java
16184: 590:
16185: 591:public class GenericMethods {
16186: 592:    public <T> void f(T x) {
16187: 593:        System.out.println(x.getClass().getName());
16188: 594:    }
16189: 595:
16190: 596:    public static void main(String[] args) {
16191: 597:        GenericMethods gm = new GenericMethods();
16192: 598:        gm.f("");
16193: 599:        gm.f(1);
16194: 600:        gm.f(1.0);
16195: 601:        gm.f(1.0F);
16196: 602:        gm.f('c');
16197: 603:        gm.f(gm);
16198: 604:    }
16199: 605:}
16200: 606:/* Output:
16201: 607:java.lang.String
16202: 608:java.lang.Integer
16203: 609:java.lang.Double
16204: 610:java.lang.Float
16205: 611:java.lang.Character
16206: 612:GenericMethods
16207: 613:*/
16208: 614:```
16209: 615:
16210: 616:尽管可以同时对类及其方法进行参数化，但这里未将 **GenericMethods** 类参数化。只有方法 `f()` 具有类型参数，该参数由方法返回类型之前的参数列表指示。
16211: 617:
16212: 618:对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 *类型参数推断*。因此，对 `f()` 的调用看起来像普通的方法调用，并且 `f()` 看起来像被重载了无数次一样。它甚至会接受 **GenericMethods** 类型的参数。
16213: 619:
16214: 620:如果使用基本类型调用 `f()` ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。
16215: 621:
16216: 622:<!-- Varargs and Generic Methods -->
16217: 623:
16218: 624:### 变长参数和泛型方法
16219: 625:
16220: 626:泛型方法和变长参数列表可以很好地共存：
16221: 627:
16222: 628:```java
16223: 629:// generics/GenericVarargs.java
16224: 630:
16225: 631:import java.util.ArrayList;
16226: 632:import java.util.List;
16227: 633:
16228: 634:public class GenericVarargs {
16229: 635:    @SafeVarargs
16230: 636:    public static <T> List<T> makeList(T... args) {
16231: 637:        List<T> result = new ArrayList<>();
16232: 638:        for (T item : args)
16233: 639:            result.add(item);
16234: 640:        return result;
16235: 641:    }
16236: 642:
16237: 643:    public static void main(String[] args) {
16238: 644:        List<String> ls = makeList("A");
16239: 645:        System.out.println(ls);
16240: 646:        ls = makeList("A", "B", "C");
16241: 647:        System.out.println(ls);
16242: 648:        ls = makeList(
16243: 649:                "ABCDEFFHIJKLMNOPQRSTUVWXYZ".split(""));
16244: 650:        System.out.println(ls);
16245: 651:    }
16246: 652:}
16247: 653:/* Output:
16248: 654:[A]
16249: 655:[A, B, C]
16250: 656:[A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R,
16251: 657:S, T, U, V, W, X, Y, Z]
16252: 658:*/
16253: 659:```
16254: 660:
16255: 661:此处显示的 `makeList()` 方法产生的功能与标准库的 `java.util.Arrays.asList()` 方法相同。
16256: 662:
16257: 663:`@SafeVarargs` 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。
16258: 664:
16259: 665:<!-- A General-Purpose Supplier -->
16260: 666:
16261: 667:### 一个泛型的 Supplier
16262: 668:
16263: 669:这是一个为任意具有无参构造方法的类生成 **Supplier** 的类。为了减少键入，它还包括一个用于生成 **BasicSupplier** 的泛型方法：
16264: 670:
16265: 671:```java
16266: 672:// onjava/BasicSupplier.java
16267: 673:// Supplier from a class with a no-arg constructor
16268: 674:package onjava;
16269: 675:
16270: 676:import java.util.function.Supplier;
16271: 677:
16272: 678:public class BasicSupplier<T> implements Supplier<T> {
16273: 679:    private Class<T> type;
16274: 680:
16275: 681:    public BasicSupplier(Class<T> type) {
16276: 682:        this.type = type;
16277: 683:    }
16278: 684:
16279: 685:    @Override
16280: 686:    public T get() {
16281: 687:        try {
16282: 688:            // Assumes type is a public class:
16283: 689:            return type.newInstance();
16284: 690:        } catch (InstantiationException |
16285: 691:                IllegalAccessException e) {
16286: 692:            throw new RuntimeException(e);
16287: 693:        }
16288: 694:    }
16289: 695:
16290: 696:    // Produce a default Supplier from a type token:
16291: 697:    public static <T> Supplier<T> create(Class<T> type) {
16292: 698:        return new BasicSupplier<>(type);
16293: 699:    }
16294: 700:}
16295: 701:```
16296: 702:
16297: 703:此类提供了产生以下对象的基本实现：
16298: 704:
16299: 705:1. 是 **public** 的。 因为 **BasicSupplier** 在单独的包中，所以相关的类必须具有 **public** 权限，而不仅仅是包级访问权限。
16300: 706:
16301: 707:2. 具有无参构造方法。要创建一个这样的 **BasicSupplier** 对象，请调用 `create()` 方法，并将要生成类型的类型令牌传递给它。通用的 `create()` 方法提供了 `BasicSupplier.create(MyType.class)` 这种较简洁的语法来代替较笨拙的 `new BasicSupplier <MyType>(MyType.class)`。
16302: 708:
16303: 709:例如，这是一个具有无参构造方法的简单类：
16304: 710:
16305: 711:```java
16306: 712:// generics/CountedObject.java
16307: 713:
16308: 714:public class CountedObject {
16309: 715:    private static long counter = 0;
16310: 716:    private final long id = counter++;
16311: 717:
16312: 718:    public long id() {
16313: 719:        return id;
16314: 720:    }
16315: 721:
16316: 722:    @Override
16317: 723:    public String toString() {
16318: 724:        return "CountedObject " + id;
16319: 725:    }
16320: 726:}
16321: 727:```
16322: 728:
16323: 729:**CountedObject** 类可以跟踪自身创建了多少个实例，并通过 `toString()` 报告这些实例的数量。 **BasicSupplier** 可以轻松地为 **CountedObject** 创建 **Supplier**：
16324: 730:
16325: 731:```java
16326: 732:  // generics/BasicSupplierDemo.java
16327: 733:
16328: 734:import onjava.BasicSupplier;
16329: 735:
16330: 736:import java.util.stream.Stream;
16331: 737:
16332: 738:public class BasicSupplierDemo {
16333: 739:    public static void main(String[] args) {
16334: 740:        Stream.generate(
16335: 741:                BasicSupplier.create(CountedObject.class))
16336: 742:                .limit(5)
16337: 743:                .forEach(System.out::println);
16338: 744:    }
16339: 745:}
16340: 746:/* Output:
16341: 747:CountedObject 0
16342: 748:CountedObject 1
16343: 749:CountedObject 2
16344: 750:CountedObject 3
16345: 751:CountedObject 4
16346: 752:*/
16347: 753:```
16348: 754:
16349: 755:泛型方法减少了产生 **Supplier** 对象所需的代码量。 Java 泛型强制传递 **Class** 对象，以便在 `create()` 方法中将其用于类型推断。
16350: 756:
16351: 757:<!-- Simplifying Tuple Use -->
16352: 758:
16353: 759:### 简化元组的使用
16354: 760:
16355: 761:使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库。在这里，我们使用重载的静态方法创建元组：
16356: 762:
16357: 763:```java
16358: 764:// onjava/Tuple.java
16359: 765:// Tuple library using type argument inference
16360: 766:package onjava;
16361: 767:
16362: 768:public class Tuple {
16363: 769:    public static <A, B> Tuple2<A, B> tuple(A a, B b) {
16364: 770:        return new Tuple2<>(a, b);
16365: 771:    }
16366: 772:
16367: 773:    public static <A, B, C> Tuple3<A, B, C>
16368: 774:    tuple(A a, B b, C c) {
16369: 775:        return new Tuple3<>(a, b, c);
16370: 776:    }
16371: 777:
16372: 778:    public static <A, B, C, D> Tuple4<A, B, C, D>
16373: 779:    tuple(A a, B b, C c, D d) {
16374: 780:        return new Tuple4<>(a, b, c, d);
16375: 781:    }
16376: 782:
16377: 783:    public static <A, B, C, D, E>
16378: 784:    Tuple5<A, B, C, D, E> tuple(A a, B b, C c, D d, E e) {
16379: 785:        return new Tuple5<>(a, b, c, d, e);
16380: 786:    }
16381: 787:}
16382: 788:```
16383: 789:
16384: 790:我们修改 **TupleTest.java** 来测试 **Tuple.java** :
16385: 791:
16386: 792:```java
16387: 793:// generics/TupleTest2.java
16388: 794:
16389: 795:import onjava.Tuple2;
16390: 796:import onjava.Tuple3;
16391: 797:import onjava.Tuple4;
16392: 798:import onjava.Tuple5;
16393: 799:
16394: 800:import static onjava.Tuple.tuple;
16395: 801:
16396: 802:public class TupleTest2 {
16397: 803:    static Tuple2<String, Integer> f() {
16398: 804:        return tuple("hi", 47);
16399: 805:    }
16400: 806:
16401: 807:    static Tuple2 f2() {
16402: 808:        return tuple("hi", 47);
16403: 809:    }
16404: 810:
16405: 811:    static Tuple3<Amphibian, String, Integer> g() {
16406: 812:        return tuple(new Amphibian(), "hi", 47);
16407: 813:    }
16408: 814:
16409: 815:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
16410: 816:        return tuple(
16411: 817:                new Vehicle(), new Amphibian(), "hi", 47);
16412: 818:    }
16413: 819:
16414: 820:    static Tuple5<Vehicle, Amphibian,
16415: 821:            String, Integer, Double> k() {
16416: 822:        return tuple(new Vehicle(), new Amphibian(),
16417: 823:                "hi", 47, 11.1);
16418: 824:    }
16419: 825:
16420: 826:    public static void main(String[] args) {
16421: 827:        Tuple2<String, Integer> ttsi = f();
16422: 828:        System.out.println(ttsi);
16423: 829:        System.out.println(f2());
16424: 830:        System.out.println(g());
16425: 831:        System.out.println(h());
16426: 832:        System.out.println(k());
16427: 833:    }
16428: 834:}
16429: 835:/* Output:
16430: 836:(hi, 47)
16431: 837:(hi, 47)
16432: 838:(Amphibian@14ae5a5, hi, 47)
16433: 839:(Vehicle@135fbaa4, Amphibian@45ee12a7, hi, 47)
16434: 840:(Vehicle@4b67cf4d, Amphibian@7ea987ac, hi, 47, 11.1)
16435: 841:*/
16436: 842:```
16437: 843:
16438: 844:请注意，`f()` 返回一个参数化的 **Tuple2** 对象，而 `f2()` 返回一个未参数化的 **Tuple2** 对象。编译器不会在这里警告 `f2()` ，因为返回值未以参数化方式使用。从某种意义上说，它被“向上转型”为一个未参数化的 **Tuple2** 。 但是，如果尝试将 `f2()` 的结果放入到参数化的 **Tuple2** 中，则编译器将发出警告。
16439: 845:
16440: 846:<!-- A Set Utility -->
16441: 847:
16442: 848:### 一个 Set 工具
16443: 849:
16444: 850:对于泛型方法的另一个示例，请考虑由 **Set** 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法：
16445: 851:
16446: 852:```java
16447: 853:// onjava/Sets.java
16448: 854:
16449: 855:package onjava;
16450: 856:
16451: 857:import java.util.HashSet;
16452: 858:import java.util.Set;
16453: 859:
16454: 860:public class Sets {
16455: 861:    public static <T> Set<T> union(Set<T> a, Set<T> b) {
16456: 862:        Set<T> result = new HashSet<>(a);
16457: 863:        result.addAll(b);
16458: 864:        return result;
16459: 865:    }
16460: 866:
16461: 867:    public static <T>
16462: 868:    Set<T> intersection(Set<T> a, Set<T> b) {
16463: 869:        Set<T> result = new HashSet<>(a);
16464: 870:        result.retainAll(b);
16465: 871:        return result;
16466: 872:    }
16467: 873:
16468: 874:    // Subtract subset from superset:
16469: 875:    public static <T> Set<T>
16470: 876:    difference(Set<T> superset, Set<T> subset) {
16471: 877:        Set<T> result = new HashSet<>(superset);
16472: 878:        result.removeAll(subset);
16473: 879:        return result;
16474: 880:    }
16475: 881:
16476: 882:    // Reflexive--everything not in the intersection:
16477: 883:    public static <T> Set<T> complement(Set<T> a, Set<T> b) {
16478: 884:        return difference(union(a, b), intersection(a, b));
16479: 885:    }
16480: 886:}
16481: 887:```
16482: 888:
16483: 889:前三个方法通过将第一个参数的引用复制到新的 **HashSet** 对象中来复制第一个参数，因此不会直接修改参数集合。因此，返回值是一个新的 **Set** 对象。
16484: 890:
16485: 891:这四种方法代表数学集合操作： `union()` 返回一个包含两个参数并集的 **Set** ， `intersection()` 返回一个包含两个参数集合交集的 **Set** ， `difference()` 从 **superset** 中减去 **subset** 的元素 ，而 `complement()` 返回所有不在交集中的元素的 **Set**。作为显示这些方法效果的简单示例的一部分，下面是一个包含不同水彩名称的 **enum** ：
16486: 892:
16487: 893:```java
16488: 894:// generics/watercolors/Watercolors.java
16489: 895:
16490: 896:package watercolors;
16491: 897:
16492: 898:public enum Watercolors {
16493: 899:    ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW,
16494: 900:    ORANGE, BRILLIANT_RED, CRIMSON, MAGENTA,
16495: 901:    ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE,
16496: 902:    PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE,
16497: 903:    PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN,
16498: 904:    YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
16499: 905:    BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK
16500: 906:}
16501: 907:```
16502: 908:
16503: 909:为了方便起见（不必全限定所有名称），将其静态导入到以下示例中。本示例使用 **EnumSet** 轻松从 **enum** 中创建 **Set** 。（可以在[第二十二章 枚举](book/22-Enumerations.md)一章中了解有关 **EnumSet** 的更多信息。）在这里，静态方法 `EnumSet.range()` 要求提供所要在结果 **Set** 中创建的元素范围的第一个和最后一个元素：
16504: 910:
16505: 911:```java
16506: 912:// generics/WatercolorSets.java
16507: 913:
16508: 914:import watercolors.*;
16509: 915:
16510: 916:import java.util.EnumSet;
16511: 917:import java.util.Set;
16512: 918:
16513: 919:import static watercolors.Watercolors.*;
16514: 920:import static onjava.Sets.*;
16515: 921:
16516: 922:public class WatercolorSets {
16517: 923:    public static void main(String[] args) {
16518: 924:        Set<Watercolors> set1 =
16519: 925:                EnumSet.range(BRILLIANT_RED, VIRIDIAN_HUE);
16520: 926:        Set<Watercolors> set2 =
16521: 927:                EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER);
16522: 928:        System.out.println("set1: " + set1);
16523: 929:        System.out.println("set2: " + set2);
16524: 930:        System.out.println(
16525: 931:                "union(set1, set2): " + union(set1, set2));
16526: 932:        Set<Watercolors> subset = intersection(set1, set2);
16527: 933:        System.out.println(
16528: 934:                "intersection(set1, set2): " + subset);
16529: 935:        System.out.println("difference(set1, subset): " +
16530: 936:                difference(set1, subset));
16531: 937:        System.out.println("difference(set2, subset): " +
16532: 938:                difference(set2, subset));
16533: 939:        System.out.println("complement(set1, set2): " +
16534: 940:                complement(set1, set2));
16535: 941:    }
16536: 942:}
16537: 943:/* Output:
16538: 944:set1: [BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER,
16539: 945:VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
16540: 946:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE]
16541: 947:set2: [CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
16542: 948:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE,
16543: 949:SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
16544: 950:BURNT_UMBER]
16545: 951:union(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
16546: 952:YELLOW_OCHRE, MAGENTA, SAP_GREEN, CERULEAN_BLUE_HUE,
16547: 953:ULTRAMARINE, VIRIDIAN_HUE, VIOLET, RAW_UMBER,
16548: 954:ROSE_MADDER, PERMANENT_GREEN, BURNT_UMBER,
16549: 955:PHTHALO_BLUE, CRIMSON, COBALT_BLUE_HUE]
16550: 956:intersection(set1, set2): [PERMANENT_GREEN,
16551: 957:CERULEAN_BLUE_HUE, ULTRAMARINE, VIRIDIAN_HUE,
16552: 958:PHTHALO_BLUE, COBALT_BLUE_HUE]
16553: 959:difference(set1, subset): [BRILLIANT_RED, MAGENTA,
16554: 960:VIOLET, CRIMSON, ROSE_MADDER]
16555: 961:difference(set2, subset): [BURNT_SIENNA, YELLOW_OCHRE,
16556: 962:BURNT_UMBER, SAP_GREEN, RAW_UMBER]
16557: 963:complement(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
16558: 964:YELLOW_OCHRE, MAGENTA, SAP_GREEN, VIOLET, RAW_UMBER,
16559: 965:ROSE_MADDER, BURNT_UMBER, CRIMSON]
16560: 966:*/
16561: 967:```
16562: 968:
16563: 969:接下来的例子使用 `Sets.difference()` 方法来展示 **java.util** 包中各种 **Collection** 和 **Map** 类之间的方法差异：
16564: 970:
16565: 971:```java
16566: 972:// onjava/CollectionMethodDifferences.java
16567: 973:// {java onjava.CollectionMethodDifferences}
16568: 974:
16569: 975:package onjava;
16570: 976:
16571: 977:import java.lang.reflect.Method;
16572: 978:import java.util.*;
16573: 979:import java.util.stream.Collectors;
16574: 980:
16575: 981:public class CollectionMethodDifferences {
16576: 982:    static Set<String> methodSet(Class<?> type) {
16577: 983:        return Arrays.stream(type.getMethods())
16578: 984:                .map(Method::getName)
16579: 985:                .collect(Collectors.toCollection(TreeSet::new));
16580: 986:    }
16581: 987:
16582: 988:    static void interfaces(Class<?> type) {
16583: 989:        System.out.print("Interfaces in " +
16584: 990:                type.getSimpleName() + ": ");
16585: 991:        System.out.println(
16586: 992:                Arrays.stream(type.getInterfaces())
16587: 993:                        .map(Class::getSimpleName)
16588: 994:                        .collect(Collectors.toList()));
16589: 995:    }
16590: 996:
16591: 997:    static Set<String> object = methodSet(Object.class);
16592: 998:
16593: 999:    static {
16594: 1000:        object.add("clone");
16595: 1001:    }
16596: 1002:
16597: 1003:    static void
16598: 1004:    difference(Class<?> superset, Class<?> subset) {
16599: 1005:        System.out.print(superset.getSimpleName() +
16600: 1006:                " extends " + subset.getSimpleName() +
16601: 1007:                ", adds: ");
16602: 1008:        Set<String> comp = Sets.difference(
16603: 1009:                methodSet(superset), methodSet(subset));
16604: 1010:        comp.removeAll(object); // Ignore 'Object' methods
16605: 1011:        System.out.println(comp);
16606: 1012:        interfaces(superset);
16607: 1013:    }
16608: 1014:
16609: 1015:    public static void main(String[] args) {
16610: 1016:        System.out.println("Collection: " +
16611: 1017:                methodSet(Collection.class));
16612: 1018:        interfaces(Collection.class);
16613: 1019:        difference(Set.class, Collection.class);
16614: 1020:        difference(HashSet.class, Set.class);
16615: 1021:        difference(LinkedHashSet.class, HashSet.class);
16616: 1022:        difference(TreeSet.class, Set.class);
16617: 1023:        difference(List.class, Collection.class);
16618: 1024:        difference(ArrayList.class, List.class);
16619: 1025:        difference(LinkedList.class, List.class);
16620: 1026:        difference(Queue.class, Collection.class);
16621: 1027:        difference(PriorityQueue.class, Queue.class);
16622: 1028:        System.out.println("Map: " + methodSet(Map.class));
16623: 1029:        difference(HashMap.class, Map.class);
16624: 1030:        difference(LinkedHashMap.class, HashMap.class);
16625: 1031:        difference(SortedMap.class, Map.class);
16626: 1032:        difference(TreeMap.class, Map.class);
16627: 1033:    }
16628: 1034:}
16629: 1035:/* Output:
16630: 1036:Collection: [add, addAll, clear, contains, containsAll,
16631: 1037:equals, forEach, hashCode, isEmpty, iterator,
16632: 1038:parallelStream, remove, removeAll, removeIf, retainAll,
16633: 1039:size, spliterator, stream, toArray]
16634: 1040:Interfaces in Collection: [Iterable]
16635: 1041:Set extends Collection, adds: []
16636: 1042:Interfaces in Set: [Collection]
16637: 1043:HashSet extends Set, adds: []
16638: 1044:Interfaces in HashSet: [Set, Cloneable, Serializable]
16639: 1045:LinkedHashSet extends HashSet, adds: []
16640: 1046:Interfaces in LinkedHashSet: [Set, Cloneable,
16641: 1047:Serializable]
16642: 1048:TreeSet extends Set, adds: [headSet,
16643: 1049:descendingIterator, descendingSet, pollLast, subSet,
16644: 1050:floor, tailSet, ceiling, last, lower, comparator,
16645: 1051:pollFirst, first, higher]
16646: 1052:Interfaces in TreeSet: [NavigableSet, Cloneable,
16647: 1053:Serializable]
16648: 1054:List extends Collection, adds: [replaceAll, get,
16649: 1055:indexOf, subList, set, sort, lastIndexOf, listIterator]
16650: 1056:Interfaces in List: [Collection]
16651: 1057:ArrayList extends List, adds: [trimToSize,
16652: 1058:ensureCapacity]
16653: 1059:Interfaces in ArrayList: [List, RandomAccess,
16654: 1060:Cloneable, Serializable]
16655: 1061:LinkedList extends List, adds: [offerFirst, poll,
16656: 1062:getLast, offer, getFirst, removeFirst, element,
16657: 1063:removeLastOccurrence, peekFirst, peekLast, push,
16658: 1064:pollFirst, removeFirstOccurrence, descendingIterator,
16659: 1065:pollLast, removeLast, pop, addLast, peek, offerLast,
16660: 1066:addFirst]
16661: 1067:Interfaces in LinkedList: [List, Deque, Cloneable,
16662: 1068:Serializable]
16663: 1069:Queue extends Collection, adds: [poll, peek, offer,
16664: 1070:element]
16665: 1071:Interfaces in Queue: [Collection]
16666: 1072:PriorityQueue extends Queue, adds: [comparator]
16667: 1073:Interfaces in PriorityQueue: [Serializable]
16668: 1074:Map: [clear, compute, computeIfAbsent,
16669: 1075:computeIfPresent, containsKey, containsValue, entrySet,
16670: 1076:equals, forEach, get, getOrDefault, hashCode, isEmpty,
16671: 1077:keySet, merge, put, putAll, putIfAbsent, remove,
16672: 1078:replace, replaceAll, size, values]
16673: 1079:HashMap extends Map, adds: []
16674: 1080:Interfaces in HashMap: [Map, Cloneable, Serializable]
16675: 1081:LinkedHashMap extends HashMap, adds: []
16676: 1082:Interfaces in LinkedHashMap: [Map]
16677: 1083:SortedMap extends Map, adds: [lastKey, subMap,
16678: 1084:comparator, firstKey, headMap, tailMap]
16679: 1085:Interfaces in SortedMap: [Map]
16680: 1086:TreeMap extends Map, adds: [descendingKeySet,
16681: 1087:navigableKeySet, higherEntry, higherKey, floorKey,
16682: 1088:subMap, ceilingKey, pollLastEntry, firstKey, lowerKey,
16683: 1089:headMap, tailMap, lowerEntry, ceilingEntry,
16684: 1090:descendingMap, pollFirstEntry, lastKey, firstEntry,
16685: 1091:floorEntry, comparator, lastEntry]
16686: 1092:Interfaces in TreeMap: [NavigableMap, Cloneable,
16687: 1093:Serializable]
16688: 1094:*/
16689: 1095:```
16690: 1096:
16691: 1097:在第十二章 [集合的本章小结](book/12-Collections.md#本章小结) 部分将会用到这里的输出结果。
16692: 1098:
16693: 1099:<!-- Building Complex Models -->
16694: 1100:
16695: 1101:## 构建复杂模型
16696: 1102:
16697: 1103:泛型的一个重要好处是能够简单安全地创建复杂模型。例如，我们可以轻松地创建一个元组列表：
16698: 1104:
16699: 1105:```java
16700: 1106:// generics/TupleList.java
16701: 1107:// Combining generic types to make complex generic types
16702: 1108:
16703: 1109:import onjava.Tuple4;
16704: 1110:
16705: 1111:import java.util.ArrayList;
16706: 1112:
16707: 1113:public class TupleList<A, B, C, D>
16708: 1114:        extends ArrayList<Tuple4<A, B, C, D>> {
16709: 1115:    public static void main(String[] args) {
16710: 1116:        TupleList<Vehicle, Amphibian, String, Integer> tl =
16711: 1117:                new TupleList<>();
16712: 1118:        tl.add(TupleTest2.h());
16713: 1119:        tl.add(TupleTest2.h());
16714: 1120:        tl.forEach(System.out::println);
16715: 1121:    }
16716: 1122:}
16717: 1123:/* Output:
16718: 1124:(Vehicle@7cca494b, Amphibian@7ba4f24f, hi, 47)
16719: 1125:(Vehicle@3b9a45b3, Amphibian@7699a589, hi, 47)
16720: 1126:*/
16721: 1127:```
16722: 1128:
16723: 1129:这将产生一个功能强大的数据结构，而无需太多代码。
16724: 1130:
16725: 1131:下面是第二个例子。每个类都是组成块，总体包含很多个块。在这里，该模型是一个具有过道，货架和产品的零售商店：
16726: 1132:
16727: 1133:```java
16728: 1134:// generics/Store.java
16729: 1135:// Building a complex model using generic collections
16730: 1136:
16731: 1137:import onjava.Suppliers;
16732: 1138:
16733: 1139:import java.util.ArrayList;
16734: 1140:import java.util.Random;
16735: 1141:import java.util.function.Supplier;
16736: 1142:
16737: 1143:class Product {
16738: 1144:    private final int id;
16739: 1145:    private String description;
16740: 1146:    private double price;
16741: 1147:
16742: 1148:    Product(int idNumber, String descr, double price) {
16743: 1149:        id = idNumber;
16744: 1150:        description = descr;
16745: 1151:        this.price = price;
16746: 1152:        System.out.println(toString());
16747: 1153:    }
16748: 1154:
16749: 1155:    @Override
16750: 1156:    public String toString() {
16751: 1157:        return id + ": " + description +
16752: 1158:                ", price: $" + price;
16753: 1159:    }
16754: 1160:
16755: 1161:    public void priceChange(double change) {
16756: 1162:        price += change;
16757: 1163:    }
16758: 1164:
16759: 1165:    public static Supplier<Product> generator =
16760: 1166:            new Supplier<Product>() {
16761: 1167:                private Random rand = new Random(47);
16762: 1168:
16763: 1169:                @Override
16764: 1170:                public Product get() {
16765: 1171:                    return new Product(rand.nextInt(1000), "Test",
16766: 1172:                            Math.round(
16767: 1173:                                    rand.nextDouble() * 1000.0) + 0.99);
16768: 1174:                }
16769: 1175:            };
16770: 1176:}
16771: 1177:
16772: 1178:class Shelf extends ArrayList<Product> {
16773: 1179:    Shelf(int nProducts) {
16774: 1180:        Suppliers.fill(this, Product.generator, nProducts);
16775: 1181:    }
16776: 1182:}
16777: 1183:
16778: 1184:class Aisle extends ArrayList<Shelf> {
16779: 1185:    Aisle(int nShelves, int nProducts) {
16780: 1186:        for (int i = 0; i < nShelves; i++)
16781: 1187:            add(new Shelf(nProducts));
16782: 1188:    }
16783: 1189:}
16784: 1190:
16785: 1191:class CheckoutStand {
16786: 1192:}
16787: 1193:
16788: 1194:class Office {
16789: 1195:}
16790: 1196:
16791: 1197:public class Store extends ArrayList<Aisle> {
16792: 1198:    private ArrayList<CheckoutStand> checkouts =
16793: 1199:            new ArrayList<>();
16794: 1200:    private Office office = new Office();
16795: 1201:
16796: 1202:    public Store(
16797: 1203:            int nAisles, int nShelves, int nProducts) {
16798: 1204:        for (int i = 0; i < nAisles; i++)
16799: 1205:            add(new Aisle(nShelves, nProducts));
16800: 1206:    }
16801: 1207:
16802: 1208:    @Override
16803: 1209:    public String toString() {
16804: 1210:        StringBuilder result = new StringBuilder();
16805: 1211:        for (Aisle a : this)
16806: 1212:            for (Shelf s : a)
16807: 1213:                for (Product p : s) {
16808: 1214:                    result.append(p);
16809: 1215:                    result.append("\n");
16810: 1216:                }
16811: 1217:        return result.toString();
16812: 1218:    }
16813: 1219:
16814: 1220:    public static void main(String[] args) {
16815: 1221:        System.out.println(new Store(5, 4, 3));
16816: 1222:    }
16817: 1223:}
16818: 1224:/* Output: (First 8 Lines)
16819: 1225:258: Test, price: $400.99
16820: 1226:861: Test, price: $160.99
16821: 1227:868: Test, price: $417.99
16822: 1228:207: Test, price: $268.99
16823: 1229:551: Test, price: $114.99
16824: 1230:278: Test, price: $804.99
16825: 1231:520: Test, price: $554.99
16826: 1232:140: Test, price: $530.99
16827: 1233:                  ...
16828: 1234:*/
16829: 1235:```
16830: 1236:
16831: 1237:`Store.toString()` 显示了结果：尽管有复杂的层次结构，但多层的集合仍然是类型安全的和可管理的。令人印象深刻的是，组装这样的模型并不需要耗费过多精力。
16832: 1238:
16833: 1239:**Shelf** 使用 `Suppliers.fill()` 这个实用程序，该实用程序接受 **Collection** （第一个参数），并使用 **Supplier** （第二个参数），以元素的数量为 **n** （第三个参数）来填充它。 **Suppliers** 类将会在本章末尾定义，其中的方法都是在执行某种填充操作，并在本章的其他示例中使用。
16834: 1240:
16835: 1241:<!-- The Mystery of Erasure -->
16836: 1242:
16837: 1243:## 泛型擦除
16838: 1244:
16839: 1245:当你开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的。例如，尽管可以说  `ArrayList.class`，但不能说成 `ArrayList<Integer>.class`。考虑下面的情况：
16840: 1246:
16841: 1247:```java
16842: 1248:// generics/ErasedTypeEquivalence.java
16843: 1249:
16844: 1250:import java.util.*;
16845: 1251:
16846: 1252:public class ErasedTypeEquivalence {
16847: 1253:    
16848: 1254:    public static void main(String[] args) {
16849: 1255:        Class c1 = new ArrayList<String>().getClass();
16850: 1256:        Class c2 = new ArrayList<Integer>().getClass();
16851: 1257:        System.out.println(c1 == c2);
16852: 1258:    }
16853: 1259:    
16854: 1260:}
16855: 1261:/* Output:
16856: 1262:true
16857: 1263:*/
16858: 1264:```
16859: 1265:
16860: 1266:`ArrayList<String>` 和 `ArrayList<Integer>` 应该是不同的类型。不同的类型会有不同的行为。例如，如果尝试向 `ArrayList<String>` 中放入一个 `Integer`，所得到的行为（失败）和向 `ArrayList<Integer>` 中放入一个 `Integer` 所得到的行为（成功）完全不同。然而上面的程序认为它们是相同的类型。
16861: 1267:
16862: 1268:下面的例子是对该谜题的补充：
16863: 1269:
16864: 1270:```java
16865: 1271:// generics/LostInformation.java
16866: 1272:
16867: 1273:import java.util.*;
16868: 1274:
16869: 1275:class Frob {}
16870: 1276:class Fnorkle {}
16871: 1277:class Quark<Q> {}
16872: 1278:
16873: 1279:class Particle<POSITION, MOMENTUM> {}
16874: 1280:
16875: 1281:public class LostInformation {
16876: 1282:
16877: 1283:    public static void main(String[] args) {
16878: 1284:        List<Frob> list = new ArrayList<>();
16879: 1285:        Map<Frob, Fnorkle> map = new HashMap<>();
16880: 1286:        Quark<Fnorkle> quark = new Quark<>();
16881: 1287:        Particle<Long, Double> p = new Particle<>();
16882: 1288:        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));
16883: 1289:        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));
16884: 1290:        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));
16885: 1291:        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));
16886: 1292:    }
16887: 1293:
16888: 1294:}
16889: 1295:/* Output:
16890: 1296:[E]
16891: 1297:[K,V]
16892: 1298:[Q]
16893: 1299:[POSITION,MOMENTUM]
16894: 1300:*/
16895: 1301:```
16896: 1302:
16897: 1303:根据 JDK 文档，**Class.getTypeParameters()** “返回一个 **TypeVariable** 对象数组，表示泛型声明中声明的类型参数...” 这暗示你可以发现这些参数类型。但是正如上例中输出所示，你只能看到用作参数占位符的标识符，这并非有用的信息。
16898: 1304:
16899: 1305:残酷的现实是：
16900: 1306:
16901: 1307:在泛型代码内部，无法获取任何有关泛型参数类型的信息。
16902: 1308:
16903: 1309:因此，你可以知道如类型参数标识符和泛型边界这些信息，但无法得知实际的类型参数从而用来创建特定的实例。如果你曾是 C++ 程序员，那么这个事实会让你很沮丧，在使用 Java 泛型工作时，它是必须处理的最基本的问题。
16904: 1310:
16905: 1311:Java 泛型是使用擦除实现的。这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此，`List<String>` 和 `List<Integer>` 在运行时实际上是相同的类型。它们都被擦除成原生类型 `List`。
16906: 1312:
16907: 1313:理解擦除并知道如何处理它，是你在学习 Java 泛型时面临的最大障碍之一。这也是本节将要探讨的内容。
16908: 1314:
16909: 1315:### C++ 的方式
16910: 1316:
16911: 1317:下面是使用模版的 C++ 示例。你会看到类型参数的语法十分相似，因为 Java 是受 C++ 启发的：
16912: 1318:
16913: 1319:```c++
16914: 1320:// generics/Templates.cpp
16915: 1321:
16916: 1322:#include <iostream>
16917: 1323:using namespace std;
16918: 1324:
16919: 1325:template<class T> class Manipulator {
16920: 1326:    T obj;
16921: 1327:public:
16922: 1328:    Manipulator(T x) { obj = x; }
16923: 1329:    void manipulate() { obj.f(); }
16924: 1330:};
16925: 1331:
16926: 1332:class HasF {
16927: 1333:public:
16928: 1334:    void f() { cout << "HasF::f()" << endl; }
16929: 1335:};
16930: 1336:
16931: 1337:int main() {
16932: 1338:    HasF hf;
16933: 1339:    Manipulator<HasF> manipulator(hf);
16934: 1340:    manipulator.manipulate();
16935: 1341:}
16936: 1342:/* Output:
16937: 1343:HasF::f()
16938: 1344:*/
16939: 1345:```
16940: 1346:
16941: 1347:**Manipulator** 类存储了一个 **T** 类型的对象。`manipulate()` 方法会调用 **obj** 上的 `f()` 方法。它是如何知道类型参数 **T** 中存在 `f()` 方法的呢？C++ 编译器会在你实例化模版时进行检查，所以在 `Manipulator<HasF>` 实例化的那一刻，它看到 **HasF** 中含有一个方法 `f()`。如果情况并非如此，你就会得到一个编译期错误，保持类型安全。
16942: 1348:
16943: 1349:用 C++ 编写这种代码很简单，因为当模版被实例化时，模版代码就知道模版参数的类型。Java 泛型就不同了。下面是 **HasF** 的 Java 版本：
16944: 1350:
16945: 1351:```java
16946: 1352:// generics/HasF.java
16947: 1353:
16948: 1354:public class HasF {
16949: 1355:    public void f() {
16950: 1356:        System.out.println("HasF.f()");
16951: 1357:    }
16952: 1358:}
16953: 1359:```
16954: 1360:
16955: 1361:如果我们将示例的其余代码用 Java 实现，就不会通过编译：
16956: 1362:
16957: 1363:```java
16958: 1364:// generics/Manipulation.java
16959: 1365:// {WillNotCompile}
16960: 1366:
16961: 1367:class Manipulator<T> {
16962: 1368:    private T obj;
16963: 1369:    
16964: 1370:    Manipulator(T x) {
16965: 1371:        obj = x;
16966: 1372:    }
16967: 1373:    
16968: 1374:    // Error: cannot find symbol: method f():
16969: 1375:    public void manipulate() {
16970: 1376:        obj.f();
16971: 1377:    }
16972: 1378:}
16973: 1379:
16974: 1380:public class Manipulation {
16975: 1381:	public static void main(String[] args) {
16976: 1382:        HasF hf = new HasF();
16977: 1383:        Manipulator<HasF> manipulator = new Manipulator<>(hf);
16978: 1384:        manipulator.manipulate();
16979: 1385:    }
16980: 1386:}
16981: 1387:```
16982: 1388:
16983: 1389:因为擦除，Java 编译器无法将 `manipulate()` 方法必须能调用 **obj** 的 `f()` 方法这一需求映射到 HasF 具有 `f()` 方法这个事实上。为了调用 `f()`，我们必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。这里重用了 **extends** 关键字。由于有了边界，下面的代码就能通过编译：
16984: 1390:
16985: 1391:```java
16986: 1392:public class Manipulator2<T extends HasF> {
16987: 1393:    private T obj;
16988: 1394:
16989: 1395:    Manipulator2(T x) {
16990: 1396:        obj = x;
16991: 1397:    }
16992: 1398:
16993: 1399:    public void manipulate() {
16994: 1400:        obj.f();
16995: 1401:    }
16996: 1402:}
16997: 1403:```
16998: 1404:
16999: 1405:边界 `<T extends HasF>` 声明 T 必须是 HasF 类型或其子类。如果情况确实如此，就可以安全地在 **obj** 上调用 `f()` 方法。
17000: 1406:
17001: 1407:我们说泛型类型参数会擦除到它的第一个边界（可能有多个边界，稍后你将看到）。我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的示例，**T** 擦除到了 **HasF**，就像在类的声明中用 **HasF** 替换了 **T** 一样。
17002: 1408:
17003: 1409:你可能正确地观察到了泛型在 **Manipulator2.java** 中没有贡献任何事。你可以很轻松地自己去执行擦除，生成没有泛型的类：
17004: 1410:
17005: 1411:```java
17006: 1412:// generics/Manipulator3.java
17007: 1413:
17008: 1414:class Manipulator3 {
17009: 1415:    private HasF obj;
17010: 1416:    
17011: 1417:    Manipulator3(HasF x) {
17012: 1418:        obj = x;
17013: 1419:    }
17014: 1420:    
17015: 1421:    public void manipulate() {
17016: 1422:        obj.f();
17017: 1423:    }
17018: 1424:}
17019: 1425:```
17020: 1426:
17021: 1427:这提出了很重要的一点：泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用。因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换更加复杂。但是，不能因此认为使用 `<T extends HasF>` 形式就是有缺陷的。例如，如果某个类有一个返回 **T** 的方法，那么泛型就有所帮助，因为它们之后将返回确切的类型：
17022: 1428:
17023: 1429:```java
17024: 1430:// generics/ReturnGenericType.java
17025: 1431:
17026: 1432:public class ReturnGenericType<T extends HasF> {
17027: 1433:    private T obj;
17028: 1434:    
17029: 1435:    ReturnGenericType(T x) {
17030: 1436:        obj = x;
17031: 1437:    }
17032: 1438:    
17033: 1439:    public T get() {
17034: 1440:        return obj;
17035: 1441:    }
17036: 1442:}
17037: 1443:```
17038: 1444:
17039: 1445:你必须查看所有的代码，从而确定代码是否复杂到必须使用泛型的程度。
17040: 1446:
17041: 1447:我们将在本章稍后看到有关边界的更多细节。
17042: 1448:
17043: 1449:### 迁移兼容性
17044: 1450:
17045: 1451:为了减少潜在的关于擦除的困惑，你必须清楚地认识到这不是一个语言特性。它是 Java 实现泛型的一种妥协，因为泛型不是 Java 语言出现时就有的，所以就有了这种妥协。它会使你痛苦，因此你需要尽早习惯它并了解为什么它会这样。
17046: 1452:
17047: 1453:如果 Java 1.0 就含有泛型的话，那么这个特性就不会使用擦除来实现——它会使用具体化，保持参数类型为第一类实体，因此你就能在类型参数上执行基于类型的语言操作和反射操作。本章稍后你会看到，擦除减少了泛型的泛化性。泛型在 Java 中仍然是有用的，只是不如它们本来设想的那么有用，而原因就是擦除。
17048: 1454:
17049: 1455:在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文使用泛型类型。泛型类型只有在静态类型检测期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如， `List<T>` 这样的类型注解会被擦除为 **List**，普通的类型变量在未指定边界的情况下会被擦除为 **Object**。
17050: 1456:
17051: 1457:擦除的核心动机是你可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称为“迁移兼容性”。在理想情况下，所有事物将在指定的某天被泛化。在现实中，即使程序员只编写泛型代码，他们也必须处理 Java 5 之前编写的非泛型类库。这些类库的作者可能从没想过要泛化他们的代码，或许他们可能刚刚开始接触泛型。
17052: 1458:
17053: 1459:因此 Java 泛型不仅必须支持向后兼容性——现有的代码和类文件仍然合法，继续保持之前的含义——而且还必须支持迁移兼容性，使得类库能按照它们自己的步调变为泛型，当某个类库变为泛型时，不会破坏依赖于它的代码和应用。在确定了这个目标后，Java 设计者们和从事此问题相关工作的各个团队决策认为擦除是唯一可行的解决方案。擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。
17054: 1460:
17055: 1461:例如，假设一个应用使用了两个类库 **X** 和 **Y**，**Y** 使用了类库 **Z**。随着 Java 5 的出现，这个应用和这些类库的创建者最终可能希望迁移到泛型上。但是当进行迁移时，它们有着不同的动机和限制。为了实现迁移兼容性，每个类库与应用必须与其他所有的部分是否使用泛型无关。因此，它们不能探测其他类库是否使用了泛型。因此，某个特定的类库使用了泛型这样的证据必须被”擦除“。
17056: 1462:
17057: 1463:如果没有某种类型的迁移途径，所有已经构建了很长时间的类库就需要与希望迁移到 Java 泛型上的开发者们说再见了。类库毫无争议是编程语言的一部分，对生产效率有着极大的影响，所以这种代码无法接受。擦除是否是最佳的或唯一的迁移途径，还待时间来证明。
17058: 1464:
17059: 1465:### 擦除的问题
17060: 1466:
17061: 1467:因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。擦除允许你继续使用现有的非泛型客户端代码，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会骤然破坏所有现有的代码。
17062: 1468:
17063: 1469:擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作中，例如转型、**instanceof** 操作和 **new** 表达式。因为所有关于参数的类型信息都丢失了，当你在编写泛型代码时，必须时刻提醒自己，你只是看起来拥有有关参数的类型信息而已。
17064: 1470:
17065: 1471:考虑如下的代码段：
17066: 1472:
17067: 1473:```java
17068: 1474:class Foo<T> {
17069: 1475:    T var;
17070: 1476:}
17071: 1477:```
17072: 1478:
17073: 1479:看上去当你创建一个 **Foo** 实例时：
17074: 1480:
17075: 1481:```java
17076: 1482:Foo<Cat> f = new Foo<>();
17077: 1483:```
17078: 1484:
17079: 1485:**class** **Foo** 中的代码应该知道现在工作于 **Cat** 之上。泛型语法也在强烈暗示整个类中所有 T 出现的地方都被替换，就像在 C++ 中一样。但是事实并非如此，当你在编写这个类的代码时，必须提醒自己：“不，这只是一个 **Object**“。
17080: 1486:
17081: 1487:另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管你可能希望这样：
17082: 1488:
17083: 1489:```java
17084: 1490:// generics/ErasureAndInheritance.java
17085: 1491:
17086: 1492:class GenericBase<T> {
17087: 1493:    private T element;
17088: 1494:    
17089: 1495:    public void set(T arg) {
17090: 1496:        element = arg;
17091: 1497:    }
17092: 1498:    
17093: 1499:    public T get() {
17094: 1500:        return element;
17095: 1501:    }
17096: 1502:}
17097: 1503:
17098: 1504:class Derived1<T> extends GenericBase<T> {}
17099: 1505:
17100: 1506:class Derived2 extends GenericBase {} // No warning
17101: 1507:
17102: 1508:// class Derived3 extends GenericBase<?> {}
17103: 1509:// Strange error:
17104: 1510:// unexpected type
17105: 1511:// required: class or interface without bounds
17106: 1512:public class ErasureAndInteritance {
17107: 1513:    @SuppressWarnings("unchecked")
17108: 1514:    public static void main(String[] args) {
17109: 1515:        Derived2 d2 = new Derived2();
17110: 1516:        Object obj = d2.get();
17111: 1517:        d2.set(obj); // Warning here!
17112: 1518:    }
17113: 1519:}
17114: 1520:```
17115: 1521:
17116: 1522:**Derived2** 继承自 **GenericBase**，但是没有任何类型参数，编译器没有发出任何警告。直到调用 `set()` 方法时才出现警告。
17117: 1523:
17118: 1524:为了关闭警告，Java 提供了一个注解，我们可以在列表中看到它：
17119: 1525:
17120: 1526:```java
17121: 1527:@SuppressWarnings("unchecked")
17122: 1528:```
17123: 1529:
17124: 1530:这个注解放置在产生警告的方法上，而不是整个类上。当你要关闭警告时，最好尽可能地“聚焦”，这样就不会因为过于宽泛地关闭警告，而导致意外地遮蔽掉真正的问题。
17125: 1531:
17126: 1532:可以推断，**Derived3** 产生的错误意味着编译器期望得到一个原生基类。
17127: 1533:
17128: 1534:当你希望将类型参数不仅仅当作 Object 处理时，就需要付出额外努力来管理边界，并且与在 C++、Ada 和 Eiffel 这样的语言中获得参数化类型相比，你需要付出多得多的努力来获得少得多的回报。这并不是说，对于大多数的编程问题而言，这些语言通常都会比 Java 更得心应手，只是说它们的参数化类型机制相比 Java 更灵活、更强大。
17129: 1535:
17130: 1536:### 边界处的动作
17131: 1537:
17132: 1538:因为擦除，我发现了泛型最令人困惑的方面是可以表示没有任何意义的事物。例如：
17133: 1539:
17134: 1540:```java
17135: 1541:// generics/ArrayMaker.java
17136: 1542:
17137: 1543:import java.lang.reflect.*;
17138: 1544:import java.util.*;
17139: 1545:
17140: 1546:public class ArrayMaker<T> {
17141: 1547:    private Class<T> kind;
17142: 1548:
17143: 1549:    public ArrayMaker(Class<T> kind) {
17144: 1550:        this.kind = kind;
17145: 1551:    }
17146: 1552:
17147: 1553:    @SuppressWarnings("unchecked")
17148: 1554:    T[] create(int size) {
17149: 1555:        return (T[]) Array.newInstance(kind, size);
17150: 1556:    }
17151: 1557:
17152: 1558:    public static void main(String[] args) {
17153: 1559:        ArrayMaker<String> stringMaker = new ArrayMaker<>(String.class);
17154: 1560:        String[] stringArray = stringMaker.create(9);
17155: 1561:        System.out.println(Arrays.toString(stringArray));
17156: 1562:    }
17157: 1563:}
17158: 1564:/* Output
17159: 1565:[null,null,null,null,null,null,null,null,null]
17160: 1566:*/
17161: 1567:```
17162: 1568:
17163: 1569:即使 **kind** 被存储为 `Class<T>`，擦除也意味着它实际被存储为没有任何参数的 **Class**。因此，当你在使用它时，例如创建数组，`Array.newInstance()` 实际上并未拥有 **kind** 所蕴含的类型信息。所以它不会产生具体的结果，因而必须转型，这会产生一条令你无法满意的警告。
17164: 1570:
17165: 1571:注意，对于在泛型中创建数组，使用 `Array.newInstance()` 是推荐的方式。
17166: 1572:
17167: 1573:如果我们创建一个集合而不是数组，情况就不同了：
17168: 1574:
17169: 1575:```java
17170: 1576:// generics/ListMaker.java
17171: 1577:
17172: 1578:import java.util.*;
17173: 1579:
17174: 1580:public class ListMaker<T> {
17175: 1581:    List<T> create() {
17176: 1582:        return new ArrayList<>();
17177: 1583:    }
17178: 1584:    
17179: 1585:    public static void main(String[] args) {
17180: 1586:        ListMaker<String> stringMaker = new ListMaker<>();
17181: 1587:        List<String> stringList = stringMaker.create();
17182: 1588:    }
17183: 1589:}
17184: 1590:```
17185: 1591:
17186: 1592:编译器不会给出任何警告，尽管我们知道（从擦除中）在 `create()` 内部的 `new ArrayList<>()` 中的 `<T>` 被移除了——在运行时，类内部没有任何 `<T>`，因此这看起来毫无意义。但是如果你遵从这种思路，并将这个表达式改为 `new ArrayList()`，编译器就会发出警告。
17187: 1593:
17188: 1594:本例中这么做真的毫无意义吗？如果在创建 **List** 的同时向其中放入一些对象呢，像这样：
17189: 1595:
17190: 1596:```java
17191: 1597:// generics/FilledList.java
17192: 1598:
17193: 1599:import java.util.*;
17194: 1600:import java.util.function.*;
17195: 1601:import onjava.*;
17196: 1602:
17197: 1603:public class FilledList<T> extends ArrayList<T> {
17198: 1604:    FilledList(Supplier<T> gen, int size) {
17199: 1605:        Suppliers.fill(this, gen, size);
17200: 1606:    }
17201: 1607:    
17202: 1608:    public FilledList(T t, int size) {
17203: 1609:        for (int i = 0; i < size; i++) {
17204: 1610:            this.add(t);
17205: 1611:        }
17206: 1612:    }
17207: 1613:    
17208: 1614:    public static void main(String[] args) {
17209: 1615:        List<String> list = new FilledList<>("Hello", 4);
17210: 1616:        System.out.println(list);
17211: 1617:        // Supplier version:
17212: 1618:        List<Integer> ilist = new FilledList<>(() -> 47, 4);
17213: 1619:        System.out.println(ilist);
17214: 1620:    }
17215: 1621:}
17216: 1622:/* Output:
17217: 1623:[Hello,Hello,Hello,Hello]
17218: 1624:[47,47,47,47]
17219: 1625:*/
17220: 1626:```
17221: 1627:
17222: 1628:即使编译器无法得知 `add()` 中的 **T** 的任何信息，但它仍可以在编译期确保你放入 **FilledList** 中的对象是 **T** 类型。因此，即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。
17223: 1629:
17224: 1630:因为擦除移除了方法体中的类型信息，所以在运行时的问题就是*边界*：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。
17225: 1631:
17226: 1632:考虑如下这段非泛型示例：
17227: 1633:
17228: 1634:```java
17229: 1635:// generics/SimpleHolder.java
17230: 1636:
17231: 1637:public class SimpleHolder {
17232: 1638:    private Object obj;
17233: 1639:    
17234: 1640:    public void set(Object obj) {
17235: 1641:        this.obj = obj;
17236: 1642:    }
17237: 1643:    
17238: 1644:    public Object get() {
17239: 1645:        return obj;
17240: 1646:    }
17241: 1647:    
17242: 1648:    public static void main(String[] args) {
17243: 1649:        SimpleHolder holder = new SimpleHolder();
17244: 1650:        holder.set("Item");
17245: 1651:        String s = (String) holder.get();
17246: 1652:    }
17247: 1653:}
17248: 1654:```
17249: 1655:
17250: 1656:如果用 **javap -c SimpleHolder** 反编译这个类，会得到如下内容（经过编辑）：
17251: 1657:
17252: 1658:```java
17253: 1659:public void set(java.lang.Object);
17254: 1660:   0: aload_0
17255: 1661:   1: aload_1
17256: 1662:   2: putfield #2; // Field obj:Object;
17257: 1663:   5: return
17258: 1664:    
17259: 1665:public java.lang.Object get();
17260: 1666:   0: aload_0
17261: 1667:   1: getfield #2; // Field obj:Object;
17262: 1668:   4: areturn
17263: 1669:    
17264: 1670:public static void main(java.lang.String[]);
17265: 1671:   0: new #3; // class SimpleHolder
17266: 1672:   3: dup
17267: 1673:   4: invokespecial #4; // Method "<init>":()V
17268: 1674:   7: astore_1
17269: 1675:   8: aload_1
17270: 1676:   9: ldc #5; // String Item
17271: 1677:   11: invokevirtual #6; // Method set:(Object;)V
17272: 1678:   14: aload_1
17273: 1679:   15: invokevirtual #7; // Method get:()Object;
17274: 1680:   18: checkcast #8; // class java/lang/String
17275: 1681:   21: astore_2
17276: 1682:   22: return
17277: 1683:```
17278: 1684:
17279: 1685:`set()` 和 `get()` 方法存储和产生值，转型在调用 `get()` 时接受检查。
17280: 1686:
17281: 1687:现在将泛型融入上例代码中：
17282: 1688:
17283: 1689:```java
17284: 1690:// generics/GenericHolder2.java
17285: 1691:
17286: 1692:public class GenericHolder2<T> {
17287: 1693:    private T obj;
17288: 1694:
17289: 1695:    public void set(T obj) {
17290: 1696:        this.obj = obj;
17291: 1697:    }
17292: 1698:
17293: 1699:    public T get() {
17294: 1700:        return obj;
17295: 1701:    }
17296: 1702:
17297: 1703:    public static void main(String[] args) {
17298: 1704:        GenericHolder2<String> holder =  new GenericHolder2<>();
17299: 1705:        holder.set("Item");
17300: 1706:        String s = holder.get();
17301: 1707:    }
17302: 1708:}
17303: 1709:```
17304: 1710:
17305: 1711:从 `get()` 返回后的转型消失了，但是我们还知道传递给 `set()` 的值在编译期会被检查。下面是相关的字节码：
17306: 1712:
17307: 1713:```java
17308: 1714:public void set(java.lang.Object);
17309: 1715:   0: aload_0
17310: 1716:   1: aload_1
17311: 1717:   2: putfield #2; // Field obj:Object;
17312: 1718:   5: return
17313: 1719:       
17314: 1720:public java.lang.Object get();
17315: 1721:   0: aload_0
17316: 1722:   1: getfield #2; // Field obj:Object;
17317: 1723:   4: areturn
17318: 1724:       
17319: 1725:public static void main(java.lang.String[]);
17320: 1726:   0: new #3; // class GenericHolder2
17321: 1727:   3: dup
17322: 1728:   4: invokespecial #4; // Method "<init>":()V
17323: 1729:   7: astore_1
17324: 1730:   8: aload_1
17325: 1731:   9: ldc #5; // String Item
17326: 1732:   11: invokevirtual #6; // Method set:(Object;)V
17327: 1733:   14: aload_1
17328: 1734:   15: invokevirtual #7; // Method get:()Object;
17329: 1735:   18: checkcast #8; // class java/lang/String
17330: 1736:   21: astore_2
17331: 1737:   22: return
17332: 1738:```
17333: 1739:
17334: 1740:所产生的字节码是相同的。对进入 `set()` 的类型进行检查是不需要的，因为这将由编译器执行。而对 `get()` 返回的值进行转型仍然是需要的，只不过不需要你来操作，它由编译器自动插入，这样你就不用编写（阅读）杂乱的代码。
17335: 1741:
17336: 1742:`get()` 和 `set()` 产生了相同的字节码，这就告诉我们泛型的所有动作都发生在边界处——对入参的编译器检查和对返回值的转型。这有助于澄清对擦除的困惑，记住：“边界就是动作发生的地方”。
17337: 1743:
17338: 1744:<!-- Compensating for Erasure -->
17339: 1745:
17340: 1746:## 补偿擦除
17341: 1747:
17342: 1748:因为擦除，我们将失去执行泛型代码中某些操作的能力。无法在运行时知道确切类型：
17343: 1749:
17344: 1750:```java
17345: 1751:// generics/Erased.java
17346: 1752:// {WillNotCompile}
17347: 1753:
17348: 1754:public class Erased<T> {
17349: 1755:    private final int SIZE = 100;
17350: 1756:
17351: 1757:    public void f(Object arg) {
17352: 1758:        // error: illegal generic type for instanceof
17353: 1759:        if (arg instanceof T) {
17354: 1760:        }
17355: 1761:        // error: unexpected type
17356: 1762:        T var = new T();
17357: 1763:        // error: generic array creation
17358: 1764:        T[] array = new T[SIZE];
17359: 1765:        // warning: [unchecked] unchecked cast
17360: 1766:        T[] array = (T[]) new Object[SIZE];
17361: 1767:
17362: 1768:    }
17363: 1769:}
17364: 1770:```
17365: 1771:
17366: 1772:有时，我们可以对这些问题进行编程，但是有时必须通过引入类型标签来补偿擦除。这意味着为所需的类型显式传递一个 **Class** 对象，以在类型表达式中使用它。
17367: 1773:
17368: 1774:例如，由于擦除了类型信息，因此在上一个程序中尝试使用 **instanceof** 将会失败。类型标签可以使用动态 `isInstance()` ：
17369: 1775:
17370: 1776:```java
17371: 1777:// generics/ClassTypeCapture.java
17372: 1778:
17373: 1779:class Building {
17374: 1780:}
17375: 1781:
17376: 1782:class House extends Building {
17377: 1783:}
17378: 1784:
17379: 1785:public class ClassTypeCapture<T> {
17380: 1786:    Class<T> kind;
17381: 1787:
17382: 1788:    public ClassTypeCapture(Class<T> kind) {
17383: 1789:        this.kind = kind;
17384: 1790:    }
17385: 1791:
17386: 1792:    public boolean f(Object arg) {
17387: 1793:        return kind.isInstance(arg);
17388: 1794:    }
17389: 1795:
17390: 1796:    public static void main(String[] args) {
17391: 1797:        ClassTypeCapture<Building> ctt1 =
17392: 1798:                new ClassTypeCapture<>(Building.class);
17393: 1799:        System.out.println(ctt1.f(new Building()));
17394: 1800:        System.out.println(ctt1.f(new House()));
17395: 1801:        ClassTypeCapture<House> ctt2 =
17396: 1802:                new ClassTypeCapture<>(House.class);
17397: 1803:        System.out.println(ctt2.f(new Building()));
17398: 1804:        System.out.println(ctt2.f(new House()));
17399: 1805:    }
17400: 1806:}
17401: 1807:/* Output:
17402: 1808:true
17403: 1809:true
17404: 1810:false
17405: 1811:true
17406: 1812:*/
17407: 1813:```
17408: 1814:
17409: 1815:编译器来保证类型标签与泛型参数相匹配。
17410: 1816:
17411: 1817:<!-- Creating Instances of Types -->
17412: 1818:
17413: 1819:### 创建类型的实例
17414: 1820:
17415: 1821:试图在 **Erased.java** 中 `new T()` 是行不通的，部分原因是由于擦除，部分原因是编译器无法验证 **T** 是否具有默认（无参）构造函数。但是在 C++ 中，此操作自然，直接且安全（在编译时检查）：
17416: 1822:
17417: 1823:```C++
17418: 1824:// generics/InstantiateGenericType.cpp
17419: 1825:// C++, not Java!
17420: 1826:
17421: 1827:template<class T> class Foo {
17422: 1828:  T x; // Create a field of type T
17423: 1829:  T* y; // Pointer to T
17424: 1830:public:
17425: 1831:  // Initialize the pointer:
17426: 1832:  Foo() { y = new T(); }
17427: 1833:};
17428: 1834:
17429: 1835:class Bar {};
17430: 1836:
17431: 1837:int main() {
17432: 1838:  Foo<Bar> fb;
17433: 1839:  Foo<int> fi; // ... and it works with primitives
17434: 1840:}
17435: 1841:```
17436: 1842:
17437: 1843:Java 中的解决方案是传入一个工厂对象，并使用该对象创建新实例。方便的工厂对象只是 **Class** 对象，因此，如果使用类型标记，则可以使用 `newInstance()` 创建该类型的新对象：
17438: 1844:
17439: 1845:```java
17440: 1846:// generics/InstantiateGenericType.java
17441: 1847:
17442: 1848:import java.util.function.Supplier;
17443: 1849:
17444: 1850:class ClassAsFactory<T> implements Supplier<T> {
17445: 1851:    Class<T> kind;
17446: 1852:
17447: 1853:    ClassAsFactory(Class<T> kind) {
17448: 1854:        this.kind = kind;
17449: 1855:    }
17450: 1856:
17451: 1857:    @Override
17452: 1858:    public T get() {
17453: 1859:        try {
17454: 1860:            return kind.newInstance();
17455: 1861:        } catch (InstantiationException |
17456: 1862:                IllegalAccessException e) {
17457: 1863:            throw new RuntimeException(e);
17458: 1864:        }
17459: 1865:    }
17460: 1866:}
17461: 1867:
17462: 1868:class Employee {
17463: 1869:    @Override
17464: 1870:    public String toString() {
17465: 1871:        return "Employee";
17466: 1872:    }
17467: 1873:}
17468: 1874:
17469: 1875:public class InstantiateGenericType {
17470: 1876:    public static void main(String[] args) {
17471: 1877:        ClassAsFactory<Employee> fe =
17472: 1878:                new ClassAsFactory<>(Employee.class);
17473: 1879:        System.out.println(fe.get());
17474: 1880:        ClassAsFactory<Integer> fi =
17475: 1881:                new ClassAsFactory<>(Integer.class);
17476: 1882:        try {
17477: 1883:            System.out.println(fi.get());
17478: 1884:        } catch (Exception e) {
17479: 1885:            System.out.println(e.getMessage());
17480: 1886:        }
17481: 1887:    }
17482: 1888:}
17483: 1889:/* Output:
17484: 1890:Employee
17485: 1891:java.lang.InstantiationException: java.lang.Integer
17486: 1892:*/
17487: 1893:```
17488: 1894:
17489: 1895:这样可以编译，但对于 `ClassAsFactory<Integer>` 会失败，这是因为 **Integer** 没有无参构造函数。由于错误不是在编译时捕获的，因此语言创建者不赞成这种方法。他们建议使用显式工厂（**Supplier**）并约束类型，以便只有实现该工厂的类可以这样创建对象。这是创建工厂的两种不同方法：
17490: 1896:
17491: 1897:```java
17492: 1898:// generics/FactoryConstraint.java
17493: 1899:
17494: 1900:import onjava.Suppliers;
17495: 1901:
17496: 1902:import java.util.ArrayList;
17497: 1903:import java.util.List;
17498: 1904:import java.util.function.Supplier;
17499: 1905:
17500: 1906:class IntegerFactory implements Supplier<Integer> {
17501: 1907:    private int i = 0;
17502: 1908:
17503: 1909:    @Override
17504: 1910:    public Integer get() {
17505: 1911:        return ++i;
17506: 1912:    }
17507: 1913:}
17508: 1914:
17509: 1915:class Widget {
17510: 1916:    private int id;
17511: 1917:
17512: 1918:    Widget(int n) {
17513: 1919:        id = n;
17514: 1920:    }
17515: 1921:
17516: 1922:    @Override
17517: 1923:    public String toString() {
17518: 1924:        return "Widget " + id;
17519: 1925:    }
17520: 1926:
17521: 1927:    public static
17522: 1928:    class Factory implements Supplier<Widget> {
17523: 1929:        private int i = 0;
17524: 1930:
17525: 1931:        @Override
17526: 1932:        public Widget get() {
17527: 1933:            return new Widget(++i);
17528: 1934:        }
17529: 1935:    }
17530: 1936:}
17531: 1937:
17532: 1938:class Fudge {
17533: 1939:    private static int count = 1;
17534: 1940:    private int n = count++;
17535: 1941:
17536: 1942:    @Override
17537: 1943:    public String toString() {
17538: 1944:        return "Fudge " + n;
17539: 1945:    }
17540: 1946:}
17541: 1947:
17542: 1948:class Foo2<T> {
17543: 1949:    private List<T> x = new ArrayList<>();
17544: 1950:
17545: 1951:    Foo2(Supplier<T> factory) {
17546: 1952:        Suppliers.fill(x, factory, 5);
17547: 1953:    }
17548: 1954:
17549: 1955:    @Override
17550: 1956:    public String toString() {
17551: 1957:        return x.toString();
17552: 1958:    }
17553: 1959:}
17554: 1960:
17555: 1961:public class FactoryConstraint {
17556: 1962:    public static void main(String[] args) {
17557: 1963:        System.out.println(
17558: 1964:                new Foo2<>(new IntegerFactory()));
17559: 1965:        System.out.println(
17560: 1966:                new Foo2<>(new Widget.Factory()));
17561: 1967:        System.out.println(
17562: 1968:                new Foo2<>(Fudge::new));
17563: 1969:    }
17564: 1970:}
17565: 1971:/* Output:
17566: 1972:[1, 2, 3, 4, 5]
17567: 1973:[Widget 1, Widget 2, Widget 3, Widget 4, Widget 5]
17568: 1974:[Fudge 1, Fudge 2, Fudge 3, Fudge 4, Fudge 5]
17569: 1975:*/
17570: 1976:```
17571: 1977:
17572: 1978:**IntegerFactory** 本身就是通过实现 `Supplier<Integer>` 的工厂。 **Widget** 包含一个内部类，它是一个工厂。还要注意，**Fudge** 并没有做任何类似于工厂的操作，并且传递 `Fudge::new` 仍然会产生工厂行为，因为编译器将对函数方法 `::new` 的调用转换为对 `get()` 的调用。
17573: 1979:
17574: 1980:另一种方法是模板方法设计模式。在以下示例中，`create()` 是模板方法，在子类中被重写以生成该类型的对象：
17575: 1981:
17576: 1982:```java
17577: 1983:// generics/CreatorGeneric.java
17578: 1984:
17579: 1985:abstract class GenericWithCreate<T> {
17580: 1986:    final T element;
17581: 1987:
17582: 1988:    GenericWithCreate() {
17583: 1989:        element = create();
17584: 1990:    }
17585: 1991:
17586: 1992:    abstract T create();
17587: 1993:}
17588: 1994:
17589: 1995:class X {
17590: 1996:}
17591: 1997:
17592: 1998:class XCreator extends GenericWithCreate<X> {
17593: 1999:    @Override
17594: 2000:    X create() {
17595: 2001:        return new X();
17596: 2002:    }
17597: 2003:
17598: 2004:    void f() {
17599: 2005:        System.out.println(
17600: 2006:                element.getClass().getSimpleName());
17601: 2007:    }
17602: 2008:}
17603: 2009:
17604: 2010:public class CreatorGeneric {
17605: 2011:    public static void main(String[] args) {
17606: 2012:        XCreator xc = new XCreator();
17607: 2013:        xc.f();
17608: 2014:    }
17609: 2015:}
17610: 2016:/* Output:
17611: 2017:X
17612: 2018:*/
17613: 2019:```
17614: 2020:
17615: 2021:**GenericWithCreate** 包含 `element` 字段，并通过无参构造函数强制其初始化，该构造函数又调用抽象的 `create()` 方法。这种创建方式可以在子类中定义，同时建立 **T** 的类型。
17616: 2022:
17617: 2023:<!-- Arrays of Generics -->
17618: 2024:
17619: 2025:### 泛型数组
17620: 2026:
17621: 2027:正如在 **Erased.java** 中所看到的，我们无法创建泛型数组。通用解决方案是在试图创建泛型数组的时候使用 **ArrayList** ：
17622: 2028:
17623: 2029:```java
17624: 2030:// generics/ListOfGenerics.java
17625: 2031:
17626: 2032:import java.util.ArrayList;
17627: 2033:import java.util.List;
17628: 2034:
17629: 2035:public class ListOfGenerics<T> {
17630: 2036:    private List<T> array = new ArrayList<>();
17631: 2037:
17632: 2038:    public void add(T item) {
17633: 2039:        array.add(item);
17634: 2040:    }
17635: 2041:
17636: 2042:    public T get(int index) {
17637: 2043:        return array.get(index);
17638: 2044:    }
17639: 2045:}
17640: 2046:```
17641: 2047:
17642: 2048:这样做可以获得数组的行为，并且还具有泛型提供的编译时类型安全性。
17643: 2049:
17644: 2050:有时，仍然会创建泛型类型的数组（例如， **ArrayList** 在内部使用数组）。可以通过使编译器满意的方式定义对数组的通用引用：
17645: 2051:
17646: 2052:```java
17647: 2053:// generics/ArrayOfGenericReference.java
17648: 2054:
17649: 2055:class Generic<T> {
17650: 2056:}
17651: 2057:
17652: 2058:public class ArrayOfGenericReference {
17653: 2059:    static Generic<Integer>[] gia;
17654: 2060:}
17655: 2061:```
17656: 2062:
17657: 2063:编译器接受此操作而不产生警告。但是我们永远无法创建具有该确切类型（包括类型参数）的数组，因此有点令人困惑。由于所有数组，无论它们持有什么类型，都具有相同的结构（每个数组插槽的大小和数组布局），因此似乎可以创建一个 **Object** 数组并将其转换为所需的数组类型。实际上，这确实可以编译，但是会产生 **ClassCastException** ：
17658: 2064:
17659: 2065:```java
17660: 2066:// generics/ArrayOfGeneric.java
17661: 2067:
17662: 2068:public class ArrayOfGeneric {
17663: 2069:    static final int SIZE = 100;
17664: 2070:    static Generic<Integer>[] gia;
17665: 2071:
17666: 2072:    @SuppressWarnings("unchecked")
17667: 2073:    public static void main(String[] args) {
17668: 2074:        try {
17669: 2075:            gia = (Generic<Integer>[]) new Object[SIZE];
17670: 2076:        } catch (ClassCastException e) {
17671: 2077:            System.out.println(e.getMessage());
17672: 2078:        }
17673: 2079:        // Runtime type is the raw (erased) type:
17674: 2080:        gia = (Generic<Integer>[]) new Generic[SIZE];
17675: 2081:        System.out.println(gia.getClass().getSimpleName());
17676: 2082:        gia[0] = new Generic<>();
17677: 2083:        //- gia[1] = new Object(); // Compile-time error
17678: 2084:        // Discovers type mismatch at compile time:
17679: 2085:        //- gia[2] = new Generic<Double>();
17680: 2086:    }
17681: 2087:}
17682: 2088:/* Output:
17683: 2089:[Ljava.lang.Object; cannot be cast to [LGeneric;
17684: 2090:Generic[]
17685: 2091:*/
17686: 2092:```
17687: 2093:
17688: 2094:问题在于数组会跟踪其实际类型，而该类型是在创建数组时建立的。因此，即使 `gia` 被强制转换为 `Generic<Integer>[]` ，该信息也仅在编译时存在（并且没有 **@SuppressWarnings** 注解，将会收到有关该强制转换的警告）。在运行时，它仍然是一个 **Object** 数组，这会引起问题。成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换。
17689: 2095:
17690: 2096:让我们看一个更复杂的示例。考虑一个包装数组的简单泛型包装器：
17691: 2097:
17692: 2098:```java
17693: 2099:// generics/GenericArray.java
17694: 2100:
17695: 2101:public class GenericArray<T> {
17696: 2102:    private T[] array;
17697: 2103:
17698: 2104:    @SuppressWarnings("unchecked")
17699: 2105:    public GenericArray(int sz) {
17700: 2106:        array = (T[]) new Object[sz];
17701: 2107:    }
17702: 2108:
17703: 2109:    public void put(int index, T item) {
17704: 2110:        array[index] = item;
17705: 2111:    }
17706: 2112:
17707: 2113:    public T get(int index) {
17708: 2114:        return array[index];
17709: 2115:    }
17710: 2116:
17711: 2117:    // Method that exposes the underlying representation:
17712: 2118:    public T[] rep() {
17713: 2119:        return array;
17714: 2120:    }
17715: 2121:
17716: 2122:    public static void main(String[] args) {
17717: 2123:        GenericArray<Integer> gai = new GenericArray<>(10);
17718: 2124:        try {
17719: 2125:            Integer[] ia = gai.rep();
17720: 2126:        } catch (ClassCastException e) {
17721: 2127:            System.out.println(e.getMessage());
17722: 2128:        }
17723: 2129:        // This is OK:
17724: 2130:        Object[] oa = gai.rep();
17725: 2131:    }
17726: 2132:}
17727: 2133:/* Output:
17728: 2134:[Ljava.lang.Object; cannot be cast to
17729: 2135:[Ljava.lang.Integer;
17730: 2136:*/
17731: 2137:```
17732: 2138:
17733: 2139:和以前一样，我们不能说 `T[] array = new T[sz]` ，所以我们创建了一个 **Object** 数组并将其强制转换。
17734: 2140:
17735: 2141:`rep()` 方法返回一个 `T[]` ，在主方法中它应该是 `gai` 的 `Integer[]`，但是如果调用它并尝试将结果转换为 `Integer[]` 引用，则会得到 **ClassCastException** ，这再次是因为实际的运行时类型为 `Object[]` 。
17736: 2142:
17737: 2143:如果再注释掉 **@SuppressWarnings** 注解后编译 **GenericArray.java** ，则编译器会产生警告：
17738: 2144:
17739: 2145:```java
17740: 2146:GenericArray.java uses unchecked or unsafe operations.
17741: 2147:Recompile with -Xlint:unchecked for details.
17742: 2148:```
17743: 2149:
17744: 2150:在这里，我们收到了一个警告，我们认为这是有关强制转换的。
17745: 2151:
17746: 2152:但是要真正确定，请使用 `-Xlint：unchecked` 进行编译：
17747: 2153:
17748: 2154:```java
17749: 2155:GenericArray.java:7: warning: [unchecked] unchecked cast    array = (T[])new Object[sz];                 ^  required: T[]  found:    Object[]  where T is a type-variable:    T extends Object declared in class GenericArray 1 warning
17750: 2156:```
17751: 2157:
17752: 2158:确实是在抱怨那个强制转换。由于警告会变成噪音，因此，一旦我们确认预期会出现特定警告，我们可以做的最好的办法就是使用 **@SuppressWarnings** 将其关闭。这样，当警告确实出现时，我们将进行实际调查。
17753: 2159:
17754: 2160:由于擦除，数组的运行时类型只能是 `Object[]` 。 如果我们立即将其转换为 `T[]` ，则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。因此，最好在集合中使用 `Object[]` ，并在使用数组元素时向 **T** 添加强制类型转换。让我们来看看在 **GenericArray.java** 示例中会是怎么样的：
17755: 2161:
17756: 2162:```java
17757: 2163:// generics/GenericArray2.java
17758: 2164:
17759: 2165:public class GenericArray2<T> {
17760: 2166:    private Object[] array;
17761: 2167:
17762: 2168:    public GenericArray2(int sz) {
17763: 2169:        array = new Object[sz];
17764: 2170:    }
17765: 2171:
17766: 2172:    public void put(int index, T item) {
17767: 2173:        array[index] = item;
17768: 2174:    }
17769: 2175:
17770: 2176:    @SuppressWarnings("unchecked")
17771: 2177:    public T get(int index) {
17772: 2178:        return (T) array[index];
17773: 2179:    }
17774: 2180:
17775: 2181:    @SuppressWarnings("unchecked")
17776: 2182:    public T[] rep() {
17777: 2183:        return (T[]) array; // Unchecked cast
17778: 2184:    }
17779: 2185:
17780: 2186:    public static void main(String[] args) {
17781: 2187:        GenericArray2<Integer> gai =
17782: 2188:                new GenericArray2<>(10);
17783: 2189:        for (int i = 0; i < 10; i++)
17784: 2190:            gai.put(i, i);
17785: 2191:        for (int i = 0; i < 10; i++)
17786: 2192:            System.out.print(gai.get(i) + " ");
17787: 2193:        System.out.println();
17788: 2194:        try {
17789: 2195:            Integer[] ia = gai.rep();
17790: 2196:        } catch (Exception e) {
17791: 2197:            System.out.println(e);
17792: 2198:        }
17793: 2199:    }
17794: 2200:}
17795: 2201:/* Output:
17796: 2202:0 1 2 3 4 5 6 7 8 9
17797: 2203:java.lang.ClassCastException: [Ljava.lang.Object;
17798: 2204:cannot be cast to [Ljava.lang.Integer;
17799: 2205:*/
17800: 2206:```
17801: 2207:
17802: 2208:最初，看起来并没有太大不同，只是转换的位置移动了。没有 **@SuppressWarnings** 注解，仍然会收到“unchecked”警告。但是，内部表示现在是 `Object[]` 而不是 `T[]` 。 调用 `get()` 时，它将对象强制转换为 **T** ，实际上这是正确的类型，因此很安全。但是，如果调用 `rep()` ，它将再次尝试将 `Object[]` 强制转换为 `T[]` ，但仍然不正确，并在编译时生成警告，并在运行时生成异常。因此，无法破坏基础数组的类型，该基础数组只能是 `Object[]` 。在内部将数组视为 `Object[]` 而不是 `T[]` 的优点是，我们不太可能会忘记数组的运行时类型并意外地引入了bug，尽管大多数（也许是全部）此类错误会在运行时被迅速检测到。
17803: 2209:
17804: 2210:对于新代码，请传入类型标记。在这种情况下，**GenericArray** 如下所示：
17805: 2211:
17806: 2212:```java
17807: 2213:// generics/GenericArrayWithTypeToken.java
17808: 2214:
17809: 2215:import java.lang.reflect.Array;
17810: 2216:
17811: 2217:public class GenericArrayWithTypeToken<T> {
17812: 2218:    private T[] array;
17813: 2219:
17814: 2220:    @SuppressWarnings("unchecked")
17815: 2221:    public GenericArrayWithTypeToken(Class<T> type, int sz) {
17816: 2222:        array = (T[]) Array.newInstance(type, sz);
17817: 2223:    }
17818: 2224:
17819: 2225:    public void put(int index, T item) {
17820: 2226:        array[index] = item;
17821: 2227:    }
17822: 2228:
17823: 2229:    public T get(int index) {
17824: 2230:        return array[index];
17825: 2231:    }
17826: 2232:
17827: 2233:    // Expose the underlying representation:
17828: 2234:    public T[] rep() {
17829: 2235:        return array;
17830: 2236:    }
17831: 2237:
17832: 2238:    public static void main(String[] args) {
17833: 2239:        GenericArrayWithTypeToken<Integer> gai =
17834: 2240:                new GenericArrayWithTypeToken<>(
17835: 2241:                        Integer.class, 10);
17836: 2242:        // This now works:
17837: 2243:        Integer[] ia = gai.rep();
17838: 2244:    }
17839: 2245:}
17840: 2246:```
17841: 2247:
17842: 2248:类型标记 **Class\<T\>** 被传递到构造函数中以从擦除中恢复，因此尽管必须使用 **@SuppressWarnings** 关闭来自强制类型转换的警告，但我们仍可以创建所需的实际数组类型。一旦获得了实际的类型，就可以返回它并产生所需的结果，如在主方法中看到的那样。数组的运行时类型是确切的类型 `T[]` 。
17843: 2249:
17844: 2250:不幸的是，如果查看 Java 标准库中的源代码，你会发现到处都有从 **Object** 数组到参数化类型的转换。例如，这是**ArrayList** 中，复制一个 **Collection** 的构造函数，这里为了简化，去除了源码中对此不重要的代码：
17845: 2251:
17846: 2252:```java
17847: 2253:public ArrayList(Collection c) {
17848: 2254:  size = c.size();
17849: 2255:  elementData = (E[])new Object[size];
17850: 2256:  c.toArray(elementData);
17851: 2257:}
17852: 2258:```
17853: 2259:
17854: 2260:如果你浏览 **ArrayList.java** 的代码，将会发现很多此类强制转换。当我们编译它时会发生什么？
17855: 2261:
17856: 2262:```java
17857: 2263:Note: ArrayList.java uses unchecked or unsafe operations
17858: 2264:Note: Recompile with -Xlint:unchecked for details.
17859: 2265:```
17860: 2266:
17861: 2267:果然，标准库会产生很多警告。如果你使用过 C 语言，尤其是使用 ANSI C 之前的语言，你会记住警告的特殊效果：发现警告后，可以忽略它们。因此，除非程序员必须对其进行处理，否则最好不要从编译器发出任何类型的消息。
17862: 2268:
17863: 2269:Neal Gafter（Java 5 的主要开发人员之一）在他的博客中[^2]指出，他在重写 Java 库时是很随意、马虎的，我们不应该像他那样做。Neal 还指出，他在不破坏现有接口的情况下无法修复某些 Java 库代码。因此，即使在 Java 库源代码中出现了一些习惯用法，它们也不一定是正确的做法。当查看库代码时，我们不能认为这就是要在自己代码中必须遵循的示例。
17864: 2270:
17865: 2271:请注意，在 Java 文献中推荐使用类型标记技术，例如 Gilad Bracha 的论文《Generics in the Java Programming Language》[^3]，他指出：“例如，这种用法已广泛用于新的 API 中以处理注解。” 我发现此技术在人们对于舒适度的看法方面存在一些不一致之处；有些人强烈喜欢本章前面介绍的工厂方法。
17866: 2272:
17867: 2273:<!-- Bounds -->
17868: 2274:
17869: 2275:## 边界
17870: 2276:
17871: 2277:*边界*（bounds）在本章的前面进行了简要介绍。边界允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法。
17872: 2278:
17873: 2279:由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 **Object** 可用的方法。但是，如果将该参数限制为某类型的子集，则可以调用该子集中的方法。为了应用约束，Java 泛型使用了 `extends` 关键字。
17874: 2280:
17875: 2281:重要的是要理解，当用于限定泛型类型时，`extends` 的含义与通常的意义截然不同。此示例展示边界的基础应用：
17876: 2282:
17877: 2283:```java
17878: 2284:// generics/BasicBounds.java
17879: 2285:
17880: 2286:interface HasColor {
17881: 2287:    java.awt.Color getColor();
17882: 2288:}
17883: 2289:
17884: 2290:class WithColor<T extends HasColor> {
17885: 2291:    T item;
17886: 2292:
17887: 2293:    WithColor(T item) {
17888: 2294:        this.item = item;
17889: 2295:    }
17890: 2296:
17891: 2297:    T getItem() {
17892: 2298:        return item;
17893: 2299:    }
17894: 2300:
17895: 2301:    // The bound allows you to call a method:
17896: 2302:    java.awt.Color color() {
17897: 2303:        return item.getColor();
17898: 2304:    }
17899: 2305:}
17900: 2306:
17901: 2307:class Coord {
17902: 2308:    public int x, y, z;
17903: 2309:}
17904: 2310:
17905: 2311:// This fails. Class must be first, then interfaces:
17906: 2312:// class WithColorCoord<T extends HasColor & Coord> {
17907: 2313:
17908: 2314:// Multiple bounds:
17909: 2315:class WithColorCoord<T extends Coord & HasColor> {
17910: 2316:    T item;
17911: 2317:
17912: 2318:    WithColorCoord(T item) {
17913: 2319:        this.item = item;
17914: 2320:    }
17915: 2321:
17916: 2322:    T getItem() {
17917: 2323:        return item;
17918: 2324:    }
17919: 2325:
17920: 2326:    java.awt.Color color() {
17921: 2327:        return item.getColor();
17922: 2328:    }
17923: 2329:
17924: 2330:    int getX() {
17925: 2331:        return item.x;
17926: 2332:    }
17927: 2333:
17928: 2334:    int getY() {
17929: 2335:        return item.y;
17930: 2336:    }
17931: 2337:
17932: 2338:    int getZ() {
17933: 2339:        return item.z;
17934: 2340:    }
17935: 2341:}
17936: 2342:
17937: 2343:interface Weight {
17938: 2344:    int weight();
17939: 2345:}
17940: 2346:
17941: 2347:// As with inheritance, you can have only one
17942: 2348:// concrete class but multiple interfaces:
17943: 2349:class Solid<T extends Coord & HasColor & Weight> {
17944: 2350:    T item;
17945: 2351:
17946: 2352:    Solid(T item) {
17947: 2353:        this.item = item;
17948: 2354:    }
17949: 2355:
17950: 2356:    T getItem() {
17951: 2357:        return item;
17952: 2358:    }
17953: 2359:
17954: 2360:    java.awt.Color color() {
17955: 2361:        return item.getColor();
17956: 2362:    }
17957: 2363:
17958: 2364:    int getX() {
17959: 2365:        return item.x;
17960: 2366:    }
17961: 2367:
17962: 2368:    int getY() {
17963: 2369:        return item.y;
17964: 2370:    }
17965: 2371:
17966: 2372:    int getZ() {
17967: 2373:        return item.z;
17968: 2374:    }
17969: 2375:
17970: 2376:    int weight() {
17971: 2377:        return item.weight();
17972: 2378:    }
17973: 2379:}
17974: 2380:
17975: 2381:class Bounded
17976: 2382:        extends Coord implements HasColor, Weight {
17977: 2383:    @Override
17978: 2384:    public java.awt.Color getColor() {
17979: 2385:        return null;
17980: 2386:    }
17981: 2387:
17982: 2388:    @Override
17983: 2389:    public int weight() {
17984: 2390:        return 0;
17985: 2391:    }
17986: 2392:}
17987: 2393:
17988: 2394:public class BasicBounds {
17989: 2395:    public static void main(String[] args) {
17990: 2396:        Solid<Bounded> solid =
17991: 2397:                new Solid<>(new Bounded());
17992: 2398:        solid.color();
17993: 2399:        solid.getY();
17994: 2400:        solid.weight();
17995: 2401:    }
17996: 2402:}
17997: 2403:```
17998: 2404:
17999: 2405:你可能会观察到 **BasicBounds.java** 中似乎包含一些冗余，它们可以通过继承来消除。在这里，每个继承级别还添加了边界约束：
18000: 2406:
18001: 2407:```java
18002: 2408:// generics/InheritBounds.java
18003: 2409:
18004: 2410:class HoldItem<T> {
18005: 2411:    T item;
18006: 2412:
18007: 2413:    HoldItem(T item) {
18008: 2414:        this.item = item;
18009: 2415:    }
18010: 2416:
18011: 2417:    T getItem() {
18012: 2418:        return item;
18013: 2419:    }
18014: 2420:}
18015: 2421:
18016: 2422:class WithColor2<T extends HasColor>
18017: 2423:        extends HoldItem<T> {
18018: 2424:    WithColor2(T item) {
18019: 2425:        super(item);
18020: 2426:    }
18021: 2427:
18022: 2428:    java.awt.Color color() {
18023: 2429:        return item.getColor();
18024: 2430:    }
18025: 2431:}
18026: 2432:
18027: 2433:class WithColorCoord2<T extends Coord & HasColor>
18028: 2434:        extends WithColor2<T> {
18029: 2435:    WithColorCoord2(T item) {
18030: 2436:        super(item);
18031: 2437:    }
18032: 2438:
18033: 2439:    int getX() {
18034: 2440:        return item.x;
18035: 2441:    }
18036: 2442:
18037: 2443:    int getY() {
18038: 2444:        return item.y;
18039: 2445:    }
18040: 2446:
18041: 2447:    int getZ() {
18042: 2448:        return item.z;
18043: 2449:    }
18044: 2450:}
18045: 2451:
18046: 2452:class Solid2<T extends Coord & HasColor & Weight>
18047: 2453:        extends WithColorCoord2<T> {
18048: 2454:    Solid2(T item) {
18049: 2455:        super(item);
18050: 2456:    }
18051: 2457:
18052: 2458:    int weight() {
18053: 2459:        return item.weight();
18054: 2460:    }
18055: 2461:}
18056: 2462:
18057: 2463:public class InheritBounds {
18058: 2464:    public static void main(String[] args) {
18059: 2465:        Solid2<Bounded> solid2 =
18060: 2466:                new Solid2<>(new Bounded());
18061: 2467:        solid2.color();
18062: 2468:        solid2.getY();
18063: 2469:        solid2.weight();
18064: 2470:    }
18065: 2471:}
18066: 2472:```
18067: 2473:
18068: 2474:**HoldItem** 拥有一个对象，因此此行为将继承到 **WithColor2** 中，这也需要其参数符合 **HasColor**。 **WithColorCoord2** 和 **Solid2** 进一步扩展了层次结构，并在每个级别添加了边界。现在，这些方法已被继承，并且在每个类中不再重复。
18069: 2475:
18070: 2476:这是一个具有更多层次的示例：
18071: 2477:
18072: 2478:```java
18073: 2479:// generics/EpicBattle.java
18074: 2480:// Bounds in Java generics
18075: 2481:
18076: 2482:import java.util.List;
18077: 2483:
18078: 2484:interface SuperPower {
18079: 2485:}
18080: 2486:
18081: 2487:interface XRayVision extends SuperPower {
18082: 2488:    void seeThroughWalls();
18083: 2489:}
18084: 2490:
18085: 2491:interface SuperHearing extends SuperPower {
18086: 2492:    void hearSubtleNoises();
18087: 2493:}
18088: 2494:
18089: 2495:interface SuperSmell extends SuperPower {
18090: 2496:    void trackBySmell();
18091: 2497:}
18092: 2498:
18093: 2499:class SuperHero<POWER extends SuperPower> {
18094: 2500:    POWER power;
18095: 2501:
18096: 2502:    SuperHero(POWER power) {
18097: 2503:        this.power = power;
18098: 2504:    }
18099: 2505:
18100: 2506:    POWER getPower() {
18101: 2507:        return power;
18102: 2508:    }
18103: 2509:}
18104: 2510:
18105: 2511:class SuperSleuth<POWER extends XRayVision>
18106: 2512:        extends SuperHero<POWER> {
18107: 2513:    SuperSleuth(POWER power) {
18108: 2514:        super(power);
18109: 2515:    }
18110: 2516:
18111: 2517:    void see() {
18112: 2518:        power.seeThroughWalls();
18113: 2519:    }
18114: 2520:}
18115: 2521:
18116: 2522:class
18117: 2523:CanineHero<POWER extends SuperHearing & SuperSmell>
18118: 2524:        extends SuperHero<POWER> {
18119: 2525:    CanineHero(POWER power) {
18120: 2526:        super(power);
18121: 2527:    }
18122: 2528:
18123: 2529:    void hear() {
18124: 2530:        power.hearSubtleNoises();
18125: 2531:    }
18126: 2532:
18127: 2533:    void smell() {
18128: 2534:        power.trackBySmell();
18129: 2535:    }
18130: 2536:}
18131: 2537:
18132: 2538:class SuperHearSmell
18133: 2539:        implements SuperHearing, SuperSmell {
18134: 2540:    @Override
18135: 2541:    public void hearSubtleNoises() {
18136: 2542:    }
18137: 2543:
18138: 2544:    @Override
18139: 2545:    public void trackBySmell() {
18140: 2546:    }
18141: 2547:}
18142: 2548:
18143: 2549:class DogPerson extends CanineHero<SuperHearSmell> {
18144: 2550:    DogPerson() {
18145: 2551:        super(new SuperHearSmell());
18146: 2552:    }
18147: 2553:}
18148: 2554:
18149: 2555:public class EpicBattle {
18150: 2556:    // Bounds in generic methods:
18151: 2557:    static <POWER extends SuperHearing>
18152: 2558:    void useSuperHearing(SuperHero<POWER> hero) {
18153: 2559:        hero.getPower().hearSubtleNoises();
18154: 2560:    }
18155: 2561:
18156: 2562:    static <POWER extends SuperHearing & SuperSmell>
18157: 2563:    void superFind(SuperHero<POWER> hero) {
18158: 2564:        hero.getPower().hearSubtleNoises();
18159: 2565:        hero.getPower().trackBySmell();
18160: 2566:    }
18161: 2567:
18162: 2568:    public static void main(String[] args) {
18163: 2569:        DogPerson dogPerson = new DogPerson();
18164: 2570:        useSuperHearing(dogPerson);
18165: 2571:        superFind(dogPerson);
18166: 2572:        // You can do this:
18167: 2573:        List<? extends SuperHearing> audioPeople;
18168: 2574:        // But you can't do this:
18169: 2575:        // List<? extends SuperHearing & SuperSmell> dogPs;
18170: 2576:    }
18171: 2577:}
18172: 2578:```
18173: 2579:
18174: 2580:接下来将要研究的通配符将会把范围限制在单个类型。
18175: 2581:
18176: 2582:<!-- Wildcards -->
18177: 2583:
18178: 2584:## 通配符
18179: 2585:
18180: 2586:你已经在 [集合](book/12-Collections.md) 章节中看到了一些简单示例使用了通配符——在泛型参数表达式中的问号，在 [类型信息](book/19-Type-Information.md) 一章中这种示例更多。本节将更深入地探讨这个特性。
18181: 2587:
18182: 2588:我们的起始示例要展示数组的一种特殊行为：你可以将派生类的数组赋值给基类的引用：
18183: 2589:
18184: 2590:```java
18185: 2591:// generics/CovariantArrays.java
18186: 2592:
18187: 2593:class Fruit {}
18188: 2594:
18189: 2595:class Apple extends Fruit {}
18190: 2596:
18191: 2597:class Jonathan extends Apple {}
18192: 2598:
18193: 2599:class Orange extends Fruit {}
18194: 2600:
18195: 2601:public class CovariantArrays {
18196: 2602:    
18197: 2603:    public static void main(String[] args) {
18198: 2604:        Fruit[] fruit = new Apple[10];
18199: 2605:        fruit[0] = new Apple(); // OK
18200: 2606:        fruit[1] = new Jonathan(); // OK
18201: 2607:        // Runtime type is Apple[], not Fruit[] or Orange[]:
18202: 2608:        try {
18203: 2609:            // Compiler allows you to add Fruit:
18204: 2610:            fruit[0] = new Fruit(); // ArrayStoreException
18205: 2611:        } catch (Exception e) {
18206: 2612:            System.out.println(e);
18207: 2613:        }
18208: 2614:        try {
18209: 2615:            // Compiler allows you to add Oranges:
18210: 2616:            fruit[0] = new Orange(); // ArrayStoreException
18211: 2617:        } catch (Exception e) {
18212: 2618:            System.out.println(e);
18213: 2619:        }
18214: 2620:    }
18215: 2621:}
18216: 2622:/* Output:
18217: 2623:java.lang.ArrayStoreException: Fruit
18218: 2624:java.lang.ArrayStoreException: Orange
18219: 2625:```
18220: 2626:
18221: 2627:`main()` 中的第一行创建了 **Apple** 数组，并赋值给一个 **Fruit** 数组引用。这是有意义的，因为 **Apple** 也是一种 **Fruit**，因此 **Apple** 数组应该也是一个 **Fruit** 数组。
18222: 2628:
18223: 2629:但是，如果实际的数组类型是 **Apple[]**，你可以在其中放置 **Apple** 或 **Apple** 的子类型，这在编译期和运行时都可以工作。但是你也可以在数组中放置 **Fruit** 对象。这对编译器来说是有意义的，因为它有一个 **Fruit[]** 引用——它有什么理由不允许将 **Fruit** 对象或任何从 **Fruit** 继承出来的对象（比如 **Orange**），放置到这个数组中呢？因此在编译期，这是允许的。然而，运行时的数组机制知道它处理的是 **Apple[]**，因此会在向数组中放置异构类型时抛出异常。
18224: 2630:
18225: 2631:向上转型用在这里不合适。你真正在做的是将一个数组赋值给另一个数组。数组的行为是持有其他对象，这里只是因为我们能够向上转型而已，所以很明显，数组对象可以保留有关它们包含的对象类型的规则。看起来就像数组对它们持有的对象是有意识的，因此在编译期检查和运行时检查之间，你不能滥用它们。
18226: 2632:
18227: 2633:数组的这种赋值并不是那么可怕，因为在运行时你可以发现插入了错误的类型。但是泛型的主要目标之一是将这种错误检测移到编译期。所以当我们试图使用泛型集合代替数组时，会发生什么呢？
18228: 2634:
18229: 2635:```java
18230: 2636:// generics/NonCovariantGenerics.java
18231: 2637:// {WillNotCompile}
18232: 2638:
18233: 2639:import java.util.*;
18234: 2640:
18235: 2641:public class NonCovariantGenerics {
18236: 2642:    // Compile Error: incompatible types:
18237: 2643:    List<Fruit> flist = new ArrayList<Apple>();
18238: 2644:}
18239: 2645:```
18240: 2646:
18241: 2647:尽管你在首次阅读这段代码时会认为“不能将一个 **Apple** 集合赋值给一个 **Fruit** 集合”。记住，泛型不仅仅是关于集合，它真正要表达的是“不能把一个涉及 **Apple** 的泛型赋值给一个涉及 **Fruit** 的泛型”。如果像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及到的集合，那么它可能会留下一些余地。但是它不知道任何有关这方面的信息，因此它拒绝向上转型。然而实际上这也不是向上转型—— **Apple** 的 **List** 不是 **Fruit** 的 **List**。**Apple** 的 **List** 将持有 **Apple** 和 **Apple** 的子类型，**Fruit** 的 **List** 将持有任何类型的 **Fruit**。是的，这包括 **Apple**，但是它不是一个 **Apple** 的 **List**，它仍然是 **Fruit** 的 **List**。**Apple** 的 **List** 在类型上不等价于 **Fruit** 的 **List**，即使 **Apple** 是一种 **Fruit** 类型。
18242: 2648:
18243: 2649:真正的问题是我们在讨论的集合类型，而不是集合持有对象的类型。与数组不同，泛型没有内建的协变类型。这是因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查，但是在使用泛型时，编译器和运行时系统不知道你想用类型做什么，以及应该采用什么规则。
18244: 2650:
18245: 2651:但是，有时你想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。
18246: 2652:
18247: 2653:```java
18248: 2654:// generics/GenericsAndCovariance.java
18249: 2655:
18250: 2656:import java.util.*;
18251: 2657:
18252: 2658:public class GenericsAndCovariance {
18253: 2659:    
18254: 2660:    public static void main(String[] args) {
18255: 2661:        // Wildcards allow covariance:
18256: 2662:        List<? extends Fruit> flist = new ArrayList<>();
18257: 2663:        // Compile Error: can't add any type of object:
18258: 2664:        // flist.add(new Apple());
18259: 2665:        // flist.add(new Fruit());
18260: 2666:        // flist.add(new Object());
18261: 2667:        flist.add(null); // Legal but uninteresting
18262: 2668:        // We know it returns at least Fruit:
18263: 2669:        Fruit f = flist.get(0);
18264: 2670:    }
18265: 2671:    
18266: 2672:}
18267: 2673:```
18268: 2674:
18269: 2675:**flist** 的类型现在是 `List<? extends Fruit>`，你可以读作“一个具有任何从 **Fruit** 继承的类型的列表”。然而，这实际上并不意味着这个 **List** 将持有任何类型的 **Fruit**。通配符引用的是明确的类型，因此它意味着“某种 **flist** 引用没有指定的具体类型”。因此这个被赋值的 **List** 必须持有诸如 **Fruit** 或 **Apple** 这样的指定类型，但是为了向上转型为 **Fruit**，这个类型是什么没人在意。
18270: 2676:
18271: 2677:**List** 必须持有一种具体的 **Fruit** 或 **Fruit** 的子类型，但是如果你不关心具体的类型是什么，那么你能对这样的 **List** 做什么呢？如果不知道 **List** 中持有的对象是什么类型，你怎能保证安全地向其中添加对象呢？就像在 **CovariantArrays.java** 中向上转型一样，你不能，除非编译器而不是运行时系统可以阻止这种操作的发生。你很快就会发现这个问题。
18272: 2678:
18273: 2679:你可能认为事情开始变得有点走极端了，因为现在你甚至不能向刚刚声明过将持有 **Apple** 对象的 **List** 中放入一个 **Apple** 对象。是的，但编译器并不知道这一点。`List<? extends Fruit>` 可能合法地指向一个 `List<Orange>`。一旦执行这种类型的向上转型，你就丢失了向其中传递任何对象的能力，甚至传递 **Object** 也不行。
18274: 2680:
18275: 2681:另一方面，如果你调用了一个返回 **Fruit** 的方法，则是安全的，因为你知道这个 **List** 中的任何对象至少具有 **Fruit** 类型，因此编译器允许这么做。
18276: 2682:
18277: 2683:### 编译器有多聪明
18278: 2684:
18279: 2685:现在你可能会猜想自己不能去调用任何接受参数的方法，但是考虑下面的代码：
18280: 2686:
18281: 2687:```java
18282: 2688:// generics/CompilerIntelligence.java
18283: 2689:
18284: 2690:import java.util.*;
18285: 2691:
18286: 2692:public class CompilerIntelligence {
18287: 2693:    
18288: 2694:    public static void main(String[] args) {
18289: 2695:        List<? extends Fruit> flist = Arrays.asList(new Apple());
18290: 2696:        Apple a = (Apple) flist.get(0); // No warning
18291: 2697:        flist.contains(new Apple()); // Argument is 'Object'
18292: 2698:        flist.indexOf(new Apple()); // Argument is 'Object'
18293: 2699:    }
18294: 2700:    
18295: 2701:}
18296: 2702:```
18297: 2703:
18298: 2704:这里对 `contains()` 和 `indexOf()` 的调用接受 **Apple** 对象作为参数，执行没问题。这是否意味着编译器实际上会检查代码，以查看是否有某个特定的方法修改了它的对象？
18299: 2705:
18300: 2706:通过查看 **ArrayList** 的文档，我们发现编译器没有那么聪明。尽管 `add()` 接受一个泛型参数类型的参数，但 `contains()` 和 `indexOf()` 接受的参数类型是 **Object**。因此当你指定一个 `ArrayList<? extends Fruit>` 时，`add()` 的参数就变成了"**? extends Fruit**"。从这个描述中，编译器无法得知这里需要 **Fruit** 的哪个具体子类型，因此它不会接受任何类型的 **Fruit**。如果你先把 **Apple** 向上转型为 **Fruit**，也没有关系——编译器仅仅会拒绝调用像 `add()` 这样参数列表中涉及通配符的方法。
18301: 2707:
18302: 2708:`contains()` 和 `indexOf()` 的参数类型是 **Object**，不涉及通配符，所以编译器允许调用它们。这意味着将由泛型类的设计者来决定哪些调用是“安全的”，并使用 **Object** 类作为它们的参数类型。为了禁止对类型中使用了通配符的方法调用，需要在参数列表中使用类型参数。
18303: 2709:
18304: 2710:下面展示一个简单的 **Holder** 类：
18305: 2711:
18306: 2712:```java
18307: 2713:// generics/Holder.java
18308: 2714:
18309: 2715:public class Holder<T> {
18310: 2716:
18311: 2717:    private T value;
18312: 2718:
18313: 2719:    public Holder() {}
18314: 2720:
18315: 2721:    public Holder(T val) {
18316: 2722:        value = val;
18317: 2723:    }
18318: 2724:
18319: 2725:    public void set(T val) {
18320: 2726:        value = val;
18321: 2727:    }
18322: 2728:
18323: 2729:    public T get() {
18324: 2730:        return value;
18325: 2731:    }
18326: 2732:
18327: 2733:    @Override
18328: 2734:    public boolean equals(Object o) {
18329: 2735:        return o instanceof Holder && Objects.equals(value, ((Holder) o).value);
18330: 2736:    }
18331: 2737:
18332: 2738:    @Override
18333: 2739:    public int hashCode() {
18334: 2740:        return Objects.hashCode(value);
18335: 2741:    }
18336: 2742:
18337: 2743:    public static void main(String[] args) {
18338: 2744:        Holder<Apple> apple = new Holder<>(new Apple());
18339: 2745:        Apple d = apple.get();
18340: 2746:        apple.set(d);
18341: 2747:        // Holder<Fruit> fruit = apple; // Cannot upcast
18342: 2748:        Holder<? extends Fruit> fruit = apple; // OK
18343: 2749:        Fruit p = fruit.get();
18344: 2750:        d = (Apple) fruit.get();
18345: 2751:        try {
18346: 2752:            Orange c = (Orange) fruit.get(); // No warning
18347: 2753:        } catch (Exception e) {
18348: 2754:            System.out.println(e);
18349: 2755:        }
18350: 2756:        // fruit.set(new Apple()); // Cannot call set()
18351: 2757:        // fruit.set(new Fruit()); // Cannot call set()
18352: 2758:        System.out.println(fruit.equals(d)); // OK
18353: 2759:    }
18354: 2760:}
18355: 2761:/* Output
18356: 2762:java.lang.ClassCastException: Apple cannot be cast to Orange
18357: 2763:false
18358: 2764:*/
18359: 2765:```
18360: 2766:
18361: 2767:**Holder** 有一个接受 **T** 类型对象的 `set()` 方法，一个返回 T 对象的 `get()` 方法和一个接受 Object 对象的 `equals()` 方法。正如你所见，如果创建了一个 `Holder<Apple>`，就不能将其向上转型为 `Holder<Fruit>`，但是可以向上转型为 `Holder<? extends Fruit>`。如果调用 `get()`，只能返回一个 **Fruit**——这就是在给定“任何扩展自 **Fruit** 的对象”这一边界后，它所能知道的一切了。如果你知道更多的信息，就可以将其转型到某种具体的 **Fruit** 而不会导致任何警告，但是存在得到 **ClassCastException** 的风险。`set()` 方法不能工作在 **Apple** 和 **Fruit** 上，因为 `set()` 的参数也是"**? extends Fruit**"，意味着它可以是任何事物，编译器无法验证“任何事物”的类型安全性。
18362: 2768:
18363: 2769:但是，`equals()` 方法可以正常工作，因为它接受的参数是 **Object** 而不是 **T** 类型。因此，编译器只关注传递进来和要返回的对象类型。它不会分析代码，以查看是否执行了任何实际的写入和读取操作。
18364: 2770:
18365: 2771:Java 7 引入了 **java.util.Objects** 库，使创建 `equals()` 和 `hashCode()` 方法变得更加容易，当然还有很多其他功能。`equals()` 方法的标准形式参考 [附录：理解 equals 和 hashCode 方法](book/Appendix-Understanding-equals-and-hashCode) 一章。
18366: 2772:
18367: 2773:### 逆变
18368: 2774:
18369: 2775:还可以走另外一条路，即使用超类型通配符。这里，可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 `<？super MyClass>` ，或者甚至使用类型参数： `<？super T>`（尽管你不能对泛型参数给出一个超类型边界；即不能声明 `<T super MyClass>` ）。这使得你可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，就可以向 **Collection** 写入了：
18370: 2776:
18371: 2777:```java
18372: 2778:// generics/SuperTypeWildcards.java
18373: 2779:import java.util.*;
18374: 2780:public class SuperTypeWildcards {
18375: 2781:    static void writeTo(List<? super Apple> apples) {
18376: 2782:        apples.add(new Apple());
18377: 2783:        apples.add(new Jonathan());
18378: 2784:        // apples.add(new Fruit()); // Error
18379: 2785:    }
18380: 2786:}
18381: 2787:```
18382: 2788:
18383: 2789:参数 **apples** 是 **Apple** 的某种基类型的 **List**，这样你就知道向其中添加 **Apple** 或 **Apple** 的子类型是安全的。但是因为 **Apple** 是下界，所以你知道向这样的 **List** 中添加 **Fruit** 是不安全的，因为这将使这个 **List** 敞开口子，从而可以向其中添加非 **Apple** 类型的对象，而这是违反静态类型安全的。
18384: 2790:下面的示例复习了一下逆变和通配符的的使用：
18385: 2791:
18386: 2792:```java
18387: 2793:// generics/GenericReading.java
18388: 2794:import java.util.*;
18389: 2795:
18390: 2796:public class GenericReading {
18391: 2797:    static List<Apple> apples = Arrays.asList(new Apple());
18392: 2798:    static List<Fruit> fruit = Arrays.asList(new Fruit());
18393: 2799:    
18394: 2800:    static <T> T readExact(List<T> list) {
18395: 2801:        return list.get(0);
18396: 2802:    }
18397: 2803:    
18398: 2804:    // A static method adapts to each call:
18399: 2805:    static void f1() {
18400: 2806:        Apple a = readExact(apples);
18401: 2807:        Fruit f = readExact(fruit);
18402: 2808:        f = readExact(apples);
18403: 2809:    }
18404: 2810:    
18405: 2811:    // A class type is established
18406: 2812:    // when the class is instantiated:
18407: 2813:    static class Reader<T> {
18408: 2814:        T readExact(List<T> list) { 
18409: 2815:            return list.get(0); 
18410: 2816:        }
18411: 2817:    }
18412: 2818:    
18413: 2819:    static void f2() {
18414: 2820:        Reader<Fruit> fruitReader = new Reader<>();
18415: 2821:        Fruit f = fruitReader.readExact(fruit);
18416: 2822:        //- Fruit a = fruitReader.readExact(apples);
18417: 2823:        // error: incompatible types: List<Apple>
18418: 2824:        // cannot be converted to List<Fruit>
18419: 2825:    }
18420: 2826:    
18421: 2827:    static class CovariantReader<T> {
18422: 2828:        T readCovariant(List<? extends T> list) {
18423: 2829:            return list.get(0);
18424: 2830:        }
18425: 2831:    }
18426: 2832:    
18427: 2833:    static void f3() {
18428: 2834:        CovariantReader<Fruit> fruitReader = new CovariantReader<>();
18429: 2835:        Fruit f = fruitReader.readCovariant(fruit);
18430: 2836:        Fruit a = fruitReader.readCovariant(apples);
18431: 2837:    }
18432: 2838:    
18433: 2839:    public static void main(String[] args) {
18434: 2840:        f1(); 
18435: 2841:        f2(); 
18436: 2842:        f3();
18437: 2843:    }
18438: 2844:}
18439: 2845:```
18440: 2846:
18441: 2847:`readExact()` 方法使用了精确的类型。如果使用这个没有任何通配符的精确类型，就可以向 **List** 中写入和读取这个精确类型。另外，对于返回值，静态的泛型方法 `readExact()` 可以有效地“适应”每个方法调用，并能够从 `List<Apple>` 中返回一个 **Apple** ，从 `List<Fruit>` 中返回一个 **Fruit** ，就像在 `f1()` 中看到的那样。因此，如果可以摆脱静态泛型方法，那么在读取时就不需要协变类型了。
18442: 2848:然而对于泛型类来说，当你创建这个类的实例时，就要为这个类确定参数。就像在 `f2()` 中看到的，**fruitReader** 实例可以从 `List<Fruit>` 中读取一个 **Fruit** ，因为这就是它的确切类型。但是 `List<Apple>` 也应该产生 **Fruit** 对象，而 **fruitReader** 不允许这么做。
18443: 2849:为了修正这个问题，`CovariantReader.readCovariant()` 方法将接受 `List<？extends T>` ，因此，从这个列表中读取一个 **T** 是安全的（你知道在这个列表中的所有对象至少是一个 **T** ，并且可能是从 T 导出的某种对象）。在 `f3()` 中，你可以看到现在可以从 `List<Apple>` 中读取 **Fruit** 了。
18444: 2850:
18445: 2851:### 无界通配符
18446: 2852:
18447: 2853:无界通配符 `<?>` 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器初看起来是支持这种判断的：
18448: 2854:
18449: 2855:```java
18450: 2856:// generics/UnboundedWildcards1.java
18451: 2857:import java.util.*;
18452: 2858:
18453: 2859:public class UnboundedWildcards1 {
18454: 2860:    static List list1;
18455: 2861:    static List<?> list2;
18456: 2862:    static List<? extends Object> list3;
18457: 2863:  
18458: 2864:    static void assign1(List list) {
18459: 2865:        list1 = list;
18460: 2866:        list2 = list;
18461: 2867:        //- list3 = list;
18462: 2868:        // warning: [unchecked] unchecked conversion
18463: 2869:        // list3 = list;
18464: 2870:        //         ^
18465: 2871:        // required: List<? extends Object>
18466: 2872:        // found:    List
18467: 2873:    }
18468: 2874:    
18469: 2875:    static void assign2(List<?> list) {
18470: 2876:        list1 = list;
18471: 2877:        list2 = list;
18472: 2878:        list3 = list;
18473: 2879:    }
18474: 2880:    
18475: 2881:    static void assign3(List<? extends Object> list) {
18476: 2882:        list1 = list;
18477: 2883:        list2 = list;
18478: 2884:        list3 = list;
18479: 2885:    }
18480: 2886:    
18481: 2887:    public static void main(String[] args) {
18482: 2888:        assign1(new ArrayList());
18483: 2889:        assign2(new ArrayList());
18484: 2890:        //- assign3(new ArrayList());
18485: 2891:        // warning: [unchecked] unchecked method invocation:
18486: 2892:        // method assign3 in class UnboundedWildcards1
18487: 2893:        // is applied to given types
18488: 2894:        // assign3(new ArrayList());
18489: 2895:        //        ^
18490: 2896:        // required: List<? extends Object>
18491: 2897:        // found: ArrayList
18492: 2898:        // warning: [unchecked] unchecked conversion
18493: 2899:        // assign3(new ArrayList());
18494: 2900:        //         ^
18495: 2901:        // required: List<? extends Object>
18496: 2902:        // found:    ArrayList
18497: 2903:        // 2 warnings
18498: 2904:        assign1(new ArrayList<>());
18499: 2905:        assign2(new ArrayList<>());
18500: 2906:        assign3(new ArrayList<>());
18501: 2907:        // Both forms are acceptable as List<?>:
18502: 2908:        List<?> wildList = new ArrayList();
18503: 2909:        wildList = new ArrayList<>();
18504: 2910:        assign1(wildList);
18505: 2911:        assign2(wildList);
18506: 2912:        assign3(wildList);
18507: 2913:    }
18508: 2914:}
18509: 2915:```
18510: 2916:
18511: 2917:有很多情况都和你在这里看到的情况类似，即编译器很少关心使用的是原生类型还是 `<?>` 。在这些情况中，`<?>` 可以被认为是一种装饰，但是它仍旧是很有价值的，因为，实际上它是在声明：“我是想用 Java 的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型。”
18512: 2918:第二个示例展示了无界通配符的一个重要应用。当你在处理多个泛型参数时，有时允许一个参数可以是任何类型，同时为其他参数确定某种特定类型的这种能力会显得很重要：
18513: 2919:
18514: 2920:```java
18515: 2921:// generics/UnboundedWildcards2.java
18516: 2922:import java.util.*;
18517: 2923:
18518: 2924:public class UnboundedWildcards2 {
18519: 2925:    static Map map1;
18520: 2926:    static Map<?,?> map2;
18521: 2927:    static Map<String,?> map3;
18522: 2928:  
18523: 2929:    static void assign1(Map map) { 
18524: 2930:        map1 = map; 
18525: 2931:    }
18526: 2932:    
18527: 2933:    static void assign2(Map<?,?> map) { 
18528: 2934:        map2 = map; 
18529: 2935:    }
18530: 2936:    
18531: 2937:    static void assign3(Map<String,?> map) { 
18532: 2938:        map3 = map; 
18533: 2939:    }
18534: 2940:    
18535: 2941:    public static void main(String[] args) {
18536: 2942:        assign1(new HashMap());
18537: 2943:        assign2(new HashMap());
18538: 2944:        //- assign3(new HashMap());
18539: 2945:        // warning: [unchecked] unchecked method invocation:
18540: 2946:        // method assign3 in class UnboundedWildcards2
18541: 2947:        // is applied to given types
18542: 2948:        //     assign3(new HashMap());
18543: 2949:        //            ^
18544: 2950:        //   required: Map<String,?>
18545: 2951:        //   found: HashMap
18546: 2952:        // warning: [unchecked] unchecked conversion
18547: 2953:        //     assign3(new HashMap());
18548: 2954:        //             ^
18549: 2955:        //   required: Map<String,?>
18550: 2956:        //   found:    HashMap
18551: 2957:        // 2 warnings
18552: 2958:        assign1(new HashMap<>());
18553: 2959:        assign2(new HashMap<>());
18554: 2960:        assign3(new HashMap<>());
18555: 2961:    }
18556: 2962:}
18557: 2963:```
18558: 2964:
18559: 2965:但是，当你拥有的全都是无界通配符时，就像在 `Map<?,?>` 中看到的那样，编译器看起来就无法将其与原生 **Map** 区分开了。另外， **UnboundedWildcards1.java** 展示了编译器处理  `List<?>` 和 `List<? extends Object>` 是不同的。
18560: 2966:令人困惑的是，编译器并非总是关注像 `List` 和 `List<?>` 之间的这种差异，因此它们看起来就像是相同的事物。事实上，因为泛型参数擦除到它的第一个边界，因此 `List<?>` 看起来等价于 `List<Object>` ，而 **List** 实际上也是 `List<Object>` ——除非这些语句都不为真。**List** 实际上表示“持有任何 **Object** 类型的原生 **List** ”，而 `List<?>` 表示“具有某种特定类型的非原生 **List** ，只是我们不知道类型是什么。”
18561: 2967:编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？下面的示例使用了前面定义的 `Holder<T>` 类，它包含接受 **Holder** 作为参数的各种方法，但是它们具有不同的形式：作为原生类型，具有具体的类型参数以及具有无界通配符参数：
18562: 2968:
18563: 2969:```java
18564: 2970:// generics/Wildcards.java
18565: 2971:// Exploring the meaning of wildcards
18566: 2972:
18567: 2973:public class Wildcards {
18568: 2974:    // Raw argument:
18569: 2975:    static void rawArgs(Holder holder, Object arg) {
18570: 2976:        //- holder.set(arg);
18571: 2977:        // warning: [unchecked] unchecked call to set(T)
18572: 2978:        // as a member of the raw type Holder
18573: 2979:        //     holder.set(arg);
18574: 2980:        //               ^
18575: 2981:        //   where T is a type-variable:
18576: 2982:        //     T extends Object declared in class Holder
18577: 2983:        // 1 warning
18578: 2984:
18579: 2985:        // Can't do this; don't have any 'T':
18580: 2986:        // T t = holder.get();
18581: 2987:
18582: 2988:        // OK, but type information is lost:
18583: 2989:        Object obj = holder.get();
18584: 2990:    }
18585: 2991:    
18586: 2992:    // Like rawArgs(), but errors instead of warnings:
18587: 2993:    static void unboundedArg(Holder<?> holder, Object arg) {
18588: 2994:        //- holder.set(arg);
18589: 2995:        // error: method set in class Holder<T>
18590: 2996:        // cannot be applied to given types;
18591: 2997:        //     holder.set(arg);
18592: 2998:        //           ^
18593: 2999:        //   required: CAP#1
18594: 3000:        //   found: Object
18595: 3001:        //   reason: argument mismatch;
18596: 3002:        //     Object cannot be converted to CAP#1
18597: 3003:        //   where T is a type-variable:
18598: 3004:        //     T extends Object declared in class Holder
18599: 3005:        //   where CAP#1 is a fresh type-variable:
18600: 3006:        //     CAP#1 extends Object from capture of ?
18601: 3007:        // 1 error
18602: 3008:
18603: 3009:        // Can't do this; don't have any 'T':
18604: 3010:        // T t = holder.get();
18605: 3011:
18606: 3012:        // OK, but type information is lost:
18607: 3013:        Object obj = holder.get();
18608: 3014:    }
18609: 3015:    
18610: 3016:    static <T> T exact1(Holder<T> holder) {
18611: 3017:        return holder.get();
18612: 3018:    }
18613: 3019:    
18614: 3020:    static <T> T exact2(Holder<T> holder, T arg) {
18615: 3021:        holder.set(arg);
18616: 3022:        return holder.get();
18617: 3023:    }
18618: 3024:    
18619: 3025:    static <T> T wildSubtype(Holder<? extends T> holder, T arg) {
18620: 3026:        //- holder.set(arg);
18621: 3027:        // error: method set in class Holder<T#2>
18622: 3028:        // cannot be applied to given types;
18623: 3029:        //     holder.set(arg);
18624: 3030:        //           ^
18625: 3031:        //   required: CAP#1
18626: 3032:        //   found: T#1
18627: 3033:        //   reason: argument mismatch;
18628: 3034:        //     T#1 cannot be converted to CAP#1
18629: 3035:        //   where T#1,T#2 are type-variables:
18630: 3036:        //     T#1 extends Object declared in method
18631: 3037:        //     <T#1>wildSubtype(Holder<? extends T#1>,T#1)
18632: 3038:        //     T#2 extends Object declared in class Holder
18633: 3039:        //   where CAP#1 is a fresh type-variable:
18634: 3040:        //     CAP#1 extends T#1 from
18635: 3041:        //       capture of ? extends T#1
18636: 3042:        // 1 error
18637: 3043:        return holder.get();
18638: 3044:    }
18639: 3045:    
18640: 3046:    static <T> void wildSupertype(Holder<? super T> holder, T arg) {
18641: 3047:        holder.set(arg);
18642: 3048:        //- T t = holder.get();
18643: 3049:        // error: incompatible types:
18644: 3050:        // CAP#1 cannot be converted to T
18645: 3051:        //     T t = holder.get();
18646: 3052:        //                     ^
18647: 3053:        //   where T is a type-variable:
18648: 3054:        //     T extends Object declared in method
18649: 3055:        //       <T>wildSupertype(Holder<? super T>,T)
18650: 3056:        //   where CAP#1 is a fresh type-variable:
18651: 3057:        //     CAP#1 extends Object super:
18652: 3058:        //       T from capture of ? super T
18653: 3059:        // 1 error
18654: 3060:
18655: 3061:        // OK, but type information is lost:
18656: 3062:        Object obj = holder.get();
18657: 3063:    }
18658: 3064:    
18659: 3065:    public static void main(String[] args) {
18660: 3066:        Holder raw = new Holder<>();
18661: 3067:        // Or:
18662: 3068:        raw = new Holder();
18663: 3069:        Holder<Long> qualified = new Holder<>();
18664: 3070:        Holder<?> unbounded = new Holder<>();
18665: 3071:        Holder<? extends Long> bounded = new Holder<>();
18666: 3072:        Long lng = 1L;
18667: 3073:
18668: 3074:        rawArgs(raw, lng);
18669: 3075:        rawArgs(qualified, lng);
18670: 3076:        rawArgs(unbounded, lng);
18671: 3077:        rawArgs(bounded, lng);
18672: 3078:
18673: 3079:        unboundedArg(raw, lng);
18674: 3080:        unboundedArg(qualified, lng);
18675: 3081:        unboundedArg(unbounded, lng);
18676: 3082:        unboundedArg(bounded, lng);
18677: 3083:
18678: 3084:        //- Object r1 = exact1(raw);
18679: 3085:        // warning: [unchecked] unchecked method invocation:
18680: 3086:        // method exact1 in class Wildcards is applied
18681: 3087:        // to given types
18682: 3088:        //      Object r1 = exact1(raw);
18683: 3089:        //                        ^
18684: 3090:        //   required: Holder<T>
18685: 3091:        //   found: Holder
18686: 3092:        //   where T is a type-variable:
18687: 3093:        //     T extends Object declared in
18688: 3094:        //     method <T>exact1(Holder<T>)
18689: 3095:        // warning: [unchecked] unchecked conversion
18690: 3096:        //      Object r1 = exact1(raw);
18691: 3097:        //                         ^
18692: 3098:        //   required: Holder<T>
18693: 3099:        //   found:    Holder
18694: 3100:        //   where T is a type-variable:
18695: 3101:        //     T extends Object declared in
18696: 3102:        //     method <T>exact1(Holder<T>)
18697: 3103:        // 2 warnings
18698: 3104:
18699: 3105:        Long r2 = exact1(qualified);
18700: 3106:        Object r3 = exact1(unbounded); // Must return Object
18701: 3107:        Long r4 = exact1(bounded);
18702: 3108:
18703: 3109:        //- Long r5 = exact2(raw, lng);
18704: 3110:        // warning: [unchecked] unchecked method invocation:
18705: 3111:        // method exact2 in class Wildcards is
18706: 3112:        // applied to given types
18707: 3113:        //     Long r5 = exact2(raw, lng);
18708: 3114:        //                     ^
18709: 3115:        //   required: Holder<T>,T
18710: 3116:        //   found: Holder,Long
18711: 3117:        //   where T is a type-variable:
18712: 3118:        //     T extends Object declared in
18713: 3119:        //       method <T>exact2(Holder<T>,T)
18714: 3120:        // warning: [unchecked] unchecked conversion
18715: 3121:        //     Long r5 = exact2(raw, lng);
18716: 3122:        //                      ^
18717: 3123:        //   required: Holder<T>
18718: 3124:        //   found:    Holder
18719: 3125:        //   where T is a type-variable:
18720: 3126:        //     T extends Object declared in
18721: 3127:        //       method <T>exact2(Holder<T>,T)
18722: 3128:        // 2 warnings
18723: 3129:
18724: 3130:        Long r6 = exact2(qualified, lng);
18725: 3131:
18726: 3132:        //- Long r7 = exact2(unbounded, lng);
18727: 3133:        // error: method exact2 in class Wildcards
18728: 3134:        // cannot be applied to given types;
18729: 3135:        //     Long r7 = exact2(unbounded, lng);
18730: 3136:        //               ^
18731: 3137:        //   required: Holder<T>,T
18732: 3138:        //   found: Holder<CAP#1>,Long
18733: 3139:        //   reason: inference variable T has
18734: 3140:        //     incompatible bounds
18735: 3141:        //     equality constraints: CAP#1
18736: 3142:        //     lower bounds: Long
18737: 3143:        //   where T is a type-variable:
18738: 3144:        //     T extends Object declared in
18739: 3145:        //       method <T>exact2(Holder<T>,T)
18740: 3146:        //   where CAP#1 is a fresh type-variable:
18741: 3147:        //     CAP#1 extends Object from capture of ?
18742: 3148:        // 1 error
18743: 3149:
18744: 3150:        //- Long r8 = exact2(bounded, lng);
18745: 3151:        // error: method exact2 in class Wildcards
18746: 3152:        // cannot be applied to given types;
18747: 3153:        //      Long r8 = exact2(bounded, lng);
18748: 3154:        //                ^
18749: 3155:        //   required: Holder<T>,T
18750: 3156:        //   found: Holder<CAP#1>,Long
18751: 3157:        //   reason: inference variable T
18752: 3158:        //     has incompatible bounds
18753: 3159:        //     equality constraints: CAP#1
18754: 3160:        //     lower bounds: Long
18755: 3161:        //   where T is a type-variable:
18756: 3162:        //     T extends Object declared in
18757: 3163:        //       method <T>exact2(Holder<T>,T)
18758: 3164:        //   where CAP#1 is a fresh type-variable:
18759: 3165:        //     CAP#1 extends Long from
18760: 3166:        //       capture of ? extends Long
18761: 3167:        // 1 error
18762: 3168:
18763: 3169:        //- Long r9 = wildSubtype(raw, lng);
18764: 3170:        // warning: [unchecked] unchecked method invocation:
18765: 3171:        // method wildSubtype in class Wildcards
18766: 3172:        // is applied to given types
18767: 3173:        //     Long r9 = wildSubtype(raw, lng);
18768: 3174:        //                          ^
18769: 3175:        //   required: Holder<? extends T>,T
18770: 3176:        //   found: Holder,Long
18771: 3177:        //   where T is a type-variable:
18772: 3178:        //     T extends Object declared in
18773: 3179:        //     method <T>wildSubtype(Holder<? extends T>,T)
18774: 3180:        // warning: [unchecked] unchecked conversion
18775: 3181:        //     Long r9 = wildSubtype(raw, lng);
18776: 3182:        //                           ^
18777: 3183:        //   required: Holder<? extends T>
18778: 3184:        //   found:    Holder
18779: 3185:        //   where T is a type-variable:
18780: 3186:        //     T extends Object declared in
18781: 3187:        //     method <T>wildSubtype(Holder<? extends T>,T)
18782: 3188:        // 2 warnings
18783: 3189:
18784: 3190:        Long r10 = wildSubtype(qualified, lng);
18785: 3191:        // OK, but can only return Object:
18786: 3192:        Object r11 = wildSubtype(unbounded, lng);
18787: 3193:        Long r12 = wildSubtype(bounded, lng);
18788: 3194:
18789: 3195:        //- wildSupertype(raw, lng);
18790: 3196:        // warning: [unchecked] unchecked method invocation:
18791: 3197:        //   method wildSupertype in class Wildcards
18792: 3198:        //   is applied to given types
18793: 3199:        //     wildSupertype(raw, lng);
18794: 3200:        //                  ^
18795: 3201:        //   required: Holder<? super T>,T
18796: 3202:        //   found: Holder,Long
18797: 3203:        //   where T is a type-variable:
18798: 3204:        //     T extends Object declared in
18799: 3205:        //     method <T>wildSupertype(Holder<? super T>,T)
18800: 3206:        // warning: [unchecked] unchecked conversion
18801: 3207:        //     wildSupertype(raw, lng);
18802: 3208:        //                   ^
18803: 3209:        //   required: Holder<? super T>
18804: 3210:        //   found:    Holder
18805: 3211:        //   where T is a type-variable:
18806: 3212:        //     T extends Object declared in
18807: 3213:        //     method <T>wildSupertype(Holder<? super T>,T)
18808: 3214:        // 2 warnings
18809: 3215:
18810: 3216:        wildSupertype(qualified, lng);
18811: 3217:
18812: 3218:        //- wildSupertype(unbounded, lng);
18813: 3219:        // error: method wildSupertype in class Wildcards
18814: 3220:        // cannot be applied to given types;
18815: 3221:        //     wildSupertype(unbounded, lng);
18816: 3222:        //     ^
18817: 3223:        //   required: Holder<? super T>,T
18818: 3224:        //   found: Holder<CAP#1>,Long
18819: 3225:        //   reason: cannot infer type-variable(s) T
18820: 3226:        //     (argument mismatch; Holder<CAP#1>
18821: 3227:        //     cannot be converted to Holder<? super T>)
18822: 3228:        //   where T is a type-variable:
18823: 3229:        //     T extends Object declared in
18824: 3230:        //     method <T>wildSupertype(Holder<? super T>,T)
18825: 3231:        //   where CAP#1 is a fresh type-variable:
18826: 3232:        //     CAP#1 extends Object from capture of ?
18827: 3233:        // 1 error
18828: 3234:
18829: 3235:        //- wildSupertype(bounded, lng);
18830: 3236:        // error: method wildSupertype in class Wildcards
18831: 3237:        // cannot be applied to given types;
18832: 3238:        //     wildSupertype(bounded, lng);
18833: 3239:        //     ^
18834: 3240:        //   required: Holder<? super T>,T
18835: 3241:        //   found: Holder<CAP#1>,Long
18836: 3242:        //   reason: cannot infer type-variable(s) T
18837: 3243:        //     (argument mismatch; Holder<CAP#1>
18838: 3244:        //     cannot be converted to Holder<? super T>)
18839: 3245:        //   where T is a type-variable:
18840: 3246:        //     T extends Object declared in
18841: 3247:        //     method <T>wildSupertype(Holder<? super T>,T)
18842: 3248:        //   where CAP#1 is a fresh type-variable:
18843: 3249:        //     CAP#1 extends Long from capture of
18844: 3250:        //     ? extends Long
18845: 3251:        // 1 error
18846: 3252:    }
18847: 3253:}
18848: 3254:```
18849: 3255:
18850: 3256:在 `rawArgs()` 中，编译器知道 `Holder` 是一个泛型类型，因此即使它在这里被表示成一个原生类型，编译器仍旧知道向 `set()` 传递一个 **Object** 是不安全的。由于它是原生类型，你可以将任何类型的对象传递给 `set()` ，而这个对象将被向上转型为 **Object** 。因此无论何时，只要使用了原生类型，都会放弃编译期检查。对 `get()` 的调用说明了相同的问题：没有任何 **T** 类型的对象，因此结果只能是一个 **Object**。
18851: 3257:人们很自然地会开始考虑原生 `Holder` 与 `Holder<?>` 是大致相同的事物。但是 `unboundedArg()` 强调它们是不同的——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，因为原生 **Holder** 将持有任何类型的组合，而 `Holder<?>` 将持有具有某种具体类型的同构集合，因此不能只是向其中传递 **Object** 。
18852: 3258:在 `exact1()` 和 `exact2()` 中，你可以看到使用了确切的泛型参数——没有任何通配符。你将看到，`exact2()`与 `exact1()` 具有不同的限制，因为它有额外的参数。
18853: 3259:在 `wildSubtype()` 中，在 **Holder** 类型上的限制被放松为包括持有任何扩展自 **T** 的对象的 **Holder** 。这还是意味着如果 T 是 **Fruit** ，那么 `holder` 可以是 `Holder<Apple>` ，这是合法的。为了防止将 **Orange** 放置到 `Holder<Apple>` 中，对 `set()` 的调用（或者对任何接受这个类型参数为参数的方法的调用）都是不允许的。但是，你仍旧知道任何来自 `Holder<？extends Fruit>` 的对象至少是 **Fruit** ，因此 `get()` （或者任何将产生具有这个类型参数的返回值的方法）都是允许的。
18854: 3260:`wildSupertype()` 展示了超类型通配符，这个方法展示了与 `wildSubtype()` 相反的行为：`holder` 可以是持有任何 T 的基类型的容器。因此， `set()` 可以接受 **T** ，因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是 **T** ）。但是，尝试着调用 `get()` 是没有用的，因为由 `holder` 持有的类型可以是任何超类型，因此唯一安全的类型就是 **Object** 。
18855: 3261:这个示例还展示了对于在 `unbounded()` 中使用无界通配符能够做什么不能做什么所做出的限制：因为你没有 **T**，所以你不能将 `set()` 或 `get()` 作用于 **T** 上。
18856: 3262:
18857: 3263:在 `main()` 方法中你看到了某些方法在接受某些类型的参数时没有报错和警告。为了迁移兼容性，`rawArgs()`  将接受所有 **Holder** 的不同变体，而不会产生警告。`unboundedArg()` 方法也可以接受相同的所有类型，尽管如前所述，它在方法体内部处理这些类型的方式并不相同。
18858: 3264:
18859: 3265:如果向接受“确切”泛型类型（没有通配符）的方法传递一个原生 **Holder** 引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息。如果向 `exact1()` 传递一个无界引用，就不会有任何可以确定返回类型的类型信息。
18860: 3266:可以看到，`exact2()` 具有最多的限制，因为它希望精确地得到一个 `Holder<T>` ，以及一个具有类型 **T** 的参数，正由于此，它将产生错误或警告，除非提供确切的参数。有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决于是否想要从泛型参数中返回类型确定的返回值（就像在 `wildSubtype()` 中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在 `wildSupertype()` 中看到的那样）。
18861: 3267:因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合你的需求的方法。
18862: 3268:
18863: 3269:### 捕获转换
18864: 3270:
18865: 3271:有一种特殊情况需要使用 `<?>` 而不是原生类型。如果向一个使用 `<?>` 的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。下面的示例演示了这种技术，它被称为捕获转换，因为未指定的通配符类型被捕获，并被转换为确切类型。这里，有关警告的注释只有在 `@SuppressWarnings` 注解被移除之后才能起作用：
18866: 3272:
18867: 3273:```java
18868: 3274:// generics/CaptureConversion.java
18869: 3275:
18870: 3276:public class CaptureConversion {
18871: 3277:    static <T> void f1(Holder<T> holder) {
18872: 3278:        T t = holder.get();
18873: 3279:        System.out.println(t.getClass().getSimpleName());
18874: 3280:    }
18875: 3281:  
18876: 3282:    static void f2(Holder<?> holder) {
18877: 3283:        f1(holder); // Call with captured type
18878: 3284:    }
18879: 3285:    
18880: 3286:    @SuppressWarnings("unchecked")
18881: 3287:    public static void main(String[] args) {
18882: 3288:        Holder raw = new Holder<>(1);
18883: 3289:        f1(raw);
18884: 3290:        // warning: [unchecked] unchecked method invocation:
18885: 3291:        // method f1 in class CaptureConversion
18886: 3292:        // is applied to given types
18887: 3293:        //     f1(raw);
18888: 3294:        //       ^
18889: 3295:        //   required: Holder<T>
18890: 3296:        //   found: Holder
18891: 3297:        //   where T is a type-variable:
18892: 3298:        //     T extends Object declared in
18893: 3299:        //     method <T>f1(Holder<T>)
18894: 3300:        // warning: [unchecked] unchecked conversion
18895: 3301:        //     f1(raw);
18896: 3302:        //        ^
18897: 3303:        //   required: Holder<T>
18898: 3304:        //   found:    Holder
18899: 3305:        //   where T is a type-variable:
18900: 3306:        //     T extends Object declared in
18901: 3307:        //     method <T>f1(Holder<T>)
18902: 3308:        // 2 warnings
18903: 3309:        f2(raw); // No warnings
18904: 3310:        
18905: 3311:        Holder rawBasic = new Holder();
18906: 3312:        rawBasic.set(new Object());
18907: 3313:        // warning: [unchecked] unchecked call to set(T)
18908: 3314:        // as a member of the raw type Holder
18909: 3315:        //     rawBasic.set(new Object());
18910: 3316:        //                 ^
18911: 3317:        //   where T is a type-variable:
18912: 3318:        //     T extends Object declared in class Holder
18913: 3319:        // 1 warning
18914: 3320:        f2(rawBasic); // No warnings
18915: 3321:        
18916: 3322:        // Upcast to Holder<?>, still figures it out:
18917: 3323:        Holder<?> wildcarded = new Holder<>(1.0);
18918: 3324:        f2(wildcarded);
18919: 3325:    }
18920: 3326:}
18921: 3327:/* Output:
18922: 3328:Integer
18923: 3329:Integer
18924: 3330:Object
18925: 3331:Double
18926: 3332:*/
18927: 3333:```
18928: 3334:
18929: 3335:`f1()` 中的类型参数都是确切的，没有通配符或边界。在 `f2()` 中，**Holder** 参数是一个无界通配符，因此它看起来是未知的。但是，在 `f2()` 中调用了 `f1()`，而 `f1()` 需要一个已知参数。这里所发生的是：在调用 `f2()` 的过程中捕获了参数类型，并在调用 `f1()` 时使用了这种类型。
18930: 3336:你可能想知道这项技术是否可以用于写入，但是这要求在传递 `Holder<?>` 时同时传递一个具体类型。捕获转换只有在这样的情况下可以工作：即在方法内部，你需要使用确切的类型。注意，不能从 `f2()` 中返回 **T**，因为 **T** 对于 `f2()` 来说是未知的。捕获转换十分有趣，但是非常受限。
18931: 3337:
18932: 3338:<!-- Issues -->
18933: 3339:
18934: 3340:## 问题
18935: 3341:
18936: 3342:本节将阐述在使用 Java 泛型时会出现的各类问题。
18937: 3343:
18938: 3344:### 任何基本类型都不能作为类型参数
18939: 3345:
18940: 3346:正如本章早先提到的，Java 泛型的限制之一是不能将基本类型用作类型参数。因此，不能创建  `ArrayList<int>` 之类的东西。
18941: 3347:解决方法是使用基本类型的包装器类以及自动装箱机制。如果创建一个 `ArrayList<Integer>`，并将基本类型 **int** 应用于这个集合，那么你将发现自动装箱机制将自动地实现 **int** 到 **Integer** 的双向转换——因此，这几乎就像是有一个 `ArrayList<int>` 一样：
18942: 3348:
18943: 3349:```java
18944: 3350:// generics/ListOfInt.java
18945: 3351:// Autoboxing compensates for the inability
18946: 3352:// to use primitives in generics
18947: 3353:import java.util.*;
18948: 3354:import java.util.stream.*;
18949: 3355:
18950: 3356:public class ListOfInt {
18951: 3357:    public static void main(String[] args) {
18952: 3358:        List<Integer> li = IntStream.range(38, 48)
18953: 3359:            .boxed() // Converts ints to Integers
18954: 3360:            .collect(Collectors.toList());
18955: 3361:        System.out.println(li);
18956: 3362:    }
18957: 3363:}
18958: 3364:/* Output:
18959: 3365:[38, 39, 40, 41, 42, 43, 44, 45, 46, 47]
18960: 3366:*/
18961: 3367:```
18962: 3368:
18963: 3369:通常，这种解决方案工作得很好——能够成功地存储和读取 **int**，自动装箱隐藏了转换的过程。但是如果性能成为问题的话，就需要使用专门为基本类型适配的特殊版本的集合；一个开源版本的实现是 **org.apache.commons.collections.primitives**。
18964: 3370:下面是另外一种方式，它可以创建持有 **Byte** 的 **Set**：
18965: 3371:
18966: 3372:```java
18967: 3373:// generics/ByteSet.java
18968: 3374:import java.util.*;
18969: 3375:
18970: 3376:public class ByteSet {
18971: 3377:    Byte[] possibles = { 1,2,3,4,5,6,7,8,9 };
18972: 3378:    Set<Byte> mySet = new HashSet<>(Arrays.asList(possibles));
18973: 3379:    // But you can't do this:
18974: 3380:    // Set<Byte> mySet2 = new HashSet<>(
18975: 3381:    // Arrays.<Byte>asList(1,2,3,4,5,6,7,8,9));
18976: 3382:}
18977: 3383:```
18978: 3384:
18979: 3385:自动装箱机制解决了一些问题，但并没有解决所有问题。
18980: 3386:
18981: 3387:在下面的示例中，**FillArray** 接口包含一些通用方法，这些方法使用 **Supplier** 来用对象填充数组（这使得类泛型在本例中无法工作，因为这个方法是静态的）。**Supplier** 实现来自 [数组](book/21-Arrays.md) 一章,并且在 `main()` 中，可以看到 `FillArray.fill()` 使用对象填充了数组：
18982: 3388:
18983: 3389:```java
18984: 3390:// generics/PrimitiveGenericTest.java
18985: 3391:import onjava.*;
18986: 3392:import java.util.*;
18987: 3393:import java.util.function.*;
18988: 3394:
18989: 3395:// Fill an array using a generator:
18990: 3396:interface FillArray {
18991: 3397:    static <T> T[] fill(T[] a, Supplier<T> gen) {
18992: 3398:        Arrays.setAll(a, n -> gen.get());
18993: 3399:        return a;
18994: 3400:    }
18995: 3401:    
18996: 3402:    static int[] fill(int[] a, IntSupplier gen) {
18997: 3403:        Arrays.setAll(a, n -> gen.getAsInt());
18998: 3404:        return a;
18999: 3405:    }
19000: 3406:    
19001: 3407:    static long[] fill(long[] a, LongSupplier gen) {
19002: 3408:        Arrays.setAll(a, n -> gen.getAsLong());
19003: 3409:        return a;
19004: 3410:    }
19005: 3411:    
19006: 3412:    static double[] fill(double[] a, DoubleSupplier gen) {
19007: 3413:        Arrays.setAll(a, n -> gen.getAsDouble());
19008: 3414:        return a;
19009: 3415:    }
19010: 3416:}
19011: 3417:
19012: 3418:public class PrimitiveGenericTest {
19013: 3419:    public static void main(String[] args) {
19014: 3420:        String[] strings = FillArray.fill(
19015: 3421:            new String[5], new Rand.String(9));
19016: 3422:        System.out.println(Arrays.toString(strings));
19017: 3423:        int[] integers = FillArray.fill(
19018: 3424:            new int[9], new Rand.Pint());
19019: 3425:        System.out.println(Arrays.toString(integers));
19020: 3426:    }
19021: 3427:}
19022: 3428:/* Output:
19023: 3429:[btpenpccu, xszgvgmei, nneeloztd, vewcippcy, gpoalkljl]
19024: 3430:[635, 8737, 3941, 4720, 6177, 8479, 6656, 3768, 4948]
19025: 3431:*/
19026: 3432:```
19027: 3433:
19028: 3434:自动装箱不适用于数组，因此我们必须创建 `FillArray.fill()` 的重载版本，或创建产生 **Wrapped** 输出的生成器。 **FillArray** 仅比 `java.util.Arrays.setAll()` 有用一点，因为它返回填充的数组。
19029: 3435:
19030: 3436:### 实现参数化接口
19031: 3437:
19032: 3438:一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。下面是产生这种冲突的情况：
19033: 3439:
19034: 3440:```java
19035: 3441:// generics/MultipleInterfaceVariants.java
19036: 3442:// {WillNotCompile}
19037: 3443:package generics;
19038: 3444:
19039: 3445:interface Payable<T> {}
19040: 3446:
19041: 3447:class Employee implements Payable<Employee> {}
19042: 3448:
19043: 3449:class Hourly extends Employee implements Payable<Hourly> {}
19044: 3450:```
19045: 3451:
19046: 3452:**Hourly** 不能编译，因为擦除会将  `Payable<Employe>` 和 `Payable<Hourly>` 简化为相同的类 **Payable**，这样，上面的代码就意味着在重复两次地实现相同的接口。十分有趣的是，如果从 **Payable** 的两种用法中都移除掉泛型参数（就像编译器在擦除阶段所做的那样）这段代码就可以编译。
19047: 3453:
19048: 3454:在使用某些更基本的 Java 接口，例如 `Comparable<T>` 时，这个问题可能会变得十分令人恼火，就像你在本节稍后看到的那样。
19049: 3455:
19050: 3456:### 转型和警告
19051: 3457:
19052: 3458:使用带有泛型类型参数的转型或 **instanceof** 不会有任何效果。下面的集合在内部将各个值存储为 **Object**，并在获取这些值时，再将它们转型回 **T**：
19053: 3459:
19054: 3460:```java
19055: 3461:// generics/GenericCast.java
19056: 3462:import java.util.*;
19057: 3463:import java.util.stream.*;
19058: 3464:
19059: 3465:class FixedSizeStack<T> {
19060: 3466:    private final int size;
19061: 3467:    private Object[] storage;
19062: 3468:    private int index = 0;
19063: 3469:    
19064: 3470:    FixedSizeStack(int size) {
19065: 3471:        this.size = size;
19066: 3472:        storage = new Object[size];
19067: 3473:    }
19068: 3474:    
19069: 3475:    public void push(T item) {
19070: 3476:        if(index < size)
19071: 3477:            storage[index++] = item;
19072: 3478:    }
19073: 3479:    
19074: 3480:    @SuppressWarnings("unchecked")
19075: 3481:    public T pop() {
19076: 3482:        return index == 0 ? null : (T)storage[--index];
19077: 3483:    }
19078: 3484:    
19079: 3485:    @SuppressWarnings("unchecked")
19080: 3486:    Stream<T> stream() {
19081: 3487:        return (Stream<T>)Arrays.stream(storage);
19082: 3488:    }
19083: 3489:}
19084: 3490:
19085: 3491:public class GenericCast {
19086: 3492:    static String[] letters = "ABCDEFGHIJKLMNOPQRS".split("");
19087: 3493:  
19088: 3494:    public static void main(String[] args) {
19089: 3495:        FixedSizeStack<String> strings =
19090: 3496:            new FixedSizeStack<>(letters.length);
19091: 3497:        Arrays.stream("ABCDEFGHIJKLMNOPQRS".split(""))
19092: 3498:            .forEach(strings::push);
19093: 3499:        System.out.println(strings.pop());
19094: 3500:        strings.stream()
19095: 3501:            .map(s -> s + " ")
19096: 3502:            .forEach(System.out::print);
19097: 3503:    }
19098: 3504:}
19099: 3505:/* Output:
19100: 3506:S
19101: 3507:A B C D E F G H I J K L M N O P Q R S
19102: 3508:*/
19103: 3509:```
19104: 3510:
19105: 3511:如果没有 **@SuppressWarnings** 注解，编译器将对 `pop()` 产生 “unchecked cast” 警告。由于擦除的原因，编译器无法知道这个转型是否是安全的，并且 `pop()` 方法实际上并没有执行任何转型。
19106: 3512:这是因为，**T** 被擦除到它的第一个边界，默认情况下是 **Object** ，因此 `pop()` 实际上只是将 **Object** 转型为 **Object**。
19107: 3513:有时，泛型没有消除对转型的需要，这就会由编译器产生警告，而这个警告是不恰当的。例如：
19108: 3514:
19109: 3515:```java
19110: 3516:// generics/NeedCasting.java
19111: 3517:import java.io.*;
19112: 3518:import java.util.*;
19113: 3519:
19114: 3520:public class NeedCasting {
19115: 3521:    @SuppressWarnings("unchecked")
19116: 3522:    public void f(String[] args) throws Exception {
19117: 3523:        ObjectInputStream in = new ObjectInputStream(
19118: 3524:            new FileInputStream(args[0]));
19119: 3525:        List<Widget> shapes = (List<Widget>)in.readObject();
19120: 3526:    }
19121: 3527:}
19122: 3528:```
19123: 3529:
19124: 3530:正如你将在 [附录：对象序列化](book/Appendix-Object-Serialization.md) 中学到的那样，`readObject()` 无法知道它正在读取的是什么，因此它返回的是必须转型的对象。但是当注释掉 **@SuppressWarnings** 注解并编译这个程序时，就会得到下面的警告。
19125: 3531:
19126: 3532:```
19127: 3533:NeedCasting.java uses unchecked or unsafe operations.
19128: 3534:Recompile with -Xlint:unchecked for details.
19129: 3535:
19130: 3536:And if you follow the instructions and recompile with  -
19131: 3537:Xlint:unchecked :(如果遵循这条指示，使用-Xlint:unchecked来重新编译：)
19132: 3538:
19133: 3539:NeedCasting.java:10: warning: [unchecked] unchecked cast
19134: 3540:    List<Widget> shapes = (List<Widget>)in.readObject();
19135: 3541:    required: List<Widget>
19136: 3542:    found: Object
19137: 3543:1 warning
19138: 3544:```
19139: 3545:
19140: 3546:你会被强制要求转型，但是又被告知不应该转型。为了解决这个问题，必须使用 Java 5 引入的新的转型形式，即通过泛型类来转型：
19141: 3547:
19142: 3548:```java
19143: 3549:// generics/ClassCasting.java
19144: 3550:import java.io.*;
19145: 3551:import java.util.*;
19146: 3552:
19147: 3553:public class ClassCasting {
19148: 3554:    @SuppressWarnings("unchecked")
19149: 3555:    public void f(String[] args) throws Exception {
19150: 3556:        ObjectInputStream in = new ObjectInputStream(
19151: 3557:            new FileInputStream(args[0]));
19152: 3558:        // Won't Compile:
19153: 3559:        //    List<Widget> lw1 =
19154: 3560:        //    List<>.class.cast(in.readObject());
19155: 3561:        List<Widget> lw2 = List.class.cast(in.readObject());
19156: 3562:    }
19157: 3563:}
19158: 3564:```
19159: 3565:
19160: 3566:但是，不能转型到实际类型（ `List<Widget>` ）。也就是说，不能声明：
19161: 3567:
19162: 3568:```
19163: 3569:List<Widget>.class.cast(in.readobject())
19164: 3570:```
19165: 3571:
19166: 3572:甚至当你添加一个像下面这样的另一个转型时：
19167: 3573:
19168: 3574:```
19169: 3575:(List<Widget>)List.class.cast(in.readobject())
19170: 3576:```
19171: 3577:
19172: 3578:仍旧会得到一个警告。
19173: 3579:
19174: 3580:### 重载
19175: 3581:
19176: 3582:下面的程序是不能编译的，即使它看起来是合理的：
19177: 3583:
19178: 3584:```java
19179: 3585:// generics/UseList.java
19180: 3586:// {WillNotCompile}
19181: 3587:import java.util.*;
19182: 3588:
19183: 3589:public class UseList<W, T> {
19184: 3590:    void f(List<T> v) {}
19185: 3591:    void f(List<W> v) {}
19186: 3592:}
19187: 3593:```
19188: 3594:
19189: 3595:因为擦除，所以重载方法产生了相同的类型签名。
19190: 3596:
19191: 3597:因而，当擦除后的参数不能产生唯一的参数列表时，你必须提供不同的方法名：
19192: 3598:
19193: 3599:```java
19194: 3600:// generics/UseList2.java
19195: 3601:
19196: 3602:import java.util.*;
19197: 3603:
19198: 3604:public class UseList2<W, T> {
19199: 3605:    void f1(List<T> v) {}
19200: 3606:    void f2(List<W> v) {}
19201: 3607:}
19202: 3608:```
19203: 3609:
19204: 3610:幸运的是，编译器可以检测到这类问题。
19205: 3611:
19206: 3612:### 基类劫持接口
19207: 3613:
19208: 3614:假设你有一个实现了 **Comparable** 接口的 **Pet** 类：
19209: 3615:
19210: 3616:```java
19211: 3617:// generics/ComparablePet.java
19212: 3618:
19213: 3619:public class ComparablePet implements Comparable<ComparablePet> {
19214: 3620:    @Override
19215: 3621:    public int compareTo(ComparablePet o) {
19216: 3622:        return 0;
19217: 3623:    }
19218: 3624:}
19219: 3625:```
19220: 3626:
19221: 3627:尝试缩小 **ComparablePet** 子类的比较类型是有意义的。例如，**Cat** 类可以与其他的 **Cat** 比较：
19222: 3628:
19223: 3629:```java
19224: 3630:// generics/HijackedInterface.java
19225: 3631:// {WillNotCompile}
19226: 3632:
19227: 3633:class Cat extends ComparablePet implements Comparable<Cat> {
19228: 3634:    // error: Comparable cannot be inherited with
19229: 3635:    // different arguments: <Cat> and <ComparablePet>
19230: 3636:    // class Cat
19231: 3637:    // ^
19232: 3638:    // 1 error
19233: 3639:    public int compareTo(Cat arg) {
19234: 3640:        return 0;
19235: 3641:    }
19236: 3642:}
19237: 3643:```
19238: 3644:
19239: 3645:不幸的是，这不能工作。一旦 **Comparable** 的类型参数设置为 **ComparablePet**，其他的实现类只能比较 **ComparablePet**：
19240: 3646:
19241: 3647:```java
19242: 3648:// generics/RestrictedComparablePets.java
19243: 3649:
19244: 3650:public class Hamster extends ComparablePet implements Comparable<ComparablePet> {
19245: 3651:
19246: 3652:    @Override
19247: 3653:    public int compareTo(ComparablePet arg) {
19248: 3654:        return 0;
19249: 3655:    }
19250: 3656:}
19251: 3657:// Or just:
19252: 3658:class Gecko extends ComparablePet {
19253: 3659:    public int compareTo(ComparablePet arg) {
19254: 3660:        return 0;
19255: 3661:    }
19256: 3662:}
19257: 3663:```
19258: 3664:
19259: 3665:**Hamster** 显示了重新实现 **ComparablePet** 中相同的接口是可能的，只要接口完全相同，包括参数类型。然而正如 **Gecko** 中所示，这与直接覆写基类的方法完全相同。
19260: 3666:
19261: 3667:<!-- Self-Bounded Types -->
19262: 3668:
19263: 3669:## 自限定的类型
19264: 3670:
19265: 3671:在 Java 泛型中，有一个似乎经常性出现的惯用法，它相当令人费解：
19266: 3672:
19267: 3673:```java
19268: 3674:class SelfBounded<T extends SelfBounded<T>> { // ...
19269: 3675:```
19270: 3676:
19271: 3677:这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。**SelfBounded** 类接受泛型参数 **T**，而 **T** 由一个边界类限定，这个边界就是拥有 **T** 作为其参数的 **SelfBounded**。
19272: 3678:
19273: 3679:当你首次看到它时，很难去解析它，它强调的是当 **extends** 关键字用于边界与用来创建子类明显是不同的。
19274: 3680:
19275: 3681:### 古怪的循环泛型
19276: 3682:
19277: 3683:为了理解自限定类型的含义，我们从这个惯用法的一个简单版本入手，它没有自限定的边界。
19278: 3684:
19279: 3685:不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类。也就是说，可以声明：
19280: 3686:
19281: 3687:```java
19282: 3688:// generics/CuriouslyRecurringGeneric.java
19283: 3689:
19284: 3690:class GenericType<T> {}
19285: 3691:
19286: 3692:public class CuriouslyRecurringGeneric
19287: 3693:  extends GenericType<CuriouslyRecurringGeneric> {}
19288: 3694:```
19289: 3695:
19290: 3696:这可以按照 Jim Coplien 在 C++ 中的*古怪的循环模版模式*的命名方式，称为古怪的循环泛型（CRG）。“古怪的循环”是指类相当古怪地出现在它自己的基类中这一事实。
19291: 3697:为了理解其含义，努力大声说：“我在创建一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为其参数。”当给出导出类的名字时，这个泛型基类能够实现什么呢？好吧，Java 中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为其参数和返回类型的基类。它还能将导出类型用作其域类型，尽管这些将被擦除为 **Object** 的类型。下面是表示了这种情况的一个泛型类：
19292: 3698:
19293: 3699:```java
19294: 3700:// generics/BasicHolder.java
19295: 3701:
19296: 3702:public class BasicHolder<T> {
19297: 3703:    T element;
19298: 3704:    void set(T arg) { element = arg; }
19299: 3705:    T get() { return element; }
19300: 3706:    void f() {
19301: 3707:        System.out.println(element.getClass().getSimpleName());
19302: 3708:    }
19303: 3709:}
19304: 3710:```
19305: 3711:
19306: 3712:这是一个普通的泛型类型，它的一些方法将接受和产生具有其参数类型的对象，还有一个方法在其存储的域上执行操作（尽管只是在这个域上执行 **Object** 操作）。
19307: 3713:我们可以在一个古怪的循环泛型中使用 **BasicHolder**：
19308: 3714:
19309: 3715:```java
19310: 3716:// generics/CRGWithBasicHolder.java
19311: 3717:
19312: 3718:class Subtype extends BasicHolder<Subtype> {}
19313: 3719:
19314: 3720:public class CRGWithBasicHolder {
19315: 3721:    public static void main(String[] args) {
19316: 3722:        Subtype st1 = new Subtype(), st2 = new Subtype();
19317: 3723:        st1.set(st2);
19318: 3724:        Subtype st3 = st1.get();
19319: 3725:        st1.f();
19320: 3726:    }
19321: 3727:}
19322: 3728:/* Output:
19323: 3729:Subtype
19324: 3730:*/
19325: 3731:```
19326: 3732:
19327: 3733:注意，这里有些东西很重要：新类 **Subtype** 接受的参数和返回的值具有 **Subtype** 类型而不仅仅是基类 **BasicHolder** 类型。这就是 CRG 的本质：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型。也就是说，在所产生的类中将使用确切类型而不是基类型。因此，在**Subtype** 中，传递给 `set()` 的参数和从 `get()` 返回的类型都是确切的 **Subtype**。
19328: 3734:
19329: 3735:### 自限定
19330: 3736:
19331: 3737:**BasicHolder** 可以使用任何类型作为其泛型参数，就像下面看到的那样：
19332: 3738:
19333: 3739:```java
19334: 3740:// generics/Unconstrained.java
19335: 3741:// (c)2017 MindView LLC: see Copyright.txt
19336: 3742:// We make no guarantees that this code is fit for any purpose.
19337: 3743:// Visit http://OnJava8.com for more book information.
19338: 3744:
19339: 3745:class Other {}
19340: 3746:class BasicOther extends BasicHolder<Other> {}
19341: 3747:
19342: 3748:public class Unconstrained {
19343: 3749:    public static void main(String[] args) {
19344: 3750:        BasicOther b = new BasicOther();
19345: 3751:        BasicOther b2 = new BasicOther();
19346: 3752:        b.set(new Other());
19347: 3753:        Other other = b.get();
19348: 3754:        b.f();
19349: 3755:    }
19350: 3756:}
19351: 3757:/* Output:
19352: 3758:Other
19353: 3759:*/
19354: 3760:```
19355: 3761:
19356: 3762:限定将采取额外的步骤，强制泛型当作其自身的边界参数来使用。观察所产生的类可以如何使用以及不可以如何使用：
19357: 3763:
19358: 3764:```java
19359: 3765:// generics/SelfBounding.java
19360: 3766:
19361: 3767:class SelfBounded<T extends SelfBounded<T>> {
19362: 3768:    T element;
19363: 3769:    SelfBounded<T> set(T arg) {
19364: 3770:        element = arg;
19365: 3771:        return this;
19366: 3772:    }
19367: 3773:    T get() { return element; }
19368: 3774:}
19369: 3775:
19370: 3776:class A extends SelfBounded<A> {}
19371: 3777:class B extends SelfBounded<A> {} // Also OK
19372: 3778:
19373: 3779:class C extends SelfBounded<C> {
19374: 3780:    C setAndGet(C arg) { 
19375: 3781:        set(arg); 
19376: 3782:        return get();
19377: 3783:    }
19378: 3784:}
19379: 3785:
19380: 3786:class D {}
19381: 3787:// Can't do this:
19382: 3788:// class E extends SelfBounded<D> {}
19383: 3789:// Compile error:
19384: 3790://   Type parameter D is not within its bound
19385: 3791:
19386: 3792:// Alas, you can do this, so you cannot force the idiom:
19387: 3793:class F extends SelfBounded {}
19388: 3794:
19389: 3795:public class SelfBounding {
19390: 3796:    public static void main(String[] args) {
19391: 3797:        A a = new A();
19392: 3798:        a.set(new A());
19393: 3799:        a = a.set(new A()).get();
19394: 3800:        a = a.get();
19395: 3801:        C c = new C();
19396: 3802:        c = c.setAndGet(new C());
19397: 3803:    }
19398: 3804:}
19399: 3805:```
19400: 3806:
19401: 3807:自限定所做的，就是要求在继承关系中，像下面这样使用这个类：
19402: 3808:
19403: 3809:```java
19404: 3810:class A extends SelfBounded<A>{}
19405: 3811:```
19406: 3812:
19407: 3813:这会强制要求将正在定义的类当作参数传递给基类。
19408: 3814:
19409: 3815:自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。正如你在 B 类的定义中所看到的，还可以从使用了另一个 **SelfBounded** 参数的 **SelfBounded** 中导出，尽管在 **A** 类看到的用法看起来是主要的用法。对定义 **E** 的尝试说明不能使用不是 **SelfBounded** 的类型参数。
19410: 3816:遗憾的是， **F** 可以编译，不会有任何警告，因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型。
19411: 3817:注意，可以移除自限定这个限制，这样所有的类仍旧是可以编译的，但是 **E** 也会因此而变得可编译：
19412: 3818:
19413: 3819:```java
19414: 3820:// generics/NotSelfBounded.java
19415: 3821:
19416: 3822:public class NotSelfBounded<T> {
19417: 3823:    T element;
19418: 3824:    NotSelfBounded<T> set(T arg) {
19419: 3825:        element = arg;
19420: 3826:        return this;
19421: 3827:    }
19422: 3828:    T get() { return element; }
19423: 3829:} 
19424: 3830:
19425: 3831:class A2 extends NotSelfBounded<A2> {}
19426: 3832:class B2 extends NotSelfBounded<A2> {}
19427: 3833:
19428: 3834:class C2 extends NotSelfBounded<C2> {
19429: 3835:    C2 setAndGet(C2 arg) { 
19430: 3836:        set(arg); 
19431: 3837:        return get(); 
19432: 3838:    }
19433: 3839:}
19434: 3840:
19435: 3841:class D2 {}
19436: 3842:// Now this is OK:
19437: 3843:class E2 extends NotSelfBounded<D2> {}
19438: 3844:```
19439: 3845:
19440: 3846:因此很明显，自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。这会强制要求使用这个类的每个人都要遵循这种形式。
19441: 3847:还可以将自限定用于泛型方法：
19442: 3848:
19443: 3849:```java
19444: 3850:// generics/SelfBoundingMethods.java
19445: 3851:// (c)2017 MindView LLC: see Copyright.txt
19446: 3852:// We make no guarantees that this code is fit for any purpose.
19447: 3853:// Visit http://OnJava8.com for more book information.
19448: 3854:
19449: 3855:public class SelfBoundingMethods {
19450: 3856:    static <T extends SelfBounded<T>> T f(T arg) {
19451: 3857:        return arg.set(arg).get();
19452: 3858:    }
19453: 3859:    
19454: 3860:    public static void main(String[] args) {
19455: 3861:        A a = f(new A());
19456: 3862:    }
19457: 3863:}
19458: 3864:```
19459: 3865:
19460: 3866:这可以防止这个方法被应用于除上述形式的自限定参数之外的任何事物上。
19461: 3867:
19462: 3868:### 参数协变
19463: 3869:
19464: 3870:自限定类型的价值在于它们可以产生*协变参数类型*——方法参数类型会随子类而变化。
19465: 3871:
19466: 3872:尽管自限定类型还可以产生与子类类型相同的返回类型，但是这并不十分重要，因为*协变返回类型*是在 Java 5 引入：
19467: 3873:
19468: 3874:```java
19469: 3875:// generics/CovariantReturnTypes.java
19470: 3876:
19471: 3877:class Base {}
19472: 3878:class Derived extends Base {}
19473: 3879:
19474: 3880:interface OrdinaryGetter {
19475: 3881:    Base get();
19476: 3882:}
19477: 3883:
19478: 3884:interface DerivedGetter extends OrdinaryGetter {
19479: 3885:    // Overridden method return type can vary:
19480: 3886:    @Override
19481: 3887:    Derived get();
19482: 3888:}
19483: 3889:
19484: 3890:public class CovariantReturnTypes {
19485: 3891:    void test(DerivedGetter d) {
19486: 3892:        Derived d2 = d.get();
19487: 3893:    }
19488: 3894:}
19489: 3895:```
19490: 3896:
19491: 3897:**DerivedGetter** 中的 `get()` 方法覆盖了 **OrdinaryGetter** 中的 `get()` ，并返回了一个从 `OrdinaryGetter.get()` 的返回类型中导出的类型。尽管这是完全合乎逻辑的事情（导出类方法应该能够返回比它覆盖的基类方法更具体的类型）但是这在早先的 Java 版本中是不合法的。
19492: 3898:
19493: 3899:自限定泛型事实上将产生确切的导出类型作为其返回值，就像在 `get()` 中所看到的一样：
19494: 3900:
19495: 3901:```java
19496: 3902:// generics/GenericsAndReturnTypes.java
19497: 3903:
19498: 3904:interface GenericGetter<T extends GenericGetter<T>> {
19499: 3905:    T get();
19500: 3906:}
19501: 3907:
19502: 3908:interface Getter extends GenericGetter<Getter> {}
19503: 3909:
19504: 3910:public class GenericsAndReturnTypes {
19505: 3911:    void test(Getter g) {
19506: 3912:        Getter result = g.get();
19507: 3913:        GenericGetter gg = g.get(); // Also the base type
19508: 3914:    }
19509: 3915:}
19510: 3916:```
19511: 3917:
19512: 3918:注意，这段代码不能编译，除非是使用囊括了协变返回类型的 Java 5。
19513: 3919:
19514: 3920:然而，在非泛型代码中，参数类型不能随子类型发生变化：
19515: 3921:
19516: 3922:```java
19517: 3923:// generics/OrdinaryArguments.java
19518: 3924:
19519: 3925:class OrdinarySetter {
19520: 3926:    void set(Base base) {
19521: 3927:        System.out.println("OrdinarySetter.set(Base)");
19522: 3928:    }
19523: 3929:}
19524: 3930:
19525: 3931:class DerivedSetter extends OrdinarySetter {
19526: 3932:    void set(Derived derived) {
19527: 3933:        System.out.println("DerivedSetter.set(Derived)");
19528: 3934:    }
19529: 3935:}
19530: 3936:
19531: 3937:public class OrdinaryArguments {
19532: 3938:    public static void main(String[] args) {
19533: 3939:        Base base = new Base();
19534: 3940:        Derived derived = new Derived();
19535: 3941:        DerivedSetter ds = new DerivedSetter();
19536: 3942:        ds.set(derived);
19537: 3943:        // Compiles--overloaded, not overridden!:
19538: 3944:        ds.set(base);
19539: 3945:    }
19540: 3946:}
19541: 3947:/* Output:
19542: 3948:DerivedSetter.set(Derived)
19543: 3949:OrdinarySetter.set(Base)
19544: 3950:*/
19545: 3951:```
19546: 3952:
19547: 3953:`set(derived)` 和 `set(base)` 都是合法的，因此 `DerivedSetter.set()` 没有覆盖 `OrdinarySetter.set()` ，而是重载了这个方法。从输出中可以看到，在 **DerivedSetter** 中有两个方法，因此基类版本仍旧是可用的，因此可以证明它被重载过。
19548: 3954:但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类型而不是基类型为参数：
19549: 3955:
19550: 3956:```java
19551: 3957:// generics/SelfBoundingAndCovariantArguments.java
19552: 3958:
19553: 3959:interface SelfBoundSetter<T extends SelfBoundSetter<T>> {
19554: 3960:    void set(T arg);
19555: 3961:}
19556: 3962:
19557: 3963:interface Setter extends SelfBoundSetter<Setter> {}
19558: 3964:
19559: 3965:public class SelfBoundingAndCovariantArguments {
19560: 3966:    void
19561: 3967:    testA(Setter s1, Setter s2, SelfBoundSetter sbs) {
19562: 3968:        s1.set(s2);
19563: 3969:        //- s1.set(sbs);
19564: 3970:        // error: method set in interface SelfBoundSetter<T>
19565: 3971:        // cannot be applied to given types;
19566: 3972:        //     s1.set(sbs);
19567: 3973:        //       ^
19568: 3974:        //   required: Setter
19569: 3975:        //   found: SelfBoundSetter
19570: 3976:        //   reason: argument mismatch;
19571: 3977:        // SelfBoundSetter cannot be converted to Setter
19572: 3978:        //   where T is a type-variable:
19573: 3979:        //     T extends SelfBoundSetter<T> declared in
19574: 3980:        //     interface SelfBoundSetter
19575: 3981:        // 1 error
19576: 3982:    }
19577: 3983:}
19578: 3984:```
19579: 3985:
19580: 3986:编译器不能识别将基类型当作参数传递给 `set()` 的尝试，因为没有任何方法具有这样的签名。实际上，这个参数已经被覆盖。
19581: 3987:如果不使用自限定类型，普通的继承机制就会介入，而你将能够重载，就像在非泛型的情况下一样：
19582: 3988:
19583: 3989:```java
19584: 3990:// generics/PlainGenericInheritance.java
19585: 3991:
19586: 3992:class GenericSetter<T> { // Not self-bounded
19587: 3993:    void set(T arg) {
19588: 3994:        System.out.println("GenericSetter.set(Base)");
19589: 3995:    }
19590: 3996:}
19591: 3997:
19592: 3998:class DerivedGS extends GenericSetter<Base> {
19593: 3999:    void set(Derived derived) {
19594: 4000:        System.out.println("DerivedGS.set(Derived)");
19595: 4001:    }
19596: 4002:}
19597: 4003:
19598: 4004:public class PlainGenericInheritance {
19599: 4005:    public static void main(String[] args) {
19600: 4006:        Base base = new Base();
19601: 4007:        Derived derived = new Derived();
19602: 4008:        DerivedGS dgs = new DerivedGS();
19603: 4009:        dgs.set(derived);
19604: 4010:        dgs.set(base); // Overloaded, not overridden!
19605: 4011:    }
19606: 4012:}
19607: 4013:/* Output:
19608: 4014:DerivedGS.set(Derived)
19609: 4015:GenericSetter.set(Base)
19610: 4016:*/
19611: 4017:```
19612: 4018:
19613: 4019:这段代码在模仿 **OrdinaryArguments.java**；在那个示例中，**DerivedSetter** 继承自包含一个 `set(Base)` 的**OrdinarySetter** 。而这里，**DerivedGS** 继承自泛型创建的也包含有一个 `set(Base)`的 `GenericSetter<Base>`。就像 **OrdinaryArguments.java** 一样，你可以从输出中看到， **DerivedGS** 包含两个  `set()` 的重载版本。如果不使用自限定，将重载参数类型。如果使用了自限定，只能获得方法的一个版本，它将接受确切的参数类型。
19614: 4020:
19615: 4021:<!-- Dynamic Type Safety -->
19616: 4022:
19617: 4023:## 动态类型安全
19618: 4024:
19619: 4025:因为可以向 Java 5 之前的代码传递泛型集合，所以旧式代码仍旧有可能会破坏你的集合。Java 5 的 **java.util.Collections** 中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：静态方法 `checkedCollection()` 、`checkedList()`、 `checkedMap()` 、 `checkedSet()` 、`checkedSortedMap()`和 `checkedSortedSet()`。这些方法每一个都会将你希望动态检查的集合当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。
19620: 4026:
19621: 4027:受检查的集合在你试图插入类型不正确的对象时抛出 **ClassCastException** ，这与泛型之前的（原生）集合形成了对比，对于后者来说，当你将对象从集合中取出时，才会通知你出现了问题。在后一种情况中，你知道存在问题，但是不知道罪魁祸首在哪里，如果使用受检查的集合，就可以发现谁在试图插入不良对象。
19622: 4028:让我们用受检查的集合来看看“将猫插入到狗列表中”这个问题。这里，`oldStyleMethod()` 表示遗留代码，因为它接受的是原生的 **List** ，而 **@SuppressWarnings（“unchecked”）** 注解对于压制所产生的警告是必需的：
19623: 4029:
19624: 4030:```java
19625: 4031:// generics/CheckedList.java
19626: 4032:// Using Collection.checkedList()
19627: 4033:import typeinfo.pets.*;
19628: 4034:import java.util.*;
19629: 4035:
19630: 4036:public class CheckedList {
19631: 4037:    @SuppressWarnings("unchecked")
19632: 4038:    static void oldStyleMethod(List probablyDogs) {
19633: 4039:        probablyDogs.add(new Cat());
19634: 4040:    }
19635: 4041:    
19636: 4042:    public static void main(String[] args) {
19637: 4043:        List<Dog> dogs1 = new ArrayList<>();
19638: 4044:        oldStyleMethod(dogs1); // Quietly accepts a Cat
19639: 4045:        List<Dog> dogs2 = Collections.checkedList(
19640: 4046:            new ArrayList<>(), Dog.class);
19641: 4047:        try {
19642: 4048:            oldStyleMethod(dogs2); // Throws an exception
19643: 4049:        } catch(Exception e) {
19644: 4050:            System.out.println("Expected: " + e);
19645: 4051:        }
19646: 4052:        // Derived types work fine:
19647: 4053:        List<Pet> pets = Collections.checkedList(
19648: 4054:            new ArrayList<>(), Pet.class);
19649: 4055:        pets.add(new Dog());
19650: 4056:        pets.add(new Cat());
19651: 4057:    }
19652: 4058:}
19653: 4059:/* Output:
19654: 4060:Expected: java.lang.ClassCastException: Attempt to
19655: 4061:insert class typeinfo.pets.Cat element into collection
19656: 4062:with element type class typeinfo.pets.Dog
19657: 4063:*/
19658: 4064:```
19659: 4065:
19660: 4066:运行这个程序时，你会发现插入一个 **Cat** 对于 **dogs1** 来说没有任何问题，而 **dogs2** 立即会在这个错误类型的插入操作上抛出一个异常。还可以看到，将导出类型的对象放置到将要检查基类型的受检查容器中是没有问题的。
19661: 4067:
19662: 4068:<!-- Exceptions -->
19663: 4069:
19664: 4070:## 泛型异常
19665: 4071:
19666: 4072:由于擦除的原因，**catch** 语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承自 **Throwable**（这将进一步阻止你去定义不能捕获的泛型异常）。
19667: 4073:但是，类型参数可能会在一个方法的 **throws** 子句中用到。这使得你可以编写随检查型异常类型变化的泛型代码：
19668: 4074:
19669: 4075:```java
19670: 4076:// generics/ThrowGenericException.java
19671: 4077:
19672: 4078:import java.util.*;
19673: 4079:
19674: 4080:interface Processor<T, E extends Exception> {
19675: 4081:    void process(List<T> resultCollector) throws E;
19676: 4082:}
19677: 4083:
19678: 4084:class ProcessRunner<T, E extends Exception>
19679: 4085:extends ArrayList<Processor<T, E>> {
19680: 4086:    List<T> processAll() throws E {
19681: 4087:        List<T> resultCollector = new ArrayList<>();
19682: 4088:        for(Processor<T, E> processor : this)
19683: 4089:            processor.process(resultCollector);
19684: 4090:        return resultCollector;
19685: 4091:    }
19686: 4092:}
19687: 4093:
19688: 4094:class Failure1 extends Exception {}
19689: 4095:
19690: 4096:class Processor1
19691: 4097:implements Processor<String, Failure1> {
19692: 4098:    static int count = 3;
19693: 4099:    @Override
19694: 4100:    public void process(List<String> resultCollector)
19695: 4101:    throws Failure1 {
19696: 4102:        if(count-- > 1)
19697: 4103:            resultCollector.add("Hep!");
19698: 4104:        else
19699: 4105:            resultCollector.add("Ho!");
19700: 4106:        if(count < 0)
19701: 4107:            throw new Failure1();
19702: 4108:    }
19703: 4109:}
19704: 4110:
19705: 4111:class Failure2 extends Exception {}
19706: 4112:
19707: 4113:class Processor2
19708: 4114:implements Processor<Integer, Failure2> {
19709: 4115:    static int count = 2;
19710: 4116:    @Override
19711: 4117:    public void process(List<Integer> resultCollector)
19712: 4118:    throws Failure2 {
19713: 4119:        if(count-- == 0)
19714: 4120:            resultCollector.add(47);
19715: 4121:        else {
19716: 4122:            resultCollector.add(11);
19717: 4123:        }
19718: 4124:        if(count < 0)
19719: 4125:            throw new Failure2();
19720: 4126:    }
19721: 4127:}
19722: 4128:
19723: 4129:public class ThrowGenericException {
19724: 4130:    public static void main(String[] args) {
19725: 4131:        ProcessRunner<String, Failure1> runner =
19726: 4132:            new ProcessRunner<>();
19727: 4133:        for(int i = 0; i < 3; i++)
19728: 4134:            runner.add(new Processor1());
19729: 4135:        try {
19730: 4136:            System.out.println(runner.processAll());
19731: 4137:        } catch(Failure1 e) {
19732: 4138:            System.out.println(e);
19733: 4139:        }
19734: 4140:
19735: 4141:        ProcessRunner<Integer, Failure2> runner2 =
19736: 4142:            new ProcessRunner<>();
19737: 4143:        for(int i = 0; i < 3; i++)
19738: 4144:            runner2.add(new Processor2());
19739: 4145:        try {
19740: 4146:            System.out.println(runner2.processAll());
19741: 4147:        } catch(Failure2 e) {
19742: 4148:            System.out.println(e);
19743: 4149:        }
19744: 4150:    }
19745: 4151:}
19746: 4152:/* Output:
19747: 4153:[Hep!, Hep!, Ho!]
19748: 4154:Failure2
19749: 4155:*/
19750: 4156:```
19751: 4157:
19752: 4158:**Processor** 执行 `process()` 方法，并且可能会抛出具有类型 **E** 的异常。`process()` 的结果存储在 `List<T>resultCollector` 中（这被称为*收集参数*）。**ProcessRunner** 有一个 `processAll()` 方法，它会在所持有的每个 **Process** 对象执行，并返回 **resultCollector** 。
19753: 4159:如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出这种泛化的代码。
19754: 4160:
19755: 4161:<!-- Mixins -->
19756: 4162:
19757: 4163:## 混型
19758: 4164:
19759: 4165:术语*混型*随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是你最后的手段，它将使组装多个类变得简单易行。
19760: 4166:混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点*面向切面编程* （AOP） 的味道，而切面经常被建议用来解决混型问题。
19761: 4167:
19762: 4168:### C++ 中的混型
19763: 4169:
19764: 4170:在 C++ 中，使用多重继承的最大理由，就是为了使用混型。但是，对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为混型就是继承自其类型参数的类。在 C++ 中，可以很容易地创建混型，因为 C++ 能够记住其模版参数的类型。
19765: 4171:下面是一个 C++ 示例，它有两个混型类型：一个使得你可以在每个对象中混入拥有一个时间戳这样的属性，而另一个可以混入一个序列号。
19766: 4172:
19767: 4173:```c++
19768: 4174:// generics/Mixins.cpp
19769: 4175:
19770: 4176:#include <string>
19771: 4177:#include <ctime>
19772: 4178:#include <iostream>
19773: 4179:using namespace std;
19774: 4180:
19775: 4181:template<class T> class TimeStamped : public T {
19776: 4182:    long timeStamp;
19777: 4183:public:
19778: 4184:    TimeStamped() { timeStamp = time(0); }
19779: 4185:    long getStamp() { return timeStamp; }
19780: 4186:};
19781: 4187:
19782: 4188:template<class T> class SerialNumbered : public T {
19783: 4189:    long serialNumber;
19784: 4190:    static long counter;
19785: 4191:public:
19786: 4192:    SerialNumbered() { serialNumber = counter++; }
19787: 4193:    long getSerialNumber() { return serialNumber; }
19788: 4194:};
19789: 4195:
19790: 4196:// Define and initialize the static storage:
19791: 4197:template<class T> long SerialNumbered<T>::counter = 1;
19792: 4198:
19793: 4199:class Basic {
19794: 4200:    string value;
19795: 4201:public:
19796: 4202:    void set(string val) { value = val; }
19797: 4203:    string get() { return value; }
19798: 4204:};
19799: 4205:
19800: 4206:int main() {
19801: 4207:    TimeStamped<SerialNumbered<Basic>> mixin1, mixin2;
19802: 4208:    mixin1.set("test string 1");
19803: 4209:    mixin2.set("test string 2");
19804: 4210:    cout << mixin1.get() << " " << mixin1.getStamp() <<
19805: 4211:      " " << mixin1.getSerialNumber() << endl;
19806: 4212:    cout << mixin2.get() << " " << mixin2.getStamp() <<
19807: 4213:      " " << mixin2.getSerialNumber() << endl;
19808: 4214:}
19809: 4215:/* Output:
19810: 4216:test string 1 1452987605 1
19811: 4217:test string 2 1452987605 2
19812: 4218:*/
19813: 4219:```
19814: 4220:
19815: 4221:在 `main()` 中， **mixin1** 和 **mixin2** 所产生的类型拥有所混入类型的所有方法。可以将混型看作是一种功能，它可以将现有类映射到新的子类上。注意，使用这种技术来创建一个混型是多么的轻而易举。基本上，只需要声明“这就是我想要的”，紧跟着它就发生了：
19816: 4222:
19817: 4223:```c++
19818: 4224:TimeStamped<SerialNumbered<Basic>> mixin1，mixin2；
19819: 4225:```
19820: 4226:
19821: 4227:遗憾的是，Java 泛型不允许这样。擦除会忘记基类类型，因此
19822: 4228:
19823: 4229:>  泛型类不能直接继承自一个泛型参数
19824: 4230:
19825: 4231:这突显了许多我在 Java 语言设计决策（以及与这些功能一起发布）中遇到的一大问题：处理一件事很有希望，但是当您实际尝试做一些有趣的事情时，您会发现自己做不到。
19826: 4232:
19827: 4233:### 与接口混合
19828: 4234:
19829: 4235:一种更常见的推荐解决方案是使用接口来产生混型效果，就像下面这样：
19830: 4236:
19831: 4237:```java
19832: 4238:// generics/Mixins.java
19833: 4239:
19834: 4240:import java.util.*;
19835: 4241:
19836: 4242:interface TimeStamped { long getStamp(); }
19837: 4243:
19838: 4244:class TimeStampedImp implements TimeStamped {
19839: 4245:    private final long timeStamp;
19840: 4246:    TimeStampedImp() {
19841: 4247:        timeStamp = new Date().getTime();
19842: 4248:    }
19843: 4249:    @Override
19844: 4250:    public long getStamp() { return timeStamp; }
19845: 4251:}
19846: 4252:
19847: 4253:interface SerialNumbered { long getSerialNumber(); }
19848: 4254:
19849: 4255:class SerialNumberedImp implements SerialNumbered {
19850: 4256:    private static long counter = 1;
19851: 4257:    private final long serialNumber = counter++;
19852: 4258:    @Override
19853: 4259:    public long getSerialNumber() { return serialNumber; }
19854: 4260:}
19855: 4261:
19856: 4262:interface Basic {
19857: 4263:    void set(String val);
19858: 4264:    String get();
19859: 4265:}
19860: 4266:
19861: 4267:class BasicImp implements Basic {
19862: 4268:    private String value;
19863: 4269:    @Override
19864: 4270:    public void set(String val) { value = val; }
19865: 4271:    @Override
19866: 4272:    public String get() { return value; }
19867: 4273:}
19868: 4274:
19869: 4275:class Mixin extends BasicImp
19870: 4276:implements TimeStamped, SerialNumbered {
19871: 4277:    private TimeStamped timeStamp = new TimeStampedImp();
19872: 4278:    private SerialNumbered serialNumber =
19873: 4279:        new SerialNumberedImp();
19874: 4280:    @Override
19875: 4281:    public long getStamp() {
19876: 4282:        return timeStamp.getStamp();
19877: 4283:    }
19878: 4284:    @Override
19879: 4285:    public long getSerialNumber() {
19880: 4286:        return serialNumber.getSerialNumber();
19881: 4287:    }
19882: 4288:}
19883: 4289:
19884: 4290:public class Mixins {
19885: 4291:    public static void main(String[] args) {
19886: 4292:        Mixin mixin1 = new Mixin(), mixin2 = new Mixin();
19887: 4293:        mixin1.set("test string 1");
19888: 4294:        mixin2.set("test string 2");
19889: 4295:        System.out.println(mixin1.get() + " " +
19890: 4296:            mixin1.getStamp() +  " " + mixin1.getSerialNumber());
19891: 4297:        System.out.println(mixin2.get() + " " +
19892: 4298:            mixin2.getStamp() +  " " + mixin2.getSerialNumber());
19893: 4299:    }
19894: 4300:}
19895: 4301:/* Output:
19896: 4302:test string 1 1494331663026 1
19897: 4303:test string 2 1494331663027 2
19898: 4304:*/
19899: 4305:```
19900: 4306:
19901: 4307:**Mixin** 类基本上是在使用*委托*，因此每个混入类型都要求在 **Mixin** 中有一个相应的域，而你必须在 **Mixin** 中编写所有必需的方法，将方法调用转发给恰当的对象。这个示例使用了非常简单的类，但是当使用更复杂的混型时，代码数量会急速增加。[^4]
19902: 4308:
19903: 4309:### 使用装饰器模式
19904: 4310:
19905: 4311:当你观察混型的使用方式时，就会发现混型概念好像与*装饰器*设计模式关系很近。装饰器经常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的。
19906: 4312:装饰器模式使用分层对象来动态透明地向单个对象中添加责任。装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。某些事物是可装饰的，可以通过将其他类包装在这个可装饰对象的四周，来将功能分层。这使得对装饰器的使用是透明的——无论对象是否被装饰，你都拥有一个可以向对象发送的公共消息集。装饰类也可以添加新方法，但是正如你所见，这将是受限的。
19907: 4313:装饰器是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。
19908: 4314:前面的示例可以被改写为使用装饰器：
19909: 4315:
19910: 4316:```java
19911: 4317:// generics/decorator/Decoration.java
19912: 4318:
19913: 4319:// {java generics.decorator.Decoration}
19914: 4320:package generics.decorator;
19915: 4321:import java.util.*;
19916: 4322:
19917: 4323:class Basic {
19918: 4324:    private String value;
19919: 4325:    public void set(String val) { value = val; }
19920: 4326:    public String get() { return value; }
19921: 4327:}
19922: 4328:
19923: 4329:class Decorator extends Basic {
19924: 4330:    protected Basic basic;
19925: 4331:    Decorator(Basic basic) { this.basic = basic; }
19926: 4332:    @Override
19927: 4333:    public void set(String val) { basic.set(val); }
19928: 4334:    @Override
19929: 4335:    public String get() { return basic.get(); }
19930: 4336:}
19931: 4337:
19932: 4338:class TimeStamped extends Decorator {
19933: 4339:    private final long timeStamp;
19934: 4340:    TimeStamped(Basic basic) {
19935: 4341:        super(basic);
19936: 4342:        timeStamp = new Date().getTime();
19937: 4343:    }
19938: 4344:    public long getStamp() { return timeStamp; }
19939: 4345:}
19940: 4346:
19941: 4347:class SerialNumbered extends Decorator {
19942: 4348:    private static long counter = 1;
19943: 4349:    private final long serialNumber = counter++;
19944: 4350:    SerialNumbered(Basic basic) { super(basic); }
19945: 4351:    public long getSerialNumber() { return serialNumber; }
19946: 4352:}
19947: 4353:
19948: 4354:public class Decoration {
19949: 4355:    public static void main(String[] args) {
19950: 4356:        TimeStamped t = new TimeStamped(new Basic());
19951: 4357:        TimeStamped t2 = new TimeStamped(
19952: 4358:            new SerialNumbered(new Basic()));
19953: 4359:        //- t2.getSerialNumber(); // Not available
19954: 4360:        SerialNumbered s = new SerialNumbered(new Basic());
19955: 4361:        SerialNumbered s2 = new SerialNumbered(
19956: 4362:            new TimeStamped(new Basic()));
19957: 4363:        //- s2.getStamp(); // Not available
19958: 4364:  }
19959: 4365:}
19960: 4366:```
19961: 4367:
19962: 4368:产生自泛型的类包含所有感兴趣的方法，但是由使用装饰器所产生的对象类型是最后被装饰的类型。也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。因此，装饰器只是对由混型提出的问题的一种局限的解决方案。
19963: 4369:
19964: 4370:### 与动态代理混合
19965: 4371:
19966: 4372:可以使用动态代理来创建一种比装饰器更贴近混型模型的机制（查看 [类型信息](book/19-Type-Information.md) 一章中关于 Java 的动态代理如何工作的解释）。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。
19967: 4373:由于动态代理的限制，每个被混入的类都必须是某个接口的实现：
19968: 4374:
19969: 4375:```java
19970: 4376:// generics/DynamicProxyMixin.java
19971: 4377:
19972: 4378:import java.lang.reflect.*;
19973: 4379:import java.util.*;
19974: 4380:import onjava.*;
19975: 4381:import static onjava.Tuple.*;
19976: 4382:
19977: 4383:class MixinProxy implements InvocationHandler {
19978: 4384:    Map<String, Object> delegatesByMethod;
19979: 4385:    @SuppressWarnings("unchecked")
19980: 4386:    MixinProxy(Tuple2<Object, Class<?>>... pairs) {
19981: 4387:        delegatesByMethod = new HashMap<>();
19982: 4388:        for(Tuple2<Object, Class<?>> pair : pairs) {
19983: 4389:            for(Method method : pair.a2.getMethods()) {
19984: 4390:                String methodName = method.getName();
19985: 4391:                // The first interface in the map
19986: 4392:                // implements the method.
19987: 4393:                if(!delegatesByMethod.containsKey(methodName))
19988: 4394:                    delegatesByMethod.put(methodName, pair.a1);
19989: 4395:            }
19990: 4396:        }
19991: 4397:    }
19992: 4398:    @Override
19993: 4399:    public Object invoke(Object proxy, Method method,
19994: 4400:      Object[] args) throws Throwable {
19995: 4401:        String methodName = method.getName();
19996: 4402:        Object delegate = delegatesByMethod.get(methodName);
19997: 4403:        return method.invoke(delegate, args);
19998: 4404:    }
19999: 4405:    
20000: 4406:    @SuppressWarnings("unchecked")
20001: 4407:    public static Object newInstance(Tuple2... pairs) {
20002: 4408:        Class[] interfaces = new Class[pairs.length];
20003: 4409:        for(int i = 0; i < pairs.length; i++) {
20004: 4410:            interfaces[i] = (Class)pairs[i].a2;
20005: 4411:        }
20006: 4412:        ClassLoader cl = pairs[0].a1.getClass().getClassLoader();
20007: 4413:        return Proxy.newProxyInstance(cl, interfaces, new MixinProxy(pairs));
20008: 4414:    }
20009: 4415:}
20010: 4416:
20011: 4417:public class DynamicProxyMixin {
20012: 4418:    public static void main(String[] args) {
20013: 4419:        Object mixin = MixinProxy.newInstance(
20014: 4420:          tuple(new BasicImp(), Basic.class),
20015: 4421:          tuple(new TimeStampedImp(), TimeStamped.class),
20016: 4422:          tuple(new SerialNumberedImp(), SerialNumbered.class));
20017: 4423:        Basic b = (Basic)mixin;
20018: 4424:        TimeStamped t = (TimeStamped)mixin;
20019: 4425:        SerialNumbered s = (SerialNumbered)mixin;
20020: 4426:        b.set("Hello");
20021: 4427:        System.out.println(b.get());
20022: 4428:        System.out.println(t.getStamp());
20023: 4429:        System.out.println(s.getSerialNumber());
20024: 4430:    }
20025: 4431:}
20026: 4432:/* Output:
20027: 4433:Hello
20028: 4434:1494331653339
20029: 4435:1
20030: 4436:*/
20031: 4437:```
20032: 4438:
20033: 4439:因为只有动态类型而不是静态类型才包含所有的混入类型，因此这仍旧不如 C++ 的方式好，因为可以在具有这些类型的对象上调用方法之前，你被强制要求必须先将这些对象向下转型到恰当的类型。但是，它明显地更接近于真正的混型。
20034: 4440:为了让 Java 支持混型，人们已经做了大量的工作朝着这个目标努力，包括创建了至少一种附加语言（ Jam 语言），它是专门用来支持混型的。
20035: 4441:
20036: 4442:<!-- Latent Typing -->
20037: 4443:
20038: 4444:## 潜在类型机制
20039: 4445:
20040: 4446:在本章的开头介绍过这样的思想，即要编写能够尽可能广泛地应用的代码。为了实现这一点，我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处。然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码。
20041: 4447:
20042: 4448:Java 泛型看起来是向这一方向迈进了一步。当你在编写或使用只是持有对象的泛型时，这些代码将可以工作于任何类型（除了基本类型，尽管正如你所见到的，自动装箱机制可以克服这一点）。或者，换个角度讲，“持有器”泛型能够声明：“我不关心你是什么类型”。如果代码不关心它将要作用的类型，那么这种代码就可以真正地应用于任何地方，并因此而相当泛化。
20043: 4449:
20044: 4450:还是正如你所见到的，当要在泛型类型上执行操作（即调用 **Object** 方法之外的方法）时，就会产生问题。擦除强制要求指定可能会用到的泛型类型的边界，以安全地调用代码中的泛型对象上的具体方法。这是对“泛化”概念的一种明显的限制，因为必须限制你的泛型类型，使它们继承自特定的类，或者实现特定的接口。在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类或接口没有任何区别。
20045: 4451:
20046: 4452:某些编程语言提供的一种解决方案称为*潜在类型机制*或*结构化类型机制*，而更古怪的术语称为*鸭子类型机制*，即“如果它走起来像鸭子，并且叫起来也像鸭子，那么你就可以将它当作鸭子对待。”鸭子类型机制变成了一种相当流行的术语，可能是因为它不像其他的术语那样承载着历史的包袱。
20047: 4453:
20048: 4454:泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得你可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以 `speak()` 和 `sit()` 即可。”由于不要求具体类型，因此代码就可以更加泛化。
20049: 4455:
20050: 4456:潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方。
20051: 4457:
20052: 4458:支持潜在类型机制的语言包括 Python（可以从 www.Python.org 免费下载）、C++、Ruby、SmallTalk 和 Go。Python 是动态类型语言（几乎所有的类型检查都发生在运行时），而 C++ 和 Go 是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查。
20053: 4459:
20054: 4460:### pyhton 中的潜在类型
20055: 4461:
20056: 4462:如果我们将上面的描述用 Python 来表示，如下所示：
20057: 4463:
20058: 4464:```python
20059: 4465:# generics/DogsAndRobots.py
20060: 4466:
20061: 4467:class Dog:
20062: 4468:    def speak(self):
20063: 4469:        print("Arf!")
20064: 4470:    def sit(self):
20065: 4471:        print("Sitting")
20066: 4472:    def reproduce(self):
20067: 4473:        pass
20068: 4474:
20069: 4475:class Robot:
20070: 4476:    def speak(self):
20071: 4477:        print("Click!")
20072: 4478:    def sit(self):
20073: 4479:        print("Clank!")
20074: 4480:    def oilChange(self):
20075: 4481:        pass
20076: 4482:
20077: 4483:def perform(anything):
20078: 4484:    anything.speak()
20079: 4485:    anything.sit()
20080: 4486:
20081: 4487:a = Dog()
20082: 4488:b = Robot()
20083: 4489:perform(a)
20084: 4490:perform(b)
20085: 4491:
20086: 4492:output = """
20087: 4493:Arf!
20088: 4494:Sitting
20089: 4495:Click!
20090: 4496:Clank!
20091: 4497:"""
20092: 4498:```
20093: 4499:
20094: 4500:Python 使用缩进来确定作用域（因此不需要任何花括号），而冒号将表示新的作用域的开始。“**#**” 表示注释到行尾，就像Java中的 “ **//** ”。类的方法需要显式地指定 **this** 引用的等价物作为第一个参数，按惯例成为 **self** 。构造器调用不要求任何类型的“ **new** ”关键字，并且 Python 允许普通（非成员）函数，就像 `perform()` 所表明的那样。注意，在 `perform(anything)` 中，没有任何针对 **anything** 的类型，**anything** 只是一个标识符，它必须能够执行 `perform()` 期望它执行的操作，因此这里隐含着一个接口。但是你从来都不必显式地写出这个接口——它是潜在的。`perform()` 不关心其参数的类型，因此我可以向它传递任何对象，只要该对象支持  `speak()` 和 `sit()` 方法。如果传递给 `perform()` 的对象不支持这些操作，那么将会得到运行时异常。
20095: 4501:
20096: 4502:输出规定使用三重引号创建带有内嵌换行符的字符串。
20097: 4503:
20098: 4504:### C++ 中的潜在类型
20099: 4505:
20100: 4506:我们可以用 C++ 产生相同的效果：
20101: 4507:
20102: 4508:```c++
20103: 4509:// generics/DogsAndRobots.cpp
20104: 4510:
20105: 4511:#include <iostream>
20106: 4512:using namespace std;
20107: 4513:
20108: 4514:class Dog {
20109: 4515:public:
20110: 4516:    void speak() { cout << "Arf!" << endl; }
20111: 4517:    void sit() { cout << "Sitting" << endl; }
20112: 4518:    void reproduce() {}
20113: 4519:};
20114: 4520:
20115: 4521:class Robot {
20116: 4522:public:
20117: 4523:    void speak() { cout << "Click!" << endl; }
20118: 4524:    void sit() { cout << "Clank!" << endl; }
20119: 4525:    void oilChange() {}
20120: 4526:};
20121: 4527:
20122: 4528:template<class T> void perform(T anything) {
20123: 4529:    anything.speak();
20124: 4530:    anything.sit();
20125: 4531:}
20126: 4532:
20127: 4533:int main() {
20128: 4534:    Dog d;
20129: 4535:    Robot r;
20130: 4536:    perform(d);
20131: 4537:    perform(r);
20132: 4538:}
20133: 4539:/* Output:
20134: 4540:Arf!
20135: 4541:Sitting
20136: 4542:Click!
20137: 4543:Clank!
20138: 4544:*/
20139: 4545:```
20140: 4546:
20141: 4547:在 Python 和 C++ 中，**Dog** 和 **Robot** 没有任何共同的东西，只是碰巧有两个方法具有相同的签名。从类型的观点看，它们是完全不同的类型。但是，`perform()` 不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。
20142: 4548:C++ 确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给你一个错误消息（这些错误消息从历史上看是相当可怕和冗长的，是 C++ 的模版名声欠佳的主要原因）。尽管它们是在不同时期实现这一点的，C++ 在编译期，而 Python 在运行时，但是这两种语言都可以确保类型不会被误用，因此被认为是强类型的。[^5]潜在类型机制没有损害强类型机制。
20143: 4549:
20144: 4550:### Go 中的潜在类型
20145: 4551:
20146: 4552:这里用 Go 语言编写相同的程序：
20147: 4553:
20148: 4554:```go
20149: 4555:// generics/dogsandrobots.go
20150: 4556:
20151: 4557:package main
20152: 4558:import "fmt"
20153: 4559:
20154: 4560:type Dog struct {}
20155: 4561:func (this Dog) speak() { fmt.Printf("Arf!\n")}
20156: 4562:func (this Dog) sit() { fmt.Printf("Sitting\n")}
20157: 4563:func (this Dog) reproduce() {}
20158: 4564:
20159: 4565:type Robot struct {}
20160: 4566:func (this Robot) speak() { fmt.Printf("Click!\n") }
20161: 4567:func (this Robot) sit() { fmt.Printf("Clank!\n") }
20162: 4568:func (this Robot) oilChange() {}
20163: 4569:
20164: 4570:func perform(speaker interface { speak(); sit() }) {
20165: 4571:  speaker.speak();
20166: 4572:  speaker.sit();
20167: 4573:}
20168: 4574:
20169: 4575:func main() {
20170: 4576:  perform(Dog{})
20171: 4577:  perform(Robot{})
20172: 4578:}
20173: 4579:/* Output:
20174: 4580:Arf!
20175: 4581:Sitting
20176: 4582:Click!
20177: 4583:Clank!
20178: 4584:*/
20179: 4585:```
20180: 4586:
20181: 4587:Go 没有 **class** 关键字，但是可以使用上述形式创建等效的基本类：它通常不定义为类，而是定义为 **struct** ，在其中定义数据字段（此处不存在）。 对于每种方法，都以 **func** 关键字开头，然后（为了将该方法附加到您的类上）放在括号中，该括号包含对象引用，该对象引用可以是任何标识符，但是我在这里使用 **this** 来提醒您，就像在 C ++ 或 Java 中的 **this** 一样。 然后，在Go中像这样定义其余的函数。
20182: 4588:
20183: 4589:Go也没有继承关系，因此这种“面向对象的目标”形式是相对原始的，并且可能是我无法花更多的时间来学习该语言的主要原因。 但是，Go 的组成很简单。
20184: 4590:
20185: 4591:`perform()` 函数使用潜在类型：参数的确切类型并不重要，只要它包含了 `speak()` 和  `sit()` 方法即可。 该接口在此处匿名定义，内联，如 `perform()` 的参数列表所示。
20186: 4592:
20187: 4593:`main()` 证明 `perform()` 确实对其参数的确切类型不在乎，只要可以在该参数上调用 `talk()` 和 `sit()` 即可。 但是，就像 C ++ 模板函数一样，在编译时检查类型。
20188: 4594:
20189: 4595:语法 **Dog {}** 和 **Robot {}** 创建匿名的 **Dog** 和 **Robot** 结构。
20190: 4596:
20191: 4597:### java中的直接潜在类型
20192: 4598:
20193: 4599:因为泛型是在这场竞赛的后期才添加到 Java 中，因此没有任何机会可以去实现任何类型的潜在类型机制，因此 Java 没有对这种特性的支持。所以，初看起来，Java 的泛型机制比支持潜在类型机制的语言更“缺乏泛化性”。（使用擦除来实现 Java 泛型的实现有时称为第二类泛型类型）例如，在 Java 8  之前如果我们试图用 Java 实现上面 dogs-and-robots 的示例，那么就会被强制要求使用一个类或接口，并在边界表达式中指定它：
20194: 4600:
20195: 4601:```java
20196: 4602:// generics/Performs.java
20197: 4603:
20198: 4604:public interface Performs {
20199: 4605:    void speak();
20200: 4606:    void sit();
20201: 4607:}
20202: 4608:```
20203: 4609:
20204: 4610:```java
20205: 4611:// generics/DogsAndRobots.java
20206: 4612:// No (direct) latent typing in Java
20207: 4613:import typeinfo.pets.*;
20208: 4614:
20209: 4615:class PerformingDog extends Dog implements Performs {
20210: 4616:    @Override
20211: 4617:    public void speak() { System.out.println("Woof!"); }
20212: 4618:    @Override
20213: 4619:    public void sit() { System.out.println("Sitting"); }
20214: 4620:    public void reproduce() {}
20215: 4621:}
20216: 4622:
20217: 4623:class Robot implements Performs {
20218: 4624:    public void speak() { System.out.println("Click!"); }
20219: 4625:    public void sit() { System.out.println("Clank!"); }
20220: 4626:    public void oilChange() {}
20221: 4627:}
20222: 4628:
20223: 4629:class Communicate {
20224: 4630:    public static <T extends Performs>
20225: 4631:      void perform(T performer) {
20226: 4632:        performer.speak();
20227: 4633:        performer.sit();
20228: 4634:    }
20229: 4635:}
20230: 4636:
20231: 4637:public class DogsAndRobots {
20232: 4638:    public static void main(String[] args) {
20233: 4639:        Communicate.perform(new PerformingDog());
20234: 4640:        Communicate.perform(new Robot());
20235: 4641:    }
20236: 4642:}
20237: 4643:/* Output:
20238: 4644:Woof!
20239: 4645:Sitting
20240: 4646:Click!
20241: 4647:Clank!
20242: 4648:*/
20243: 4649:```
20244: 4650:
20245: 4651:但是要注意，`perform()` 不需要使用泛型来工作，它可以被简单地指定为接受一个 **Performs** 对象：
20246: 4652:
20247: 4653:```java
20248: 4654:// generics/SimpleDogsAndRobots.java
20249: 4655:// Removing the generic; code still works
20250: 4656:
20251: 4657:class CommunicateSimply {
20252: 4658:    static void perform(Performs performer) {
20253: 4659:        performer.speak();
20254: 4660:        performer.sit();
20255: 4661:    }
20256: 4662:}
20257: 4663:
20258: 4664:public class SimpleDogsAndRobots {
20259: 4665:    public static void main(String[] args) {
20260: 4666:        CommunicateSimply.perform(new PerformingDog());
20261: 4667:        CommunicateSimply.perform(new Robot());
20262: 4668:    }
20263: 4669:}
20264: 4670:/* Output:
20265: 4671:Woof!
20266: 4672:Sitting
20267: 4673:Click!
20268: 4674:Clank!
20269: 4675:*/
20270: 4676:```
20271: 4677:
20272: 4678:在本例中，泛型不是必需的，因为这些类已经被强制要求实现 **Performs** 接口。
20273: 4679:
20274: 4680:<!-- Compensating for the Lack of (Direct) Latent -->
20275: 4681:
20276: 4682:## 对缺乏潜在类型机制的补偿
20277: 4683:
20278: 4684:尽管 Java 不直接支持潜在类型机制，但是这并不意味着泛型代码不能在不同的类型层次结构之间应用。也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。
20279: 4685:
20280: 4686:### 反射
20281: 4687:
20282: 4688:可以使用的一种方式是反射，下面的 `perform()` 方法就是用了潜在类型机制：
20283: 4689:
20284: 4690:```java
20285: 4691:// generics/LatentReflection.java
20286: 4692:// Using reflection for latent typing
20287: 4693:import java.lang.reflect.*;
20288: 4694:
20289: 4695:// Does not implement Performs:
20290: 4696:class Mime {
20291: 4697:    public void walkAgainstTheWind() {}
20292: 4698:    public void sit() {
20293: 4699:        System.out.println("Pretending to sit");
20294: 4700:    }
20295: 4701:    public void pushInvisibleWalls() {}
20296: 4702:    @Override
20297: 4703:    public String toString() { return "Mime"; }
20298: 4704:}
20299: 4705:
20300: 4706:// Does not implement Performs:
20301: 4707:class SmartDog {
20302: 4708:    public void speak() { System.out.println("Woof!"); }
20303: 4709:    public void sit() { System.out.println("Sitting"); }
20304: 4710:    public void reproduce() {}
20305: 4711:}
20306: 4712:
20307: 4713:class CommunicateReflectively {
20308: 4714:    public static void perform(Object speaker) {
20309: 4715:        Class<?> spkr = speaker.getClass();
20310: 4716:        try {
20311: 4717:            try {
20312: 4718:                Method speak = spkr.getMethod("speak");
20313: 4719:                speak.invoke(speaker);
20314: 4720:            } catch(NoSuchMethodException e) {
20315: 4721:                System.out.println(speaker + " cannot speak");
20316: 4722:            }
20317: 4723:            try {
20318: 4724:                Method sit = spkr.getMethod("sit");
20319: 4725:                sit.invoke(speaker);
20320: 4726:            } catch(NoSuchMethodException e) {
20321: 4727:                System.out.println(speaker + " cannot sit");
20322: 4728:            }
20323: 4729:        } catch(SecurityException |
20324: 4730:            IllegalAccessException |
20325: 4731:            IllegalArgumentException |
20326: 4732:            InvocationTargetException e) {
20327: 4733:            throw new RuntimeException(speaker.toString(), e);
20328: 4734:        }
20329: 4735:    }
20330: 4736:}
20331: 4737:
20332: 4738:public class LatentReflection {
20333: 4739:    public static void main(String[] args) {
20334: 4740:        CommunicateReflectively.perform(new SmartDog());
20335: 4741:        CommunicateReflectively.perform(new Robot());
20336: 4742:        CommunicateReflectively.perform(new Mime());
20337: 4743:    }
20338: 4744:}
20339: 4745:/* Output:
20340: 4746:Woof!
20341: 4747:Sitting
20342: 4748:Click!
20343: 4749:Clank!
20344: 4750:Mime cannot speak
20345: 4751:Pretending to sit
20346: 4752:*/
20347: 4753:```
20348: 4754:
20349: 4755:上例中，这些类完全是彼此分离的，没有任何公共基类（除了 **Object** ）或接口。通过反射, `CommunicateReflectively.perform()` 能够动态地确定所需要的方法是否可用并调用它们。它甚至能够处理 **Mime** 只具有一个必需的方法这一事实，并能够部分实现其目标。
20350: 4756:
20351: 4757:### 将一个方法应用于序列
20352: 4758:
20353: 4759:反射提供了一些有用的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。但是有可能实现编译期类型检查和潜在类型机制吗？
20354: 4760:
20355: 4761:让我们看一个说明这个问题的示例。假设想要创建一个 `apply()` 方法，它能够将任何方法应用于某个序列中的所有对象。这种情况下使用接口不适合，因为你想要将任何方法应用于一个对象集合，而接口不可能描述任何方法。如何用 Java 来实现这个需求呢？
20356: 4762:
20357: 4763:最初，我们可以用反射来解决这个问题，由于有了 Java 的可变参数，这种方式被证明是相当优雅的：
20358: 4764:
20359: 4765:```java
20360: 4766:// generics/Apply.java
20361: 4767:
20362: 4768:import java.lang.reflect.*;
20363: 4769:import java.util.*;
20364: 4770:
20365: 4771:public class Apply {
20366: 4772:    public static <T, S extends Iterable<T>>
20367: 4773:      void apply(S seq, Method f, Object... args) {
20368: 4774:        try {
20369: 4775:            for(T t: seq)
20370: 4776:                f.invoke(t, args);
20371: 4777:        } catch(IllegalAccessException |
20372: 4778:            IllegalArgumentException |
20373: 4779:            InvocationTargetException e) {
20374: 4780:            // Failures are programmer errors
20375: 4781:            throw new RuntimeException(e);
20376: 4782:        }
20377: 4783:    }
20378: 4784:}
20379: 4785:```
20380: 4786:
20381: 4787:在 **Apply.java** 中，异常被转换为 **RuntimeException** ，因为没有多少办法可以从这种异常中恢复——在这种情况下，它们实际上代表着程序员的错误。
20382: 4788:
20383: 4789:为什么我们不只使用 Java 8 方法参考（稍后显示）而不是反射方法 **f** ？ 注意，`invoke()` 和 `apply()` 的优点是它们可以接受任意数量的参数。 在某些情况下，灵活性可能至关重要。
20384: 4790:
20385: 4791:为了测试 **Apply** ，我们首先创建一个 **Shape** 类：
20386: 4792:
20387: 4793:```java
20388: 4794:// generics/Shape.java
20389: 4795:
20390: 4796:public class Shape {
20391: 4797:    private static long counter = 0;
20392: 4798:    private final long id = counter++;
20393: 4799:    @Override
20394: 4800:    public String toString() {
20395: 4801:        return getClass().getSimpleName() + " " + id;
20396: 4802:    }
20397: 4803:    public void rotate() {
20398: 4804:        System.out.println(this + " rotate");
20399: 4805:    }
20400: 4806:    public void resize(int newSize) {
20401: 4807:        System.out.println(this + " resize " + newSize);
20402: 4808:    }
20403: 4809:}
20404: 4810:```
20405: 4811:
20406: 4812:被一个子类 **Square** 继承：
20407: 4813:
20408: 4814:```java
20409: 4815:// generics/Square.java
20410: 4816:
20411: 4817:public class Square extends Shape {}
20412: 4818:```
20413: 4819:
20414: 4820:通过这些，我们可以测试 **Apply**：
20415: 4821:
20416: 4822:```java
20417: 4823:// generics/ApplyTest.java
20418: 4824:
20419: 4825:import java.util.*;
20420: 4826:import java.util.function.*;
20421: 4827:import onjava.*;
20422: 4828:
20423: 4829:public class ApplyTest {
20424: 4830:    public static
20425: 4831:    void main(String[] args) throws Exception {
20426: 4832:        List<Shape> shapes =
20427: 4833:          Suppliers.create(ArrayList::new, Shape::new, 3);
20428: 4834:        Apply.apply(shapes, Shape.class.getMethod("rotate"));
20429: 4835:        Apply.apply(shapes, Shape.class.getMethod("resize", int.class), 7);
20430: 4836:
20431: 4837:        List<Square> squares =
20432: 4838:          Suppliers.create(ArrayList::new, Square::new, 3);
20433: 4839:        Apply.apply(squares, Shape.class.getMethod("rotate"));
20434: 4840:        Apply.apply(squares, Shape.class.getMethod("resize", int.class), 7);
20435: 4841:
20436: 4842:        Apply.apply(new FilledList<>(Shape::new, 3),
20437: 4843:          Shape.class.getMethod("rotate"));
20438: 4844:        Apply.apply(new FilledList<>(Square::new, 3),
20439: 4845:          Shape.class.getMethod("rotate"));
20440: 4846:
20441: 4847:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
20442: 4848:          new SimpleQueue<>(), SimpleQueue::add,
20443: 4849:          Shape::new, 3);
20444: 4850:        Suppliers.fill(shapeQ, SimpleQueue::add,
20445: 4851:          Square::new, 3);
20446: 4852:        Apply.apply(shapeQ, Shape.class.getMethod("rotate"));
20447: 4853:    }
20448: 4854:}
20449: 4855:/* Output:
20450: 4856:Shape 0 rotate
20451: 4857:Shape 1 rotate
20452: 4858:Shape 2 rotate
20453: 4859:Shape 0 resize 7
20454: 4860:Shape 1 resize 7
20455: 4861:Shape 2 resize 7
20456: 4862:Square 3 rotate
20457: 4863:Square 4 rotate
20458: 4864:Square 5 rotate
20459: 4865:Square 3 resize 7
20460: 4866:Square 4 resize 7
20461: 4867:Square 5 resize 7
20462: 4868:Shape 6 rotate
20463: 4869:Shape 7 rotate
20464: 4870:Shape 8 rotate
20465: 4871:Square 9 rotate
20466: 4872:Square 10 rotate
20467: 4873:Square 11 rotate
20468: 4874:Shape 12 rotate
20469: 4875:Shape 13 rotate
20470: 4876:Shape 14 rotate
20471: 4877:Square 15 rotate
20472: 4878:Square 16 rotate
20473: 4879:Square 17 rotate
20474: 4880:*/
20475: 4881:```
20476: 4882:
20477: 4883:在 **Apply** 中，我们运气很好，因为碰巧在 Java 中内建了一个由 Java 集合类库使用的 **Iterable** 接口。正由于此， `apply()` 方法可以接受任何实现了 **Iterable** 接口的事物，包括诸如 **List** 这样的所有 **Collection** 类。但是它还可以接受其他任何事物，只要能够使这些事物是 **Iterable** 的——例如，在 `main()` 中使用下面定义的 **SimpleQueue** 类：
20478: 4884:
20479: 4885:```java
20480: 4886:// generics/SimpleQueue.java
20481: 4887:
20482: 4888:// A different kind of Iterable collection
20483: 4889:import java.util.*;
20484: 4890:
20485: 4891:public class SimpleQueue<T> implements Iterable<T> {
20486: 4892:    private LinkedList<T> storage = new LinkedList<>();
20487: 4893:    public void add(T t) { storage.offer(t); }
20488: 4894:    public T get() { return storage.poll(); }
20489: 4895:    @Override
20490: 4896:    public Iterator<T> iterator() {
20491: 4897:        return storage.iterator();
20492: 4898:    }
20493: 4899:}
20494: 4900:```
20495: 4901:
20496: 4902:正如反射解决方案看起来那样优雅，我们必须观察到反射（尽管在 Java 的最新版本中得到了显着改进）通常比非反射实现要慢，因为在运行时发生了很多事情。 但它不应阻止您尝试这种解决方案，这依然是值得考虑的一点。
20497: 4903:
20498: 4904:几乎可以肯定，你会首先使用 Java 8 的函数式方法，并且只有在解决了特殊需求时才诉诸反射。 这里对 **ApplyTest.java** 进行了重写，以利用 Java 8 的流和函数工具：
20499: 4905:
20500: 4906:```java
20501: 4907:// generics/ApplyFunctional.java
20502: 4908:
20503: 4909:import java.util.*;
20504: 4910:import java.util.stream.*;
20505: 4911:import java.util.function.*;
20506: 4912:import onjava.*;
20507: 4913:
20508: 4914:public class ApplyFunctional {
20509: 4915:    public static void main(String[] args) {
20510: 4916:        Stream.of(
20511: 4917:          Stream.generate(Shape::new).limit(2),
20512: 4918:          Stream.generate(Square::new).limit(2))
20513: 4919:        .flatMap(c -> c) // flatten into one stream
20514: 4920:        .peek(Shape::rotate)
20515: 4921:        .forEach(s -> s.resize(7));
20516: 4922:
20517: 4923:        new FilledList<>(Shape::new, 2)
20518: 4924:          .forEach(Shape::rotate);
20519: 4925:        new FilledList<>(Square::new, 2)
20520: 4926:          .forEach(Shape::rotate);
20521: 4927:
20522: 4928:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
20523: 4929:          new SimpleQueue<>(), SimpleQueue::add,
20524: 4930:          Shape::new, 2);
20525: 4931:        Suppliers.fill(shapeQ, SimpleQueue::add,
20526: 4932:          Square::new, 2);
20527: 4933:        shapeQ.forEach(Shape::rotate);
20528: 4934:    }
20529: 4935:}
20530: 4936:/* Output:
20531: 4937:Shape 0 rotate
20532: 4938:Shape 0 resize 7
20533: 4939:Shape 1 rotate
20534: 4940:Shape 1 resize 7
20535: 4941:Square 2 rotate
20536: 4942:Square 2 resize 7
20537: 4943:Square 3 rotate
20538: 4944:Square 3 resize 7
20539: 4945:Shape 4 rotate
20540: 4946:Shape 5 rotate
20541: 4947:Square 6 rotate
20542: 4948:Square 7 rotate
20543: 4949:Shape 8 rotate
20544: 4950:Shape 9 rotate
20545: 4951:Square 10 rotate
20546: 4952:Square 11 rotate
20547: 4953:*/
20548: 4954:```
20549: 4955:
20550: 4956:由于使用 Java 8，因此不需要 `Apply.apply()` 。
20551: 4957:
20552: 4958:我们首先生成两个 **Stream** ： 一个是 **Shape** ，一个是 **Square** ，并将它们展平为单个流。 尽管 Java 缺少功能语言中经常出现的 `flatten()` ，但是我们可以使用 `flatMap(c-> c)` 产生相同的结果，后者使用身份映射将操作简化为“  **flatten** ”。
20553: 4959:
20554: 4960:我们使用 `peek()` 当做对 `rotate()` 的调用，因为 `peek()` 执行一个操作（此处是出于副作用），并在未更改的情况下传递对象。
20555: 4961:
20556: 4962:注意，使用 **FilledList** 和 **shapeQ** 调用 `forEach()` 比 `Apply.apply()` 代码整洁得多。 在代码简单性和可读性方面，结果比以前的方法好得多。 并且，现在也不可能从  `main()` 引发异常。
20557: 4963:
20558: 4964:<!-- Assisted Latent Typing in Java 8 -->
20559: 4965:
20560: 4966:## Java8 中的辅助潜在类型
20561: 4967:
20562: 4968:先前声明关于 Java 缺乏对潜在类型的支持在 Java 8 之前是完全正确的。但是，Java 8 中的非绑定方法引用使我们能够产生一种潜在类型的形式，以满足创建一段可工作在不相干类型上的代码。因为 Java 最初并不是如此设计，所以结果可想而知，比其他语言中要尴尬一些。但是，至少现在成为了可能，只是缺乏令人惊艳之处。
20563: 4969:
20564: 4970:我在其他地方从没遇过这种技术，因此我将其称为辅助潜在类型。
20565: 4971:
20566: 4972:我们将重写 **DogsAndRobots.java** 来演示该技术。 为使外观看起来与原始示例尽可能相似，我仅向每个原始类名添加了 **A**：
20567: 4973:
20568: 4974:```java
20569: 4975:// generics/DogsAndRobotMethodReferences.java
20570: 4976:
20571: 4977:// "Assisted Latent Typing"
20572: 4978:import typeinfo.pets.*;
20573: 4979:import java.util.function.*;
20574: 4980:
20575: 4981:class PerformingDogA extends Dog {
20576: 4982:    public void speak() { System.out.println("Woof!"); }
20577: 4983:    public void sit() { System.out.println("Sitting"); }
20578: 4984:    public void reproduce() {}
20579: 4985:}
20580: 4986:
20581: 4987:class RobotA {
20582: 4988:    public void speak() { System.out.println("Click!"); }
20583: 4989:    public void sit() { System.out.println("Clank!"); }
20584: 4990:    public void oilChange() {}
20585: 4991:}
20586: 4992:
20587: 4993:class CommunicateA {
20588: 4994:    public static <P> void perform(P performer,
20589: 4995:      Consumer<P> action1, Consumer<P> action2) {
20590: 4996:        action1.accept(performer);
20591: 4997:        action2.accept(performer);
20592: 4998:    }
20593: 4999:}
20594: 5000:
20595: 5001:public class DogsAndRobotMethodReferences {
20596: 5002:    public static void main(String[] args) {
20597: 5003:        CommunicateA.perform(new PerformingDogA(),
20598: 5004:          PerformingDogA::speak, PerformingDogA::sit);
20599: 5005:        CommunicateA.perform(new RobotA(),
20600: 5006:          RobotA::speak, RobotA::sit);
20601: 5007:        CommunicateA.perform(new Mime(),
20602: 5008:          Mime::walkAgainstTheWind,
20603: 5009:          Mime::pushInvisibleWalls);
20604: 5010:    }
20605: 5011:}
20606: 5012:/* Output:
20607: 5013:Woof!
20608: 5014:Sitting
20609: 5015:Click!
20610: 5016:Clank!
20611: 5017:*/
20612: 5018:```
20613: 5019:
20614: 5020:**PerformingDogA** 和 **RobotA** 与 **DogsAndRobots.java** 中的相同，不同之处在于它们不继承通用接口 **Performs** ，因此它们没有通用性。
20615: 5021:
20616: 5022:`CommunicateA.perform()` 在没有约束的 **P** 上生成。 只要可以使用 `Consumer <P>`，它在这里就可以是任何东西，这些 `Consumer<P>` 代表不带参数的 **P** 方法的未绑定方法引用。当您调用 **Consumer**  的 `accept()` 方法时，它将方法引用绑定到执行者对象并调用该方法。 由于 [函数式编程](book/13-Functional-Programming.md) 一章中描述的“魔术”，我们可以将任何符合签名的未绑定方法引用传递给 `CommunicateA.perform()` 。
20617: 5023:
20618: 5024:之所以称其为“辅助”，是因为您必须显式地为 `perform()` 提供要使用的方法引用。 它不能只按名称调用方法。
20619: 5025:
20620: 5026:尽管传递未绑定的方法引用似乎要花很多力气，但潜在类型的最终目标还是可以实现的。 我们创建了一个代码片段 `CommunicateA.perform()` ，该代码可用于任何具有符合签名的方法引用的类型。 请注意，这与我们看到的其他语言中的潜在类型有所不同，因为这些语言不仅需要签名以符合规范，还需要方法名称。 因此，该技术可以说产生了更多的通用代码。
20621: 5027:
20622: 5028:为了证明这一点，我还从 **LatentReflection.java** 中引入了 **Mime**。
20623: 5029:
20624: 5030:### 使用**Suppliers**类的通用方法
20625: 5031:
20626: 5032:通过辅助潜在类型，我们可以定义本章其他部分中使用的 **Suppliers** 类。 此类包含使用生成器填充 **Collection** 的工具方法。 泛化这些操作很有意义：
20627: 5033:
20628: 5034:```java
20629: 5035:// onjava/Suppliers.java
20630: 5036:
20631: 5037:// A utility to use with Suppliers
20632: 5038:package onjava;
20633: 5039:import java.util.*;
20634: 5040:import java.util.function.*;
20635: 5041:import java.util.stream.*;
20636: 5042:
20637: 5043:public class Suppliers {
20638: 5044:    // Create a collection and fill it:
20639: 5045:    public static <T, C extends Collection<T>> C
20640: 5046:      create(Supplier<C> factory, Supplier<T> gen, int n) {
20641: 5047:        return Stream.generate(gen)
20642: 5048:            .limit(n)
20643: 5049:            .collect(factory, C::add, C::addAll);
20644: 5050:    }
20645: 5051:    
20646: 5052:    // Fill an existing collection:
20647: 5053:    public static <T, C extends Collection<T>>
20648: 5054:      C fill(C coll, Supplier<T> gen, int n) {
20649: 5055:        Stream.generate(gen)
20650: 5056:            .limit(n)
20651: 5057:            .forEach(coll::add);
20652: 5058:        return coll;
20653: 5059:    }
20654: 5060:    
20655: 5061:    // Use an unbound method reference to
20656: 5062:    // produce a more general method:
20657: 5063:    public static <H, A> H fill(H holder,
20658: 5064:      BiConsumer<H, A> adder, Supplier<A> gen, int n) {
20659: 5065:        Stream.generate(gen)
20660: 5066:            .limit(n)
20661: 5067:            .forEach(a -> adder.accept(holder, a));
20662: 5068:        return holder;
20663: 5069:    }
20664: 5070:}
20665: 5071:```
20666: 5072:
20667: 5073:`create()` 为你创建一个新的 **Collection** 子类型，而 `fill()` 的第一个版本将元素放入 **Collection** 的现有子类型中。 请注意，还会返回传入的容器的确切类型，因此不会丢失类型信息。[^6]
20668: 5074:
20669: 5075:前两种方法一般都受约束，只能与 **Collection** 子类型一起使用。`fill()` 的第二个版本适用于任何类型的 **holder** 。 它需要一个附加参数：未绑定方法引用 `adder. fill()` ，使用辅助潜在类型来使其与任何具有添加元素方法的 **holder** 类型一起使用。因为此未绑定方法 **adder** 必须带有一个参数（要添加到 **holder** 的元素），所以 **adder** 必须是 `BiConsumer <H，A>` ，其中 **H** 是要绑定到的 **holder** 对象的类型，而 **A** 是要被添加的绑定元素类型。 对 `accept()` 的调用将使用参数 a 调用对象 **holder** 上的未绑定方法 **holder**。
20670: 5076:
20671: 5077:在一个稍作模拟的测试中对 **Suppliers** 工具程序进行了测试，该仿真还使用了本章前面定义的 **RandomList** ：
20672: 5078:
20673: 5079:```java
20674: 5080:// generics/BankTeller.java
20675: 5081:
20676: 5082:// A very simple bank teller simulation
20677: 5083:import java.util.*;
20678: 5084:import onjava.*;
20679: 5085:
20680: 5086:class Customer {
20681: 5087:    private static long counter = 1;
20682: 5088:    private final long id = counter++;
20683: 5089:    @Override
20684: 5090:    public String toString() {
20685: 5091:        return "Customer " + id;
20686: 5092:    }
20687: 5093:}
20688: 5094:
20689: 5095:class Teller {
20690: 5096:    private static long counter = 1;
20691: 5097:    private final long id = counter++;
20692: 5098:    @Override
20693: 5099:    public String toString() {
20694: 5100:        return "Teller " + id;
20695: 5101:    }
20696: 5102:}
20697: 5103:
20698: 5104:class Bank {
20699: 5105:    private List<BankTeller> tellers =
20700: 5106:        new ArrayList<>();
20701: 5107:    public void put(BankTeller bt) {
20702: 5108:        tellers.add(bt);
20703: 5109:    }
20704: 5110:}
20705: 5111:
20706: 5112:public class BankTeller {
20707: 5113:    public static void serve(Teller t, Customer c) {
20708: 5114:        System.out.println(t + " serves " + c);
20709: 5115:    }
20710: 5116:    public static void main(String[] args) {
20711: 5117:        // Demonstrate create():
20712: 5118:        RandomList<Teller> tellers =
20713: 5119:            Suppliers.create(
20714: 5120:            RandomList::new, Teller::new, 4);
20715: 5121:        // Demonstrate fill():
20716: 5122:        List<Customer> customers = Suppliers.fill(
20717: 5123:            new ArrayList<>(), Customer::new, 12);
20718: 5124:        customers.forEach(c ->
20719: 5125:            serve(tellers.select(), c));
20720: 5126:        // Demonstrate assisted latent typing:
20721: 5127:        Bank bank = Suppliers.fill(
20722: 5128:            new Bank(), Bank::put, BankTeller::new, 3);
20723: 5129:        // Can also use second version of fill():
20724: 5130:        List<Customer> customers2 = Suppliers.fill(
20725: 5131:            new ArrayList<>(),
20726: 5132:            List::add, Customer::new, 12);
20727: 5133:    }
20728: 5134:}
20729: 5135:/* Output:
20730: 5136:Teller 3 serves Customer 1
20731: 5137:Teller 2 serves Customer 2
20732: 5138:Teller 3 serves Customer 3
20733: 5139:Teller 1 serves Customer 4
20734: 5140:Teller 1 serves Customer 5
20735: 5141:Teller 3 serves Customer 6
20736: 5142:Teller 1 serves Customer 7
20737: 5143:Teller 2 serves Customer 8
20738: 5144:Teller 3 serves Customer 9
20739: 5145:Teller 3 serves Customer 10
20740: 5146:Teller 2 serves Customer 11
20741: 5147:Teller 4 serves Customer 12
20742: 5148:*/
20743: 5149:```
20744: 5150:
20745: 5151:可以看到 `create()` 生成一个新的 **Collection** 对象，而 `fill()` 添加到现有 **Collection** 中。第二个版本`fill()` 显示，它不仅与无关的新类型 **Bank** 一起使用，还能与 **List** 一起使用。因此，从技术上讲，`fill()` 的第一个版本在技术上不是必需的，但在使用 **Collection** 时提供了较短的语法。
20746: 5152:
20747: 5153:<!-- Summary: Is Casting Really So Bad? -->
20748: 5154:
20749: 5155:## 总结：类型转换真的如此之糟吗？
20750: 5156:
20751: 5157:自从 C++ 模版出现以来，我就一直在致力于解释它，我可能比大多数人都更早地提出了下面的论点。直到最近，我才停下来，去思考这个论点到底在多少时间内是有效的——我将要描述的问题到底有多少次可以穿越障碍得以解决。
20752: 5158:
20753: 5159:这个论点就是：使用泛型类型机制的最吸引人的地方，就是在使用集合类的地方，这些类包括诸如各种 **List** 、各种 **Set** 、各种 **Map** 等你在 [集合](book/12-Collections.md) 和 [附录：集合主题](book/Appendix-Collection-Topics.md) 这两章所见。在 Java 5 之前，当你将一个对象放置到集合中时，这个对象就会被向上转型为 **Object** ，因此你会丢失类型信息。当你想要将这个对象从集合中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。我用的示例是持有 **Cat** 的 **List** （这个示例的一种使用苹果和桔子的变体在 [集合](book/12-Collections.md) 章节的开头展示过）。如果没有 Java 5 泛型版本的集合，你放到容集里和从集合中取回的都是 **Object** 。因此，我们很可能会将一个 **Dog** 放置到 **Cat** 的 **List** 中。
20754: 5160:
20755: 5161:但是，泛型出现之前的 Java 并不会让你误用放入到集合中的对象。如果将一个 **Dog** 扔到 **Cat** 的集合中，并且试图将这个集合中的所有东西都当作 **Cat** 处理，那么当你从这个 **Cat** 集合中取回那个 **Dog** 引用，并试图将其转型为 **Cat** 时，就会得到一个 **RuntimeException** 。你仍旧可以发现问题，但是是在运行时而非编译期发现它的。
20756: 5162:
20757: 5163:在本书以前的版本中，我曾经说过：
20758: 5164:
20759: 5165:> 这不止令人恼火，它还可能会产生难以发现的缺陷。如果这个程序的某个部分（或数个部分）向集合中插入了对象，并且通过异常，你在程序的另一个独立的部分中发现有不良对象被放置到了集合中，那么必须发现这个不良插入到底是在何处发生的。
20760: 5166:
20761: 5167:但是，随着对这个论点的进一步检查，我开始怀疑它了。首先，这会多么频繁地发生呢？我记得这类事情从未发生在我身上，并且当我在会议上询问其他人时，我也从来没有听说过有人碰上过。另一本书使用了一个称为 **files** 的 list 示例，它包含 **String** 对象。在这个示例中，向 **files** 中添加一个 **File** 对象看起来相当自然，因此这个对象的名字可能叫 **fileNames** 更好。无论 Java 提供了多少类型检查，仍旧可能会写出晦涩的程序，而编写差劲儿的程序即便可以编译，它仍旧是编写差劲儿的程序。可能大多数人都会使用命名良好的集合，例如 **cats** ，因为它们可以向试图添加非 **Cat** 对象的程序员提供可视的警告。并且即便这类事情发生了，它真正又能潜伏多久呢？只要你开始用真实数据来运行测试，就会非常快地看到异常。
20762: 5168:
20763: 5169:有一位作者甚至断言，这样的缺陷将“*潜伏数年*”。但是我不记得有任何大量的相关报告，来说明人们在查找“狗在猫列表中”这类缺陷时困难重重，或者是说明人们会非常频繁地产生这种错误。然而，你将在 [多线程编程](book/24-Concurrent-Programming.md) 章节中看到，在使用线程时，出现那些可能看起来极罕见的缺陷，是很寻常并容易发生的事，而且，对于到底出了什么错，这些缺陷只能给你一个很模糊的概念。因此，对于泛型是添加到 Java 中的非常显著和相当复杂的特性这一点，“狗在猫列表中”这个论据真的能够成为它的理由吗？
20764: 5170:我相信被称为*泛型*的通用语言特性（并非必须是其在 Java 中的特定实现）的目的在于可表达性，而不仅仅是为了创建类型安全的集合。类型安全的集合是能够创建更通用代码这一能力所带来的副作用。
20765: 5171:因此，即便“狗在猫列表中”这个论据经常被用来证明泛型是必要的，但是它仍旧是有问题的。就像我在本章开头声称的，我不相信这就是泛型这个概念真正的含义。相反，泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。正如你在本章中看到的，编写真正泛化的“持有器”类（ Java 的容器就是这种类）相当简单，但是编写出能够操作其泛型类型的泛化代码就需要额外的努力了，这些努力需要类创建者和类消费者共同付出，他们必须理解这些代码的概念和实现。这些额外的努力会增加使用这种特性的难度，并可能会因此而使其在某些场合缺乏可应用性，而在这些场合中，它可能会带来附加的价值。
20766: 5172:
20767: 5173:还要注意到，因为泛型是后来添加到 Java 中，而不是从一开始就设计到这种语言中的，所以某些容器无法达到它们应该具备的健壮性。例如，观察一下 **Map** ，在特定的方法 `containsKey(Object key) `和 `get(Object key)` 中就包含这类情况。如果这些类是使用在它们之前就存在的泛型设计的，那么这些方法将会使用参数化类型而不是 **Object** ，因此也就可以提供这些泛型假设会提供的编译期检查。例如，在 C++ 的 **map** 中，键的类型总是在编译期检查的。
20768: 5174:
20769: 5175:有一件事很明显：在一种语言已经被广泛应用之后，在其较新的版本中引入任何种类的泛型机制，都会是一项非常非常棘手的任务，并且是一项不付出艰辛就无法完成的任务。在 C++ 中，模版是在其最初的 ISO 版本中就引入的（即便如此，也引发了阵痛，因为在第一个标准 C++ 出现之前，有很多非模版版本在使用），因此实际上模版一直都是这种语言的一部分。在 Java 中，泛型是在这种语言首次发布大约 10 年之后才引入的，因此向泛型迁移的问题特别多，并且对泛型的设计产生了明显的影响。其结果就是，程序员将承受这些痛苦，而这一切都是由于 Java 设计者在设计 1.0 版本时所表现出来的短视造成的。当 Java 最初被创建时，它的设计者们当然了解 C++ 的模版，他们甚至考虑将其囊括到 Java 语言中，但是出于这样或那样的原因，他们决定将模版排除在外（其迹象就是他们过于匆忙）。因此， Java 语言和使用它的程序员都将承受这些痛苦。只有时间将会说明 Java 的泛型方式对这种语言所造成的最终影响。
20770: 5176:某些语言，已经融入了更简洁、影响更小的方式，来实现参数化类型。我们不可能不去想象这样的语言将会成为 Java 的继任者，因为它们采用的方式，与 C++ 通过 C 来实现的方式相同：按原样使用它，然后对其进行改进。
20771: 5177:
20772: 5178:## 进阶阅读
20773: 5179:
20774: 5180:泛型的入门文档是 《Generics in the Java Programming Language》，作者是 Gilad Bracha，可以从 http://java.oracle.com 获取。
20775: 5181:
20776: 5182:Angelika Langer 的《Java Generics FAQs》是一份非常有帮助的资料，可以从 http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html 获取。
20777: 5183:
20778: 5184:你可以从 《Adding Wildcards to the Java Programming Language》中学到更多关于通配符的知识，作者是 Torgerson、Ernst、Hansen、von der Ahe、Bracha 和 Gafter，地址是 http://www.jot.fm/issues/issue_2004_12/article5。
20779: 5185:
20780: 5186:Neal After 对于 Java 问题（尤其是擦除）的看法可以从这里找到：http://www.infoq.com/articles/neal-gafter-on-java。
20781: 5187:
20782: 5188:[^1]: 在编写本章期间，Angelika Langer的 Java 泛型常见问题解答以及她的其他著作（与Klaus Kreft一起）是非常宝贵的。
20783: 5189:[^2]: [http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html](http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html)
20784: 5190:[^3]: 参见本章章末引文。
20785: 5191:[^4]: 注意，一些编程环境，如 Eclipse 和 IntelliJ IDEA，将会自动生成委托代码。
20786: 5192:[^5]: 因为可以使用转型，有效地禁止了类型系统，一些人就认为 C++ 是弱类型，但这太极端了。一种可能更好的说法是 C++ 是有一道暗门的强类型语言。
20787: 5193:[^6]: 我再次从 Brian Goetz 那获得帮助。
20788: 5194:
20789: 5195:<!-- 分页 -->
20790: 5196:
20791: 5197:<div style="page-break-after: always;"></div>
20792: 
20793: 1:[TOC]
20794: 2:
20795: 3:<!-- Generics -->
20796: 4:
20797: 5:# 第二十章 泛型
20798: 6:
20799: 7:> 普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。
20800: 8:
20801: 9:多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。除了 `final` 类（或只提供私有构造函数的类）任何类型都可被扩展，所以大部分时候这种灵活性是自带的。
20802: 10:
20803: 11:拘泥于单一的继承体系太过局限，因为只有继承体系中的对象才能适用基类作为参数的方法中。如果方法以接口而不是类作为参数，限制就宽松多了，只要实现了接口就可以。这给予调用方一种选项，通过调整现有的类来实现接口，满足方法参数要求。接口可以突破继承体系的限制。
20804: 12:
20805: 13:即便是接口也还是有诸多限制。一旦指定了接口，它就要求你的代码必须使用特定的接口。而我们希望编写更通用的代码，能够适用“非特定的类型”，而不是一个具体的接口或类。
20806: 14:
20807: 15:这就是泛型的概念，是 Java 5 的重大变化之一。泛型实现了*参数化类型*，这样你编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。随后你会发现 Java 中泛型的实现并没有那么“泛”，你可能会质疑“泛型”这个词是否合适用来描述这一功能。
20808: 16:
20809: 17:如果你从未接触过参数化类型机制，你会发现泛型对 Java 语言确实是个很有益的补充。在你实例化一个类型参数时，编译器会负责转型并确保类型的正确性。这是一大进步。
20810: 18:
20811: 19:然而，如果你了解其他语言（例如 C++ ）的参数化机制，你会发现，Java 泛型并不能满足所有的预期。使用别人创建好的泛型相对容易，但是创建自己的泛型时，就会遇到很多意料之外的麻烦。
20812: 20:
20813: 21:这并不是说 Java 泛型毫无用处。在很多情况下，它可以使代码更直接更优雅。不过，如果你见识过那种实现了更纯粹的泛型的编程语言，那么，Java 可能会令你失望。本章会介绍 Java 泛型的优点与局限。我会解释 Java 的泛型是如何发展成现在这样的，希望能够帮助你更有效地使用这个特性。[^1]
20814: 22:
20815: 23:### 与 C++ 的比较
20816: 24:
20817: 25:Java 的设计者曾说过，这门语言的灵感主要来自 C++ 。尽管如此，学习 Java 时基本不用参考 C++ 。
20818: 26:
20819: 27:但是，Java 中的泛型需要与 C++ 进行对比，理由有两个：首先，理解 C++ *模板*（泛型的主要灵感来源，包括基本语法）的某些特性，有助于理解泛型的基础理念。同时，非常重要的一点是，你可以了解 Java 泛型的局限是什么，以及为什么会有这些局限。最终的目标是明确 Java 泛型的边界，让你成为一个程序高手。只有知道了某个技术不能做什么，你才能更好地做到所能做的（部分原因是，不必浪费时间在死胡同里）。
20820: 28:
20821: 29:第二个原因是，在 Java 社区中，大家普遍对 C++ 模板有一种误解，而这种误解可能会令你在理解泛型的意图时产生偏差。
20822: 30:
20823: 31:因此，本章中会介绍少量 C++ 模板的例子，仅当它们确实可以加深理解时才会引入。
20824: 32:
20825: 33:<!-- Simple Generics -->
20826: 34:
20827: 35:## 简单泛型
20828: 36:
20829: 37:促成泛型出现的最主要的动机之一是为了创建*集合类*，参见 [集合](book/12-Collections.md) 章节。集合用于存放要使用到的对象。数组也是如此，不过集合比数组更加灵活，功能更丰富。几乎所有程序在运行过程中都会涉及到一组对象，因此集合是可复用性最高的类库之一。
20830: 38:
20831: 39:我们先看一个只能持有单个对象的类。这个类可以明确指定其持有的对象的类型：
20832: 40:
20833: 41:```java
20834: 42:// generics/Holder1.java
20835: 43:
20836: 44:class Automobile {}
20837: 45:
20838: 46:public class Holder1 {
20839: 47:    private Automobile a;
20840: 48:    public Holder1(Automobile a) { this.a = a; }
20841: 49:    Automobile get() { return a; }
20842: 50:}
20843: 51:```
20844: 52:
20845: 53:这个类的可复用性不高，它无法持有其他类型的对象。我们可不希望为碰到的每个类型都编写一个新的类。
20846: 54:
20847: 55:在 Java 5 之前，我们可以让这个类直接持有 `Object` 类型的对象：
20848: 56:
20849: 57:```java
20850: 58:// generics/ObjectHolder.java
20851: 59:
20852: 60:public class ObjectHolder {
20853: 61:    private Object a;
20854: 62:    public ObjectHolder(Object a) { this.a = a; }
20855: 63:    public void set(Object a) { this.a = a; }
20856: 64:    public Object get() { return a; }
20857: 65:    
20858: 66:    public static void main(String[] args) {
20859: 67:        ObjectHolder h2 = new ObjectHolder(new Automobile());
20860: 68:        Automobile a = (Automobile)h2.get();
20861: 69:        h2.set("Not an Automobile");
20862: 70:        String s = (String)h2.get();
20863: 71:        h2.set(1); // 自动装箱为 Integer
20864: 72:        Integer x = (Integer)h2.get();
20865: 73:    }
20866: 74:}
20867: 75:```
20868: 76:
20869: 77:现在，`ObjectHolder` 可以持有任何类型的对象，在上面的示例中，一个 `ObjectHolder` 先后持有了三种不同类型的对象。
20870: 78:
20871: 79:一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。
20872: 80:
20873: 81:因此，与其使用 `Object` ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用*类型参数*，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，`T` 就是类型参数：
20874: 82:
20875: 83:```java
20876: 84:// generics/GenericHolder.java
20877: 85:
20878: 86:public class GenericHolder<T> {
20879: 87:    private T a;
20880: 88:    public GenericHolder() {}
20881: 89:    public void set(T a) { this.a = a; }
20882: 90:    public T get() { return a; }
20883: 91:    
20884: 92:    public static void main(String[] args) {
20885: 93:        GenericHolder<Automobile> h3 = new GenericHolder<Automobile>();
20886: 94:        h3.set(new Automobile()); // 此处有类型校验
20887: 95:        Automobile a = h3.get();  // 无需类型转换
20888: 96:        //- h3.set("Not an Automobile"); // 报错
20889: 97:        //- h3.set(1);  // 报错
20890: 98:    }
20891: 99:}
20892: 100:```
20893: 101:
20894: 102:创建 `GenericHolder` 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 `main()` 中那样使用。然后，你就只能在 `GenericHolder` 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当你调用 `get()` 取值时，直接就是正确的类型。
20895: 103:
20896: 104:这就是 Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。
20897: 105:
20898: 106:你可能注意到 `h3` 的定义非常繁复。在 `=` 左边有 `GenericHolder<Automobile>`, 右边又重复了一次。在 Java 5 中，这种写法被解释成“必要的”，但在 Java 7 中设计者修正了这个问题（新的简写语法随后成为备受欢迎的特性）。以下是简写的例子：
20899: 107:
20900: 108:```java
20901: 109:// generics/Diamond.java
20902: 110:
20903: 111:class Bob {}
20904: 112:
20905: 113:public class Diamond<T> {
20906: 114:    public static void main(String[] args) {
20907: 115:        GenericHolder<Bob> h3 = new GenericHolder<>();
20908: 116:        h3.set(new Bob());
20909: 117:    }
20910: 118:}
20911: 119:```
20912: 120:
20913: 121:注意，在 `h3` 的定义处，`=` 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。在本书剩余部分都会使用这种语法。
20914: 122:
20915: 123:一般来说，你可以认为泛型和其他类型差不多，只不过它们碰巧有类型参数罢了。在使用泛型时，你只需要指定它们的名称和类型参数列表即可。
20916: 124:
20917: 125:### 一个元组类库
20918: 126:
20919: 127:有时一个方法需要能返回多个对象。而 **return** 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得了编译时的类型安全。
20920: 128:
20921: 129:这个概念称为*元组*，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 *数据传输对象* 或 *信使* ）。
20922: 130:
20923: 131:通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组：
20924: 132:
20925: 133:```java
20926: 134:// onjava/Tuple2.java
20927: 135:package onjava;
20928: 136:
20929: 137:public class Tuple2<A, B> {
20930: 138:    public final A a1;
20931: 139:    public final B a2;
20932: 140:    public Tuple2(A a, B b) { a1 = a; a2 = b; }
20933: 141:    public String rep() { return a1 + ", " + a2; }
20934: 142:  
20935: 143:    @Override
20936: 144:    public String toString() {
20937: 145:        return "(" + rep() + ")";
20938: 146:    }
20939: 147:}
20940: 148:```
20941: 149:
20942: 150:构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。
20943: 151:
20944: 152:初次阅读上面的代码时，你可能认为这违反了 Java 编程的封装原则。`a1` 和 `a2` 应该声明为 **private**，然后提供 `getFirst()` 和 `getSecond()` 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取 `a1` 和 `a2` 然后对它们执行任何操作，但无法对 `a1` 和 `a2` 重新赋值。例子中的 `final` 可以实现同样的效果，并且更为简洁明了。
20945: 153:
20946: 154:另一种设计思路是允许元组的用户给 `a1` 和 `a2` 重新赋值。然而，采用上例中的形式无疑更加安全，如果用户想存储不同的元素，就会强制他们创建新的 `Tuple2` 对象。
20947: 155:
20948: 156:我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了：
20949: 157:
20950: 158:```java
20951: 159:// onjava/Tuple3.java
20952: 160:package onjava;
20953: 161:
20954: 162:public class Tuple3<A, B, C> extends Tuple2<A, B> {
20955: 163:    public final C a3;
20956: 164:    public Tuple3(A a, B b, C c) {
20957: 165:        super(a, b);
20958: 166:        a3 = c;
20959: 167:    }
20960: 168:    
20961: 169:    @Override
20962: 170:    public String rep() {
20963: 171:        return super.rep() + ", " + a3;
20964: 172:    }
20965: 173:}
20966: 174:
20967: 175:// onjava/Tuple4.java
20968: 176:package onjava;
20969: 177:
20970: 178:public class Tuple4<A, B, C, D>
20971: 179:  extends Tuple3<A, B, C> {
20972: 180:    public final D a4;
20973: 181:    public Tuple4(A a, B b, C c, D d) {
20974: 182:        super(a, b, c);
20975: 183:        a4 = d;
20976: 184:    }
20977: 185:    
20978: 186:    @Override
20979: 187:    public String rep() {
20980: 188:        return super.rep() + ", " + a4;
20981: 189:    }
20982: 190:}
20983: 191:
20984: 192:// onjava/Tuple5.java
20985: 193:package onjava;
20986: 194:
20987: 195:public class Tuple5<A, B, C, D, E>
20988: 196:  extends Tuple4<A, B, C, D> {
20989: 197:    public final E a5;
20990: 198:    public Tuple5(A a, B b, C c, D d, E e) {
20991: 199:        super(a, b, c, d);
20992: 200:        a5 = e;
20993: 201:    }
20994: 202:    
20995: 203:    @Override
20996: 204:    public String rep() {
20997: 205:        return super.rep() + ", " + a5;
20998: 206:    }
20999: 207:}
21000: 208:```
21001: 209:
21002: 210:演示需要，再定义两个类：
21003: 211:
21004: 212:```java
21005: 213:// generics/Amphibian.java
21006: 214:public class Amphibian {}
21007: 215:
21008: 216:// generics/Vehicle.java
21009: 217:public class Vehicle {}
21010: 218:```
21011: 219:
21012: 220:使用元组时，你只需要定义一个长度适合的元组，将其作为返回值即可。注意下面例子中方法的返回类型：
21013: 221:
21014: 222:```java
21015: 223:// generics/TupleTest.java
21016: 224:import onjava.*;
21017: 225:
21018: 226:public class TupleTest {
21019: 227:    static Tuple2<String, Integer> f() {
21020: 228:        // 47 自动装箱为 Integer
21021: 229:        return new Tuple2<>("hi", 47);
21022: 230:    }
21023: 231:  
21024: 232:    static Tuple3<Amphibian, String, Integer> g() {
21025: 233:        return new Tuple3<>(new Amphibian(), "hi", 47);
21026: 234:    }
21027: 235:  
21028: 236:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
21029: 237:        return new Tuple4<>(new Vehicle(), new Amphibian(), "hi", 47);
21030: 238:    }
21031: 239:  
21032: 240:    static Tuple5<Vehicle, Amphibian, String, Integer, Double> k() {
21033: 241:        return new Tuple5<>(new Vehicle(), new Amphibian(), "hi", 47, 11.1);
21034: 242:    }
21035: 243:  
21036: 244:    public static void main(String[] args) {
21037: 245:        Tuple2<String, Integer> ttsi = f();
21038: 246:        System.out.println(ttsi);
21039: 247:        // ttsi.a1 = "there"; // 编译错误，因为 final 不能重新赋值
21040: 248:        System.out.println(g());
21041: 249:        System.out.println(h());
21042: 250:        System.out.println(k());
21043: 251:    }
21044: 252:}
21045: 253:
21046: 254:/* 输出：
21047: 255: (hi, 47)
21048: 256: (Amphibian@1540e19d, hi, 47)
21049: 257: (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47)
21050: 258: (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1)
21051: 259: */
21052: 260:```
21053: 261:
21054: 262:有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。
21055: 263:
21056: 264:通过 `ttsi.a1 = "there"` 语句的报错，我们可以看出，**final** 声明确实可以确保 **public** 字段在对象被构造出来之后就不能重新赋值了。
21057: 265:
21058: 266:在上面的程序中，`new` 表达式有些啰嗦。本章稍后会介绍，如何利用 *泛型方法* 简化它们。
21059: 267:
21060: 268:### 一个堆栈类
21061: 269:
21062: 270:接下来我们看一个稍微复杂一点的例子：堆栈。在 [集合](book/12-Collections.md) 一章中，我们用 `LinkedList` 实现了 `onjava.Stack` 类。在那个例子中，`LinkedList` 本身已经具备了创建堆栈所需的方法。`Stack` 是通过两个泛型类 `Stack<T>` 和 `LinkedList<T>` 的组合来创建。我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。
21063: 271:
21064: 272:这次我们不用 `LinkedList` 来实现自己的内部链式存储机制。
21065: 273:
21066: 274:```java
21067: 275:// generics/LinkedStack.java
21068: 276:// 用链式结构实现的堆栈
21069: 277:
21070: 278:public class LinkedStack<T> {
21071: 279:    private static class Node<U> {
21072: 280:        U item;
21073: 281:        Node<U> next;
21074: 282:    
21075: 283:        Node() { item = null; next = null; }
21076: 284:        
21077: 285:        Node(U item, Node<U> next) {
21078: 286:            this.item = item;
21079: 287:            this.next = next;
21080: 288:        }
21081: 289:    
21082: 290:        boolean end() {
21083: 291:            return item == null && next == null;
21084: 292:        }
21085: 293:    }
21086: 294:  
21087: 295:    private Node<T> top = new Node<>();  // 栈顶
21088: 296:  
21089: 297:    public void push(T item) {
21090: 298:        top = new Node<>(item, top);
21091: 299:    }
21092: 300:  
21093: 301:    public T pop() {
21094: 302:        T result = top.item;
21095: 303:        if (!top.end()) {
21096: 304:            top = top.next;
21097: 305:        }
21098: 306:        return result;
21099: 307:    }
21100: 308:  
21101: 309:    public static void main(String[] args) {
21102: 310:        LinkedStack<String> lss = new LinkedStack<>();
21103: 311:        for (String s : "Phasers on stun!".split(" ")) {
21104: 312:            lss.push(s);
21105: 313:        }
21106: 314:        String s;
21107: 315:        while ((s = lss.pop()) != null) {
21108: 316:            System.out.println(s);
21109: 317:        }
21110: 318:    }
21111: 319:}
21112: 320:```
21113: 321:
21114: 322:输出结果：
21115: 323:
21116: 324:```java
21117: 325:stun!
21118: 326:on
21119: 327:Phasers
21120: 328:```
21121: 329:
21122: 330:内部类 `Node` 也是一个泛型，它拥有自己的类型参数。
21123: 331:
21124: 332:这个例子使用了一个 *末端标识* (end sentinel) 来判断栈何时为空。这个末端标识是在构造 `LinkedStack` 时创建的。然后，每次调用 `push()` 就会创建一个 `Node<T>` 对象，并将其链接到前一个 `Node<T>` 对象。当你调用 `pop()` 方法时，总是返回 `top.item`，然后丢弃当前 `top` 所指向的 `Node<T>`，并将 `top` 指向下一个 `Node<T>`，除非到达末端标识，这时就不能再移动 `top` 了。如果已经到达末端，程序还继续调用 `pop()` 方法，它只能得到 `null`，说明栈已经空了。
21125: 333:
21126: 334:### RandomList
21127: 335:
21128: 336:作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 `select()` 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型：
21129: 337:
21130: 338:```java
21131: 339:// generics/RandomList.java
21132: 340:import java.util.*;
21133: 341:import java.util.stream.*;
21134: 342:
21135: 343:public class RandomList<T> extends ArrayList<T> {
21136: 344:    private Random rand = new Random(47);
21137: 345:  
21138: 346:    public T select() {
21139: 347:        return get(rand.nextInt(size()));
21140: 348:    }
21141: 349:  
21142: 350:    public static void main(String[] args) {
21143: 351:        RandomList<String> rs = new RandomList<>();
21144: 352:        Arrays.stream("The quick brown fox jumped over the lazy brown dog".split(" ")).forEach(rs::add);
21145: 353:        IntStream.range(0, 11).forEach(i -> 
21146: 354:            System.out.print(rs.select() + " "));
21147: 355:    }
21148: 356:}
21149: 357:```
21150: 358:
21151: 359:输出结果：
21152: 360:
21153: 361:```java
21154: 362:brown over fox quick quick dog brown The brown lazy brown
21155: 363:```
21156: 364:
21157: 365:`RandomList` 继承了 `ArrayList` 的所有方法。本例中只添加了 `select()` 这个方法。
21158: 366:
21159: 367:<!-- Generic Interfaces -->
21160: 368:
21161: 369:## 泛型接口
21162: 370:
21163: 371:泛型也可以应用于接口。例如 *生成器*，这是一种专门负责创建对象的类。实际上，这是 *工厂方法* 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。
21164: 372:
21165: 373:一般而言，一个生成器只定义一个方法，用于创建对象。例如 `java.util.function` 类库中的 `Supplier` 就是一个生成器，调用其 `get()` 获取对象。`get()` 是泛型方法，返回值为类型参数 `T`。
21166: 374:
21167: 375:为了演示 `Supplier`，我们需要定义几个类。下面是个咖啡相关的继承体系：
21168: 376:
21169: 377:```java
21170: 378:// generics/coffee/Coffee.java
21171: 379:package generics.coffee;
21172: 380:
21173: 381:public class Coffee {
21174: 382:    private static long counter = 0;
21175: 383:    private final long id = counter++;
21176: 384:  
21177: 385:    @Override
21178: 386:    public String toString() {
21179: 387:        return getClass().getSimpleName() + " " + id;
21180: 388:    }
21181: 389:}
21182: 390:
21183: 391:
21184: 392:// generics/coffee/Latte.java
21185: 393:package generics.coffee;
21186: 394:public class Latte extends Coffee {}
21187: 395:
21188: 396:
21189: 397:// generics/coffee/Mocha.java
21190: 398:package generics.coffee;
21191: 399:public class Mocha extends Coffee {}
21192: 400:
21193: 401:
21194: 402:// generics/coffee/Cappuccino.java
21195: 403:package generics.coffee;
21196: 404:public class Cappuccino extends Coffee {}
21197: 405:
21198: 406:
21199: 407:// generics/coffee/Americano.java
21200: 408:package generics.coffee;
21201: 409:public class Americano extends Coffee {}
21202: 410:
21203: 411:
21204: 412:// generics/coffee/Breve.java
21205: 413:package generics.coffee;
21206: 414:public class Breve extends Coffee {}
21207: 415:```
21208: 416:
21209: 417:现在，我们可以编写一个类，实现 `Supplier<Coffee>` 接口，它能够随机生成不同类型的 `Coffee` 对象：
21210: 418:
21211: 419:```java
21212: 420:// generics/coffee/CoffeeSupplier.java
21213: 421:// {java generics.coffee.CoffeeSupplier}
21214: 422:package generics.coffee;
21215: 423:import java.util.*;
21216: 424:import java.util.function.*;
21217: 425:import java.util.stream.*;
21218: 426:
21219: 427:public class CoffeeSupplier
21220: 428:implements Supplier<Coffee>, Iterable<Coffee> {
21221: 429:    private Class<?>[] types = { Latte.class, Mocha.class, 
21222: 430:        Cappuccino.class, Americano.class, Breve.class };
21223: 431:    private static Random rand = new Random(47);
21224: 432:  
21225: 433:    public CoffeeSupplier() {}
21226: 434:    // For iteration:
21227: 435:    private int size = 0;
21228: 436:    public CoffeeSupplier(int sz) { size = sz; }
21229: 437:  
21230: 438:    @Override
21231: 439:    public Coffee get() {
21232: 440:        try {
21233: 441:            return (Coffee) types[rand.nextInt(types.length)].newInstance();
21234: 442:        } catch (InstantiationException | IllegalAccessException e) {
21235: 443:            throw new RuntimeException(e);
21236: 444:        }
21237: 445:    }
21238: 446:  
21239: 447:    class CoffeeIterator implements Iterator<Coffee> {
21240: 448:        int count = size;
21241: 449:        @Override
21242: 450:        public boolean hasNext() { return count > 0; }
21243: 451:        @Override
21244: 452:        public Coffee next() {
21245: 453:            count--;
21246: 454:            return CoffeeSupplier.this.get();
21247: 455:        }
21248: 456:        @Override
21249: 457:        public void remove() {
21250: 458:            throw new UnsupportedOperationException();
21251: 459:        }
21252: 460:    }
21253: 461:  
21254: 462:    @Override
21255: 463:    public Iterator<Coffee> iterator() {
21256: 464:        return new CoffeeIterator();
21257: 465:    }
21258: 466:  
21259: 467:    public static void main(String[] args) {
21260: 468:        Stream.generate(new CoffeeSupplier())
21261: 469:              .limit(5)
21262: 470:              .forEach(System.out::println);
21263: 471:        for (Coffee c : new CoffeeSupplier(5)) {
21264: 472:            System.out.println(c);
21265: 473:        }
21266: 474:    }
21267: 475:}
21268: 476:```
21269: 477:
21270: 478:输出结果：
21271: 479:
21272: 480:```java
21273: 481:Americano 0
21274: 482:Latte 1
21275: 483:Americano 2
21276: 484:Mocha 3
21277: 485:Mocha 4
21278: 486:Breve 5
21279: 487:Americano 6
21280: 488:Latte 7
21281: 489:Cappuccino 8
21282: 490:Cappuccino 9
21283: 491:```
21284: 492:
21285: 493:参数化的 `Supplier` 接口确保 `get()` 返回值是参数的类型。`CoffeeSupplier` 同时还实现了 `Iterable` 接口，所以能用于 *for-in* 语句。不过，它还需要知道何时终止循环，这正是第二个构造函数的作用。
21286: 494:
21287: 495:下面是另一个实现 `Supplier<T>` 接口的例子，它负责生成 Fibonacci 数列：
21288: 496:
21289: 497:```java
21290: 498:// generics/Fibonacci.java
21291: 499:// Generate a Fibonacci sequence
21292: 500:import java.util.function.*;
21293: 501:import java.util.stream.*;
21294: 502:
21295: 503:public class Fibonacci implements Supplier<Integer> {
21296: 504:    private int count = 0;
21297: 505:    @Override
21298: 506:    public Integer get() { return fib(count++); }
21299: 507:  
21300: 508:    private int fib(int n) {
21301: 509:        if(n < 2) return 1;
21302: 510:        return fib(n-2) + fib(n-1);
21303: 511:    }
21304: 512:  
21305: 513:    public static void main(String[] args) {
21306: 514:        Stream.generate(new Fibonacci())
21307: 515:              .limit(18)
21308: 516:              .map(n -> n + " ")
21309: 517:              .forEach(System.out::print);
21310: 518:    }
21311: 519:}
21312: 520:```
21313: 521:
21314: 522:输出结果：
21315: 523:
21316: 524:```java
21317: 525:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
21318: 526:```
21319: 527:
21320: 528:虽然我们在 `Fibonacci` 类的里里外外使用的都是 `int` 类型，但是其参数类型却是 `Integer`。这个例子引出了 Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备自动装箱和拆箱的功能，可以很方便地在基本类型和相应的包装类之间进行转换。通过这个例子中 `Fibonacci` 类对 `int` 的使用，我们已经看到了这种效果。
21321: 529:
21322: 530:如果还想更进一步，编写一个实现了 `Iterable` 的 `Fibnoacci` 生成器。我们的一个选择是重写这个类，令其实现 `Iterable` 接口。不过，你并不是总能拥有源代码的控制权，并且，除非必须这么做，否则，我们也不愿意重写一个类。而且我们还有另一种选择，就是创建一个 *适配器* (Adapter) 来实现所需的接口，我们在前面介绍过这个设计模式。
21323: 531:
21324: 532:有多种方法可以实现适配器。例如，可以通过继承来创建适配器类：
21325: 533:
21326: 534:```java
21327: 535:// generics/IterableFibonacci.java
21328: 536:// Adapt the Fibonacci class to make it Iterable
21329: 537:import java.util.*;
21330: 538:
21331: 539:public class IterableFibonacci
21332: 540:extends Fibonacci implements Iterable<Integer> {
21333: 541:    private int n;
21334: 542:    public IterableFibonacci(int count) { n = count; }
21335: 543:  
21336: 544:    @Override
21337: 545:    public Iterator<Integer> iterator() {
21338: 546:        return new Iterator<Integer>() {
21339: 547:            @Override
21340: 548:            public boolean hasNext() { return n > 0; }
21341: 549:            @Override
21342: 550:            public Integer next() {
21343: 551:                n--;
21344: 552:                return IterableFibonacci.this.get();
21345: 553:            }
21346: 554:            @Override
21347: 555:            public void remove() { // Not implemented
21348: 556:                throw new UnsupportedOperationException();
21349: 557:            }
21350: 558:        };
21351: 559:    }
21352: 560:  
21353: 561:    public static void main(String[] args) {
21354: 562:        for(int i : new IterableFibonacci(18))
21355: 563:            System.out.print(i + " ");
21356: 564:    }
21357: 565:}
21358: 566:```
21359: 567:
21360: 568:输出结果：
21361: 569:
21362: 570:```java
21363: 571:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
21364: 572:```
21365: 573:
21366: 574:在 *for-in* 语句中使用 `IterableFibonacci`，必须在构造函数中提供一个边界值，这样 `hasNext()` 才知道何时返回 **false**，结束循环。
21367: 575:
21368: 576:<!-- Generic Methods -->
21369: 577:
21370: 578:## 泛型方法
21371: 579:
21372: 580:到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。
21373: 581:
21374: 582:泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。
21375: 583:
21376: 584:如果方法是 **static** 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型类型参数，则它必须是泛型方法。
21377: 585:
21378: 586:要定义泛型方法，请将泛型参数列表放置在返回值之前，如下所示：
21379: 587:
21380: 588:```java
21381: 589:// generics/GenericMethods.java
21382: 590:
21383: 591:public class GenericMethods {
21384: 592:    public <T> void f(T x) {
21385: 593:        System.out.println(x.getClass().getName());
21386: 594:    }
21387: 595:
21388: 596:    public static void main(String[] args) {
21389: 597:        GenericMethods gm = new GenericMethods();
21390: 598:        gm.f("");
21391: 599:        gm.f(1);
21392: 600:        gm.f(1.0);
21393: 601:        gm.f(1.0F);
21394: 602:        gm.f('c');
21395: 603:        gm.f(gm);
21396: 604:    }
21397: 605:}
21398: 606:/* Output:
21399: 607:java.lang.String
21400: 608:java.lang.Integer
21401: 609:java.lang.Double
21402: 610:java.lang.Float
21403: 611:java.lang.Character
21404: 612:GenericMethods
21405: 613:*/
21406: 614:```
21407: 615:
21408: 616:尽管可以同时对类及其方法进行参数化，但这里未将 **GenericMethods** 类参数化。只有方法 `f()` 具有类型参数，该参数由方法返回类型之前的参数列表指示。
21409: 617:
21410: 618:对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 *类型参数推断*。因此，对 `f()` 的调用看起来像普通的方法调用，并且 `f()` 看起来像被重载了无数次一样。它甚至会接受 **GenericMethods** 类型的参数。
21411: 619:
21412: 620:如果使用基本类型调用 `f()` ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。
21413: 621:
21414: 622:<!-- Varargs and Generic Methods -->
21415: 623:
21416: 624:### 变长参数和泛型方法
21417: 625:
21418: 626:泛型方法和变长参数列表可以很好地共存：
21419: 627:
21420: 628:```java
21421: 629:// generics/GenericVarargs.java
21422: 630:
21423: 631:import java.util.ArrayList;
21424: 632:import java.util.List;
21425: 633:
21426: 634:public class GenericVarargs {
21427: 635:    @SafeVarargs
21428: 636:    public static <T> List<T> makeList(T... args) {
21429: 637:        List<T> result = new ArrayList<>();
21430: 638:        for (T item : args)
21431: 639:            result.add(item);
21432: 640:        return result;
21433: 641:    }
21434: 642:
21435: 643:    public static void main(String[] args) {
21436: 644:        List<String> ls = makeList("A");
21437: 645:        System.out.println(ls);
21438: 646:        ls = makeList("A", "B", "C");
21439: 647:        System.out.println(ls);
21440: 648:        ls = makeList(
21441: 649:                "ABCDEFFHIJKLMNOPQRSTUVWXYZ".split(""));
21442: 650:        System.out.println(ls);
21443: 651:    }
21444: 652:}
21445: 653:/* Output:
21446: 654:[A]
21447: 655:[A, B, C]
21448: 656:[A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R,
21449: 657:S, T, U, V, W, X, Y, Z]
21450: 658:*/
21451: 659:```
21452: 660:
21453: 661:此处显示的 `makeList()` 方法产生的功能与标准库的 `java.util.Arrays.asList()` 方法相同。
21454: 662:
21455: 663:`@SafeVarargs` 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。
21456: 664:
21457: 665:<!-- A General-Purpose Supplier -->
21458: 666:
21459: 667:### 一个泛型的 Supplier
21460: 668:
21461: 669:这是一个为任意具有无参构造方法的类生成 **Supplier** 的类。为了减少键入，它还包括一个用于生成 **BasicSupplier** 的泛型方法：
21462: 670:
21463: 671:```java
21464: 672:// onjava/BasicSupplier.java
21465: 673:// Supplier from a class with a no-arg constructor
21466: 674:package onjava;
21467: 675:
21468: 676:import java.util.function.Supplier;
21469: 677:
21470: 678:public class BasicSupplier<T> implements Supplier<T> {
21471: 679:    private Class<T> type;
21472: 680:
21473: 681:    public BasicSupplier(Class<T> type) {
21474: 682:        this.type = type;
21475: 683:    }
21476: 684:
21477: 685:    @Override
21478: 686:    public T get() {
21479: 687:        try {
21480: 688:            // Assumes type is a public class:
21481: 689:            return type.newInstance();
21482: 690:        } catch (InstantiationException |
21483: 691:                IllegalAccessException e) {
21484: 692:            throw new RuntimeException(e);
21485: 693:        }
21486: 694:    }
21487: 695:
21488: 696:    // Produce a default Supplier from a type token:
21489: 697:    public static <T> Supplier<T> create(Class<T> type) {
21490: 698:        return new BasicSupplier<>(type);
21491: 699:    }
21492: 700:}
21493: 701:```
21494: 702:
21495: 703:此类提供了产生以下对象的基本实现：
21496: 704:
21497: 705:1. 是 **public** 的。 因为 **BasicSupplier** 在单独的包中，所以相关的类必须具有 **public** 权限，而不仅仅是包级访问权限。
21498: 706:
21499: 707:2. 具有无参构造方法。要创建一个这样的 **BasicSupplier** 对象，请调用 `create()` 方法，并将要生成类型的类型令牌传递给它。通用的 `create()` 方法提供了 `BasicSupplier.create(MyType.class)` 这种较简洁的语法来代替较笨拙的 `new BasicSupplier <MyType>(MyType.class)`。
21500: 708:
21501: 709:例如，这是一个具有无参构造方法的简单类：
21502: 710:
21503: 711:```java
21504: 712:// generics/CountedObject.java
21505: 713:
21506: 714:public class CountedObject {
21507: 715:    private static long counter = 0;
21508: 716:    private final long id = counter++;
21509: 717:
21510: 718:    public long id() {
21511: 719:        return id;
21512: 720:    }
21513: 721:
21514: 722:    @Override
21515: 723:    public String toString() {
21516: 724:        return "CountedObject " + id;
21517: 725:    }
21518: 726:}
21519: 727:```
21520: 728:
21521: 729:**CountedObject** 类可以跟踪自身创建了多少个实例，并通过 `toString()` 报告这些实例的数量。 **BasicSupplier** 可以轻松地为 **CountedObject** 创建 **Supplier**：
21522: 730:
21523: 731:```java
21524: 732:  // generics/BasicSupplierDemo.java
21525: 733:
21526: 734:import onjava.BasicSupplier;
21527: 735:
21528: 736:import java.util.stream.Stream;
21529: 737:
21530: 738:public class BasicSupplierDemo {
21531: 739:    public static void main(String[] args) {
21532: 740:        Stream.generate(
21533: 741:                BasicSupplier.create(CountedObject.class))
21534: 742:                .limit(5)
21535: 743:                .forEach(System.out::println);
21536: 744:    }
21537: 745:}
21538: 746:/* Output:
21539: 747:CountedObject 0
21540: 748:CountedObject 1
21541: 749:CountedObject 2
21542: 750:CountedObject 3
21543: 751:CountedObject 4
21544: 752:*/
21545: 753:```
21546: 754:
21547: 755:泛型方法减少了产生 **Supplier** 对象所需的代码量。 Java 泛型强制传递 **Class** 对象，以便在 `create()` 方法中将其用于类型推断。
21548: 756:
21549: 757:<!-- Simplifying Tuple Use -->
21550: 758:
21551: 759:### 简化元组的使用
21552: 760:
21553: 761:使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库。在这里，我们使用重载的静态方法创建元组：
21554: 762:
21555: 763:```java
21556: 764:// onjava/Tuple.java
21557: 765:// Tuple library using type argument inference
21558: 766:package onjava;
21559: 767:
21560: 768:public class Tuple {
21561: 769:    public static <A, B> Tuple2<A, B> tuple(A a, B b) {
21562: 770:        return new Tuple2<>(a, b);
21563: 771:    }
21564: 772:
21565: 773:    public static <A, B, C> Tuple3<A, B, C>
21566: 774:    tuple(A a, B b, C c) {
21567: 775:        return new Tuple3<>(a, b, c);
21568: 776:    }
21569: 777:
21570: 778:    public static <A, B, C, D> Tuple4<A, B, C, D>
21571: 779:    tuple(A a, B b, C c, D d) {
21572: 780:        return new Tuple4<>(a, b, c, d);
21573: 781:    }
21574: 782:
21575: 783:    public static <A, B, C, D, E>
21576: 784:    Tuple5<A, B, C, D, E> tuple(A a, B b, C c, D d, E e) {
21577: 785:        return new Tuple5<>(a, b, c, d, e);
21578: 786:    }
21579: 787:}
21580: 788:```
21581: 789:
21582: 790:我们修改 **TupleTest.java** 来测试 **Tuple.java** :
21583: 791:
21584: 792:```java
21585: 793:// generics/TupleTest2.java
21586: 794:
21587: 795:import onjava.Tuple2;
21588: 796:import onjava.Tuple3;
21589: 797:import onjava.Tuple4;
21590: 798:import onjava.Tuple5;
21591: 799:
21592: 800:import static onjava.Tuple.tuple;
21593: 801:
21594: 802:public class TupleTest2 {
21595: 803:    static Tuple2<String, Integer> f() {
21596: 804:        return tuple("hi", 47);
21597: 805:    }
21598: 806:
21599: 807:    static Tuple2 f2() {
21600: 808:        return tuple("hi", 47);
21601: 809:    }
21602: 810:
21603: 811:    static Tuple3<Amphibian, String, Integer> g() {
21604: 812:        return tuple(new Amphibian(), "hi", 47);
21605: 813:    }
21606: 814:
21607: 815:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
21608: 816:        return tuple(
21609: 817:                new Vehicle(), new Amphibian(), "hi", 47);
21610: 818:    }
21611: 819:
21612: 820:    static Tuple5<Vehicle, Amphibian,
21613: 821:            String, Integer, Double> k() {
21614: 822:        return tuple(new Vehicle(), new Amphibian(),
21615: 823:                "hi", 47, 11.1);
21616: 824:    }
21617: 825:
21618: 826:    public static void main(String[] args) {
21619: 827:        Tuple2<String, Integer> ttsi = f();
21620: 828:        System.out.println(ttsi);
21621: 829:        System.out.println(f2());
21622: 830:        System.out.println(g());
21623: 831:        System.out.println(h());
21624: 832:        System.out.println(k());
21625: 833:    }
21626: 834:}
21627: 835:/* Output:
21628: 836:(hi, 47)
21629: 837:(hi, 47)
21630: 838:(Amphibian@14ae5a5, hi, 47)
21631: 839:(Vehicle@135fbaa4, Amphibian@45ee12a7, hi, 47)
21632: 840:(Vehicle@4b67cf4d, Amphibian@7ea987ac, hi, 47, 11.1)
21633: 841:*/
21634: 842:```
21635: 843:
21636: 844:请注意，`f()` 返回一个参数化的 **Tuple2** 对象，而 `f2()` 返回一个未参数化的 **Tuple2** 对象。编译器不会在这里警告 `f2()` ，因为返回值未以参数化方式使用。从某种意义上说，它被“向上转型”为一个未参数化的 **Tuple2** 。 但是，如果尝试将 `f2()` 的结果放入到参数化的 **Tuple2** 中，则编译器将发出警告。
21637: 845:
21638: 846:<!-- A Set Utility -->
21639: 847:
21640: 848:### 一个 Set 工具
21641: 849:
21642: 850:对于泛型方法的另一个示例，请考虑由 **Set** 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法：
21643: 851:
21644: 852:```java
21645: 853:// onjava/Sets.java
21646: 854:
21647: 855:package onjava;
21648: 856:
21649: 857:import java.util.HashSet;
21650: 858:import java.util.Set;
21651: 859:
21652: 860:public class Sets {
21653: 861:    public static <T> Set<T> union(Set<T> a, Set<T> b) {
21654: 862:        Set<T> result = new HashSet<>(a);
21655: 863:        result.addAll(b);
21656: 864:        return result;
21657: 865:    }
21658: 866:
21659: 867:    public static <T>
21660: 868:    Set<T> intersection(Set<T> a, Set<T> b) {
21661: 869:        Set<T> result = new HashSet<>(a);
21662: 870:        result.retainAll(b);
21663: 871:        return result;
21664: 872:    }
21665: 873:
21666: 874:    // Subtract subset from superset:
21667: 875:    public static <T> Set<T>
21668: 876:    difference(Set<T> superset, Set<T> subset) {
21669: 877:        Set<T> result = new HashSet<>(superset);
21670: 878:        result.removeAll(subset);
21671: 879:        return result;
21672: 880:    }
21673: 881:
21674: 882:    // Reflexive--everything not in the intersection:
21675: 883:    public static <T> Set<T> complement(Set<T> a, Set<T> b) {
21676: 884:        return difference(union(a, b), intersection(a, b));
21677: 885:    }
21678: 886:}
21679: 887:```
21680: 888:
21681: 889:前三个方法通过将第一个参数的引用复制到新的 **HashSet** 对象中来复制第一个参数，因此不会直接修改参数集合。因此，返回值是一个新的 **Set** 对象。
21682: 890:
21683: 891:这四种方法代表数学集合操作： `union()` 返回一个包含两个参数并集的 **Set** ， `intersection()` 返回一个包含两个参数集合交集的 **Set** ， `difference()` 从 **superset** 中减去 **subset** 的元素 ，而 `complement()` 返回所有不在交集中的元素的 **Set**。作为显示这些方法效果的简单示例的一部分，下面是一个包含不同水彩名称的 **enum** ：
21684: 892:
21685: 893:```java
21686: 894:// generics/watercolors/Watercolors.java
21687: 895:
21688: 896:package watercolors;
21689: 897:
21690: 898:public enum Watercolors {
21691: 899:    ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW,
21692: 900:    ORANGE, BRILLIANT_RED, CRIMSON, MAGENTA,
21693: 901:    ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE,
21694: 902:    PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE,
21695: 903:    PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN,
21696: 904:    YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
21697: 905:    BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK
21698: 906:}
21699: 907:```
21700: 908:
21701: 909:为了方便起见（不必全限定所有名称），将其静态导入到以下示例中。本示例使用 **EnumSet** 轻松从 **enum** 中创建 **Set** 。（可以在[第二十二章 枚举](book/22-Enumerations.md)一章中了解有关 **EnumSet** 的更多信息。）在这里，静态方法 `EnumSet.range()` 要求提供所要在结果 **Set** 中创建的元素范围的第一个和最后一个元素：
21702: 910:
21703: 911:```java
21704: 912:// generics/WatercolorSets.java
21705: 913:
21706: 914:import watercolors.*;
21707: 915:
21708: 916:import java.util.EnumSet;
21709: 917:import java.util.Set;
21710: 918:
21711: 919:import static watercolors.Watercolors.*;
21712: 920:import static onjava.Sets.*;
21713: 921:
21714: 922:public class WatercolorSets {
21715: 923:    public static void main(String[] args) {
21716: 924:        Set<Watercolors> set1 =
21717: 925:                EnumSet.range(BRILLIANT_RED, VIRIDIAN_HUE);
21718: 926:        Set<Watercolors> set2 =
21719: 927:                EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER);
21720: 928:        System.out.println("set1: " + set1);
21721: 929:        System.out.println("set2: " + set2);
21722: 930:        System.out.println(
21723: 931:                "union(set1, set2): " + union(set1, set2));
21724: 932:        Set<Watercolors> subset = intersection(set1, set2);
21725: 933:        System.out.println(
21726: 934:                "intersection(set1, set2): " + subset);
21727: 935:        System.out.println("difference(set1, subset): " +
21728: 936:                difference(set1, subset));
21729: 937:        System.out.println("difference(set2, subset): " +
21730: 938:                difference(set2, subset));
21731: 939:        System.out.println("complement(set1, set2): " +
21732: 940:                complement(set1, set2));
21733: 941:    }
21734: 942:}
21735: 943:/* Output:
21736: 944:set1: [BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER,
21737: 945:VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
21738: 946:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE]
21739: 947:set2: [CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
21740: 948:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE,
21741: 949:SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
21742: 950:BURNT_UMBER]
21743: 951:union(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
21744: 952:YELLOW_OCHRE, MAGENTA, SAP_GREEN, CERULEAN_BLUE_HUE,
21745: 953:ULTRAMARINE, VIRIDIAN_HUE, VIOLET, RAW_UMBER,
21746: 954:ROSE_MADDER, PERMANENT_GREEN, BURNT_UMBER,
21747: 955:PHTHALO_BLUE, CRIMSON, COBALT_BLUE_HUE]
21748: 956:intersection(set1, set2): [PERMANENT_GREEN,
21749: 957:CERULEAN_BLUE_HUE, ULTRAMARINE, VIRIDIAN_HUE,
21750: 958:PHTHALO_BLUE, COBALT_BLUE_HUE]
21751: 959:difference(set1, subset): [BRILLIANT_RED, MAGENTA,
21752: 960:VIOLET, CRIMSON, ROSE_MADDER]
21753: 961:difference(set2, subset): [BURNT_SIENNA, YELLOW_OCHRE,
21754: 962:BURNT_UMBER, SAP_GREEN, RAW_UMBER]
21755: 963:complement(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
21756: 964:YELLOW_OCHRE, MAGENTA, SAP_GREEN, VIOLET, RAW_UMBER,
21757: 965:ROSE_MADDER, BURNT_UMBER, CRIMSON]
21758: 966:*/
21759: 967:```
21760: 968:
21761: 969:接下来的例子使用 `Sets.difference()` 方法来展示 **java.util** 包中各种 **Collection** 和 **Map** 类之间的方法差异：
21762: 970:
21763: 971:```java
21764: 972:// onjava/CollectionMethodDifferences.java
21765: 973:// {java onjava.CollectionMethodDifferences}
21766: 974:
21767: 975:package onjava;
21768: 976:
21769: 977:import java.lang.reflect.Method;
21770: 978:import java.util.*;
21771: 979:import java.util.stream.Collectors;
21772: 980:
21773: 981:public class CollectionMethodDifferences {
21774: 982:    static Set<String> methodSet(Class<?> type) {
21775: 983:        return Arrays.stream(type.getMethods())
21776: 984:                .map(Method::getName)
21777: 985:                .collect(Collectors.toCollection(TreeSet::new));
21778: 986:    }
21779: 987:
21780: 988:    static void interfaces(Class<?> type) {
21781: 989:        System.out.print("Interfaces in " +
21782: 990:                type.getSimpleName() + ": ");
21783: 991:        System.out.println(
21784: 992:                Arrays.stream(type.getInterfaces())
21785: 993:                        .map(Class::getSimpleName)
21786: 994:                        .collect(Collectors.toList()));
21787: 995:    }
21788: 996:
21789: 997:    static Set<String> object = methodSet(Object.class);
21790: 998:
21791: 999:    static {
21792: 1000:        object.add("clone");
21793: 1001:    }
21794: 1002:
21795: 1003:    static void
21796: 1004:    difference(Class<?> superset, Class<?> subset) {
21797: 1005:        System.out.print(superset.getSimpleName() +
21798: 1006:                " extends " + subset.getSimpleName() +
21799: 1007:                ", adds: ");
21800: 1008:        Set<String> comp = Sets.difference(
21801: 1009:                methodSet(superset), methodSet(subset));
21802: 1010:        comp.removeAll(object); // Ignore 'Object' methods
21803: 1011:        System.out.println(comp);
21804: 1012:        interfaces(superset);
21805: 1013:    }
21806: 1014:
21807: 1015:    public static void main(String[] args) {
21808: 1016:        System.out.println("Collection: " +
21809: 1017:                methodSet(Collection.class));
21810: 1018:        interfaces(Collection.class);
21811: 1019:        difference(Set.class, Collection.class);
21812: 1020:        difference(HashSet.class, Set.class);
21813: 1021:        difference(LinkedHashSet.class, HashSet.class);
21814: 1022:        difference(TreeSet.class, Set.class);
21815: 1023:        difference(List.class, Collection.class);
21816: 1024:        difference(ArrayList.class, List.class);
21817: 1025:        difference(LinkedList.class, List.class);
21818: 1026:        difference(Queue.class, Collection.class);
21819: 1027:        difference(PriorityQueue.class, Queue.class);
21820: 1028:        System.out.println("Map: " + methodSet(Map.class));
21821: 1029:        difference(HashMap.class, Map.class);
21822: 1030:        difference(LinkedHashMap.class, HashMap.class);
21823: 1031:        difference(SortedMap.class, Map.class);
21824: 1032:        difference(TreeMap.class, Map.class);
21825: 1033:    }
21826: 1034:}
21827: 1035:/* Output:
21828: 1036:Collection: [add, addAll, clear, contains, containsAll,
21829: 1037:equals, forEach, hashCode, isEmpty, iterator,
21830: 1038:parallelStream, remove, removeAll, removeIf, retainAll,
21831: 1039:size, spliterator, stream, toArray]
21832: 1040:Interfaces in Collection: [Iterable]
21833: 1041:Set extends Collection, adds: []
21834: 1042:Interfaces in Set: [Collection]
21835: 1043:HashSet extends Set, adds: []
21836: 1044:Interfaces in HashSet: [Set, Cloneable, Serializable]
21837: 1045:LinkedHashSet extends HashSet, adds: []
21838: 1046:Interfaces in LinkedHashSet: [Set, Cloneable,
21839: 1047:Serializable]
21840: 1048:TreeSet extends Set, adds: [headSet,
21841: 1049:descendingIterator, descendingSet, pollLast, subSet,
21842: 1050:floor, tailSet, ceiling, last, lower, comparator,
21843: 1051:pollFirst, first, higher]
21844: 1052:Interfaces in TreeSet: [NavigableSet, Cloneable,
21845: 1053:Serializable]
21846: 1054:List extends Collection, adds: [replaceAll, get,
21847: 1055:indexOf, subList, set, sort, lastIndexOf, listIterator]
21848: 1056:Interfaces in List: [Collection]
21849: 1057:ArrayList extends List, adds: [trimToSize,
21850: 1058:ensureCapacity]
21851: 1059:Interfaces in ArrayList: [List, RandomAccess,
21852: 1060:Cloneable, Serializable]
21853: 1061:LinkedList extends List, adds: [offerFirst, poll,
21854: 1062:getLast, offer, getFirst, removeFirst, element,
21855: 1063:removeLastOccurrence, peekFirst, peekLast, push,
21856: 1064:pollFirst, removeFirstOccurrence, descendingIterator,
21857: 1065:pollLast, removeLast, pop, addLast, peek, offerLast,
21858: 1066:addFirst]
21859: 1067:Interfaces in LinkedList: [List, Deque, Cloneable,
21860: 1068:Serializable]
21861: 1069:Queue extends Collection, adds: [poll, peek, offer,
21862: 1070:element]
21863: 1071:Interfaces in Queue: [Collection]
21864: 1072:PriorityQueue extends Queue, adds: [comparator]
21865: 1073:Interfaces in PriorityQueue: [Serializable]
21866: 1074:Map: [clear, compute, computeIfAbsent,
21867: 1075:computeIfPresent, containsKey, containsValue, entrySet,
21868: 1076:equals, forEach, get, getOrDefault, hashCode, isEmpty,
21869: 1077:keySet, merge, put, putAll, putIfAbsent, remove,
21870: 1078:replace, replaceAll, size, values]
21871: 1079:HashMap extends Map, adds: []
21872: 1080:Interfaces in HashMap: [Map, Cloneable, Serializable]
21873: 1081:LinkedHashMap extends HashMap, adds: []
21874: 1082:Interfaces in LinkedHashMap: [Map]
21875: 1083:SortedMap extends Map, adds: [lastKey, subMap,
21876: 1084:comparator, firstKey, headMap, tailMap]
21877: 1085:Interfaces in SortedMap: [Map]
21878: 1086:TreeMap extends Map, adds: [descendingKeySet,
21879: 1087:navigableKeySet, higherEntry, higherKey, floorKey,
21880: 1088:subMap, ceilingKey, pollLastEntry, firstKey, lowerKey,
21881: 1089:headMap, tailMap, lowerEntry, ceilingEntry,
21882: 1090:descendingMap, pollFirstEntry, lastKey, firstEntry,
21883: 1091:floorEntry, comparator, lastEntry]
21884: 1092:Interfaces in TreeMap: [NavigableMap, Cloneable,
21885: 1093:Serializable]
21886: 1094:*/
21887: 1095:```
21888: 1096:
21889: 1097:在第十二章 [集合的本章小结](book/12-Collections.md#本章小结) 部分将会用到这里的输出结果。
21890: 1098:
21891: 1099:<!-- Building Complex Models -->
21892: 1100:
21893: 1101:## 构建复杂模型
21894: 1102:
21895: 1103:泛型的一个重要好处是能够简单安全地创建复杂模型。例如，我们可以轻松地创建一个元组列表：
21896: 1104:
21897: 1105:```java
21898: 1106:// generics/TupleList.java
21899: 1107:// Combining generic types to make complex generic types
21900: 1108:
21901: 1109:import onjava.Tuple4;
21902: 1110:
21903: 1111:import java.util.ArrayList;
21904: 1112:
21905: 1113:public class TupleList<A, B, C, D>
21906: 1114:        extends ArrayList<Tuple4<A, B, C, D>> {
21907: 1115:    public static void main(String[] args) {
21908: 1116:        TupleList<Vehicle, Amphibian, String, Integer> tl =
21909: 1117:                new TupleList<>();
21910: 1118:        tl.add(TupleTest2.h());
21911: 1119:        tl.add(TupleTest2.h());
21912: 1120:        tl.forEach(System.out::println);
21913: 1121:    }
21914: 1122:}
21915: 1123:/* Output:
21916: 1124:(Vehicle@7cca494b, Amphibian@7ba4f24f, hi, 47)
21917: 1125:(Vehicle@3b9a45b3, Amphibian@7699a589, hi, 47)
21918: 1126:*/
21919: 1127:```
21920: 1128:
21921: 1129:这将产生一个功能强大的数据结构，而无需太多代码。
21922: 1130:
21923: 1131:下面是第二个例子。每个类都是组成块，总体包含很多个块。在这里，该模型是一个具有过道，货架和产品的零售商店：
21924: 1132:
21925: 1133:```java
21926: 1134:// generics/Store.java
21927: 1135:// Building a complex model using generic collections
21928: 1136:
21929: 1137:import onjava.Suppliers;
21930: 1138:
21931: 1139:import java.util.ArrayList;
21932: 1140:import java.util.Random;
21933: 1141:import java.util.function.Supplier;
21934: 1142:
21935: 1143:class Product {
21936: 1144:    private final int id;
21937: 1145:    private String description;
21938: 1146:    private double price;
21939: 1147:
21940: 1148:    Product(int idNumber, String descr, double price) {
21941: 1149:        id = idNumber;
21942: 1150:        description = descr;
21943: 1151:        this.price = price;
21944: 1152:        System.out.println(toString());
21945: 1153:    }
21946: 1154:
21947: 1155:    @Override
21948: 1156:    public String toString() {
21949: 1157:        return id + ": " + description +
21950: 1158:                ", price: $" + price;
21951: 1159:    }
21952: 1160:
21953: 1161:    public void priceChange(double change) {
21954: 1162:        price += change;
21955: 1163:    }
21956: 1164:
21957: 1165:    public static Supplier<Product> generator =
21958: 1166:            new Supplier<Product>() {
21959: 1167:                private Random rand = new Random(47);
21960: 1168:
21961: 1169:                @Override
21962: 1170:                public Product get() {
21963: 1171:                    return new Product(rand.nextInt(1000), "Test",
21964: 1172:                            Math.round(
21965: 1173:                                    rand.nextDouble() * 1000.0) + 0.99);
21966: 1174:                }
21967: 1175:            };
21968: 1176:}
21969: 1177:
21970: 1178:class Shelf extends ArrayList<Product> {
21971: 1179:    Shelf(int nProducts) {
21972: 1180:        Suppliers.fill(this, Product.generator, nProducts);
21973: 1181:    }
21974: 1182:}
21975: 1183:
21976: 1184:class Aisle extends ArrayList<Shelf> {
21977: 1185:    Aisle(int nShelves, int nProducts) {
21978: 1186:        for (int i = 0; i < nShelves; i++)
21979: 1187:            add(new Shelf(nProducts));
21980: 1188:    }
21981: 1189:}
21982: 1190:
21983: 1191:class CheckoutStand {
21984: 1192:}
21985: 1193:
21986: 1194:class Office {
21987: 1195:}
21988: 1196:
21989: 1197:public class Store extends ArrayList<Aisle> {
21990: 1198:    private ArrayList<CheckoutStand> checkouts =
21991: 1199:            new ArrayList<>();
21992: 1200:    private Office office = new Office();
21993: 1201:
21994: 1202:    public Store(
21995: 1203:            int nAisles, int nShelves, int nProducts) {
21996: 1204:        for (int i = 0; i < nAisles; i++)
21997: 1205:            add(new Aisle(nShelves, nProducts));
21998: 1206:    }
21999: 1207:
22000: 1208:    @Override
22001: 1209:    public String toString() {
22002: 1210:        StringBuilder result = new StringBuilder();
22003: 1211:        for (Aisle a : this)
22004: 1212:            for (Shelf s : a)
22005: 1213:                for (Product p : s) {
22006: 1214:                    result.append(p);
22007: 1215:                    result.append("\n");
22008: 1216:                }
22009: 1217:        return result.toString();
22010: 1218:    }
22011: 1219:
22012: 1220:    public static void main(String[] args) {
22013: 1221:        System.out.println(new Store(5, 4, 3));
22014: 1222:    }
22015: 1223:}
22016: 1224:/* Output: (First 8 Lines)
22017: 1225:258: Test, price: $400.99
22018: 1226:861: Test, price: $160.99
22019: 1227:868: Test, price: $417.99
22020: 1228:207: Test, price: $268.99
22021: 1229:551: Test, price: $114.99
22022: 1230:278: Test, price: $804.99
22023: 1231:520: Test, price: $554.99
22024: 1232:140: Test, price: $530.99
22025: 1233:                  ...
22026: 1234:*/
22027: 1235:```
22028: 1236:
22029: 1237:`Store.toString()` 显示了结果：尽管有复杂的层次结构，但多层的集合仍然是类型安全的和可管理的。令人印象深刻的是，组装这样的模型并不需要耗费过多精力。
22030: 1238:
22031: 1239:**Shelf** 使用 `Suppliers.fill()` 这个实用程序，该实用程序接受 **Collection** （第一个参数），并使用 **Supplier** （第二个参数），以元素的数量为 **n** （第三个参数）来填充它。 **Suppliers** 类将会在本章末尾定义，其中的方法都是在执行某种填充操作，并在本章的其他示例中使用。
22032: 1240:
22033: 1241:<!-- The Mystery of Erasure -->
22034: 1242:
22035: 1243:## 泛型擦除
22036: 1244:
22037: 1245:当你开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的。例如，尽管可以说  `ArrayList.class`，但不能说成 `ArrayList<Integer>.class`。考虑下面的情况：
22038: 1246:
22039: 1247:```java
22040: 1248:// generics/ErasedTypeEquivalence.java
22041: 1249:
22042: 1250:import java.util.*;
22043: 1251:
22044: 1252:public class ErasedTypeEquivalence {
22045: 1253:    
22046: 1254:    public static void main(String[] args) {
22047: 1255:        Class c1 = new ArrayList<String>().getClass();
22048: 1256:        Class c2 = new ArrayList<Integer>().getClass();
22049: 1257:        System.out.println(c1 == c2);
22050: 1258:    }
22051: 1259:    
22052: 1260:}
22053: 1261:/* Output:
22054: 1262:true
22055: 1263:*/
22056: 1264:```
22057: 1265:
22058: 1266:`ArrayList<String>` 和 `ArrayList<Integer>` 应该是不同的类型。不同的类型会有不同的行为。例如，如果尝试向 `ArrayList<String>` 中放入一个 `Integer`，所得到的行为（失败）和向 `ArrayList<Integer>` 中放入一个 `Integer` 所得到的行为（成功）完全不同。然而上面的程序认为它们是相同的类型。
22059: 1267:
22060: 1268:下面的例子是对该谜题的补充：
22061: 1269:
22062: 1270:```java
22063: 1271:// generics/LostInformation.java
22064: 1272:
22065: 1273:import java.util.*;
22066: 1274:
22067: 1275:class Frob {}
22068: 1276:class Fnorkle {}
22069: 1277:class Quark<Q> {}
22070: 1278:
22071: 1279:class Particle<POSITION, MOMENTUM> {}
22072: 1280:
22073: 1281:public class LostInformation {
22074: 1282:
22075: 1283:    public static void main(String[] args) {
22076: 1284:        List<Frob> list = new ArrayList<>();
22077: 1285:        Map<Frob, Fnorkle> map = new HashMap<>();
22078: 1286:        Quark<Fnorkle> quark = new Quark<>();
22079: 1287:        Particle<Long, Double> p = new Particle<>();
22080: 1288:        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));
22081: 1289:        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));
22082: 1290:        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));
22083: 1291:        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));
22084: 1292:    }
22085: 1293:
22086: 1294:}
22087: 1295:/* Output:
22088: 1296:[E]
22089: 1297:[K,V]
22090: 1298:[Q]
22091: 1299:[POSITION,MOMENTUM]
22092: 1300:*/
22093: 1301:```
22094: 1302:
22095: 1303:根据 JDK 文档，**Class.getTypeParameters()** “返回一个 **TypeVariable** 对象数组，表示泛型声明中声明的类型参数...” 这暗示你可以发现这些参数类型。但是正如上例中输出所示，你只能看到用作参数占位符的标识符，这并非有用的信息。
22096: 1304:
22097: 1305:残酷的现实是：
22098: 1306:
22099: 1307:在泛型代码内部，无法获取任何有关泛型参数类型的信息。
22100: 1308:
22101: 1309:因此，你可以知道如类型参数标识符和泛型边界这些信息，但无法得知实际的类型参数从而用来创建特定的实例。如果你曾是 C++ 程序员，那么这个事实会让你很沮丧，在使用 Java 泛型工作时，它是必须处理的最基本的问题。
22102: 1310:
22103: 1311:Java 泛型是使用擦除实现的。这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此，`List<String>` 和 `List<Integer>` 在运行时实际上是相同的类型。它们都被擦除成原生类型 `List`。
22104: 1312:
22105: 1313:理解擦除并知道如何处理它，是你在学习 Java 泛型时面临的最大障碍之一。这也是本节将要探讨的内容。
22106: 1314:
22107: 1315:### C++ 的方式
22108: 1316:
22109: 1317:下面是使用模版的 C++ 示例。你会看到类型参数的语法十分相似，因为 Java 是受 C++ 启发的：
22110: 1318:
22111: 1319:```c++
22112: 1320:// generics/Templates.cpp
22113: 1321:
22114: 1322:#include <iostream>
22115: 1323:using namespace std;
22116: 1324:
22117: 1325:template<class T> class Manipulator {
22118: 1326:    T obj;
22119: 1327:public:
22120: 1328:    Manipulator(T x) { obj = x; }
22121: 1329:    void manipulate() { obj.f(); }
22122: 1330:};
22123: 1331:
22124: 1332:class HasF {
22125: 1333:public:
22126: 1334:    void f() { cout << "HasF::f()" << endl; }
22127: 1335:};
22128: 1336:
22129: 1337:int main() {
22130: 1338:    HasF hf;
22131: 1339:    Manipulator<HasF> manipulator(hf);
22132: 1340:    manipulator.manipulate();
22133: 1341:}
22134: 1342:/* Output:
22135: 1343:HasF::f()
22136: 1344:*/
22137: 1345:```
22138: 1346:
22139: 1347:**Manipulator** 类存储了一个 **T** 类型的对象。`manipulate()` 方法会调用 **obj** 上的 `f()` 方法。它是如何知道类型参数 **T** 中存在 `f()` 方法的呢？C++ 编译器会在你实例化模版时进行检查，所以在 `Manipulator<HasF>` 实例化的那一刻，它看到 **HasF** 中含有一个方法 `f()`。如果情况并非如此，你就会得到一个编译期错误，保持类型安全。
22140: 1348:
22141: 1349:用 C++ 编写这种代码很简单，因为当模版被实例化时，模版代码就知道模版参数的类型。Java 泛型就不同了。下面是 **HasF** 的 Java 版本：
22142: 1350:
22143: 1351:```java
22144: 1352:// generics/HasF.java
22145: 1353:
22146: 1354:public class HasF {
22147: 1355:    public void f() {
22148: 1356:        System.out.println("HasF.f()");
22149: 1357:    }
22150: 1358:}
22151: 1359:```
22152: 1360:
22153: 1361:如果我们将示例的其余代码用 Java 实现，就不会通过编译：
22154: 1362:
22155: 1363:```java
22156: 1364:// generics/Manipulation.java
22157: 1365:// {WillNotCompile}
22158: 1366:
22159: 1367:class Manipulator<T> {
22160: 1368:    private T obj;
22161: 1369:    
22162: 1370:    Manipulator(T x) {
22163: 1371:        obj = x;
22164: 1372:    }
22165: 1373:    
22166: 1374:    // Error: cannot find symbol: method f():
22167: 1375:    public void manipulate() {
22168: 1376:        obj.f();
22169: 1377:    }
22170: 1378:}
22171: 1379:
22172: 1380:public class Manipulation {
22173: 1381:	public static void main(String[] args) {
22174: 1382:        HasF hf = new HasF();
22175: 1383:        Manipulator<HasF> manipulator = new Manipulator<>(hf);
22176: 1384:        manipulator.manipulate();
22177: 1385:    }
22178: 1386:}
22179: 1387:```
22180: 1388:
22181: 1389:因为擦除，Java 编译器无法将 `manipulate()` 方法必须能调用 **obj** 的 `f()` 方法这一需求映射到 HasF 具有 `f()` 方法这个事实上。为了调用 `f()`，我们必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。这里重用了 **extends** 关键字。由于有了边界，下面的代码就能通过编译：
22182: 1390:
22183: 1391:```java
22184: 1392:public class Manipulator2<T extends HasF> {
22185: 1393:    private T obj;
22186: 1394:
22187: 1395:    Manipulator2(T x) {
22188: 1396:        obj = x;
22189: 1397:    }
22190: 1398:
22191: 1399:    public void manipulate() {
22192: 1400:        obj.f();
22193: 1401:    }
22194: 1402:}
22195: 1403:```
22196: 1404:
22197: 1405:边界 `<T extends HasF>` 声明 T 必须是 HasF 类型或其子类。如果情况确实如此，就可以安全地在 **obj** 上调用 `f()` 方法。
22198: 1406:
22199: 1407:我们说泛型类型参数会擦除到它的第一个边界（可能有多个边界，稍后你将看到）。我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的示例，**T** 擦除到了 **HasF**，就像在类的声明中用 **HasF** 替换了 **T** 一样。
22200: 1408:
22201: 1409:你可能正确地观察到了泛型在 **Manipulator2.java** 中没有贡献任何事。你可以很轻松地自己去执行擦除，生成没有泛型的类：
22202: 1410:
22203: 1411:```java
22204: 1412:// generics/Manipulator3.java
22205: 1413:
22206: 1414:class Manipulator3 {
22207: 1415:    private HasF obj;
22208: 1416:    
22209: 1417:    Manipulator3(HasF x) {
22210: 1418:        obj = x;
22211: 1419:    }
22212: 1420:    
22213: 1421:    public void manipulate() {
22214: 1422:        obj.f();
22215: 1423:    }
22216: 1424:}
22217: 1425:```
22218: 1426:
22219: 1427:这提出了很重要的一点：泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用。因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换更加复杂。但是，不能因此认为使用 `<T extends HasF>` 形式就是有缺陷的。例如，如果某个类有一个返回 **T** 的方法，那么泛型就有所帮助，因为它们之后将返回确切的类型：
22220: 1428:
22221: 1429:```java
22222: 1430:// generics/ReturnGenericType.java
22223: 1431:
22224: 1432:public class ReturnGenericType<T extends HasF> {
22225: 1433:    private T obj;
22226: 1434:    
22227: 1435:    ReturnGenericType(T x) {
22228: 1436:        obj = x;
22229: 1437:    }
22230: 1438:    
22231: 1439:    public T get() {
22232: 1440:        return obj;
22233: 1441:    }
22234: 1442:}
22235: 1443:```
22236: 1444:
22237: 1445:你必须查看所有的代码，从而确定代码是否复杂到必须使用泛型的程度。
22238: 1446:
22239: 1447:我们将在本章稍后看到有关边界的更多细节。
22240: 1448:
22241: 1449:### 迁移兼容性
22242: 1450:
22243: 1451:为了减少潜在的关于擦除的困惑，你必须清楚地认识到这不是一个语言特性。它是 Java 实现泛型的一种妥协，因为泛型不是 Java 语言出现时就有的，所以就有了这种妥协。它会使你痛苦，因此你需要尽早习惯它并了解为什么它会这样。
22244: 1452:
22245: 1453:如果 Java 1.0 就含有泛型的话，那么这个特性就不会使用擦除来实现——它会使用具体化，保持参数类型为第一类实体，因此你就能在类型参数上执行基于类型的语言操作和反射操作。本章稍后你会看到，擦除减少了泛型的泛化性。泛型在 Java 中仍然是有用的，只是不如它们本来设想的那么有用，而原因就是擦除。
22246: 1454:
22247: 1455:在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文使用泛型类型。泛型类型只有在静态类型检测期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如， `List<T>` 这样的类型注解会被擦除为 **List**，普通的类型变量在未指定边界的情况下会被擦除为 **Object**。
22248: 1456:
22249: 1457:擦除的核心动机是你可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称为“迁移兼容性”。在理想情况下，所有事物将在指定的某天被泛化。在现实中，即使程序员只编写泛型代码，他们也必须处理 Java 5 之前编写的非泛型类库。这些类库的作者可能从没想过要泛化他们的代码，或许他们可能刚刚开始接触泛型。
22250: 1458:
22251: 1459:因此 Java 泛型不仅必须支持向后兼容性——现有的代码和类文件仍然合法，继续保持之前的含义——而且还必须支持迁移兼容性，使得类库能按照它们自己的步调变为泛型，当某个类库变为泛型时，不会破坏依赖于它的代码和应用。在确定了这个目标后，Java 设计者们和从事此问题相关工作的各个团队决策认为擦除是唯一可行的解决方案。擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。
22252: 1460:
22253: 1461:例如，假设一个应用使用了两个类库 **X** 和 **Y**，**Y** 使用了类库 **Z**。随着 Java 5 的出现，这个应用和这些类库的创建者最终可能希望迁移到泛型上。但是当进行迁移时，它们有着不同的动机和限制。为了实现迁移兼容性，每个类库与应用必须与其他所有的部分是否使用泛型无关。因此，它们不能探测其他类库是否使用了泛型。因此，某个特定的类库使用了泛型这样的证据必须被”擦除“。
22254: 1462:
22255: 1463:如果没有某种类型的迁移途径，所有已经构建了很长时间的类库就需要与希望迁移到 Java 泛型上的开发者们说再见了。类库毫无争议是编程语言的一部分，对生产效率有着极大的影响，所以这种代码无法接受。擦除是否是最佳的或唯一的迁移途径，还待时间来证明。
22256: 1464:
22257: 1465:### 擦除的问题
22258: 1466:
22259: 1467:因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。擦除允许你继续使用现有的非泛型客户端代码，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会骤然破坏所有现有的代码。
22260: 1468:
22261: 1469:擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作中，例如转型、**instanceof** 操作和 **new** 表达式。因为所有关于参数的类型信息都丢失了，当你在编写泛型代码时，必须时刻提醒自己，你只是看起来拥有有关参数的类型信息而已。
22262: 1470:
22263: 1471:考虑如下的代码段：
22264: 1472:
22265: 1473:```java
22266: 1474:class Foo<T> {
22267: 1475:    T var;
22268: 1476:}
22269: 1477:```
22270: 1478:
22271: 1479:看上去当你创建一个 **Foo** 实例时：
22272: 1480:
22273: 1481:```java
22274: 1482:Foo<Cat> f = new Foo<>();
22275: 1483:```
22276: 1484:
22277: 1485:**class** **Foo** 中的代码应该知道现在工作于 **Cat** 之上。泛型语法也在强烈暗示整个类中所有 T 出现的地方都被替换，就像在 C++ 中一样。但是事实并非如此，当你在编写这个类的代码时，必须提醒自己：“不，这只是一个 **Object**“。
22278: 1486:
22279: 1487:另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管你可能希望这样：
22280: 1488:
22281: 1489:```java
22282: 1490:// generics/ErasureAndInheritance.java
22283: 1491:
22284: 1492:class GenericBase<T> {
22285: 1493:    private T element;
22286: 1494:    
22287: 1495:    public void set(T arg) {
22288: 1496:        element = arg;
22289: 1497:    }
22290: 1498:    
22291: 1499:    public T get() {
22292: 1500:        return element;
22293: 1501:    }
22294: 1502:}
22295: 1503:
22296: 1504:class Derived1<T> extends GenericBase<T> {}
22297: 1505:
22298: 1506:class Derived2 extends GenericBase {} // No warning
22299: 1507:
22300: 1508:// class Derived3 extends GenericBase<?> {}
22301: 1509:// Strange error:
22302: 1510:// unexpected type
22303: 1511:// required: class or interface without bounds
22304: 1512:public class ErasureAndInteritance {
22305: 1513:    @SuppressWarnings("unchecked")
22306: 1514:    public static void main(String[] args) {
22307: 1515:        Derived2 d2 = new Derived2();
22308: 1516:        Object obj = d2.get();
22309: 1517:        d2.set(obj); // Warning here!
22310: 1518:    }
22311: 1519:}
22312: 1520:```
22313: 1521:
22314: 1522:**Derived2** 继承自 **GenericBase**，但是没有任何类型参数，编译器没有发出任何警告。直到调用 `set()` 方法时才出现警告。
22315: 1523:
22316: 1524:为了关闭警告，Java 提供了一个注解，我们可以在列表中看到它：
22317: 1525:
22318: 1526:```java
22319: 1527:@SuppressWarnings("unchecked")
22320: 1528:```
22321: 1529:
22322: 1530:这个注解放置在产生警告的方法上，而不是整个类上。当你要关闭警告时，最好尽可能地“聚焦”，这样就不会因为过于宽泛地关闭警告，而导致意外地遮蔽掉真正的问题。
22323: 1531:
22324: 1532:可以推断，**Derived3** 产生的错误意味着编译器期望得到一个原生基类。
22325: 1533:
22326: 1534:当你希望将类型参数不仅仅当作 Object 处理时，就需要付出额外努力来管理边界，并且与在 C++、Ada 和 Eiffel 这样的语言中获得参数化类型相比，你需要付出多得多的努力来获得少得多的回报。这并不是说，对于大多数的编程问题而言，这些语言通常都会比 Java 更得心应手，只是说它们的参数化类型机制相比 Java 更灵活、更强大。
22327: 1535:
22328: 1536:### 边界处的动作
22329: 1537:
22330: 1538:因为擦除，我发现了泛型最令人困惑的方面是可以表示没有任何意义的事物。例如：
22331: 1539:
22332: 1540:```java
22333: 1541:// generics/ArrayMaker.java
22334: 1542:
22335: 1543:import java.lang.reflect.*;
22336: 1544:import java.util.*;
22337: 1545:
22338: 1546:public class ArrayMaker<T> {
22339: 1547:    private Class<T> kind;
22340: 1548:
22341: 1549:    public ArrayMaker(Class<T> kind) {
22342: 1550:        this.kind = kind;
22343: 1551:    }
22344: 1552:
22345: 1553:    @SuppressWarnings("unchecked")
22346: 1554:    T[] create(int size) {
22347: 1555:        return (T[]) Array.newInstance(kind, size);
22348: 1556:    }
22349: 1557:
22350: 1558:    public static void main(String[] args) {
22351: 1559:        ArrayMaker<String> stringMaker = new ArrayMaker<>(String.class);
22352: 1560:        String[] stringArray = stringMaker.create(9);
22353: 1561:        System.out.println(Arrays.toString(stringArray));
22354: 1562:    }
22355: 1563:}
22356: 1564:/* Output
22357: 1565:[null,null,null,null,null,null,null,null,null]
22358: 1566:*/
22359: 1567:```
22360: 1568:
22361: 1569:即使 **kind** 被存储为 `Class<T>`，擦除也意味着它实际被存储为没有任何参数的 **Class**。因此，当你在使用它时，例如创建数组，`Array.newInstance()` 实际上并未拥有 **kind** 所蕴含的类型信息。所以它不会产生具体的结果，因而必须转型，这会产生一条令你无法满意的警告。
22362: 1570:
22363: 1571:注意，对于在泛型中创建数组，使用 `Array.newInstance()` 是推荐的方式。
22364: 1572:
22365: 1573:如果我们创建一个集合而不是数组，情况就不同了：
22366: 1574:
22367: 1575:```java
22368: 1576:// generics/ListMaker.java
22369: 1577:
22370: 1578:import java.util.*;
22371: 1579:
22372: 1580:public class ListMaker<T> {
22373: 1581:    List<T> create() {
22374: 1582:        return new ArrayList<>();
22375: 1583:    }
22376: 1584:    
22377: 1585:    public static void main(String[] args) {
22378: 1586:        ListMaker<String> stringMaker = new ListMaker<>();
22379: 1587:        List<String> stringList = stringMaker.create();
22380: 1588:    }
22381: 1589:}
22382: 1590:```
22383: 1591:
22384: 1592:编译器不会给出任何警告，尽管我们知道（从擦除中）在 `create()` 内部的 `new ArrayList<>()` 中的 `<T>` 被移除了——在运行时，类内部没有任何 `<T>`，因此这看起来毫无意义。但是如果你遵从这种思路，并将这个表达式改为 `new ArrayList()`，编译器就会发出警告。
22385: 1593:
22386: 1594:本例中这么做真的毫无意义吗？如果在创建 **List** 的同时向其中放入一些对象呢，像这样：
22387: 1595:
22388: 1596:```java
22389: 1597:// generics/FilledList.java
22390: 1598:
22391: 1599:import java.util.*;
22392: 1600:import java.util.function.*;
22393: 1601:import onjava.*;
22394: 1602:
22395: 1603:public class FilledList<T> extends ArrayList<T> {
22396: 1604:    FilledList(Supplier<T> gen, int size) {
22397: 1605:        Suppliers.fill(this, gen, size);
22398: 1606:    }
22399: 1607:    
22400: 1608:    public FilledList(T t, int size) {
22401: 1609:        for (int i = 0; i < size; i++) {
22402: 1610:            this.add(t);
22403: 1611:        }
22404: 1612:    }
22405: 1613:    
22406: 1614:    public static void main(String[] args) {
22407: 1615:        List<String> list = new FilledList<>("Hello", 4);
22408: 1616:        System.out.println(list);
22409: 1617:        // Supplier version:
22410: 1618:        List<Integer> ilist = new FilledList<>(() -> 47, 4);
22411: 1619:        System.out.println(ilist);
22412: 1620:    }
22413: 1621:}
22414: 1622:/* Output:
22415: 1623:[Hello,Hello,Hello,Hello]
22416: 1624:[47,47,47,47]
22417: 1625:*/
22418: 1626:```
22419: 1627:
22420: 1628:即使编译器无法得知 `add()` 中的 **T** 的任何信息，但它仍可以在编译期确保你放入 **FilledList** 中的对象是 **T** 类型。因此，即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。
22421: 1629:
22422: 1630:因为擦除移除了方法体中的类型信息，所以在运行时的问题就是*边界*：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。
22423: 1631:
22424: 1632:考虑如下这段非泛型示例：
22425: 1633:
22426: 1634:```java
22427: 1635:// generics/SimpleHolder.java
22428: 1636:
22429: 1637:public class SimpleHolder {
22430: 1638:    private Object obj;
22431: 1639:    
22432: 1640:    public void set(Object obj) {
22433: 1641:        this.obj = obj;
22434: 1642:    }
22435: 1643:    
22436: 1644:    public Object get() {
22437: 1645:        return obj;
22438: 1646:    }
22439: 1647:    
22440: 1648:    public static void main(String[] args) {
22441: 1649:        SimpleHolder holder = new SimpleHolder();
22442: 1650:        holder.set("Item");
22443: 1651:        String s = (String) holder.get();
22444: 1652:    }
22445: 1653:}
22446: 1654:```
22447: 1655:
22448: 1656:如果用 **javap -c SimpleHolder** 反编译这个类，会得到如下内容（经过编辑）：
22449: 1657:
22450: 1658:```java
22451: 1659:public void set(java.lang.Object);
22452: 1660:   0: aload_0
22453: 1661:   1: aload_1
22454: 1662:   2: putfield #2; // Field obj:Object;
22455: 1663:   5: return
22456: 1664:    
22457: 1665:public java.lang.Object get();
22458: 1666:   0: aload_0
22459: 1667:   1: getfield #2; // Field obj:Object;
22460: 1668:   4: areturn
22461: 1669:    
22462: 1670:public static void main(java.lang.String[]);
22463: 1671:   0: new #3; // class SimpleHolder
22464: 1672:   3: dup
22465: 1673:   4: invokespecial #4; // Method "<init>":()V
22466: 1674:   7: astore_1
22467: 1675:   8: aload_1
22468: 1676:   9: ldc #5; // String Item
22469: 1677:   11: invokevirtual #6; // Method set:(Object;)V
22470: 1678:   14: aload_1
22471: 1679:   15: invokevirtual #7; // Method get:()Object;
22472: 1680:   18: checkcast #8; // class java/lang/String
22473: 1681:   21: astore_2
22474: 1682:   22: return
22475: 1683:```
22476: 1684:
22477: 1685:`set()` 和 `get()` 方法存储和产生值，转型在调用 `get()` 时接受检查。
22478: 1686:
22479: 1687:现在将泛型融入上例代码中：
22480: 1688:
22481: 1689:```java
22482: 1690:// generics/GenericHolder2.java
22483: 1691:
22484: 1692:public class GenericHolder2<T> {
22485: 1693:    private T obj;
22486: 1694:
22487: 1695:    public void set(T obj) {
22488: 1696:        this.obj = obj;
22489: 1697:    }
22490: 1698:
22491: 1699:    public T get() {
22492: 1700:        return obj;
22493: 1701:    }
22494: 1702:
22495: 1703:    public static void main(String[] args) {
22496: 1704:        GenericHolder2<String> holder =  new GenericHolder2<>();
22497: 1705:        holder.set("Item");
22498: 1706:        String s = holder.get();
22499: 1707:    }
22500: 1708:}
22501: 1709:```
22502: 1710:
22503: 1711:从 `get()` 返回后的转型消失了，但是我们还知道传递给 `set()` 的值在编译期会被检查。下面是相关的字节码：
22504: 1712:
22505: 1713:```java
22506: 1714:public void set(java.lang.Object);
22507: 1715:   0: aload_0
22508: 1716:   1: aload_1
22509: 1717:   2: putfield #2; // Field obj:Object;
22510: 1718:   5: return
22511: 1719:       
22512: 1720:public java.lang.Object get();
22513: 1721:   0: aload_0
22514: 1722:   1: getfield #2; // Field obj:Object;
22515: 1723:   4: areturn
22516: 1724:       
22517: 1725:public static void main(java.lang.String[]);
22518: 1726:   0: new #3; // class GenericHolder2
22519: 1727:   3: dup
22520: 1728:   4: invokespecial #4; // Method "<init>":()V
22521: 1729:   7: astore_1
22522: 1730:   8: aload_1
22523: 1731:   9: ldc #5; // String Item
22524: 1732:   11: invokevirtual #6; // Method set:(Object;)V
22525: 1733:   14: aload_1
22526: 1734:   15: invokevirtual #7; // Method get:()Object;
22527: 1735:   18: checkcast #8; // class java/lang/String
22528: 1736:   21: astore_2
22529: 1737:   22: return
22530: 1738:```
22531: 1739:
22532: 1740:所产生的字节码是相同的。对进入 `set()` 的类型进行检查是不需要的，因为这将由编译器执行。而对 `get()` 返回的值进行转型仍然是需要的，只不过不需要你来操作，它由编译器自动插入，这样你就不用编写（阅读）杂乱的代码。
22533: 1741:
22534: 1742:`get()` 和 `set()` 产生了相同的字节码，这就告诉我们泛型的所有动作都发生在边界处——对入参的编译器检查和对返回值的转型。这有助于澄清对擦除的困惑，记住：“边界就是动作发生的地方”。
22535: 1743:
22536: 1744:<!-- Compensating for Erasure -->
22537: 1745:
22538: 1746:## 补偿擦除
22539: 1747:
22540: 1748:因为擦除，我们将失去执行泛型代码中某些操作的能力。无法在运行时知道确切类型：
22541: 1749:
22542: 1750:```java
22543: 1751:// generics/Erased.java
22544: 1752:// {WillNotCompile}
22545: 1753:
22546: 1754:public class Erased<T> {
22547: 1755:    private final int SIZE = 100;
22548: 1756:
22549: 1757:    public void f(Object arg) {
22550: 1758:        // error: illegal generic type for instanceof
22551: 1759:        if (arg instanceof T) {
22552: 1760:        }
22553: 1761:        // error: unexpected type
22554: 1762:        T var = new T();
22555: 1763:        // error: generic array creation
22556: 1764:        T[] array = new T[SIZE];
22557: 1765:        // warning: [unchecked] unchecked cast
22558: 1766:        T[] array = (T[]) new Object[SIZE];
22559: 1767:
22560: 1768:    }
22561: 1769:}
22562: 1770:```
22563: 1771:
22564: 1772:有时，我们可以对这些问题进行编程，但是有时必须通过引入类型标签来补偿擦除。这意味着为所需的类型显式传递一个 **Class** 对象，以在类型表达式中使用它。
22565: 1773:
22566: 1774:例如，由于擦除了类型信息，因此在上一个程序中尝试使用 **instanceof** 将会失败。类型标签可以使用动态 `isInstance()` ：
22567: 1775:
22568: 1776:```java
22569: 1777:// generics/ClassTypeCapture.java
22570: 1778:
22571: 1779:class Building {
22572: 1780:}
22573: 1781:
22574: 1782:class House extends Building {
22575: 1783:}
22576: 1784:
22577: 1785:public class ClassTypeCapture<T> {
22578: 1786:    Class<T> kind;
22579: 1787:
22580: 1788:    public ClassTypeCapture(Class<T> kind) {
22581: 1789:        this.kind = kind;
22582: 1790:    }
22583: 1791:
22584: 1792:    public boolean f(Object arg) {
22585: 1793:        return kind.isInstance(arg);
22586: 1794:    }
22587: 1795:
22588: 1796:    public static void main(String[] args) {
22589: 1797:        ClassTypeCapture<Building> ctt1 =
22590: 1798:                new ClassTypeCapture<>(Building.class);
22591: 1799:        System.out.println(ctt1.f(new Building()));
22592: 1800:        System.out.println(ctt1.f(new House()));
22593: 1801:        ClassTypeCapture<House> ctt2 =
22594: 1802:                new ClassTypeCapture<>(House.class);
22595: 1803:        System.out.println(ctt2.f(new Building()));
22596: 1804:        System.out.println(ctt2.f(new House()));
22597: 1805:    }
22598: 1806:}
22599: 1807:/* Output:
22600: 1808:true
22601: 1809:true
22602: 1810:false
22603: 1811:true
22604: 1812:*/
22605: 1813:```
22606: 1814:
22607: 1815:编译器来保证类型标签与泛型参数相匹配。
22608: 1816:
22609: 1817:<!-- Creating Instances of Types -->
22610: 1818:
22611: 1819:### 创建类型的实例
22612: 1820:
22613: 1821:试图在 **Erased.java** 中 `new T()` 是行不通的，部分原因是由于擦除，部分原因是编译器无法验证 **T** 是否具有默认（无参）构造函数。但是在 C++ 中，此操作自然，直接且安全（在编译时检查）：
22614: 1822:
22615: 1823:```C++
22616: 1824:// generics/InstantiateGenericType.cpp
22617: 1825:// C++, not Java!
22618: 1826:
22619: 1827:template<class T> class Foo {
22620: 1828:  T x; // Create a field of type T
22621: 1829:  T* y; // Pointer to T
22622: 1830:public:
22623: 1831:  // Initialize the pointer:
22624: 1832:  Foo() { y = new T(); }
22625: 1833:};
22626: 1834:
22627: 1835:class Bar {};
22628: 1836:
22629: 1837:int main() {
22630: 1838:  Foo<Bar> fb;
22631: 1839:  Foo<int> fi; // ... and it works with primitives
22632: 1840:}
22633: 1841:```
22634: 1842:
22635: 1843:Java 中的解决方案是传入一个工厂对象，并使用该对象创建新实例。方便的工厂对象只是 **Class** 对象，因此，如果使用类型标记，则可以使用 `newInstance()` 创建该类型的新对象：
22636: 1844:
22637: 1845:```java
22638: 1846:// generics/InstantiateGenericType.java
22639: 1847:
22640: 1848:import java.util.function.Supplier;
22641: 1849:
22642: 1850:class ClassAsFactory<T> implements Supplier<T> {
22643: 1851:    Class<T> kind;
22644: 1852:
22645: 1853:    ClassAsFactory(Class<T> kind) {
22646: 1854:        this.kind = kind;
22647: 1855:    }
22648: 1856:
22649: 1857:    @Override
22650: 1858:    public T get() {
22651: 1859:        try {
22652: 1860:            return kind.newInstance();
22653: 1861:        } catch (InstantiationException |
22654: 1862:                IllegalAccessException e) {
22655: 1863:            throw new RuntimeException(e);
22656: 1864:        }
22657: 1865:    }
22658: 1866:}
22659: 1867:
22660: 1868:class Employee {
22661: 1869:    @Override
22662: 1870:    public String toString() {
22663: 1871:        return "Employee";
22664: 1872:    }
22665: 1873:}
22666: 1874:
22667: 1875:public class InstantiateGenericType {
22668: 1876:    public static void main(String[] args) {
22669: 1877:        ClassAsFactory<Employee> fe =
22670: 1878:                new ClassAsFactory<>(Employee.class);
22671: 1879:        System.out.println(fe.get());
22672: 1880:        ClassAsFactory<Integer> fi =
22673: 1881:                new ClassAsFactory<>(Integer.class);
22674: 1882:        try {
22675: 1883:            System.out.println(fi.get());
22676: 1884:        } catch (Exception e) {
22677: 1885:            System.out.println(e.getMessage());
22678: 1886:        }
22679: 1887:    }
22680: 1888:}
22681: 1889:/* Output:
22682: 1890:Employee
22683: 1891:java.lang.InstantiationException: java.lang.Integer
22684: 1892:*/
22685: 1893:```
22686: 1894:
22687: 1895:这样可以编译，但对于 `ClassAsFactory<Integer>` 会失败，这是因为 **Integer** 没有无参构造函数。由于错误不是在编译时捕获的，因此语言创建者不赞成这种方法。他们建议使用显式工厂（**Supplier**）并约束类型，以便只有实现该工厂的类可以这样创建对象。这是创建工厂的两种不同方法：
22688: 1896:
22689: 1897:```java
22690: 1898:// generics/FactoryConstraint.java
22691: 1899:
22692: 1900:import onjava.Suppliers;
22693: 1901:
22694: 1902:import java.util.ArrayList;
22695: 1903:import java.util.List;
22696: 1904:import java.util.function.Supplier;
22697: 1905:
22698: 1906:class IntegerFactory implements Supplier<Integer> {
22699: 1907:    private int i = 0;
22700: 1908:
22701: 1909:    @Override
22702: 1910:    public Integer get() {
22703: 1911:        return ++i;
22704: 1912:    }
22705: 1913:}
22706: 1914:
22707: 1915:class Widget {
22708: 1916:    private int id;
22709: 1917:
22710: 1918:    Widget(int n) {
22711: 1919:        id = n;
22712: 1920:    }
22713: 1921:
22714: 1922:    @Override
22715: 1923:    public String toString() {
22716: 1924:        return "Widget " + id;
22717: 1925:    }
22718: 1926:
22719: 1927:    public static
22720: 1928:    class Factory implements Supplier<Widget> {
22721: 1929:        private int i = 0;
22722: 1930:
22723: 1931:        @Override
22724: 1932:        public Widget get() {
22725: 1933:            return new Widget(++i);
22726: 1934:        }
22727: 1935:    }
22728: 1936:}
22729: 1937:
22730: 1938:class Fudge {
22731: 1939:    private static int count = 1;
22732: 1940:    private int n = count++;
22733: 1941:
22734: 1942:    @Override
22735: 1943:    public String toString() {
22736: 1944:        return "Fudge " + n;
22737: 1945:    }
22738: 1946:}
22739: 1947:
22740: 1948:class Foo2<T> {
22741: 1949:    private List<T> x = new ArrayList<>();
22742: 1950:
22743: 1951:    Foo2(Supplier<T> factory) {
22744: 1952:        Suppliers.fill(x, factory, 5);
22745: 1953:    }
22746: 1954:
22747: 1955:    @Override
22748: 1956:    public String toString() {
22749: 1957:        return x.toString();
22750: 1958:    }
22751: 1959:}
22752: 1960:
22753: 1961:public class FactoryConstraint {
22754: 1962:    public static void main(String[] args) {
22755: 1963:        System.out.println(
22756: 1964:                new Foo2<>(new IntegerFactory()));
22757: 1965:        System.out.println(
22758: 1966:                new Foo2<>(new Widget.Factory()));
22759: 1967:        System.out.println(
22760: 1968:                new Foo2<>(Fudge::new));
22761: 1969:    }
22762: 1970:}
22763: 1971:/* Output:
22764: 1972:[1, 2, 3, 4, 5]
22765: 1973:[Widget 1, Widget 2, Widget 3, Widget 4, Widget 5]
22766: 1974:[Fudge 1, Fudge 2, Fudge 3, Fudge 4, Fudge 5]
22767: 1975:*/
22768: 1976:```
22769: 1977:
22770: 1978:**IntegerFactory** 本身就是通过实现 `Supplier<Integer>` 的工厂。 **Widget** 包含一个内部类，它是一个工厂。还要注意，**Fudge** 并没有做任何类似于工厂的操作，并且传递 `Fudge::new` 仍然会产生工厂行为，因为编译器将对函数方法 `::new` 的调用转换为对 `get()` 的调用。
22771: 1979:
22772: 1980:另一种方法是模板方法设计模式。在以下示例中，`create()` 是模板方法，在子类中被重写以生成该类型的对象：
22773: 1981:
22774: 1982:```java
22775: 1983:// generics/CreatorGeneric.java
22776: 1984:
22777: 1985:abstract class GenericWithCreate<T> {
22778: 1986:    final T element;
22779: 1987:
22780: 1988:    GenericWithCreate() {
22781: 1989:        element = create();
22782: 1990:    }
22783: 1991:
22784: 1992:    abstract T create();
22785: 1993:}
22786: 1994:
22787: 1995:class X {
22788: 1996:}
22789: 1997:
22790: 1998:class XCreator extends GenericWithCreate<X> {
22791: 1999:    @Override
22792: 2000:    X create() {
22793: 2001:        return new X();
22794: 2002:    }
22795: 2003:
22796: 2004:    void f() {
22797: 2005:        System.out.println(
22798: 2006:                element.getClass().getSimpleName());
22799: 2007:    }
22800: 2008:}
22801: 2009:
22802: 2010:public class CreatorGeneric {
22803: 2011:    public static void main(String[] args) {
22804: 2012:        XCreator xc = new XCreator();
22805: 2013:        xc.f();
22806: 2014:    }
22807: 2015:}
22808: 2016:/* Output:
22809: 2017:X
22810: 2018:*/
22811: 2019:```
22812: 2020:
22813: 2021:**GenericWithCreate** 包含 `element` 字段，并通过无参构造函数强制其初始化，该构造函数又调用抽象的 `create()` 方法。这种创建方式可以在子类中定义，同时建立 **T** 的类型。
22814: 2022:
22815: 2023:<!-- Arrays of Generics -->
22816: 2024:
22817: 2025:### 泛型数组
22818: 2026:
22819: 2027:正如在 **Erased.java** 中所看到的，我们无法创建泛型数组。通用解决方案是在试图创建泛型数组的时候使用 **ArrayList** ：
22820: 2028:
22821: 2029:```java
22822: 2030:// generics/ListOfGenerics.java
22823: 2031:
22824: 2032:import java.util.ArrayList;
22825: 2033:import java.util.List;
22826: 2034:
22827: 2035:public class ListOfGenerics<T> {
22828: 2036:    private List<T> array = new ArrayList<>();
22829: 2037:
22830: 2038:    public void add(T item) {
22831: 2039:        array.add(item);
22832: 2040:    }
22833: 2041:
22834: 2042:    public T get(int index) {
22835: 2043:        return array.get(index);
22836: 2044:    }
22837: 2045:}
22838: 2046:```
22839: 2047:
22840: 2048:这样做可以获得数组的行为，并且还具有泛型提供的编译时类型安全性。
22841: 2049:
22842: 2050:有时，仍然会创建泛型类型的数组（例如， **ArrayList** 在内部使用数组）。可以通过使编译器满意的方式定义对数组的通用引用：
22843: 2051:
22844: 2052:```java
22845: 2053:// generics/ArrayOfGenericReference.java
22846: 2054:
22847: 2055:class Generic<T> {
22848: 2056:}
22849: 2057:
22850: 2058:public class ArrayOfGenericReference {
22851: 2059:    static Generic<Integer>[] gia;
22852: 2060:}
22853: 2061:```
22854: 2062:
22855: 2063:编译器接受此操作而不产生警告。但是我们永远无法创建具有该确切类型（包括类型参数）的数组，因此有点令人困惑。由于所有数组，无论它们持有什么类型，都具有相同的结构（每个数组插槽的大小和数组布局），因此似乎可以创建一个 **Object** 数组并将其转换为所需的数组类型。实际上，这确实可以编译，但是会产生 **ClassCastException** ：
22856: 2064:
22857: 2065:```java
22858: 2066:// generics/ArrayOfGeneric.java
22859: 2067:
22860: 2068:public class ArrayOfGeneric {
22861: 2069:    static final int SIZE = 100;
22862: 2070:    static Generic<Integer>[] gia;
22863: 2071:
22864: 2072:    @SuppressWarnings("unchecked")
22865: 2073:    public static void main(String[] args) {
22866: 2074:        try {
22867: 2075:            gia = (Generic<Integer>[]) new Object[SIZE];
22868: 2076:        } catch (ClassCastException e) {
22869: 2077:            System.out.println(e.getMessage());
22870: 2078:        }
22871: 2079:        // Runtime type is the raw (erased) type:
22872: 2080:        gia = (Generic<Integer>[]) new Generic[SIZE];
22873: 2081:        System.out.println(gia.getClass().getSimpleName());
22874: 2082:        gia[0] = new Generic<>();
22875: 2083:        //- gia[1] = new Object(); // Compile-time error
22876: 2084:        // Discovers type mismatch at compile time:
22877: 2085:        //- gia[2] = new Generic<Double>();
22878: 2086:    }
22879: 2087:}
22880: 2088:/* Output:
22881: 2089:[Ljava.lang.Object; cannot be cast to [LGeneric;
22882: 2090:Generic[]
22883: 2091:*/
22884: 2092:```
22885: 2093:
22886: 2094:问题在于数组会跟踪其实际类型，而该类型是在创建数组时建立的。因此，即使 `gia` 被强制转换为 `Generic<Integer>[]` ，该信息也仅在编译时存在（并且没有 **@SuppressWarnings** 注解，将会收到有关该强制转换的警告）。在运行时，它仍然是一个 **Object** 数组，这会引起问题。成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换。
22887: 2095:
22888: 2096:让我们看一个更复杂的示例。考虑一个包装数组的简单泛型包装器：
22889: 2097:
22890: 2098:```java
22891: 2099:// generics/GenericArray.java
22892: 2100:
22893: 2101:public class GenericArray<T> {
22894: 2102:    private T[] array;
22895: 2103:
22896: 2104:    @SuppressWarnings("unchecked")
22897: 2105:    public GenericArray(int sz) {
22898: 2106:        array = (T[]) new Object[sz];
22899: 2107:    }
22900: 2108:
22901: 2109:    public void put(int index, T item) {
22902: 2110:        array[index] = item;
22903: 2111:    }
22904: 2112:
22905: 2113:    public T get(int index) {
22906: 2114:        return array[index];
22907: 2115:    }
22908: 2116:
22909: 2117:    // Method that exposes the underlying representation:
22910: 2118:    public T[] rep() {
22911: 2119:        return array;
22912: 2120:    }
22913: 2121:
22914: 2122:    public static void main(String[] args) {
22915: 2123:        GenericArray<Integer> gai = new GenericArray<>(10);
22916: 2124:        try {
22917: 2125:            Integer[] ia = gai.rep();
22918: 2126:        } catch (ClassCastException e) {
22919: 2127:            System.out.println(e.getMessage());
22920: 2128:        }
22921: 2129:        // This is OK:
22922: 2130:        Object[] oa = gai.rep();
22923: 2131:    }
22924: 2132:}
22925: 2133:/* Output:
22926: 2134:[Ljava.lang.Object; cannot be cast to
22927: 2135:[Ljava.lang.Integer;
22928: 2136:*/
22929: 2137:```
22930: 2138:
22931: 2139:和以前一样，我们不能说 `T[] array = new T[sz]` ，所以我们创建了一个 **Object** 数组并将其强制转换。
22932: 2140:
22933: 2141:`rep()` 方法返回一个 `T[]` ，在主方法中它应该是 `gai` 的 `Integer[]`，但是如果调用它并尝试将结果转换为 `Integer[]` 引用，则会得到 **ClassCastException** ，这再次是因为实际的运行时类型为 `Object[]` 。
22934: 2142:
22935: 2143:如果再注释掉 **@SuppressWarnings** 注解后编译 **GenericArray.java** ，则编译器会产生警告：
22936: 2144:
22937: 2145:```java
22938: 2146:GenericArray.java uses unchecked or unsafe operations.
22939: 2147:Recompile with -Xlint:unchecked for details.
22940: 2148:```
22941: 2149:
22942: 2150:在这里，我们收到了一个警告，我们认为这是有关强制转换的。
22943: 2151:
22944: 2152:但是要真正确定，请使用 `-Xlint：unchecked` 进行编译：
22945: 2153:
22946: 2154:```java
22947: 2155:GenericArray.java:7: warning: [unchecked] unchecked cast    array = (T[])new Object[sz];                 ^  required: T[]  found:    Object[]  where T is a type-variable:    T extends Object declared in class GenericArray 1 warning
22948: 2156:```
22949: 2157:
22950: 2158:确实是在抱怨那个强制转换。由于警告会变成噪音，因此，一旦我们确认预期会出现特定警告，我们可以做的最好的办法就是使用 **@SuppressWarnings** 将其关闭。这样，当警告确实出现时，我们将进行实际调查。
22951: 2159:
22952: 2160:由于擦除，数组的运行时类型只能是 `Object[]` 。 如果我们立即将其转换为 `T[]` ，则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。因此，最好在集合中使用 `Object[]` ，并在使用数组元素时向 **T** 添加强制类型转换。让我们来看看在 **GenericArray.java** 示例中会是怎么样的：
22953: 2161:
22954: 2162:```java
22955: 2163:// generics/GenericArray2.java
22956: 2164:
22957: 2165:public class GenericArray2<T> {
22958: 2166:    private Object[] array;
22959: 2167:
22960: 2168:    public GenericArray2(int sz) {
22961: 2169:        array = new Object[sz];
22962: 2170:    }
22963: 2171:
22964: 2172:    public void put(int index, T item) {
22965: 2173:        array[index] = item;
22966: 2174:    }
22967: 2175:
22968: 2176:    @SuppressWarnings("unchecked")
22969: 2177:    public T get(int index) {
22970: 2178:        return (T) array[index];
22971: 2179:    }
22972: 2180:
22973: 2181:    @SuppressWarnings("unchecked")
22974: 2182:    public T[] rep() {
22975: 2183:        return (T[]) array; // Unchecked cast
22976: 2184:    }
22977: 2185:
22978: 2186:    public static void main(String[] args) {
22979: 2187:        GenericArray2<Integer> gai =
22980: 2188:                new GenericArray2<>(10);
22981: 2189:        for (int i = 0; i < 10; i++)
22982: 2190:            gai.put(i, i);
22983: 2191:        for (int i = 0; i < 10; i++)
22984: 2192:            System.out.print(gai.get(i) + " ");
22985: 2193:        System.out.println();
22986: 2194:        try {
22987: 2195:            Integer[] ia = gai.rep();
22988: 2196:        } catch (Exception e) {
22989: 2197:            System.out.println(e);
22990: 2198:        }
22991: 2199:    }
22992: 2200:}
22993: 2201:/* Output:
22994: 2202:0 1 2 3 4 5 6 7 8 9
22995: 2203:java.lang.ClassCastException: [Ljava.lang.Object;
22996: 2204:cannot be cast to [Ljava.lang.Integer;
22997: 2205:*/
22998: 2206:```
22999: 2207:
23000: 2208:最初，看起来并没有太大不同，只是转换的位置移动了。没有 **@SuppressWarnings** 注解，仍然会收到“unchecked”警告。但是，内部表示现在是 `Object[]` 而不是 `T[]` 。 调用 `get()` 时，它将对象强制转换为 **T** ，实际上这是正确的类型，因此很安全。但是，如果调用 `rep()` ，它将再次尝试将 `Object[]` 强制转换为 `T[]` ，但仍然不正确，并在编译时生成警告，并在运行时生成异常。因此，无法破坏基础数组的类型，该基础数组只能是 `Object[]` 。在内部将数组视为 `Object[]` 而不是 `T[]` 的优点是，我们不太可能会忘记数组的运行时类型并意外地引入了bug，尽管大多数（也许是全部）此类错误会在运行时被迅速检测到。
23001: 2209:
23002: 2210:对于新代码，请传入类型标记。在这种情况下，**GenericArray** 如下所示：
23003: 2211:
23004: 2212:```java
23005: 2213:// generics/GenericArrayWithTypeToken.java
23006: 2214:
23007: 2215:import java.lang.reflect.Array;
23008: 2216:
23009: 2217:public class GenericArrayWithTypeToken<T> {
23010: 2218:    private T[] array;
23011: 2219:
23012: 2220:    @SuppressWarnings("unchecked")
23013: 2221:    public GenericArrayWithTypeToken(Class<T> type, int sz) {
23014: 2222:        array = (T[]) Array.newInstance(type, sz);
23015: 2223:    }
23016: 2224:
23017: 2225:    public void put(int index, T item) {
23018: 2226:        array[index] = item;
23019: 2227:    }
23020: 2228:
23021: 2229:    public T get(int index) {
23022: 2230:        return array[index];
23023: 2231:    }
23024: 2232:
23025: 2233:    // Expose the underlying representation:
23026: 2234:    public T[] rep() {
23027: 2235:        return array;
23028: 2236:    }
23029: 2237:
23030: 2238:    public static void main(String[] args) {
23031: 2239:        GenericArrayWithTypeToken<Integer> gai =
23032: 2240:                new GenericArrayWithTypeToken<>(
23033: 2241:                        Integer.class, 10);
23034: 2242:        // This now works:
23035: 2243:        Integer[] ia = gai.rep();
23036: 2244:    }
23037: 2245:}
23038: 2246:```
23039: 2247:
23040: 2248:类型标记 **Class\<T\>** 被传递到构造函数中以从擦除中恢复，因此尽管必须使用 **@SuppressWarnings** 关闭来自强制类型转换的警告，但我们仍可以创建所需的实际数组类型。一旦获得了实际的类型，就可以返回它并产生所需的结果，如在主方法中看到的那样。数组的运行时类型是确切的类型 `T[]` 。
23041: 2249:
23042: 2250:不幸的是，如果查看 Java 标准库中的源代码，你会发现到处都有从 **Object** 数组到参数化类型的转换。例如，这是**ArrayList** 中，复制一个 **Collection** 的构造函数，这里为了简化，去除了源码中对此不重要的代码：
23043: 2251:
23044: 2252:```java
23045: 2253:public ArrayList(Collection c) {
23046: 2254:  size = c.size();
23047: 2255:  elementData = (E[])new Object[size];
23048: 2256:  c.toArray(elementData);
23049: 2257:}
23050: 2258:```
23051: 2259:
23052: 2260:如果你浏览 **ArrayList.java** 的代码，将会发现很多此类强制转换。当我们编译它时会发生什么？
23053: 2261:
23054: 2262:```java
23055: 2263:Note: ArrayList.java uses unchecked or unsafe operations
23056: 2264:Note: Recompile with -Xlint:unchecked for details.
23057: 2265:```
23058: 2266:
23059: 2267:果然，标准库会产生很多警告。如果你使用过 C 语言，尤其是使用 ANSI C 之前的语言，你会记住警告的特殊效果：发现警告后，可以忽略它们。因此，除非程序员必须对其进行处理，否则最好不要从编译器发出任何类型的消息。
23060: 2268:
23061: 2269:Neal Gafter（Java 5 的主要开发人员之一）在他的博客中[^2]指出，他在重写 Java 库时是很随意、马虎的，我们不应该像他那样做。Neal 还指出，他在不破坏现有接口的情况下无法修复某些 Java 库代码。因此，即使在 Java 库源代码中出现了一些习惯用法，它们也不一定是正确的做法。当查看库代码时，我们不能认为这就是要在自己代码中必须遵循的示例。
23062: 2270:
23063: 2271:请注意，在 Java 文献中推荐使用类型标记技术，例如 Gilad Bracha 的论文《Generics in the Java Programming Language》[^3]，他指出：“例如，这种用法已广泛用于新的 API 中以处理注解。” 我发现此技术在人们对于舒适度的看法方面存在一些不一致之处；有些人强烈喜欢本章前面介绍的工厂方法。
23064: 2272:
23065: 2273:<!-- Bounds -->
23066: 2274:
23067: 2275:## 边界
23068: 2276:
23069: 2277:*边界*（bounds）在本章的前面进行了简要介绍。边界允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法。
23070: 2278:
23071: 2279:由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 **Object** 可用的方法。但是，如果将该参数限制为某类型的子集，则可以调用该子集中的方法。为了应用约束，Java 泛型使用了 `extends` 关键字。
23072: 2280:
23073: 2281:重要的是要理解，当用于限定泛型类型时，`extends` 的含义与通常的意义截然不同。此示例展示边界的基础应用：
23074: 2282:
23075: 2283:```java
23076: 2284:// generics/BasicBounds.java
23077: 2285:
23078: 2286:interface HasColor {
23079: 2287:    java.awt.Color getColor();
23080: 2288:}
23081: 2289:
23082: 2290:class WithColor<T extends HasColor> {
23083: 2291:    T item;
23084: 2292:
23085: 2293:    WithColor(T item) {
23086: 2294:        this.item = item;
23087: 2295:    }
23088: 2296:
23089: 2297:    T getItem() {
23090: 2298:        return item;
23091: 2299:    }
23092: 2300:
23093: 2301:    // The bound allows you to call a method:
23094: 2302:    java.awt.Color color() {
23095: 2303:        return item.getColor();
23096: 2304:    }
23097: 2305:}
23098: 2306:
23099: 2307:class Coord {
23100: 2308:    public int x, y, z;
23101: 2309:}
23102: 2310:
23103: 2311:// This fails. Class must be first, then interfaces:
23104: 2312:// class WithColorCoord<T extends HasColor & Coord> {
23105: 2313:
23106: 2314:// Multiple bounds:
23107: 2315:class WithColorCoord<T extends Coord & HasColor> {
23108: 2316:    T item;
23109: 2317:
23110: 2318:    WithColorCoord(T item) {
23111: 2319:        this.item = item;
23112: 2320:    }
23113: 2321:
23114: 2322:    T getItem() {
23115: 2323:        return item;
23116: 2324:    }
23117: 2325:
23118: 2326:    java.awt.Color color() {
23119: 2327:        return item.getColor();
23120: 2328:    }
23121: 2329:
23122: 2330:    int getX() {
23123: 2331:        return item.x;
23124: 2332:    }
23125: 2333:
23126: 2334:    int getY() {
23127: 2335:        return item.y;
23128: 2336:    }
23129: 2337:
23130: 2338:    int getZ() {
23131: 2339:        return item.z;
23132: 2340:    }
23133: 2341:}
23134: 2342:
23135: 2343:interface Weight {
23136: 2344:    int weight();
23137: 2345:}
23138: 2346:
23139: 2347:// As with inheritance, you can have only one
23140: 2348:// concrete class but multiple interfaces:
23141: 2349:class Solid<T extends Coord & HasColor & Weight> {
23142: 2350:    T item;
23143: 2351:
23144: 2352:    Solid(T item) {
23145: 2353:        this.item = item;
23146: 2354:    }
23147: 2355:
23148: 2356:    T getItem() {
23149: 2357:        return item;
23150: 2358:    }
23151: 2359:
23152: 2360:    java.awt.Color color() {
23153: 2361:        return item.getColor();
23154: 2362:    }
23155: 2363:
23156: 2364:    int getX() {
23157: 2365:        return item.x;
23158: 2366:    }
23159: 2367:
23160: 2368:    int getY() {
23161: 2369:        return item.y;
23162: 2370:    }
23163: 2371:
23164: 2372:    int getZ() {
23165: 2373:        return item.z;
23166: 2374:    }
23167: 2375:
23168: 2376:    int weight() {
23169: 2377:        return item.weight();
23170: 2378:    }
23171: 2379:}
23172: 2380:
23173: 2381:class Bounded
23174: 2382:        extends Coord implements HasColor, Weight {
23175: 2383:    @Override
23176: 2384:    public java.awt.Color getColor() {
23177: 2385:        return null;
23178: 2386:    }
23179: 2387:
23180: 2388:    @Override
23181: 2389:    public int weight() {
23182: 2390:        return 0;
23183: 2391:    }
23184: 2392:}
23185: 2393:
23186: 2394:public class BasicBounds {
23187: 2395:    public static void main(String[] args) {
23188: 2396:        Solid<Bounded> solid =
23189: 2397:                new Solid<>(new Bounded());
23190: 2398:        solid.color();
23191: 2399:        solid.getY();
23192: 2400:        solid.weight();
23193: 2401:    }
23194: 2402:}
23195: 2403:```
23196: 2404:
23197: 2405:你可能会观察到 **BasicBounds.java** 中似乎包含一些冗余，它们可以通过继承来消除。在这里，每个继承级别还添加了边界约束：
23198: 2406:
23199: 2407:```java
23200: 2408:// generics/InheritBounds.java
23201: 2409:
23202: 2410:class HoldItem<T> {
23203: 2411:    T item;
23204: 2412:
23205: 2413:    HoldItem(T item) {
23206: 2414:        this.item = item;
23207: 2415:    }
23208: 2416:
23209: 2417:    T getItem() {
23210: 2418:        return item;
23211: 2419:    }
23212: 2420:}
23213: 2421:
23214: 2422:class WithColor2<T extends HasColor>
23215: 2423:        extends HoldItem<T> {
23216: 2424:    WithColor2(T item) {
23217: 2425:        super(item);
23218: 2426:    }
23219: 2427:
23220: 2428:    java.awt.Color color() {
23221: 2429:        return item.getColor();
23222: 2430:    }
23223: 2431:}
23224: 2432:
23225: 2433:class WithColorCoord2<T extends Coord & HasColor>
23226: 2434:        extends WithColor2<T> {
23227: 2435:    WithColorCoord2(T item) {
23228: 2436:        super(item);
23229: 2437:    }
23230: 2438:
23231: 2439:    int getX() {
23232: 2440:        return item.x;
23233: 2441:    }
23234: 2442:
23235: 2443:    int getY() {
23236: 2444:        return item.y;
23237: 2445:    }
23238: 2446:
23239: 2447:    int getZ() {
23240: 2448:        return item.z;
23241: 2449:    }
23242: 2450:}
23243: 2451:
23244: 2452:class Solid2<T extends Coord & HasColor & Weight>
23245: 2453:        extends WithColorCoord2<T> {
23246: 2454:    Solid2(T item) {
23247: 2455:        super(item);
23248: 2456:    }
23249: 2457:
23250: 2458:    int weight() {
23251: 2459:        return item.weight();
23252: 2460:    }
23253: 2461:}
23254: 2462:
23255: 2463:public class InheritBounds {
23256: 2464:    public static void main(String[] args) {
23257: 2465:        Solid2<Bounded> solid2 =
23258: 2466:                new Solid2<>(new Bounded());
23259: 2467:        solid2.color();
23260: 2468:        solid2.getY();
23261: 2469:        solid2.weight();
23262: 2470:    }
23263: 2471:}
23264: 2472:```
23265: 2473:
23266: 2474:**HoldItem** 拥有一个对象，因此此行为将继承到 **WithColor2** 中，这也需要其参数符合 **HasColor**。 **WithColorCoord2** 和 **Solid2** 进一步扩展了层次结构，并在每个级别添加了边界。现在，这些方法已被继承，并且在每个类中不再重复。
23267: 2475:
23268: 2476:这是一个具有更多层次的示例：
23269: 2477:
23270: 2478:```java
23271: 2479:// generics/EpicBattle.java
23272: 2480:// Bounds in Java generics
23273: 2481:
23274: 2482:import java.util.List;
23275: 2483:
23276: 2484:interface SuperPower {
23277: 2485:}
23278: 2486:
23279: 2487:interface XRayVision extends SuperPower {
23280: 2488:    void seeThroughWalls();
23281: 2489:}
23282: 2490:
23283: 2491:interface SuperHearing extends SuperPower {
23284: 2492:    void hearSubtleNoises();
23285: 2493:}
23286: 2494:
23287: 2495:interface SuperSmell extends SuperPower {
23288: 2496:    void trackBySmell();
23289: 2497:}
23290: 2498:
23291: 2499:class SuperHero<POWER extends SuperPower> {
23292: 2500:    POWER power;
23293: 2501:
23294: 2502:    SuperHero(POWER power) {
23295: 2503:        this.power = power;
23296: 2504:    }
23297: 2505:
23298: 2506:    POWER getPower() {
23299: 2507:        return power;
23300: 2508:    }
23301: 2509:}
23302: 2510:
23303: 2511:class SuperSleuth<POWER extends XRayVision>
23304: 2512:        extends SuperHero<POWER> {
23305: 2513:    SuperSleuth(POWER power) {
23306: 2514:        super(power);
23307: 2515:    }
23308: 2516:
23309: 2517:    void see() {
23310: 2518:        power.seeThroughWalls();
23311: 2519:    }
23312: 2520:}
23313: 2521:
23314: 2522:class
23315: 2523:CanineHero<POWER extends SuperHearing & SuperSmell>
23316: 2524:        extends SuperHero<POWER> {
23317: 2525:    CanineHero(POWER power) {
23318: 2526:        super(power);
23319: 2527:    }
23320: 2528:
23321: 2529:    void hear() {
23322: 2530:        power.hearSubtleNoises();
23323: 2531:    }
23324: 2532:
23325: 2533:    void smell() {
23326: 2534:        power.trackBySmell();
23327: 2535:    }
23328: 2536:}
23329: 2537:
23330: 2538:class SuperHearSmell
23331: 2539:        implements SuperHearing, SuperSmell {
23332: 2540:    @Override
23333: 2541:    public void hearSubtleNoises() {
23334: 2542:    }
23335: 2543:
23336: 2544:    @Override
23337: 2545:    public void trackBySmell() {
23338: 2546:    }
23339: 2547:}
23340: 2548:
23341: 2549:class DogPerson extends CanineHero<SuperHearSmell> {
23342: 2550:    DogPerson() {
23343: 2551:        super(new SuperHearSmell());
23344: 2552:    }
23345: 2553:}
23346: 2554:
23347: 2555:public class EpicBattle {
23348: 2556:    // Bounds in generic methods:
23349: 2557:    static <POWER extends SuperHearing>
23350: 2558:    void useSuperHearing(SuperHero<POWER> hero) {
23351: 2559:        hero.getPower().hearSubtleNoises();
23352: 2560:    }
23353: 2561:
23354: 2562:    static <POWER extends SuperHearing & SuperSmell>
23355: 2563:    void superFind(SuperHero<POWER> hero) {
23356: 2564:        hero.getPower().hearSubtleNoises();
23357: 2565:        hero.getPower().trackBySmell();
23358: 2566:    }
23359: 2567:
23360: 2568:    public static void main(String[] args) {
23361: 2569:        DogPerson dogPerson = new DogPerson();
23362: 2570:        useSuperHearing(dogPerson);
23363: 2571:        superFind(dogPerson);
23364: 2572:        // You can do this:
23365: 2573:        List<? extends SuperHearing> audioPeople;
23366: 2574:        // But you can't do this:
23367: 2575:        // List<? extends SuperHearing & SuperSmell> dogPs;
23368: 2576:    }
23369: 2577:}
23370: 2578:```
23371: 2579:
23372: 2580:接下来将要研究的通配符将会把范围限制在单个类型。
23373: 2581:
23374: 2582:<!-- Wildcards -->
23375: 2583:
23376: 2584:## 通配符
23377: 2585:
23378: 2586:你已经在 [集合](book/12-Collections.md) 章节中看到了一些简单示例使用了通配符——在泛型参数表达式中的问号，在 [类型信息](book/19-Type-Information.md) 一章中这种示例更多。本节将更深入地探讨这个特性。
23379: 2587:
23380: 2588:我们的起始示例要展示数组的一种特殊行为：你可以将派生类的数组赋值给基类的引用：
23381: 2589:
23382: 2590:```java
23383: 2591:// generics/CovariantArrays.java
23384: 2592:
23385: 2593:class Fruit {}
23386: 2594:
23387: 2595:class Apple extends Fruit {}
23388: 2596:
23389: 2597:class Jonathan extends Apple {}
23390: 2598:
23391: 2599:class Orange extends Fruit {}
23392: 2600:
23393: 2601:public class CovariantArrays {
23394: 2602:    
23395: 2603:    public static void main(String[] args) {
23396: 2604:        Fruit[] fruit = new Apple[10];
23397: 2605:        fruit[0] = new Apple(); // OK
23398: 2606:        fruit[1] = new Jonathan(); // OK
23399: 2607:        // Runtime type is Apple[], not Fruit[] or Orange[]:
23400: 2608:        try {
23401: 2609:            // Compiler allows you to add Fruit:
23402: 2610:            fruit[0] = new Fruit(); // ArrayStoreException
23403: 2611:        } catch (Exception e) {
23404: 2612:            System.out.println(e);
23405: 2613:        }
23406: 2614:        try {
23407: 2615:            // Compiler allows you to add Oranges:
23408: 2616:            fruit[0] = new Orange(); // ArrayStoreException
23409: 2617:        } catch (Exception e) {
23410: 2618:            System.out.println(e);
23411: 2619:        }
23412: 2620:    }
23413: 2621:}
23414: 2622:/* Output:
23415: 2623:java.lang.ArrayStoreException: Fruit
23416: 2624:java.lang.ArrayStoreException: Orange
23417: 2625:```
23418: 2626:
23419: 2627:`main()` 中的第一行创建了 **Apple** 数组，并赋值给一个 **Fruit** 数组引用。这是有意义的，因为 **Apple** 也是一种 **Fruit**，因此 **Apple** 数组应该也是一个 **Fruit** 数组。
23420: 2628:
23421: 2629:但是，如果实际的数组类型是 **Apple[]**，你可以在其中放置 **Apple** 或 **Apple** 的子类型，这在编译期和运行时都可以工作。但是你也可以在数组中放置 **Fruit** 对象。这对编译器来说是有意义的，因为它有一个 **Fruit[]** 引用——它有什么理由不允许将 **Fruit** 对象或任何从 **Fruit** 继承出来的对象（比如 **Orange**），放置到这个数组中呢？因此在编译期，这是允许的。然而，运行时的数组机制知道它处理的是 **Apple[]**，因此会在向数组中放置异构类型时抛出异常。
23422: 2630:
23423: 2631:向上转型用在这里不合适。你真正在做的是将一个数组赋值给另一个数组。数组的行为是持有其他对象，这里只是因为我们能够向上转型而已，所以很明显，数组对象可以保留有关它们包含的对象类型的规则。看起来就像数组对它们持有的对象是有意识的，因此在编译期检查和运行时检查之间，你不能滥用它们。
23424: 2632:
23425: 2633:数组的这种赋值并不是那么可怕，因为在运行时你可以发现插入了错误的类型。但是泛型的主要目标之一是将这种错误检测移到编译期。所以当我们试图使用泛型集合代替数组时，会发生什么呢？
23426: 2634:
23427: 2635:```java
23428: 2636:// generics/NonCovariantGenerics.java
23429: 2637:// {WillNotCompile}
23430: 2638:
23431: 2639:import java.util.*;
23432: 2640:
23433: 2641:public class NonCovariantGenerics {
23434: 2642:    // Compile Error: incompatible types:
23435: 2643:    List<Fruit> flist = new ArrayList<Apple>();
23436: 2644:}
23437: 2645:```
23438: 2646:
23439: 2647:尽管你在首次阅读这段代码时会认为“不能将一个 **Apple** 集合赋值给一个 **Fruit** 集合”。记住，泛型不仅仅是关于集合，它真正要表达的是“不能把一个涉及 **Apple** 的泛型赋值给一个涉及 **Fruit** 的泛型”。如果像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及到的集合，那么它可能会留下一些余地。但是它不知道任何有关这方面的信息，因此它拒绝向上转型。然而实际上这也不是向上转型—— **Apple** 的 **List** 不是 **Fruit** 的 **List**。**Apple** 的 **List** 将持有 **Apple** 和 **Apple** 的子类型，**Fruit** 的 **List** 将持有任何类型的 **Fruit**。是的，这包括 **Apple**，但是它不是一个 **Apple** 的 **List**，它仍然是 **Fruit** 的 **List**。**Apple** 的 **List** 在类型上不等价于 **Fruit** 的 **List**，即使 **Apple** 是一种 **Fruit** 类型。
23440: 2648:
23441: 2649:真正的问题是我们在讨论的集合类型，而不是集合持有对象的类型。与数组不同，泛型没有内建的协变类型。这是因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查，但是在使用泛型时，编译器和运行时系统不知道你想用类型做什么，以及应该采用什么规则。
23442: 2650:
23443: 2651:但是，有时你想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。
23444: 2652:
23445: 2653:```java
23446: 2654:// generics/GenericsAndCovariance.java
23447: 2655:
23448: 2656:import java.util.*;
23449: 2657:
23450: 2658:public class GenericsAndCovariance {
23451: 2659:    
23452: 2660:    public static void main(String[] args) {
23453: 2661:        // Wildcards allow covariance:
23454: 2662:        List<? extends Fruit> flist = new ArrayList<>();
23455: 2663:        // Compile Error: can't add any type of object:
23456: 2664:        // flist.add(new Apple());
23457: 2665:        // flist.add(new Fruit());
23458: 2666:        // flist.add(new Object());
23459: 2667:        flist.add(null); // Legal but uninteresting
23460: 2668:        // We know it returns at least Fruit:
23461: 2669:        Fruit f = flist.get(0);
23462: 2670:    }
23463: 2671:    
23464: 2672:}
23465: 2673:```
23466: 2674:
23467: 2675:**flist** 的类型现在是 `List<? extends Fruit>`，你可以读作“一个具有任何从 **Fruit** 继承的类型的列表”。然而，这实际上并不意味着这个 **List** 将持有任何类型的 **Fruit**。通配符引用的是明确的类型，因此它意味着“某种 **flist** 引用没有指定的具体类型”。因此这个被赋值的 **List** 必须持有诸如 **Fruit** 或 **Apple** 这样的指定类型，但是为了向上转型为 **Fruit**，这个类型是什么没人在意。
23468: 2676:
23469: 2677:**List** 必须持有一种具体的 **Fruit** 或 **Fruit** 的子类型，但是如果你不关心具体的类型是什么，那么你能对这样的 **List** 做什么呢？如果不知道 **List** 中持有的对象是什么类型，你怎能保证安全地向其中添加对象呢？就像在 **CovariantArrays.java** 中向上转型一样，你不能，除非编译器而不是运行时系统可以阻止这种操作的发生。你很快就会发现这个问题。
23470: 2678:
23471: 2679:你可能认为事情开始变得有点走极端了，因为现在你甚至不能向刚刚声明过将持有 **Apple** 对象的 **List** 中放入一个 **Apple** 对象。是的，但编译器并不知道这一点。`List<? extends Fruit>` 可能合法地指向一个 `List<Orange>`。一旦执行这种类型的向上转型，你就丢失了向其中传递任何对象的能力，甚至传递 **Object** 也不行。
23472: 2680:
23473: 2681:另一方面，如果你调用了一个返回 **Fruit** 的方法，则是安全的，因为你知道这个 **List** 中的任何对象至少具有 **Fruit** 类型，因此编译器允许这么做。
23474: 2682:
23475: 2683:### 编译器有多聪明
23476: 2684:
23477: 2685:现在你可能会猜想自己不能去调用任何接受参数的方法，但是考虑下面的代码：
23478: 2686:
23479: 2687:```java
23480: 2688:// generics/CompilerIntelligence.java
23481: 2689:
23482: 2690:import java.util.*;
23483: 2691:
23484: 2692:public class CompilerIntelligence {
23485: 2693:    
23486: 2694:    public static void main(String[] args) {
23487: 2695:        List<? extends Fruit> flist = Arrays.asList(new Apple());
23488: 2696:        Apple a = (Apple) flist.get(0); // No warning
23489: 2697:        flist.contains(new Apple()); // Argument is 'Object'
23490: 2698:        flist.indexOf(new Apple()); // Argument is 'Object'
23491: 2699:    }
23492: 2700:    
23493: 2701:}
23494: 2702:```
23495: 2703:
23496: 2704:这里对 `contains()` 和 `indexOf()` 的调用接受 **Apple** 对象作为参数，执行没问题。这是否意味着编译器实际上会检查代码，以查看是否有某个特定的方法修改了它的对象？
23497: 2705:
23498: 2706:通过查看 **ArrayList** 的文档，我们发现编译器没有那么聪明。尽管 `add()` 接受一个泛型参数类型的参数，但 `contains()` 和 `indexOf()` 接受的参数类型是 **Object**。因此当你指定一个 `ArrayList<? extends Fruit>` 时，`add()` 的参数就变成了"**? extends Fruit**"。从这个描述中，编译器无法得知这里需要 **Fruit** 的哪个具体子类型，因此它不会接受任何类型的 **Fruit**。如果你先把 **Apple** 向上转型为 **Fruit**，也没有关系——编译器仅仅会拒绝调用像 `add()` 这样参数列表中涉及通配符的方法。
23499: 2707:
23500: 2708:`contains()` 和 `indexOf()` 的参数类型是 **Object**，不涉及通配符，所以编译器允许调用它们。这意味着将由泛型类的设计者来决定哪些调用是“安全的”，并使用 **Object** 类作为它们的参数类型。为了禁止对类型中使用了通配符的方法调用，需要在参数列表中使用类型参数。
23501: 2709:
23502: 2710:下面展示一个简单的 **Holder** 类：
23503: 2711:
23504: 2712:```java
23505: 2713:// generics/Holder.java
23506: 2714:
23507: 2715:public class Holder<T> {
23508: 2716:
23509: 2717:    private T value;
23510: 2718:
23511: 2719:    public Holder() {}
23512: 2720:
23513: 2721:    public Holder(T val) {
23514: 2722:        value = val;
23515: 2723:    }
23516: 2724:
23517: 2725:    public void set(T val) {
23518: 2726:        value = val;
23519: 2727:    }
23520: 2728:
23521: 2729:    public T get() {
23522: 2730:        return value;
23523: 2731:    }
23524: 2732:
23525: 2733:    @Override
23526: 2734:    public boolean equals(Object o) {
23527: 2735:        return o instanceof Holder && Objects.equals(value, ((Holder) o).value);
23528: 2736:    }
23529: 2737:
23530: 2738:    @Override
23531: 2739:    public int hashCode() {
23532: 2740:        return Objects.hashCode(value);
23533: 2741:    }
23534: 2742:
23535: 2743:    public static void main(String[] args) {
23536: 2744:        Holder<Apple> apple = new Holder<>(new Apple());
23537: 2745:        Apple d = apple.get();
23538: 2746:        apple.set(d);
23539: 2747:        // Holder<Fruit> fruit = apple; // Cannot upcast
23540: 2748:        Holder<? extends Fruit> fruit = apple; // OK
23541: 2749:        Fruit p = fruit.get();
23542: 2750:        d = (Apple) fruit.get();
23543: 2751:        try {
23544: 2752:            Orange c = (Orange) fruit.get(); // No warning
23545: 2753:        } catch (Exception e) {
23546: 2754:            System.out.println(e);
23547: 2755:        }
23548: 2756:        // fruit.set(new Apple()); // Cannot call set()
23549: 2757:        // fruit.set(new Fruit()); // Cannot call set()
23550: 2758:        System.out.println(fruit.equals(d)); // OK
23551: 2759:    }
23552: 2760:}
23553: 2761:/* Output
23554: 2762:java.lang.ClassCastException: Apple cannot be cast to Orange
23555: 2763:false
23556: 2764:*/
23557: 2765:```
23558: 2766:
23559: 2767:**Holder** 有一个接受 **T** 类型对象的 `set()` 方法，一个返回 T 对象的 `get()` 方法和一个接受 Object 对象的 `equals()` 方法。正如你所见，如果创建了一个 `Holder<Apple>`，就不能将其向上转型为 `Holder<Fruit>`，但是可以向上转型为 `Holder<? extends Fruit>`。如果调用 `get()`，只能返回一个 **Fruit**——这就是在给定“任何扩展自 **Fruit** 的对象”这一边界后，它所能知道的一切了。如果你知道更多的信息，就可以将其转型到某种具体的 **Fruit** 而不会导致任何警告，但是存在得到 **ClassCastException** 的风险。`set()` 方法不能工作在 **Apple** 和 **Fruit** 上，因为 `set()` 的参数也是"**? extends Fruit**"，意味着它可以是任何事物，编译器无法验证“任何事物”的类型安全性。
23560: 2768:
23561: 2769:但是，`equals()` 方法可以正常工作，因为它接受的参数是 **Object** 而不是 **T** 类型。因此，编译器只关注传递进来和要返回的对象类型。它不会分析代码，以查看是否执行了任何实际的写入和读取操作。
23562: 2770:
23563: 2771:Java 7 引入了 **java.util.Objects** 库，使创建 `equals()` 和 `hashCode()` 方法变得更加容易，当然还有很多其他功能。`equals()` 方法的标准形式参考 [附录：理解 equals 和 hashCode 方法](book/Appendix-Understanding-equals-and-hashCode) 一章。
23564: 2772:
23565: 2773:### 逆变
23566: 2774:
23567: 2775:还可以走另外一条路，即使用超类型通配符。这里，可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 `<？super MyClass>` ，或者甚至使用类型参数： `<？super T>`（尽管你不能对泛型参数给出一个超类型边界；即不能声明 `<T super MyClass>` ）。这使得你可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，就可以向 **Collection** 写入了：
23568: 2776:
23569: 2777:```java
23570: 2778:// generics/SuperTypeWildcards.java
23571: 2779:import java.util.*;
23572: 2780:public class SuperTypeWildcards {
23573: 2781:    static void writeTo(List<? super Apple> apples) {
23574: 2782:        apples.add(new Apple());
23575: 2783:        apples.add(new Jonathan());
23576: 2784:        // apples.add(new Fruit()); // Error
23577: 2785:    }
23578: 2786:}
23579: 2787:```
23580: 2788:
23581: 2789:参数 **apples** 是 **Apple** 的某种基类型的 **List**，这样你就知道向其中添加 **Apple** 或 **Apple** 的子类型是安全的。但是因为 **Apple** 是下界，所以你知道向这样的 **List** 中添加 **Fruit** 是不安全的，因为这将使这个 **List** 敞开口子，从而可以向其中添加非 **Apple** 类型的对象，而这是违反静态类型安全的。
23582: 2790:下面的示例复习了一下逆变和通配符的的使用：
23583: 2791:
23584: 2792:```java
23585: 2793:// generics/GenericReading.java
23586: 2794:import java.util.*;
23587: 2795:
23588: 2796:public class GenericReading {
23589: 2797:    static List<Apple> apples = Arrays.asList(new Apple());
23590: 2798:    static List<Fruit> fruit = Arrays.asList(new Fruit());
23591: 2799:    
23592: 2800:    static <T> T readExact(List<T> list) {
23593: 2801:        return list.get(0);
23594: 2802:    }
23595: 2803:    
23596: 2804:    // A static method adapts to each call:
23597: 2805:    static void f1() {
23598: 2806:        Apple a = readExact(apples);
23599: 2807:        Fruit f = readExact(fruit);
23600: 2808:        f = readExact(apples);
23601: 2809:    }
23602: 2810:    
23603: 2811:    // A class type is established
23604: 2812:    // when the class is instantiated:
23605: 2813:    static class Reader<T> {
23606: 2814:        T readExact(List<T> list) { 
23607: 2815:            return list.get(0); 
23608: 2816:        }
23609: 2817:    }
23610: 2818:    
23611: 2819:    static void f2() {
23612: 2820:        Reader<Fruit> fruitReader = new Reader<>();
23613: 2821:        Fruit f = fruitReader.readExact(fruit);
23614: 2822:        //- Fruit a = fruitReader.readExact(apples);
23615: 2823:        // error: incompatible types: List<Apple>
23616: 2824:        // cannot be converted to List<Fruit>
23617: 2825:    }
23618: 2826:    
23619: 2827:    static class CovariantReader<T> {
23620: 2828:        T readCovariant(List<? extends T> list) {
23621: 2829:            return list.get(0);
23622: 2830:        }
23623: 2831:    }
23624: 2832:    
23625: 2833:    static void f3() {
23626: 2834:        CovariantReader<Fruit> fruitReader = new CovariantReader<>();
23627: 2835:        Fruit f = fruitReader.readCovariant(fruit);
23628: 2836:        Fruit a = fruitReader.readCovariant(apples);
23629: 2837:    }
23630: 2838:    
23631: 2839:    public static void main(String[] args) {
23632: 2840:        f1(); 
23633: 2841:        f2(); 
23634: 2842:        f3();
23635: 2843:    }
23636: 2844:}
23637: 2845:```
23638: 2846:
23639: 2847:`readExact()` 方法使用了精确的类型。如果使用这个没有任何通配符的精确类型，就可以向 **List** 中写入和读取这个精确类型。另外，对于返回值，静态的泛型方法 `readExact()` 可以有效地“适应”每个方法调用，并能够从 `List<Apple>` 中返回一个 **Apple** ，从 `List<Fruit>` 中返回一个 **Fruit** ，就像在 `f1()` 中看到的那样。因此，如果可以摆脱静态泛型方法，那么在读取时就不需要协变类型了。
23640: 2848:然而对于泛型类来说，当你创建这个类的实例时，就要为这个类确定参数。就像在 `f2()` 中看到的，**fruitReader** 实例可以从 `List<Fruit>` 中读取一个 **Fruit** ，因为这就是它的确切类型。但是 `List<Apple>` 也应该产生 **Fruit** 对象，而 **fruitReader** 不允许这么做。
23641: 2849:为了修正这个问题，`CovariantReader.readCovariant()` 方法将接受 `List<？extends T>` ，因此，从这个列表中读取一个 **T** 是安全的（你知道在这个列表中的所有对象至少是一个 **T** ，并且可能是从 T 导出的某种对象）。在 `f3()` 中，你可以看到现在可以从 `List<Apple>` 中读取 **Fruit** 了。
23642: 2850:
23643: 2851:### 无界通配符
23644: 2852:
23645: 2853:无界通配符 `<?>` 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器初看起来是支持这种判断的：
23646: 2854:
23647: 2855:```java
23648: 2856:// generics/UnboundedWildcards1.java
23649: 2857:import java.util.*;
23650: 2858:
23651: 2859:public class UnboundedWildcards1 {
23652: 2860:    static List list1;
23653: 2861:    static List<?> list2;
23654: 2862:    static List<? extends Object> list3;
23655: 2863:  
23656: 2864:    static void assign1(List list) {
23657: 2865:        list1 = list;
23658: 2866:        list2 = list;
23659: 2867:        //- list3 = list;
23660: 2868:        // warning: [unchecked] unchecked conversion
23661: 2869:        // list3 = list;
23662: 2870:        //         ^
23663: 2871:        // required: List<? extends Object>
23664: 2872:        // found:    List
23665: 2873:    }
23666: 2874:    
23667: 2875:    static void assign2(List<?> list) {
23668: 2876:        list1 = list;
23669: 2877:        list2 = list;
23670: 2878:        list3 = list;
23671: 2879:    }
23672: 2880:    
23673: 2881:    static void assign3(List<? extends Object> list) {
23674: 2882:        list1 = list;
23675: 2883:        list2 = list;
23676: 2884:        list3 = list;
23677: 2885:    }
23678: 2886:    
23679: 2887:    public static void main(String[] args) {
23680: 2888:        assign1(new ArrayList());
23681: 2889:        assign2(new ArrayList());
23682: 2890:        //- assign3(new ArrayList());
23683: 2891:        // warning: [unchecked] unchecked method invocation:
23684: 2892:        // method assign3 in class UnboundedWildcards1
23685: 2893:        // is applied to given types
23686: 2894:        // assign3(new ArrayList());
23687: 2895:        //        ^
23688: 2896:        // required: List<? extends Object>
23689: 2897:        // found: ArrayList
23690: 2898:        // warning: [unchecked] unchecked conversion
23691: 2899:        // assign3(new ArrayList());
23692: 2900:        //         ^
23693: 2901:        // required: List<? extends Object>
23694: 2902:        // found:    ArrayList
23695: 2903:        // 2 warnings
23696: 2904:        assign1(new ArrayList<>());
23697: 2905:        assign2(new ArrayList<>());
23698: 2906:        assign3(new ArrayList<>());
23699: 2907:        // Both forms are acceptable as List<?>:
23700: 2908:        List<?> wildList = new ArrayList();
23701: 2909:        wildList = new ArrayList<>();
23702: 2910:        assign1(wildList);
23703: 2911:        assign2(wildList);
23704: 2912:        assign3(wildList);
23705: 2913:    }
23706: 2914:}
23707: 2915:```
23708: 2916:
23709: 2917:有很多情况都和你在这里看到的情况类似，即编译器很少关心使用的是原生类型还是 `<?>` 。在这些情况中，`<?>` 可以被认为是一种装饰，但是它仍旧是很有价值的，因为，实际上它是在声明：“我是想用 Java 的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型。”
23710: 2918:第二个示例展示了无界通配符的一个重要应用。当你在处理多个泛型参数时，有时允许一个参数可以是任何类型，同时为其他参数确定某种特定类型的这种能力会显得很重要：
23711: 2919:
23712: 2920:```java
23713: 2921:// generics/UnboundedWildcards2.java
23714: 2922:import java.util.*;
23715: 2923:
23716: 2924:public class UnboundedWildcards2 {
23717: 2925:    static Map map1;
23718: 2926:    static Map<?,?> map2;
23719: 2927:    static Map<String,?> map3;
23720: 2928:  
23721: 2929:    static void assign1(Map map) { 
23722: 2930:        map1 = map; 
23723: 2931:    }
23724: 2932:    
23725: 2933:    static void assign2(Map<?,?> map) { 
23726: 2934:        map2 = map; 
23727: 2935:    }
23728: 2936:    
23729: 2937:    static void assign3(Map<String,?> map) { 
23730: 2938:        map3 = map; 
23731: 2939:    }
23732: 2940:    
23733: 2941:    public static void main(String[] args) {
23734: 2942:        assign1(new HashMap());
23735: 2943:        assign2(new HashMap());
23736: 2944:        //- assign3(new HashMap());
23737: 2945:        // warning: [unchecked] unchecked method invocation:
23738: 2946:        // method assign3 in class UnboundedWildcards2
23739: 2947:        // is applied to given types
23740: 2948:        //     assign3(new HashMap());
23741: 2949:        //            ^
23742: 2950:        //   required: Map<String,?>
23743: 2951:        //   found: HashMap
23744: 2952:        // warning: [unchecked] unchecked conversion
23745: 2953:        //     assign3(new HashMap());
23746: 2954:        //             ^
23747: 2955:        //   required: Map<String,?>
23748: 2956:        //   found:    HashMap
23749: 2957:        // 2 warnings
23750: 2958:        assign1(new HashMap<>());
23751: 2959:        assign2(new HashMap<>());
23752: 2960:        assign3(new HashMap<>());
23753: 2961:    }
23754: 2962:}
23755: 2963:```
23756: 2964:
23757: 2965:但是，当你拥有的全都是无界通配符时，就像在 `Map<?,?>` 中看到的那样，编译器看起来就无法将其与原生 **Map** 区分开了。另外， **UnboundedWildcards1.java** 展示了编译器处理  `List<?>` 和 `List<? extends Object>` 是不同的。
23758: 2966:令人困惑的是，编译器并非总是关注像 `List` 和 `List<?>` 之间的这种差异，因此它们看起来就像是相同的事物。事实上，因为泛型参数擦除到它的第一个边界，因此 `List<?>` 看起来等价于 `List<Object>` ，而 **List** 实际上也是 `List<Object>` ——除非这些语句都不为真。**List** 实际上表示“持有任何 **Object** 类型的原生 **List** ”，而 `List<?>` 表示“具有某种特定类型的非原生 **List** ，只是我们不知道类型是什么。”
23759: 2967:编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？下面的示例使用了前面定义的 `Holder<T>` 类，它包含接受 **Holder** 作为参数的各种方法，但是它们具有不同的形式：作为原生类型，具有具体的类型参数以及具有无界通配符参数：
23760: 2968:
23761: 2969:```java
23762: 2970:// generics/Wildcards.java
23763: 2971:// Exploring the meaning of wildcards
23764: 2972:
23765: 2973:public class Wildcards {
23766: 2974:    // Raw argument:
23767: 2975:    static void rawArgs(Holder holder, Object arg) {
23768: 2976:        //- holder.set(arg);
23769: 2977:        // warning: [unchecked] unchecked call to set(T)
23770: 2978:        // as a member of the raw type Holder
23771: 2979:        //     holder.set(arg);
23772: 2980:        //               ^
23773: 2981:        //   where T is a type-variable:
23774: 2982:        //     T extends Object declared in class Holder
23775: 2983:        // 1 warning
23776: 2984:
23777: 2985:        // Can't do this; don't have any 'T':
23778: 2986:        // T t = holder.get();
23779: 2987:
23780: 2988:        // OK, but type information is lost:
23781: 2989:        Object obj = holder.get();
23782: 2990:    }
23783: 2991:    
23784: 2992:    // Like rawArgs(), but errors instead of warnings:
23785: 2993:    static void unboundedArg(Holder<?> holder, Object arg) {
23786: 2994:        //- holder.set(arg);
23787: 2995:        // error: method set in class Holder<T>
23788: 2996:        // cannot be applied to given types;
23789: 2997:        //     holder.set(arg);
23790: 2998:        //           ^
23791: 2999:        //   required: CAP#1
23792: 3000:        //   found: Object
23793: 3001:        //   reason: argument mismatch;
23794: 3002:        //     Object cannot be converted to CAP#1
23795: 3003:        //   where T is a type-variable:
23796: 3004:        //     T extends Object declared in class Holder
23797: 3005:        //   where CAP#1 is a fresh type-variable:
23798: 3006:        //     CAP#1 extends Object from capture of ?
23799: 3007:        // 1 error
23800: 3008:
23801: 3009:        // Can't do this; don't have any 'T':
23802: 3010:        // T t = holder.get();
23803: 3011:
23804: 3012:        // OK, but type information is lost:
23805: 3013:        Object obj = holder.get();
23806: 3014:    }
23807: 3015:    
23808: 3016:    static <T> T exact1(Holder<T> holder) {
23809: 3017:        return holder.get();
23810: 3018:    }
23811: 3019:    
23812: 3020:    static <T> T exact2(Holder<T> holder, T arg) {
23813: 3021:        holder.set(arg);
23814: 3022:        return holder.get();
23815: 3023:    }
23816: 3024:    
23817: 3025:    static <T> T wildSubtype(Holder<? extends T> holder, T arg) {
23818: 3026:        //- holder.set(arg);
23819: 3027:        // error: method set in class Holder<T#2>
23820: 3028:        // cannot be applied to given types;
23821: 3029:        //     holder.set(arg);
23822: 3030:        //           ^
23823: 3031:        //   required: CAP#1
23824: 3032:        //   found: T#1
23825: 3033:        //   reason: argument mismatch;
23826: 3034:        //     T#1 cannot be converted to CAP#1
23827: 3035:        //   where T#1,T#2 are type-variables:
23828: 3036:        //     T#1 extends Object declared in method
23829: 3037:        //     <T#1>wildSubtype(Holder<? extends T#1>,T#1)
23830: 3038:        //     T#2 extends Object declared in class Holder
23831: 3039:        //   where CAP#1 is a fresh type-variable:
23832: 3040:        //     CAP#1 extends T#1 from
23833: 3041:        //       capture of ? extends T#1
23834: 3042:        // 1 error
23835: 3043:        return holder.get();
23836: 3044:    }
23837: 3045:    
23838: 3046:    static <T> void wildSupertype(Holder<? super T> holder, T arg) {
23839: 3047:        holder.set(arg);
23840: 3048:        //- T t = holder.get();
23841: 3049:        // error: incompatible types:
23842: 3050:        // CAP#1 cannot be converted to T
23843: 3051:        //     T t = holder.get();
23844: 3052:        //                     ^
23845: 3053:        //   where T is a type-variable:
23846: 3054:        //     T extends Object declared in method
23847: 3055:        //       <T>wildSupertype(Holder<? super T>,T)
23848: 3056:        //   where CAP#1 is a fresh type-variable:
23849: 3057:        //     CAP#1 extends Object super:
23850: 3058:        //       T from capture of ? super T
23851: 3059:        // 1 error
23852: 3060:
23853: 3061:        // OK, but type information is lost:
23854: 3062:        Object obj = holder.get();
23855: 3063:    }
23856: 3064:    
23857: 3065:    public static void main(String[] args) {
23858: 3066:        Holder raw = new Holder<>();
23859: 3067:        // Or:
23860: 3068:        raw = new Holder();
23861: 3069:        Holder<Long> qualified = new Holder<>();
23862: 3070:        Holder<?> unbounded = new Holder<>();
23863: 3071:        Holder<? extends Long> bounded = new Holder<>();
23864: 3072:        Long lng = 1L;
23865: 3073:
23866: 3074:        rawArgs(raw, lng);
23867: 3075:        rawArgs(qualified, lng);
23868: 3076:        rawArgs(unbounded, lng);
23869: 3077:        rawArgs(bounded, lng);
23870: 3078:
23871: 3079:        unboundedArg(raw, lng);
23872: 3080:        unboundedArg(qualified, lng);
23873: 3081:        unboundedArg(unbounded, lng);
23874: 3082:        unboundedArg(bounded, lng);
23875: 3083:
23876: 3084:        //- Object r1 = exact1(raw);
23877: 3085:        // warning: [unchecked] unchecked method invocation:
23878: 3086:        // method exact1 in class Wildcards is applied
23879: 3087:        // to given types
23880: 3088:        //      Object r1 = exact1(raw);
23881: 3089:        //                        ^
23882: 3090:        //   required: Holder<T>
23883: 3091:        //   found: Holder
23884: 3092:        //   where T is a type-variable:
23885: 3093:        //     T extends Object declared in
23886: 3094:        //     method <T>exact1(Holder<T>)
23887: 3095:        // warning: [unchecked] unchecked conversion
23888: 3096:        //      Object r1 = exact1(raw);
23889: 3097:        //                         ^
23890: 3098:        //   required: Holder<T>
23891: 3099:        //   found:    Holder
23892: 3100:        //   where T is a type-variable:
23893: 3101:        //     T extends Object declared in
23894: 3102:        //     method <T>exact1(Holder<T>)
23895: 3103:        // 2 warnings
23896: 3104:
23897: 3105:        Long r2 = exact1(qualified);
23898: 3106:        Object r3 = exact1(unbounded); // Must return Object
23899: 3107:        Long r4 = exact1(bounded);
23900: 3108:
23901: 3109:        //- Long r5 = exact2(raw, lng);
23902: 3110:        // warning: [unchecked] unchecked method invocation:
23903: 3111:        // method exact2 in class Wildcards is
23904: 3112:        // applied to given types
23905: 3113:        //     Long r5 = exact2(raw, lng);
23906: 3114:        //                     ^
23907: 3115:        //   required: Holder<T>,T
23908: 3116:        //   found: Holder,Long
23909: 3117:        //   where T is a type-variable:
23910: 3118:        //     T extends Object declared in
23911: 3119:        //       method <T>exact2(Holder<T>,T)
23912: 3120:        // warning: [unchecked] unchecked conversion
23913: 3121:        //     Long r5 = exact2(raw, lng);
23914: 3122:        //                      ^
23915: 3123:        //   required: Holder<T>
23916: 3124:        //   found:    Holder
23917: 3125:        //   where T is a type-variable:
23918: 3126:        //     T extends Object declared in
23919: 3127:        //       method <T>exact2(Holder<T>,T)
23920: 3128:        // 2 warnings
23921: 3129:
23922: 3130:        Long r6 = exact2(qualified, lng);
23923: 3131:
23924: 3132:        //- Long r7 = exact2(unbounded, lng);
23925: 3133:        // error: method exact2 in class Wildcards
23926: 3134:        // cannot be applied to given types;
23927: 3135:        //     Long r7 = exact2(unbounded, lng);
23928: 3136:        //               ^
23929: 3137:        //   required: Holder<T>,T
23930: 3138:        //   found: Holder<CAP#1>,Long
23931: 3139:        //   reason: inference variable T has
23932: 3140:        //     incompatible bounds
23933: 3141:        //     equality constraints: CAP#1
23934: 3142:        //     lower bounds: Long
23935: 3143:        //   where T is a type-variable:
23936: 3144:        //     T extends Object declared in
23937: 3145:        //       method <T>exact2(Holder<T>,T)
23938: 3146:        //   where CAP#1 is a fresh type-variable:
23939: 3147:        //     CAP#1 extends Object from capture of ?
23940: 3148:        // 1 error
23941: 3149:
23942: 3150:        //- Long r8 = exact2(bounded, lng);
23943: 3151:        // error: method exact2 in class Wildcards
23944: 3152:        // cannot be applied to given types;
23945: 3153:        //      Long r8 = exact2(bounded, lng);
23946: 3154:        //                ^
23947: 3155:        //   required: Holder<T>,T
23948: 3156:        //   found: Holder<CAP#1>,Long
23949: 3157:        //   reason: inference variable T
23950: 3158:        //     has incompatible bounds
23951: 3159:        //     equality constraints: CAP#1
23952: 3160:        //     lower bounds: Long
23953: 3161:        //   where T is a type-variable:
23954: 3162:        //     T extends Object declared in
23955: 3163:        //       method <T>exact2(Holder<T>,T)
23956: 3164:        //   where CAP#1 is a fresh type-variable:
23957: 3165:        //     CAP#1 extends Long from
23958: 3166:        //       capture of ? extends Long
23959: 3167:        // 1 error
23960: 3168:
23961: 3169:        //- Long r9 = wildSubtype(raw, lng);
23962: 3170:        // warning: [unchecked] unchecked method invocation:
23963: 3171:        // method wildSubtype in class Wildcards
23964: 3172:        // is applied to given types
23965: 3173:        //     Long r9 = wildSubtype(raw, lng);
23966: 3174:        //                          ^
23967: 3175:        //   required: Holder<? extends T>,T
23968: 3176:        //   found: Holder,Long
23969: 3177:        //   where T is a type-variable:
23970: 3178:        //     T extends Object declared in
23971: 3179:        //     method <T>wildSubtype(Holder<? extends T>,T)
23972: 3180:        // warning: [unchecked] unchecked conversion
23973: 3181:        //     Long r9 = wildSubtype(raw, lng);
23974: 3182:        //                           ^
23975: 3183:        //   required: Holder<? extends T>
23976: 3184:        //   found:    Holder
23977: 3185:        //   where T is a type-variable:
23978: 3186:        //     T extends Object declared in
23979: 3187:        //     method <T>wildSubtype(Holder<? extends T>,T)
23980: 3188:        // 2 warnings
23981: 3189:
23982: 3190:        Long r10 = wildSubtype(qualified, lng);
23983: 3191:        // OK, but can only return Object:
23984: 3192:        Object r11 = wildSubtype(unbounded, lng);
23985: 3193:        Long r12 = wildSubtype(bounded, lng);
23986: 3194:
23987: 3195:        //- wildSupertype(raw, lng);
23988: 3196:        // warning: [unchecked] unchecked method invocation:
23989: 3197:        //   method wildSupertype in class Wildcards
23990: 3198:        //   is applied to given types
23991: 3199:        //     wildSupertype(raw, lng);
23992: 3200:        //                  ^
23993: 3201:        //   required: Holder<? super T>,T
23994: 3202:        //   found: Holder,Long
23995: 3203:        //   where T is a type-variable:
23996: 3204:        //     T extends Object declared in
23997: 3205:        //     method <T>wildSupertype(Holder<? super T>,T)
23998: 3206:        // warning: [unchecked] unchecked conversion
23999: 3207:        //     wildSupertype(raw, lng);
24000: 3208:        //                   ^
24001: 3209:        //   required: Holder<? super T>
24002: 3210:        //   found:    Holder
24003: 3211:        //   where T is a type-variable:
24004: 3212:        //     T extends Object declared in
24005: 3213:        //     method <T>wildSupertype(Holder<? super T>,T)
24006: 3214:        // 2 warnings
24007: 3215:
24008: 3216:        wildSupertype(qualified, lng);
24009: 3217:
24010: 3218:        //- wildSupertype(unbounded, lng);
24011: 3219:        // error: method wildSupertype in class Wildcards
24012: 3220:        // cannot be applied to given types;
24013: 3221:        //     wildSupertype(unbounded, lng);
24014: 3222:        //     ^
24015: 3223:        //   required: Holder<? super T>,T
24016: 3224:        //   found: Holder<CAP#1>,Long
24017: 3225:        //   reason: cannot infer type-variable(s) T
24018: 3226:        //     (argument mismatch; Holder<CAP#1>
24019: 3227:        //     cannot be converted to Holder<? super T>)
24020: 3228:        //   where T is a type-variable:
24021: 3229:        //     T extends Object declared in
24022: 3230:        //     method <T>wildSupertype(Holder<? super T>,T)
24023: 3231:        //   where CAP#1 is a fresh type-variable:
24024: 3232:        //     CAP#1 extends Object from capture of ?
24025: 3233:        // 1 error
24026: 3234:
24027: 3235:        //- wildSupertype(bounded, lng);
24028: 3236:        // error: method wildSupertype in class Wildcards
24029: 3237:        // cannot be applied to given types;
24030: 3238:        //     wildSupertype(bounded, lng);
24031: 3239:        //     ^
24032: 3240:        //   required: Holder<? super T>,T
24033: 3241:        //   found: Holder<CAP#1>,Long
24034: 3242:        //   reason: cannot infer type-variable(s) T
24035: 3243:        //     (argument mismatch; Holder<CAP#1>
24036: 3244:        //     cannot be converted to Holder<? super T>)
24037: 3245:        //   where T is a type-variable:
24038: 3246:        //     T extends Object declared in
24039: 3247:        //     method <T>wildSupertype(Holder<? super T>,T)
24040: 3248:        //   where CAP#1 is a fresh type-variable:
24041: 3249:        //     CAP#1 extends Long from capture of
24042: 3250:        //     ? extends Long
24043: 3251:        // 1 error
24044: 3252:    }
24045: 3253:}
24046: 3254:```
24047: 3255:
24048: 3256:在 `rawArgs()` 中，编译器知道 `Holder` 是一个泛型类型，因此即使它在这里被表示成一个原生类型，编译器仍旧知道向 `set()` 传递一个 **Object** 是不安全的。由于它是原生类型，你可以将任何类型的对象传递给 `set()` ，而这个对象将被向上转型为 **Object** 。因此无论何时，只要使用了原生类型，都会放弃编译期检查。对 `get()` 的调用说明了相同的问题：没有任何 **T** 类型的对象，因此结果只能是一个 **Object**。
24049: 3257:人们很自然地会开始考虑原生 `Holder` 与 `Holder<?>` 是大致相同的事物。但是 `unboundedArg()` 强调它们是不同的——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，因为原生 **Holder** 将持有任何类型的组合，而 `Holder<?>` 将持有具有某种具体类型的同构集合，因此不能只是向其中传递 **Object** 。
24050: 3258:在 `exact1()` 和 `exact2()` 中，你可以看到使用了确切的泛型参数——没有任何通配符。你将看到，`exact2()`与 `exact1()` 具有不同的限制，因为它有额外的参数。
24051: 3259:在 `wildSubtype()` 中，在 **Holder** 类型上的限制被放松为包括持有任何扩展自 **T** 的对象的 **Holder** 。这还是意味着如果 T 是 **Fruit** ，那么 `holder` 可以是 `Holder<Apple>` ，这是合法的。为了防止将 **Orange** 放置到 `Holder<Apple>` 中，对 `set()` 的调用（或者对任何接受这个类型参数为参数的方法的调用）都是不允许的。但是，你仍旧知道任何来自 `Holder<？extends Fruit>` 的对象至少是 **Fruit** ，因此 `get()` （或者任何将产生具有这个类型参数的返回值的方法）都是允许的。
24052: 3260:`wildSupertype()` 展示了超类型通配符，这个方法展示了与 `wildSubtype()` 相反的行为：`holder` 可以是持有任何 T 的基类型的容器。因此， `set()` 可以接受 **T** ，因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是 **T** ）。但是，尝试着调用 `get()` 是没有用的，因为由 `holder` 持有的类型可以是任何超类型，因此唯一安全的类型就是 **Object** 。
24053: 3261:这个示例还展示了对于在 `unbounded()` 中使用无界通配符能够做什么不能做什么所做出的限制：因为你没有 **T**，所以你不能将 `set()` 或 `get()` 作用于 **T** 上。
24054: 3262:
24055: 3263:在 `main()` 方法中你看到了某些方法在接受某些类型的参数时没有报错和警告。为了迁移兼容性，`rawArgs()`  将接受所有 **Holder** 的不同变体，而不会产生警告。`unboundedArg()` 方法也可以接受相同的所有类型，尽管如前所述，它在方法体内部处理这些类型的方式并不相同。
24056: 3264:
24057: 3265:如果向接受“确切”泛型类型（没有通配符）的方法传递一个原生 **Holder** 引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息。如果向 `exact1()` 传递一个无界引用，就不会有任何可以确定返回类型的类型信息。
24058: 3266:可以看到，`exact2()` 具有最多的限制，因为它希望精确地得到一个 `Holder<T>` ，以及一个具有类型 **T** 的参数，正由于此，它将产生错误或警告，除非提供确切的参数。有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决于是否想要从泛型参数中返回类型确定的返回值（就像在 `wildSubtype()` 中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在 `wildSupertype()` 中看到的那样）。
24059: 3267:因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合你的需求的方法。
24060: 3268:
24061: 3269:### 捕获转换
24062: 3270:
24063: 3271:有一种特殊情况需要使用 `<?>` 而不是原生类型。如果向一个使用 `<?>` 的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。下面的示例演示了这种技术，它被称为捕获转换，因为未指定的通配符类型被捕获，并被转换为确切类型。这里，有关警告的注释只有在 `@SuppressWarnings` 注解被移除之后才能起作用：
24064: 3272:
24065: 3273:```java
24066: 3274:// generics/CaptureConversion.java
24067: 3275:
24068: 3276:public class CaptureConversion {
24069: 3277:    static <T> void f1(Holder<T> holder) {
24070: 3278:        T t = holder.get();
24071: 3279:        System.out.println(t.getClass().getSimpleName());
24072: 3280:    }
24073: 3281:  
24074: 3282:    static void f2(Holder<?> holder) {
24075: 3283:        f1(holder); // Call with captured type
24076: 3284:    }
24077: 3285:    
24078: 3286:    @SuppressWarnings("unchecked")
24079: 3287:    public static void main(String[] args) {
24080: 3288:        Holder raw = new Holder<>(1);
24081: 3289:        f1(raw);
24082: 3290:        // warning: [unchecked] unchecked method invocation:
24083: 3291:        // method f1 in class CaptureConversion
24084: 3292:        // is applied to given types
24085: 3293:        //     f1(raw);
24086: 3294:        //       ^
24087: 3295:        //   required: Holder<T>
24088: 3296:        //   found: Holder
24089: 3297:        //   where T is a type-variable:
24090: 3298:        //     T extends Object declared in
24091: 3299:        //     method <T>f1(Holder<T>)
24092: 3300:        // warning: [unchecked] unchecked conversion
24093: 3301:        //     f1(raw);
24094: 3302:        //        ^
24095: 3303:        //   required: Holder<T>
24096: 3304:        //   found:    Holder
24097: 3305:        //   where T is a type-variable:
24098: 3306:        //     T extends Object declared in
24099: 3307:        //     method <T>f1(Holder<T>)
24100: 3308:        // 2 warnings
24101: 3309:        f2(raw); // No warnings
24102: 3310:        
24103: 3311:        Holder rawBasic = new Holder();
24104: 3312:        rawBasic.set(new Object());
24105: 3313:        // warning: [unchecked] unchecked call to set(T)
24106: 3314:        // as a member of the raw type Holder
24107: 3315:        //     rawBasic.set(new Object());
24108: 3316:        //                 ^
24109: 3317:        //   where T is a type-variable:
24110: 3318:        //     T extends Object declared in class Holder
24111: 3319:        // 1 warning
24112: 3320:        f2(rawBasic); // No warnings
24113: 3321:        
24114: 3322:        // Upcast to Holder<?>, still figures it out:
24115: 3323:        Holder<?> wildcarded = new Holder<>(1.0);
24116: 3324:        f2(wildcarded);
24117: 3325:    }
24118: 3326:}
24119: 3327:/* Output:
24120: 3328:Integer
24121: 3329:Integer
24122: 3330:Object
24123: 3331:Double
24124: 3332:*/
24125: 3333:```
24126: 3334:
24127: 3335:`f1()` 中的类型参数都是确切的，没有通配符或边界。在 `f2()` 中，**Holder** 参数是一个无界通配符，因此它看起来是未知的。但是，在 `f2()` 中调用了 `f1()`，而 `f1()` 需要一个已知参数。这里所发生的是：在调用 `f2()` 的过程中捕获了参数类型，并在调用 `f1()` 时使用了这种类型。
24128: 3336:你可能想知道这项技术是否可以用于写入，但是这要求在传递 `Holder<?>` 时同时传递一个具体类型。捕获转换只有在这样的情况下可以工作：即在方法内部，你需要使用确切的类型。注意，不能从 `f2()` 中返回 **T**，因为 **T** 对于 `f2()` 来说是未知的。捕获转换十分有趣，但是非常受限。
24129: 3337:
24130: 3338:<!-- Issues -->
24131: 3339:
24132: 3340:## 问题
24133: 3341:
24134: 3342:本节将阐述在使用 Java 泛型时会出现的各类问题。
24135: 3343:
24136: 3344:### 任何基本类型都不能作为类型参数
24137: 3345:
24138: 3346:正如本章早先提到的，Java 泛型的限制之一是不能将基本类型用作类型参数。因此，不能创建  `ArrayList<int>` 之类的东西。
24139: 3347:解决方法是使用基本类型的包装器类以及自动装箱机制。如果创建一个 `ArrayList<Integer>`，并将基本类型 **int** 应用于这个集合，那么你将发现自动装箱机制将自动地实现 **int** 到 **Integer** 的双向转换——因此，这几乎就像是有一个 `ArrayList<int>` 一样：
24140: 3348:
24141: 3349:```java
24142: 3350:// generics/ListOfInt.java
24143: 3351:// Autoboxing compensates for the inability
24144: 3352:// to use primitives in generics
24145: 3353:import java.util.*;
24146: 3354:import java.util.stream.*;
24147: 3355:
24148: 3356:public class ListOfInt {
24149: 3357:    public static void main(String[] args) {
24150: 3358:        List<Integer> li = IntStream.range(38, 48)
24151: 3359:            .boxed() // Converts ints to Integers
24152: 3360:            .collect(Collectors.toList());
24153: 3361:        System.out.println(li);
24154: 3362:    }
24155: 3363:}
24156: 3364:/* Output:
24157: 3365:[38, 39, 40, 41, 42, 43, 44, 45, 46, 47]
24158: 3366:*/
24159: 3367:```
24160: 3368:
24161: 3369:通常，这种解决方案工作得很好——能够成功地存储和读取 **int**，自动装箱隐藏了转换的过程。但是如果性能成为问题的话，就需要使用专门为基本类型适配的特殊版本的集合；一个开源版本的实现是 **org.apache.commons.collections.primitives**。
24162: 3370:下面是另外一种方式，它可以创建持有 **Byte** 的 **Set**：
24163: 3371:
24164: 3372:```java
24165: 3373:// generics/ByteSet.java
24166: 3374:import java.util.*;
24167: 3375:
24168: 3376:public class ByteSet {
24169: 3377:    Byte[] possibles = { 1,2,3,4,5,6,7,8,9 };
24170: 3378:    Set<Byte> mySet = new HashSet<>(Arrays.asList(possibles));
24171: 3379:    // But you can't do this:
24172: 3380:    // Set<Byte> mySet2 = new HashSet<>(
24173: 3381:    // Arrays.<Byte>asList(1,2,3,4,5,6,7,8,9));
24174: 3382:}
24175: 3383:```
24176: 3384:
24177: 3385:自动装箱机制解决了一些问题，但并没有解决所有问题。
24178: 3386:
24179: 3387:在下面的示例中，**FillArray** 接口包含一些通用方法，这些方法使用 **Supplier** 来用对象填充数组（这使得类泛型在本例中无法工作，因为这个方法是静态的）。**Supplier** 实现来自 [数组](book/21-Arrays.md) 一章,并且在 `main()` 中，可以看到 `FillArray.fill()` 使用对象填充了数组：
24180: 3388:
24181: 3389:```java
24182: 3390:// generics/PrimitiveGenericTest.java
24183: 3391:import onjava.*;
24184: 3392:import java.util.*;
24185: 3393:import java.util.function.*;
24186: 3394:
24187: 3395:// Fill an array using a generator:
24188: 3396:interface FillArray {
24189: 3397:    static <T> T[] fill(T[] a, Supplier<T> gen) {
24190: 3398:        Arrays.setAll(a, n -> gen.get());
24191: 3399:        return a;
24192: 3400:    }
24193: 3401:    
24194: 3402:    static int[] fill(int[] a, IntSupplier gen) {
24195: 3403:        Arrays.setAll(a, n -> gen.getAsInt());
24196: 3404:        return a;
24197: 3405:    }
24198: 3406:    
24199: 3407:    static long[] fill(long[] a, LongSupplier gen) {
24200: 3408:        Arrays.setAll(a, n -> gen.getAsLong());
24201: 3409:        return a;
24202: 3410:    }
24203: 3411:    
24204: 3412:    static double[] fill(double[] a, DoubleSupplier gen) {
24205: 3413:        Arrays.setAll(a, n -> gen.getAsDouble());
24206: 3414:        return a;
24207: 3415:    }
24208: 3416:}
24209: 3417:
24210: 3418:public class PrimitiveGenericTest {
24211: 3419:    public static void main(String[] args) {
24212: 3420:        String[] strings = FillArray.fill(
24213: 3421:            new String[5], new Rand.String(9));
24214: 3422:        System.out.println(Arrays.toString(strings));
24215: 3423:        int[] integers = FillArray.fill(
24216: 3424:            new int[9], new Rand.Pint());
24217: 3425:        System.out.println(Arrays.toString(integers));
24218: 3426:    }
24219: 3427:}
24220: 3428:/* Output:
24221: 3429:[btpenpccu, xszgvgmei, nneeloztd, vewcippcy, gpoalkljl]
24222: 3430:[635, 8737, 3941, 4720, 6177, 8479, 6656, 3768, 4948]
24223: 3431:*/
24224: 3432:```
24225: 3433:
24226: 3434:自动装箱不适用于数组，因此我们必须创建 `FillArray.fill()` 的重载版本，或创建产生 **Wrapped** 输出的生成器。 **FillArray** 仅比 `java.util.Arrays.setAll()` 有用一点，因为它返回填充的数组。
24227: 3435:
24228: 3436:### 实现参数化接口
24229: 3437:
24230: 3438:一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。下面是产生这种冲突的情况：
24231: 3439:
24232: 3440:```java
24233: 3441:// generics/MultipleInterfaceVariants.java
24234: 3442:// {WillNotCompile}
24235: 3443:package generics;
24236: 3444:
24237: 3445:interface Payable<T> {}
24238: 3446:
24239: 3447:class Employee implements Payable<Employee> {}
24240: 3448:
24241: 3449:class Hourly extends Employee implements Payable<Hourly> {}
24242: 3450:```
24243: 3451:
24244: 3452:**Hourly** 不能编译，因为擦除会将  `Payable<Employe>` 和 `Payable<Hourly>` 简化为相同的类 **Payable**，这样，上面的代码就意味着在重复两次地实现相同的接口。十分有趣的是，如果从 **Payable** 的两种用法中都移除掉泛型参数（就像编译器在擦除阶段所做的那样）这段代码就可以编译。
24245: 3453:
24246: 3454:在使用某些更基本的 Java 接口，例如 `Comparable<T>` 时，这个问题可能会变得十分令人恼火，就像你在本节稍后看到的那样。
24247: 3455:
24248: 3456:### 转型和警告
24249: 3457:
24250: 3458:使用带有泛型类型参数的转型或 **instanceof** 不会有任何效果。下面的集合在内部将各个值存储为 **Object**，并在获取这些值时，再将它们转型回 **T**：
24251: 3459:
24252: 3460:```java
24253: 3461:// generics/GenericCast.java
24254: 3462:import java.util.*;
24255: 3463:import java.util.stream.*;
24256: 3464:
24257: 3465:class FixedSizeStack<T> {
24258: 3466:    private final int size;
24259: 3467:    private Object[] storage;
24260: 3468:    private int index = 0;
24261: 3469:    
24262: 3470:    FixedSizeStack(int size) {
24263: 3471:        this.size = size;
24264: 3472:        storage = new Object[size];
24265: 3473:    }
24266: 3474:    
24267: 3475:    public void push(T item) {
24268: 3476:        if(index < size)
24269: 3477:            storage[index++] = item;
24270: 3478:    }
24271: 3479:    
24272: 3480:    @SuppressWarnings("unchecked")
24273: 3481:    public T pop() {
24274: 3482:        return index == 0 ? null : (T)storage[--index];
24275: 3483:    }
24276: 3484:    
24277: 3485:    @SuppressWarnings("unchecked")
24278: 3486:    Stream<T> stream() {
24279: 3487:        return (Stream<T>)Arrays.stream(storage);
24280: 3488:    }
24281: 3489:}
24282: 3490:
24283: 3491:public class GenericCast {
24284: 3492:    static String[] letters = "ABCDEFGHIJKLMNOPQRS".split("");
24285: 3493:  
24286: 3494:    public static void main(String[] args) {
24287: 3495:        FixedSizeStack<String> strings =
24288: 3496:            new FixedSizeStack<>(letters.length);
24289: 3497:        Arrays.stream("ABCDEFGHIJKLMNOPQRS".split(""))
24290: 3498:            .forEach(strings::push);
24291: 3499:        System.out.println(strings.pop());
24292: 3500:        strings.stream()
24293: 3501:            .map(s -> s + " ")
24294: 3502:            .forEach(System.out::print);
24295: 3503:    }
24296: 3504:}
24297: 3505:/* Output:
24298: 3506:S
24299: 3507:A B C D E F G H I J K L M N O P Q R S
24300: 3508:*/
24301: 3509:```
24302: 3510:
24303: 3511:如果没有 **@SuppressWarnings** 注解，编译器将对 `pop()` 产生 “unchecked cast” 警告。由于擦除的原因，编译器无法知道这个转型是否是安全的，并且 `pop()` 方法实际上并没有执行任何转型。
24304: 3512:这是因为，**T** 被擦除到它的第一个边界，默认情况下是 **Object** ，因此 `pop()` 实际上只是将 **Object** 转型为 **Object**。
24305: 3513:有时，泛型没有消除对转型的需要，这就会由编译器产生警告，而这个警告是不恰当的。例如：
24306: 3514:
24307: 3515:```java
24308: 3516:// generics/NeedCasting.java
24309: 3517:import java.io.*;
24310: 3518:import java.util.*;
24311: 3519:
24312: 3520:public class NeedCasting {
24313: 3521:    @SuppressWarnings("unchecked")
24314: 3522:    public void f(String[] args) throws Exception {
24315: 3523:        ObjectInputStream in = new ObjectInputStream(
24316: 3524:            new FileInputStream(args[0]));
24317: 3525:        List<Widget> shapes = (List<Widget>)in.readObject();
24318: 3526:    }
24319: 3527:}
24320: 3528:```
24321: 3529:
24322: 3530:正如你将在 [附录：对象序列化](book/Appendix-Object-Serialization.md) 中学到的那样，`readObject()` 无法知道它正在读取的是什么，因此它返回的是必须转型的对象。但是当注释掉 **@SuppressWarnings** 注解并编译这个程序时，就会得到下面的警告。
24323: 3531:
24324: 3532:```
24325: 3533:NeedCasting.java uses unchecked or unsafe operations.
24326: 3534:Recompile with -Xlint:unchecked for details.
24327: 3535:
24328: 3536:And if you follow the instructions and recompile with  -
24329: 3537:Xlint:unchecked :(如果遵循这条指示，使用-Xlint:unchecked来重新编译：)
24330: 3538:
24331: 3539:NeedCasting.java:10: warning: [unchecked] unchecked cast
24332: 3540:    List<Widget> shapes = (List<Widget>)in.readObject();
24333: 3541:    required: List<Widget>
24334: 3542:    found: Object
24335: 3543:1 warning
24336: 3544:```
24337: 3545:
24338: 3546:你会被强制要求转型，但是又被告知不应该转型。为了解决这个问题，必须使用 Java 5 引入的新的转型形式，即通过泛型类来转型：
24339: 3547:
24340: 3548:```java
24341: 3549:// generics/ClassCasting.java
24342: 3550:import java.io.*;
24343: 3551:import java.util.*;
24344: 3552:
24345: 3553:public class ClassCasting {
24346: 3554:    @SuppressWarnings("unchecked")
24347: 3555:    public void f(String[] args) throws Exception {
24348: 3556:        ObjectInputStream in = new ObjectInputStream(
24349: 3557:            new FileInputStream(args[0]));
24350: 3558:        // Won't Compile:
24351: 3559:        //    List<Widget> lw1 =
24352: 3560:        //    List<>.class.cast(in.readObject());
24353: 3561:        List<Widget> lw2 = List.class.cast(in.readObject());
24354: 3562:    }
24355: 3563:}
24356: 3564:```
24357: 3565:
24358: 3566:但是，不能转型到实际类型（ `List<Widget>` ）。也就是说，不能声明：
24359: 3567:
24360: 3568:```
24361: 3569:List<Widget>.class.cast(in.readobject())
24362: 3570:```
24363: 3571:
24364: 3572:甚至当你添加一个像下面这样的另一个转型时：
24365: 3573:
24366: 3574:```
24367: 3575:(List<Widget>)List.class.cast(in.readobject())
24368: 3576:```
24369: 3577:
24370: 3578:仍旧会得到一个警告。
24371: 3579:
24372: 3580:### 重载
24373: 3581:
24374: 3582:下面的程序是不能编译的，即使它看起来是合理的：
24375: 3583:
24376: 3584:```java
24377: 3585:// generics/UseList.java
24378: 3586:// {WillNotCompile}
24379: 3587:import java.util.*;
24380: 3588:
24381: 3589:public class UseList<W, T> {
24382: 3590:    void f(List<T> v) {}
24383: 3591:    void f(List<W> v) {}
24384: 3592:}
24385: 3593:```
24386: 3594:
24387: 3595:因为擦除，所以重载方法产生了相同的类型签名。
24388: 3596:
24389: 3597:因而，当擦除后的参数不能产生唯一的参数列表时，你必须提供不同的方法名：
24390: 3598:
24391: 3599:```java
24392: 3600:// generics/UseList2.java
24393: 3601:
24394: 3602:import java.util.*;
24395: 3603:
24396: 3604:public class UseList2<W, T> {
24397: 3605:    void f1(List<T> v) {}
24398: 3606:    void f2(List<W> v) {}
24399: 3607:}
24400: 3608:```
24401: 3609:
24402: 3610:幸运的是，编译器可以检测到这类问题。
24403: 3611:
24404: 3612:### 基类劫持接口
24405: 3613:
24406: 3614:假设你有一个实现了 **Comparable** 接口的 **Pet** 类：
24407: 3615:
24408: 3616:```java
24409: 3617:// generics/ComparablePet.java
24410: 3618:
24411: 3619:public class ComparablePet implements Comparable<ComparablePet> {
24412: 3620:    @Override
24413: 3621:    public int compareTo(ComparablePet o) {
24414: 3622:        return 0;
24415: 3623:    }
24416: 3624:}
24417: 3625:```
24418: 3626:
24419: 3627:尝试缩小 **ComparablePet** 子类的比较类型是有意义的。例如，**Cat** 类可以与其他的 **Cat** 比较：
24420: 3628:
24421: 3629:```java
24422: 3630:// generics/HijackedInterface.java
24423: 3631:// {WillNotCompile}
24424: 3632:
24425: 3633:class Cat extends ComparablePet implements Comparable<Cat> {
24426: 3634:    // error: Comparable cannot be inherited with
24427: 3635:    // different arguments: <Cat> and <ComparablePet>
24428: 3636:    // class Cat
24429: 3637:    // ^
24430: 3638:    // 1 error
24431: 3639:    public int compareTo(Cat arg) {
24432: 3640:        return 0;
24433: 3641:    }
24434: 3642:}
24435: 3643:```
24436: 3644:
24437: 3645:不幸的是，这不能工作。一旦 **Comparable** 的类型参数设置为 **ComparablePet**，其他的实现类只能比较 **ComparablePet**：
24438: 3646:
24439: 3647:```java
24440: 3648:// generics/RestrictedComparablePets.java
24441: 3649:
24442: 3650:public class Hamster extends ComparablePet implements Comparable<ComparablePet> {
24443: 3651:
24444: 3652:    @Override
24445: 3653:    public int compareTo(ComparablePet arg) {
24446: 3654:        return 0;
24447: 3655:    }
24448: 3656:}
24449: 3657:// Or just:
24450: 3658:class Gecko extends ComparablePet {
24451: 3659:    public int compareTo(ComparablePet arg) {
24452: 3660:        return 0;
24453: 3661:    }
24454: 3662:}
24455: 3663:```
24456: 3664:
24457: 3665:**Hamster** 显示了重新实现 **ComparablePet** 中相同的接口是可能的，只要接口完全相同，包括参数类型。然而正如 **Gecko** 中所示，这与直接覆写基类的方法完全相同。
24458: 3666:
24459: 3667:<!-- Self-Bounded Types -->
24460: 3668:
24461: 3669:## 自限定的类型
24462: 3670:
24463: 3671:在 Java 泛型中，有一个似乎经常性出现的惯用法，它相当令人费解：
24464: 3672:
24465: 3673:```java
24466: 3674:class SelfBounded<T extends SelfBounded<T>> { // ...
24467: 3675:```
24468: 3676:
24469: 3677:这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。**SelfBounded** 类接受泛型参数 **T**，而 **T** 由一个边界类限定，这个边界就是拥有 **T** 作为其参数的 **SelfBounded**。
24470: 3678:
24471: 3679:当你首次看到它时，很难去解析它，它强调的是当 **extends** 关键字用于边界与用来创建子类明显是不同的。
24472: 3680:
24473: 3681:### 古怪的循环泛型
24474: 3682:
24475: 3683:为了理解自限定类型的含义，我们从这个惯用法的一个简单版本入手，它没有自限定的边界。
24476: 3684:
24477: 3685:不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类。也就是说，可以声明：
24478: 3686:
24479: 3687:```java
24480: 3688:// generics/CuriouslyRecurringGeneric.java
24481: 3689:
24482: 3690:class GenericType<T> {}
24483: 3691:
24484: 3692:public class CuriouslyRecurringGeneric
24485: 3693:  extends GenericType<CuriouslyRecurringGeneric> {}
24486: 3694:```
24487: 3695:
24488: 3696:这可以按照 Jim Coplien 在 C++ 中的*古怪的循环模版模式*的命名方式，称为古怪的循环泛型（CRG）。“古怪的循环”是指类相当古怪地出现在它自己的基类中这一事实。
24489: 3697:为了理解其含义，努力大声说：“我在创建一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为其参数。”当给出导出类的名字时，这个泛型基类能够实现什么呢？好吧，Java 中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为其参数和返回类型的基类。它还能将导出类型用作其域类型，尽管这些将被擦除为 **Object** 的类型。下面是表示了这种情况的一个泛型类：
24490: 3698:
24491: 3699:```java
24492: 3700:// generics/BasicHolder.java
24493: 3701:
24494: 3702:public class BasicHolder<T> {
24495: 3703:    T element;
24496: 3704:    void set(T arg) { element = arg; }
24497: 3705:    T get() { return element; }
24498: 3706:    void f() {
24499: 3707:        System.out.println(element.getClass().getSimpleName());
24500: 3708:    }
24501: 3709:}
24502: 3710:```
24503: 3711:
24504: 3712:这是一个普通的泛型类型，它的一些方法将接受和产生具有其参数类型的对象，还有一个方法在其存储的域上执行操作（尽管只是在这个域上执行 **Object** 操作）。
24505: 3713:我们可以在一个古怪的循环泛型中使用 **BasicHolder**：
24506: 3714:
24507: 3715:```java
24508: 3716:// generics/CRGWithBasicHolder.java
24509: 3717:
24510: 3718:class Subtype extends BasicHolder<Subtype> {}
24511: 3719:
24512: 3720:public class CRGWithBasicHolder {
24513: 3721:    public static void main(String[] args) {
24514: 3722:        Subtype st1 = new Subtype(), st2 = new Subtype();
24515: 3723:        st1.set(st2);
24516: 3724:        Subtype st3 = st1.get();
24517: 3725:        st1.f();
24518: 3726:    }
24519: 3727:}
24520: 3728:/* Output:
24521: 3729:Subtype
24522: 3730:*/
24523: 3731:```
24524: 3732:
24525: 3733:注意，这里有些东西很重要：新类 **Subtype** 接受的参数和返回的值具有 **Subtype** 类型而不仅仅是基类 **BasicHolder** 类型。这就是 CRG 的本质：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型。也就是说，在所产生的类中将使用确切类型而不是基类型。因此，在**Subtype** 中，传递给 `set()` 的参数和从 `get()` 返回的类型都是确切的 **Subtype**。
24526: 3734:
24527: 3735:### 自限定
24528: 3736:
24529: 3737:**BasicHolder** 可以使用任何类型作为其泛型参数，就像下面看到的那样：
24530: 3738:
24531: 3739:```java
24532: 3740:// generics/Unconstrained.java
24533: 3741:// (c)2017 MindView LLC: see Copyright.txt
24534: 3742:// We make no guarantees that this code is fit for any purpose.
24535: 3743:// Visit http://OnJava8.com for more book information.
24536: 3744:
24537: 3745:class Other {}
24538: 3746:class BasicOther extends BasicHolder<Other> {}
24539: 3747:
24540: 3748:public class Unconstrained {
24541: 3749:    public static void main(String[] args) {
24542: 3750:        BasicOther b = new BasicOther();
24543: 3751:        BasicOther b2 = new BasicOther();
24544: 3752:        b.set(new Other());
24545: 3753:        Other other = b.get();
24546: 3754:        b.f();
24547: 3755:    }
24548: 3756:}
24549: 3757:/* Output:
24550: 3758:Other
24551: 3759:*/
24552: 3760:```
24553: 3761:
24554: 3762:限定将采取额外的步骤，强制泛型当作其自身的边界参数来使用。观察所产生的类可以如何使用以及不可以如何使用：
24555: 3763:
24556: 3764:```java
24557: 3765:// generics/SelfBounding.java
24558: 3766:
24559: 3767:class SelfBounded<T extends SelfBounded<T>> {
24560: 3768:    T element;
24561: 3769:    SelfBounded<T> set(T arg) {
24562: 3770:        element = arg;
24563: 3771:        return this;
24564: 3772:    }
24565: 3773:    T get() { return element; }
24566: 3774:}
24567: 3775:
24568: 3776:class A extends SelfBounded<A> {}
24569: 3777:class B extends SelfBounded<A> {} // Also OK
24570: 3778:
24571: 3779:class C extends SelfBounded<C> {
24572: 3780:    C setAndGet(C arg) { 
24573: 3781:        set(arg); 
24574: 3782:        return get();
24575: 3783:    }
24576: 3784:}
24577: 3785:
24578: 3786:class D {}
24579: 3787:// Can't do this:
24580: 3788:// class E extends SelfBounded<D> {}
24581: 3789:// Compile error:
24582: 3790://   Type parameter D is not within its bound
24583: 3791:
24584: 3792:// Alas, you can do this, so you cannot force the idiom:
24585: 3793:class F extends SelfBounded {}
24586: 3794:
24587: 3795:public class SelfBounding {
24588: 3796:    public static void main(String[] args) {
24589: 3797:        A a = new A();
24590: 3798:        a.set(new A());
24591: 3799:        a = a.set(new A()).get();
24592: 3800:        a = a.get();
24593: 3801:        C c = new C();
24594: 3802:        c = c.setAndGet(new C());
24595: 3803:    }
24596: 3804:}
24597: 3805:```
24598: 3806:
24599: 3807:自限定所做的，就是要求在继承关系中，像下面这样使用这个类：
24600: 3808:
24601: 3809:```java
24602: 3810:class A extends SelfBounded<A>{}
24603: 3811:```
24604: 3812:
24605: 3813:这会强制要求将正在定义的类当作参数传递给基类。
24606: 3814:
24607: 3815:自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。正如你在 B 类的定义中所看到的，还可以从使用了另一个 **SelfBounded** 参数的 **SelfBounded** 中导出，尽管在 **A** 类看到的用法看起来是主要的用法。对定义 **E** 的尝试说明不能使用不是 **SelfBounded** 的类型参数。
24608: 3816:遗憾的是， **F** 可以编译，不会有任何警告，因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型。
24609: 3817:注意，可以移除自限定这个限制，这样所有的类仍旧是可以编译的，但是 **E** 也会因此而变得可编译：
24610: 3818:
24611: 3819:```java
24612: 3820:// generics/NotSelfBounded.java
24613: 3821:
24614: 3822:public class NotSelfBounded<T> {
24615: 3823:    T element;
24616: 3824:    NotSelfBounded<T> set(T arg) {
24617: 3825:        element = arg;
24618: 3826:        return this;
24619: 3827:    }
24620: 3828:    T get() { return element; }
24621: 3829:} 
24622: 3830:
24623: 3831:class A2 extends NotSelfBounded<A2> {}
24624: 3832:class B2 extends NotSelfBounded<A2> {}
24625: 3833:
24626: 3834:class C2 extends NotSelfBounded<C2> {
24627: 3835:    C2 setAndGet(C2 arg) { 
24628: 3836:        set(arg); 
24629: 3837:        return get(); 
24630: 3838:    }
24631: 3839:}
24632: 3840:
24633: 3841:class D2 {}
24634: 3842:// Now this is OK:
24635: 3843:class E2 extends NotSelfBounded<D2> {}
24636: 3844:```
24637: 3845:
24638: 3846:因此很明显，自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。这会强制要求使用这个类的每个人都要遵循这种形式。
24639: 3847:还可以将自限定用于泛型方法：
24640: 3848:
24641: 3849:```java
24642: 3850:// generics/SelfBoundingMethods.java
24643: 3851:// (c)2017 MindView LLC: see Copyright.txt
24644: 3852:// We make no guarantees that this code is fit for any purpose.
24645: 3853:// Visit http://OnJava8.com for more book information.
24646: 3854:
24647: 3855:public class SelfBoundingMethods {
24648: 3856:    static <T extends SelfBounded<T>> T f(T arg) {
24649: 3857:        return arg.set(arg).get();
24650: 3858:    }
24651: 3859:    
24652: 3860:    public static void main(String[] args) {
24653: 3861:        A a = f(new A());
24654: 3862:    }
24655: 3863:}
24656: 3864:```
24657: 3865:
24658: 3866:这可以防止这个方法被应用于除上述形式的自限定参数之外的任何事物上。
24659: 3867:
24660: 3868:### 参数协变
24661: 3869:
24662: 3870:自限定类型的价值在于它们可以产生*协变参数类型*——方法参数类型会随子类而变化。
24663: 3871:
24664: 3872:尽管自限定类型还可以产生与子类类型相同的返回类型，但是这并不十分重要，因为*协变返回类型*是在 Java 5 引入：
24665: 3873:
24666: 3874:```java
24667: 3875:// generics/CovariantReturnTypes.java
24668: 3876:
24669: 3877:class Base {}
24670: 3878:class Derived extends Base {}
24671: 3879:
24672: 3880:interface OrdinaryGetter {
24673: 3881:    Base get();
24674: 3882:}
24675: 3883:
24676: 3884:interface DerivedGetter extends OrdinaryGetter {
24677: 3885:    // Overridden method return type can vary:
24678: 3886:    @Override
24679: 3887:    Derived get();
24680: 3888:}
24681: 3889:
24682: 3890:public class CovariantReturnTypes {
24683: 3891:    void test(DerivedGetter d) {
24684: 3892:        Derived d2 = d.get();
24685: 3893:    }
24686: 3894:}
24687: 3895:```
24688: 3896:
24689: 3897:**DerivedGetter** 中的 `get()` 方法覆盖了 **OrdinaryGetter** 中的 `get()` ，并返回了一个从 `OrdinaryGetter.get()` 的返回类型中导出的类型。尽管这是完全合乎逻辑的事情（导出类方法应该能够返回比它覆盖的基类方法更具体的类型）但是这在早先的 Java 版本中是不合法的。
24690: 3898:
24691: 3899:自限定泛型事实上将产生确切的导出类型作为其返回值，就像在 `get()` 中所看到的一样：
24692: 3900:
24693: 3901:```java
24694: 3902:// generics/GenericsAndReturnTypes.java
24695: 3903:
24696: 3904:interface GenericGetter<T extends GenericGetter<T>> {
24697: 3905:    T get();
24698: 3906:}
24699: 3907:
24700: 3908:interface Getter extends GenericGetter<Getter> {}
24701: 3909:
24702: 3910:public class GenericsAndReturnTypes {
24703: 3911:    void test(Getter g) {
24704: 3912:        Getter result = g.get();
24705: 3913:        GenericGetter gg = g.get(); // Also the base type
24706: 3914:    }
24707: 3915:}
24708: 3916:```
24709: 3917:
24710: 3918:注意，这段代码不能编译，除非是使用囊括了协变返回类型的 Java 5。
24711: 3919:
24712: 3920:然而，在非泛型代码中，参数类型不能随子类型发生变化：
24713: 3921:
24714: 3922:```java
24715: 3923:// generics/OrdinaryArguments.java
24716: 3924:
24717: 3925:class OrdinarySetter {
24718: 3926:    void set(Base base) {
24719: 3927:        System.out.println("OrdinarySetter.set(Base)");
24720: 3928:    }
24721: 3929:}
24722: 3930:
24723: 3931:class DerivedSetter extends OrdinarySetter {
24724: 3932:    void set(Derived derived) {
24725: 3933:        System.out.println("DerivedSetter.set(Derived)");
24726: 3934:    }
24727: 3935:}
24728: 3936:
24729: 3937:public class OrdinaryArguments {
24730: 3938:    public static void main(String[] args) {
24731: 3939:        Base base = new Base();
24732: 3940:        Derived derived = new Derived();
24733: 3941:        DerivedSetter ds = new DerivedSetter();
24734: 3942:        ds.set(derived);
24735: 3943:        // Compiles--overloaded, not overridden!:
24736: 3944:        ds.set(base);
24737: 3945:    }
24738: 3946:}
24739: 3947:/* Output:
24740: 3948:DerivedSetter.set(Derived)
24741: 3949:OrdinarySetter.set(Base)
24742: 3950:*/
24743: 3951:```
24744: 3952:
24745: 3953:`set(derived)` 和 `set(base)` 都是合法的，因此 `DerivedSetter.set()` 没有覆盖 `OrdinarySetter.set()` ，而是重载了这个方法。从输出中可以看到，在 **DerivedSetter** 中有两个方法，因此基类版本仍旧是可用的，因此可以证明它被重载过。
24746: 3954:但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类型而不是基类型为参数：
24747: 3955:
24748: 3956:```java
24749: 3957:// generics/SelfBoundingAndCovariantArguments.java
24750: 3958:
24751: 3959:interface SelfBoundSetter<T extends SelfBoundSetter<T>> {
24752: 3960:    void set(T arg);
24753: 3961:}
24754: 3962:
24755: 3963:interface Setter extends SelfBoundSetter<Setter> {}
24756: 3964:
24757: 3965:public class SelfBoundingAndCovariantArguments {
24758: 3966:    void
24759: 3967:    testA(Setter s1, Setter s2, SelfBoundSetter sbs) {
24760: 3968:        s1.set(s2);
24761: 3969:        //- s1.set(sbs);
24762: 3970:        // error: method set in interface SelfBoundSetter<T>
24763: 3971:        // cannot be applied to given types;
24764: 3972:        //     s1.set(sbs);
24765: 3973:        //       ^
24766: 3974:        //   required: Setter
24767: 3975:        //   found: SelfBoundSetter
24768: 3976:        //   reason: argument mismatch;
24769: 3977:        // SelfBoundSetter cannot be converted to Setter
24770: 3978:        //   where T is a type-variable:
24771: 3979:        //     T extends SelfBoundSetter<T> declared in
24772: 3980:        //     interface SelfBoundSetter
24773: 3981:        // 1 error
24774: 3982:    }
24775: 3983:}
24776: 3984:```
24777: 3985:
24778: 3986:编译器不能识别将基类型当作参数传递给 `set()` 的尝试，因为没有任何方法具有这样的签名。实际上，这个参数已经被覆盖。
24779: 3987:如果不使用自限定类型，普通的继承机制就会介入，而你将能够重载，就像在非泛型的情况下一样：
24780: 3988:
24781: 3989:```java
24782: 3990:// generics/PlainGenericInheritance.java
24783: 3991:
24784: 3992:class GenericSetter<T> { // Not self-bounded
24785: 3993:    void set(T arg) {
24786: 3994:        System.out.println("GenericSetter.set(Base)");
24787: 3995:    }
24788: 3996:}
24789: 3997:
24790: 3998:class DerivedGS extends GenericSetter<Base> {
24791: 3999:    void set(Derived derived) {
24792: 4000:        System.out.println("DerivedGS.set(Derived)");
24793: 4001:    }
24794: 4002:}
24795: 4003:
24796: 4004:public class PlainGenericInheritance {
24797: 4005:    public static void main(String[] args) {
24798: 4006:        Base base = new Base();
24799: 4007:        Derived derived = new Derived();
24800: 4008:        DerivedGS dgs = new DerivedGS();
24801: 4009:        dgs.set(derived);
24802: 4010:        dgs.set(base); // Overloaded, not overridden!
24803: 4011:    }
24804: 4012:}
24805: 4013:/* Output:
24806: 4014:DerivedGS.set(Derived)
24807: 4015:GenericSetter.set(Base)
24808: 4016:*/
24809: 4017:```
24810: 4018:
24811: 4019:这段代码在模仿 **OrdinaryArguments.java**；在那个示例中，**DerivedSetter** 继承自包含一个 `set(Base)` 的**OrdinarySetter** 。而这里，**DerivedGS** 继承自泛型创建的也包含有一个 `set(Base)`的 `GenericSetter<Base>`。就像 **OrdinaryArguments.java** 一样，你可以从输出中看到， **DerivedGS** 包含两个  `set()` 的重载版本。如果不使用自限定，将重载参数类型。如果使用了自限定，只能获得方法的一个版本，它将接受确切的参数类型。
24812: 4020:
24813: 4021:<!-- Dynamic Type Safety -->
24814: 4022:
24815: 4023:## 动态类型安全
24816: 4024:
24817: 4025:因为可以向 Java 5 之前的代码传递泛型集合，所以旧式代码仍旧有可能会破坏你的集合。Java 5 的 **java.util.Collections** 中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：静态方法 `checkedCollection()` 、`checkedList()`、 `checkedMap()` 、 `checkedSet()` 、`checkedSortedMap()`和 `checkedSortedSet()`。这些方法每一个都会将你希望动态检查的集合当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。
24818: 4026:
24819: 4027:受检查的集合在你试图插入类型不正确的对象时抛出 **ClassCastException** ，这与泛型之前的（原生）集合形成了对比，对于后者来说，当你将对象从集合中取出时，才会通知你出现了问题。在后一种情况中，你知道存在问题，但是不知道罪魁祸首在哪里，如果使用受检查的集合，就可以发现谁在试图插入不良对象。
24820: 4028:让我们用受检查的集合来看看“将猫插入到狗列表中”这个问题。这里，`oldStyleMethod()` 表示遗留代码，因为它接受的是原生的 **List** ，而 **@SuppressWarnings（“unchecked”）** 注解对于压制所产生的警告是必需的：
24821: 4029:
24822: 4030:```java
24823: 4031:// generics/CheckedList.java
24824: 4032:// Using Collection.checkedList()
24825: 4033:import typeinfo.pets.*;
24826: 4034:import java.util.*;
24827: 4035:
24828: 4036:public class CheckedList {
24829: 4037:    @SuppressWarnings("unchecked")
24830: 4038:    static void oldStyleMethod(List probablyDogs) {
24831: 4039:        probablyDogs.add(new Cat());
24832: 4040:    }
24833: 4041:    
24834: 4042:    public static void main(String[] args) {
24835: 4043:        List<Dog> dogs1 = new ArrayList<>();
24836: 4044:        oldStyleMethod(dogs1); // Quietly accepts a Cat
24837: 4045:        List<Dog> dogs2 = Collections.checkedList(
24838: 4046:            new ArrayList<>(), Dog.class);
24839: 4047:        try {
24840: 4048:            oldStyleMethod(dogs2); // Throws an exception
24841: 4049:        } catch(Exception e) {
24842: 4050:            System.out.println("Expected: " + e);
24843: 4051:        }
24844: 4052:        // Derived types work fine:
24845: 4053:        List<Pet> pets = Collections.checkedList(
24846: 4054:            new ArrayList<>(), Pet.class);
24847: 4055:        pets.add(new Dog());
24848: 4056:        pets.add(new Cat());
24849: 4057:    }
24850: 4058:}
24851: 4059:/* Output:
24852: 4060:Expected: java.lang.ClassCastException: Attempt to
24853: 4061:insert class typeinfo.pets.Cat element into collection
24854: 4062:with element type class typeinfo.pets.Dog
24855: 4063:*/
24856: 4064:```
24857: 4065:
24858: 4066:运行这个程序时，你会发现插入一个 **Cat** 对于 **dogs1** 来说没有任何问题，而 **dogs2** 立即会在这个错误类型的插入操作上抛出一个异常。还可以看到，将导出类型的对象放置到将要检查基类型的受检查容器中是没有问题的。
24859: 4067:
24860: 4068:<!-- Exceptions -->
24861: 4069:
24862: 4070:## 泛型异常
24863: 4071:
24864: 4072:由于擦除的原因，**catch** 语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承自 **Throwable**（这将进一步阻止你去定义不能捕获的泛型异常）。
24865: 4073:但是，类型参数可能会在一个方法的 **throws** 子句中用到。这使得你可以编写随检查型异常类型变化的泛型代码：
24866: 4074:
24867: 4075:```java
24868: 4076:// generics/ThrowGenericException.java
24869: 4077:
24870: 4078:import java.util.*;
24871: 4079:
24872: 4080:interface Processor<T, E extends Exception> {
24873: 4081:    void process(List<T> resultCollector) throws E;
24874: 4082:}
24875: 4083:
24876: 4084:class ProcessRunner<T, E extends Exception>
24877: 4085:extends ArrayList<Processor<T, E>> {
24878: 4086:    List<T> processAll() throws E {
24879: 4087:        List<T> resultCollector = new ArrayList<>();
24880: 4088:        for(Processor<T, E> processor : this)
24881: 4089:            processor.process(resultCollector);
24882: 4090:        return resultCollector;
24883: 4091:    }
24884: 4092:}
24885: 4093:
24886: 4094:class Failure1 extends Exception {}
24887: 4095:
24888: 4096:class Processor1
24889: 4097:implements Processor<String, Failure1> {
24890: 4098:    static int count = 3;
24891: 4099:    @Override
24892: 4100:    public void process(List<String> resultCollector)
24893: 4101:    throws Failure1 {
24894: 4102:        if(count-- > 1)
24895: 4103:            resultCollector.add("Hep!");
24896: 4104:        else
24897: 4105:            resultCollector.add("Ho!");
24898: 4106:        if(count < 0)
24899: 4107:            throw new Failure1();
24900: 4108:    }
24901: 4109:}
24902: 4110:
24903: 4111:class Failure2 extends Exception {}
24904: 4112:
24905: 4113:class Processor2
24906: 4114:implements Processor<Integer, Failure2> {
24907: 4115:    static int count = 2;
24908: 4116:    @Override
24909: 4117:    public void process(List<Integer> resultCollector)
24910: 4118:    throws Failure2 {
24911: 4119:        if(count-- == 0)
24912: 4120:            resultCollector.add(47);
24913: 4121:        else {
24914: 4122:            resultCollector.add(11);
24915: 4123:        }
24916: 4124:        if(count < 0)
24917: 4125:            throw new Failure2();
24918: 4126:    }
24919: 4127:}
24920: 4128:
24921: 4129:public class ThrowGenericException {
24922: 4130:    public static void main(String[] args) {
24923: 4131:        ProcessRunner<String, Failure1> runner =
24924: 4132:            new ProcessRunner<>();
24925: 4133:        for(int i = 0; i < 3; i++)
24926: 4134:            runner.add(new Processor1());
24927: 4135:        try {
24928: 4136:            System.out.println(runner.processAll());
24929: 4137:        } catch(Failure1 e) {
24930: 4138:            System.out.println(e);
24931: 4139:        }
24932: 4140:
24933: 4141:        ProcessRunner<Integer, Failure2> runner2 =
24934: 4142:            new ProcessRunner<>();
24935: 4143:        for(int i = 0; i < 3; i++)
24936: 4144:            runner2.add(new Processor2());
24937: 4145:        try {
24938: 4146:            System.out.println(runner2.processAll());
24939: 4147:        } catch(Failure2 e) {
24940: 4148:            System.out.println(e);
24941: 4149:        }
24942: 4150:    }
24943: 4151:}
24944: 4152:/* Output:
24945: 4153:[Hep!, Hep!, Ho!]
24946: 4154:Failure2
24947: 4155:*/
24948: 4156:```
24949: 4157:
24950: 4158:**Processor** 执行 `process()` 方法，并且可能会抛出具有类型 **E** 的异常。`process()` 的结果存储在 `List<T>resultCollector` 中（这被称为*收集参数*）。**ProcessRunner** 有一个 `processAll()` 方法，它会在所持有的每个 **Process** 对象执行，并返回 **resultCollector** 。
24951: 4159:如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出这种泛化的代码。
24952: 4160:
24953: 4161:<!-- Mixins -->
24954: 4162:
24955: 4163:## 混型
24956: 4164:
24957: 4165:术语*混型*随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是你最后的手段，它将使组装多个类变得简单易行。
24958: 4166:混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点*面向切面编程* （AOP） 的味道，而切面经常被建议用来解决混型问题。
24959: 4167:
24960: 4168:### C++ 中的混型
24961: 4169:
24962: 4170:在 C++ 中，使用多重继承的最大理由，就是为了使用混型。但是，对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为混型就是继承自其类型参数的类。在 C++ 中，可以很容易地创建混型，因为 C++ 能够记住其模版参数的类型。
24963: 4171:下面是一个 C++ 示例，它有两个混型类型：一个使得你可以在每个对象中混入拥有一个时间戳这样的属性，而另一个可以混入一个序列号。
24964: 4172:
24965: 4173:```c++
24966: 4174:// generics/Mixins.cpp
24967: 4175:
24968: 4176:#include <string>
24969: 4177:#include <ctime>
24970: 4178:#include <iostream>
24971: 4179:using namespace std;
24972: 4180:
24973: 4181:template<class T> class TimeStamped : public T {
24974: 4182:    long timeStamp;
24975: 4183:public:
24976: 4184:    TimeStamped() { timeStamp = time(0); }
24977: 4185:    long getStamp() { return timeStamp; }
24978: 4186:};
24979: 4187:
24980: 4188:template<class T> class SerialNumbered : public T {
24981: 4189:    long serialNumber;
24982: 4190:    static long counter;
24983: 4191:public:
24984: 4192:    SerialNumbered() { serialNumber = counter++; }
24985: 4193:    long getSerialNumber() { return serialNumber; }
24986: 4194:};
24987: 4195:
24988: 4196:// Define and initialize the static storage:
24989: 4197:template<class T> long SerialNumbered<T>::counter = 1;
24990: 4198:
24991: 4199:class Basic {
24992: 4200:    string value;
24993: 4201:public:
24994: 4202:    void set(string val) { value = val; }
24995: 4203:    string get() { return value; }
24996: 4204:};
24997: 4205:
24998: 4206:int main() {
24999: 4207:    TimeStamped<SerialNumbered<Basic>> mixin1, mixin2;
25000: 4208:    mixin1.set("test string 1");
25001: 4209:    mixin2.set("test string 2");
25002: 4210:    cout << mixin1.get() << " " << mixin1.getStamp() <<
25003: 4211:      " " << mixin1.getSerialNumber() << endl;
25004: 4212:    cout << mixin2.get() << " " << mixin2.getStamp() <<
25005: 4213:      " " << mixin2.getSerialNumber() << endl;
25006: 4214:}
25007: 4215:/* Output:
25008: 4216:test string 1 1452987605 1
25009: 4217:test string 2 1452987605 2
25010: 4218:*/
25011: 4219:```
25012: 4220:
25013: 4221:在 `main()` 中， **mixin1** 和 **mixin2** 所产生的类型拥有所混入类型的所有方法。可以将混型看作是一种功能，它可以将现有类映射到新的子类上。注意，使用这种技术来创建一个混型是多么的轻而易举。基本上，只需要声明“这就是我想要的”，紧跟着它就发生了：
25014: 4222:
25015: 4223:```c++
25016: 4224:TimeStamped<SerialNumbered<Basic>> mixin1，mixin2；
25017: 4225:```
25018: 4226:
25019: 4227:遗憾的是，Java 泛型不允许这样。擦除会忘记基类类型，因此
25020: 4228:
25021: 4229:>  泛型类不能直接继承自一个泛型参数
25022: 4230:
25023: 4231:这突显了许多我在 Java 语言设计决策（以及与这些功能一起发布）中遇到的一大问题：处理一件事很有希望，但是当您实际尝试做一些有趣的事情时，您会发现自己做不到。
25024: 4232:
25025: 4233:### 与接口混合
25026: 4234:
25027: 4235:一种更常见的推荐解决方案是使用接口来产生混型效果，就像下面这样：
25028: 4236:
25029: 4237:```java
25030: 4238:// generics/Mixins.java
25031: 4239:
25032: 4240:import java.util.*;
25033: 4241:
25034: 4242:interface TimeStamped { long getStamp(); }
25035: 4243:
25036: 4244:class TimeStampedImp implements TimeStamped {
25037: 4245:    private final long timeStamp;
25038: 4246:    TimeStampedImp() {
25039: 4247:        timeStamp = new Date().getTime();
25040: 4248:    }
25041: 4249:    @Override
25042: 4250:    public long getStamp() { return timeStamp; }
25043: 4251:}
25044: 4252:
25045: 4253:interface SerialNumbered { long getSerialNumber(); }
25046: 4254:
25047: 4255:class SerialNumberedImp implements SerialNumbered {
25048: 4256:    private static long counter = 1;
25049: 4257:    private final long serialNumber = counter++;
25050: 4258:    @Override
25051: 4259:    public long getSerialNumber() { return serialNumber; }
25052: 4260:}
25053: 4261:
25054: 4262:interface Basic {
25055: 4263:    void set(String val);
25056: 4264:    String get();
25057: 4265:}
25058: 4266:
25059: 4267:class BasicImp implements Basic {
25060: 4268:    private String value;
25061: 4269:    @Override
25062: 4270:    public void set(String val) { value = val; }
25063: 4271:    @Override
25064: 4272:    public String get() { return value; }
25065: 4273:}
25066: 4274:
25067: 4275:class Mixin extends BasicImp
25068: 4276:implements TimeStamped, SerialNumbered {
25069: 4277:    private TimeStamped timeStamp = new TimeStampedImp();
25070: 4278:    private SerialNumbered serialNumber =
25071: 4279:        new SerialNumberedImp();
25072: 4280:    @Override
25073: 4281:    public long getStamp() {
25074: 4282:        return timeStamp.getStamp();
25075: 4283:    }
25076: 4284:    @Override
25077: 4285:    public long getSerialNumber() {
25078: 4286:        return serialNumber.getSerialNumber();
25079: 4287:    }
25080: 4288:}
25081: 4289:
25082: 4290:public class Mixins {
25083: 4291:    public static void main(String[] args) {
25084: 4292:        Mixin mixin1 = new Mixin(), mixin2 = new Mixin();
25085: 4293:        mixin1.set("test string 1");
25086: 4294:        mixin2.set("test string 2");
25087: 4295:        System.out.println(mixin1.get() + " " +
25088: 4296:            mixin1.getStamp() +  " " + mixin1.getSerialNumber());
25089: 4297:        System.out.println(mixin2.get() + " " +
25090: 4298:            mixin2.getStamp() +  " " + mixin2.getSerialNumber());
25091: 4299:    }
25092: 4300:}
25093: 4301:/* Output:
25094: 4302:test string 1 1494331663026 1
25095: 4303:test string 2 1494331663027 2
25096: 4304:*/
25097: 4305:```
25098: 4306:
25099: 4307:**Mixin** 类基本上是在使用*委托*，因此每个混入类型都要求在 **Mixin** 中有一个相应的域，而你必须在 **Mixin** 中编写所有必需的方法，将方法调用转发给恰当的对象。这个示例使用了非常简单的类，但是当使用更复杂的混型时，代码数量会急速增加。[^4]
25100: 4308:
25101: 4309:### 使用装饰器模式
25102: 4310:
25103: 4311:当你观察混型的使用方式时，就会发现混型概念好像与*装饰器*设计模式关系很近。装饰器经常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的。
25104: 4312:装饰器模式使用分层对象来动态透明地向单个对象中添加责任。装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。某些事物是可装饰的，可以通过将其他类包装在这个可装饰对象的四周，来将功能分层。这使得对装饰器的使用是透明的——无论对象是否被装饰，你都拥有一个可以向对象发送的公共消息集。装饰类也可以添加新方法，但是正如你所见，这将是受限的。
25105: 4313:装饰器是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。
25106: 4314:前面的示例可以被改写为使用装饰器：
25107: 4315:
25108: 4316:```java
25109: 4317:// generics/decorator/Decoration.java
25110: 4318:
25111: 4319:// {java generics.decorator.Decoration}
25112: 4320:package generics.decorator;
25113: 4321:import java.util.*;
25114: 4322:
25115: 4323:class Basic {
25116: 4324:    private String value;
25117: 4325:    public void set(String val) { value = val; }
25118: 4326:    public String get() { return value; }
25119: 4327:}
25120: 4328:
25121: 4329:class Decorator extends Basic {
25122: 4330:    protected Basic basic;
25123: 4331:    Decorator(Basic basic) { this.basic = basic; }
25124: 4332:    @Override
25125: 4333:    public void set(String val) { basic.set(val); }
25126: 4334:    @Override
25127: 4335:    public String get() { return basic.get(); }
25128: 4336:}
25129: 4337:
25130: 4338:class TimeStamped extends Decorator {
25131: 4339:    private final long timeStamp;
25132: 4340:    TimeStamped(Basic basic) {
25133: 4341:        super(basic);
25134: 4342:        timeStamp = new Date().getTime();
25135: 4343:    }
25136: 4344:    public long getStamp() { return timeStamp; }
25137: 4345:}
25138: 4346:
25139: 4347:class SerialNumbered extends Decorator {
25140: 4348:    private static long counter = 1;
25141: 4349:    private final long serialNumber = counter++;
25142: 4350:    SerialNumbered(Basic basic) { super(basic); }
25143: 4351:    public long getSerialNumber() { return serialNumber; }
25144: 4352:}
25145: 4353:
25146: 4354:public class Decoration {
25147: 4355:    public static void main(String[] args) {
25148: 4356:        TimeStamped t = new TimeStamped(new Basic());
25149: 4357:        TimeStamped t2 = new TimeStamped(
25150: 4358:            new SerialNumbered(new Basic()));
25151: 4359:        //- t2.getSerialNumber(); // Not available
25152: 4360:        SerialNumbered s = new SerialNumbered(new Basic());
25153: 4361:        SerialNumbered s2 = new SerialNumbered(
25154: 4362:            new TimeStamped(new Basic()));
25155: 4363:        //- s2.getStamp(); // Not available
25156: 4364:  }
25157: 4365:}
25158: 4366:```
25159: 4367:
25160: 4368:产生自泛型的类包含所有感兴趣的方法，但是由使用装饰器所产生的对象类型是最后被装饰的类型。也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。因此，装饰器只是对由混型提出的问题的一种局限的解决方案。
25161: 4369:
25162: 4370:### 与动态代理混合
25163: 4371:
25164: 4372:可以使用动态代理来创建一种比装饰器更贴近混型模型的机制（查看 [类型信息](book/19-Type-Information.md) 一章中关于 Java 的动态代理如何工作的解释）。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。
25165: 4373:由于动态代理的限制，每个被混入的类都必须是某个接口的实现：
25166: 4374:
25167: 4375:```java
25168: 4376:// generics/DynamicProxyMixin.java
25169: 4377:
25170: 4378:import java.lang.reflect.*;
25171: 4379:import java.util.*;
25172: 4380:import onjava.*;
25173: 4381:import static onjava.Tuple.*;
25174: 4382:
25175: 4383:class MixinProxy implements InvocationHandler {
25176: 4384:    Map<String, Object> delegatesByMethod;
25177: 4385:    @SuppressWarnings("unchecked")
25178: 4386:    MixinProxy(Tuple2<Object, Class<?>>... pairs) {
25179: 4387:        delegatesByMethod = new HashMap<>();
25180: 4388:        for(Tuple2<Object, Class<?>> pair : pairs) {
25181: 4389:            for(Method method : pair.a2.getMethods()) {
25182: 4390:                String methodName = method.getName();
25183: 4391:                // The first interface in the map
25184: 4392:                // implements the method.
25185: 4393:                if(!delegatesByMethod.containsKey(methodName))
25186: 4394:                    delegatesByMethod.put(methodName, pair.a1);
25187: 4395:            }
25188: 4396:        }
25189: 4397:    }
25190: 4398:    @Override
25191: 4399:    public Object invoke(Object proxy, Method method,
25192: 4400:      Object[] args) throws Throwable {
25193: 4401:        String methodName = method.getName();
25194: 4402:        Object delegate = delegatesByMethod.get(methodName);
25195: 4403:        return method.invoke(delegate, args);
25196: 4404:    }
25197: 4405:    
25198: 4406:    @SuppressWarnings("unchecked")
25199: 4407:    public static Object newInstance(Tuple2... pairs) {
25200: 4408:        Class[] interfaces = new Class[pairs.length];
25201: 4409:        for(int i = 0; i < pairs.length; i++) {
25202: 4410:            interfaces[i] = (Class)pairs[i].a2;
25203: 4411:        }
25204: 4412:        ClassLoader cl = pairs[0].a1.getClass().getClassLoader();
25205: 4413:        return Proxy.newProxyInstance(cl, interfaces, new MixinProxy(pairs));
25206: 4414:    }
25207: 4415:}
25208: 4416:
25209: 4417:public class DynamicProxyMixin {
25210: 4418:    public static void main(String[] args) {
25211: 4419:        Object mixin = MixinProxy.newInstance(
25212: 4420:          tuple(new BasicImp(), Basic.class),
25213: 4421:          tuple(new TimeStampedImp(), TimeStamped.class),
25214: 4422:          tuple(new SerialNumberedImp(), SerialNumbered.class));
25215: 4423:        Basic b = (Basic)mixin;
25216: 4424:        TimeStamped t = (TimeStamped)mixin;
25217: 4425:        SerialNumbered s = (SerialNumbered)mixin;
25218: 4426:        b.set("Hello");
25219: 4427:        System.out.println(b.get());
25220: 4428:        System.out.println(t.getStamp());
25221: 4429:        System.out.println(s.getSerialNumber());
25222: 4430:    }
25223: 4431:}
25224: 4432:/* Output:
25225: 4433:Hello
25226: 4434:1494331653339
25227: 4435:1
25228: 4436:*/
25229: 4437:```
25230: 4438:
25231: 4439:因为只有动态类型而不是静态类型才包含所有的混入类型，因此这仍旧不如 C++ 的方式好，因为可以在具有这些类型的对象上调用方法之前，你被强制要求必须先将这些对象向下转型到恰当的类型。但是，它明显地更接近于真正的混型。
25232: 4440:为了让 Java 支持混型，人们已经做了大量的工作朝着这个目标努力，包括创建了至少一种附加语言（ Jam 语言），它是专门用来支持混型的。
25233: 4441:
25234: 4442:<!-- Latent Typing -->
25235: 4443:
25236: 4444:## 潜在类型机制
25237: 4445:
25238: 4446:在本章的开头介绍过这样的思想，即要编写能够尽可能广泛地应用的代码。为了实现这一点，我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处。然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码。
25239: 4447:
25240: 4448:Java 泛型看起来是向这一方向迈进了一步。当你在编写或使用只是持有对象的泛型时，这些代码将可以工作于任何类型（除了基本类型，尽管正如你所见到的，自动装箱机制可以克服这一点）。或者，换个角度讲，“持有器”泛型能够声明：“我不关心你是什么类型”。如果代码不关心它将要作用的类型，那么这种代码就可以真正地应用于任何地方，并因此而相当泛化。
25241: 4449:
25242: 4450:还是正如你所见到的，当要在泛型类型上执行操作（即调用 **Object** 方法之外的方法）时，就会产生问题。擦除强制要求指定可能会用到的泛型类型的边界，以安全地调用代码中的泛型对象上的具体方法。这是对“泛化”概念的一种明显的限制，因为必须限制你的泛型类型，使它们继承自特定的类，或者实现特定的接口。在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类或接口没有任何区别。
25243: 4451:
25244: 4452:某些编程语言提供的一种解决方案称为*潜在类型机制*或*结构化类型机制*，而更古怪的术语称为*鸭子类型机制*，即“如果它走起来像鸭子，并且叫起来也像鸭子，那么你就可以将它当作鸭子对待。”鸭子类型机制变成了一种相当流行的术语，可能是因为它不像其他的术语那样承载着历史的包袱。
25245: 4453:
25246: 4454:泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得你可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以 `speak()` 和 `sit()` 即可。”由于不要求具体类型，因此代码就可以更加泛化。
25247: 4455:
25248: 4456:潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方。
25249: 4457:
25250: 4458:支持潜在类型机制的语言包括 Python（可以从 www.Python.org 免费下载）、C++、Ruby、SmallTalk 和 Go。Python 是动态类型语言（几乎所有的类型检查都发生在运行时），而 C++ 和 Go 是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查。
25251: 4459:
25252: 4460:### pyhton 中的潜在类型
25253: 4461:
25254: 4462:如果我们将上面的描述用 Python 来表示，如下所示：
25255: 4463:
25256: 4464:```python
25257: 4465:# generics/DogsAndRobots.py
25258: 4466:
25259: 4467:class Dog:
25260: 4468:    def speak(self):
25261: 4469:        print("Arf!")
25262: 4470:    def sit(self):
25263: 4471:        print("Sitting")
25264: 4472:    def reproduce(self):
25265: 4473:        pass
25266: 4474:
25267: 4475:class Robot:
25268: 4476:    def speak(self):
25269: 4477:        print("Click!")
25270: 4478:    def sit(self):
25271: 4479:        print("Clank!")
25272: 4480:    def oilChange(self):
25273: 4481:        pass
25274: 4482:
25275: 4483:def perform(anything):
25276: 4484:    anything.speak()
25277: 4485:    anything.sit()
25278: 4486:
25279: 4487:a = Dog()
25280: 4488:b = Robot()
25281: 4489:perform(a)
25282: 4490:perform(b)
25283: 4491:
25284: 4492:output = """
25285: 4493:Arf!
25286: 4494:Sitting
25287: 4495:Click!
25288: 4496:Clank!
25289: 4497:"""
25290: 4498:```
25291: 4499:
25292: 4500:Python 使用缩进来确定作用域（因此不需要任何花括号），而冒号将表示新的作用域的开始。“**#**” 表示注释到行尾，就像Java中的 “ **//** ”。类的方法需要显式地指定 **this** 引用的等价物作为第一个参数，按惯例成为 **self** 。构造器调用不要求任何类型的“ **new** ”关键字，并且 Python 允许普通（非成员）函数，就像 `perform()` 所表明的那样。注意，在 `perform(anything)` 中，没有任何针对 **anything** 的类型，**anything** 只是一个标识符，它必须能够执行 `perform()` 期望它执行的操作，因此这里隐含着一个接口。但是你从来都不必显式地写出这个接口——它是潜在的。`perform()` 不关心其参数的类型，因此我可以向它传递任何对象，只要该对象支持  `speak()` 和 `sit()` 方法。如果传递给 `perform()` 的对象不支持这些操作，那么将会得到运行时异常。
25293: 4501:
25294: 4502:输出规定使用三重引号创建带有内嵌换行符的字符串。
25295: 4503:
25296: 4504:### C++ 中的潜在类型
25297: 4505:
25298: 4506:我们可以用 C++ 产生相同的效果：
25299: 4507:
25300: 4508:```c++
25301: 4509:// generics/DogsAndRobots.cpp
25302: 4510:
25303: 4511:#include <iostream>
25304: 4512:using namespace std;
25305: 4513:
25306: 4514:class Dog {
25307: 4515:public:
25308: 4516:    void speak() { cout << "Arf!" << endl; }
25309: 4517:    void sit() { cout << "Sitting" << endl; }
25310: 4518:    void reproduce() {}
25311: 4519:};
25312: 4520:
25313: 4521:class Robot {
25314: 4522:public:
25315: 4523:    void speak() { cout << "Click!" << endl; }
25316: 4524:    void sit() { cout << "Clank!" << endl; }
25317: 4525:    void oilChange() {}
25318: 4526:};
25319: 4527:
25320: 4528:template<class T> void perform(T anything) {
25321: 4529:    anything.speak();
25322: 4530:    anything.sit();
25323: 4531:}
25324: 4532:
25325: 4533:int main() {
25326: 4534:    Dog d;
25327: 4535:    Robot r;
25328: 4536:    perform(d);
25329: 4537:    perform(r);
25330: 4538:}
25331: 4539:/* Output:
25332: 4540:Arf!
25333: 4541:Sitting
25334: 4542:Click!
25335: 4543:Clank!
25336: 4544:*/
25337: 4545:```
25338: 4546:
25339: 4547:在 Python 和 C++ 中，**Dog** 和 **Robot** 没有任何共同的东西，只是碰巧有两个方法具有相同的签名。从类型的观点看，它们是完全不同的类型。但是，`perform()` 不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。
25340: 4548:C++ 确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给你一个错误消息（这些错误消息从历史上看是相当可怕和冗长的，是 C++ 的模版名声欠佳的主要原因）。尽管它们是在不同时期实现这一点的，C++ 在编译期，而 Python 在运行时，但是这两种语言都可以确保类型不会被误用，因此被认为是强类型的。[^5]潜在类型机制没有损害强类型机制。
25341: 4549:
25342: 4550:### Go 中的潜在类型
25343: 4551:
25344: 4552:这里用 Go 语言编写相同的程序：
25345: 4553:
25346: 4554:```go
25347: 4555:// generics/dogsandrobots.go
25348: 4556:
25349: 4557:package main
25350: 4558:import "fmt"
25351: 4559:
25352: 4560:type Dog struct {}
25353: 4561:func (this Dog) speak() { fmt.Printf("Arf!\n")}
25354: 4562:func (this Dog) sit() { fmt.Printf("Sitting\n")}
25355: 4563:func (this Dog) reproduce() {}
25356: 4564:
25357: 4565:type Robot struct {}
25358: 4566:func (this Robot) speak() { fmt.Printf("Click!\n") }
25359: 4567:func (this Robot) sit() { fmt.Printf("Clank!\n") }
25360: 4568:func (this Robot) oilChange() {}
25361: 4569:
25362: 4570:func perform(speaker interface { speak(); sit() }) {
25363: 4571:  speaker.speak();
25364: 4572:  speaker.sit();
25365: 4573:}
25366: 4574:
25367: 4575:func main() {
25368: 4576:  perform(Dog{})
25369: 4577:  perform(Robot{})
25370: 4578:}
25371: 4579:/* Output:
25372: 4580:Arf!
25373: 4581:Sitting
25374: 4582:Click!
25375: 4583:Clank!
25376: 4584:*/
25377: 4585:```
25378: 4586:
25379: 4587:Go 没有 **class** 关键字，但是可以使用上述形式创建等效的基本类：它通常不定义为类，而是定义为 **struct** ，在其中定义数据字段（此处不存在）。 对于每种方法，都以 **func** 关键字开头，然后（为了将该方法附加到您的类上）放在括号中，该括号包含对象引用，该对象引用可以是任何标识符，但是我在这里使用 **this** 来提醒您，就像在 C ++ 或 Java 中的 **this** 一样。 然后，在Go中像这样定义其余的函数。
25380: 4588:
25381: 4589:Go也没有继承关系，因此这种“面向对象的目标”形式是相对原始的，并且可能是我无法花更多的时间来学习该语言的主要原因。 但是，Go 的组成很简单。
25382: 4590:
25383: 4591:`perform()` 函数使用潜在类型：参数的确切类型并不重要，只要它包含了 `speak()` 和  `sit()` 方法即可。 该接口在此处匿名定义，内联，如 `perform()` 的参数列表所示。
25384: 4592:
25385: 4593:`main()` 证明 `perform()` 确实对其参数的确切类型不在乎，只要可以在该参数上调用 `talk()` 和 `sit()` 即可。 但是，就像 C ++ 模板函数一样，在编译时检查类型。
25386: 4594:
25387: 4595:语法 **Dog {}** 和 **Robot {}** 创建匿名的 **Dog** 和 **Robot** 结构。
25388: 4596:
25389: 4597:### java中的直接潜在类型
25390: 4598:
25391: 4599:因为泛型是在这场竞赛的后期才添加到 Java 中，因此没有任何机会可以去实现任何类型的潜在类型机制，因此 Java 没有对这种特性的支持。所以，初看起来，Java 的泛型机制比支持潜在类型机制的语言更“缺乏泛化性”。（使用擦除来实现 Java 泛型的实现有时称为第二类泛型类型）例如，在 Java 8  之前如果我们试图用 Java 实现上面 dogs-and-robots 的示例，那么就会被强制要求使用一个类或接口，并在边界表达式中指定它：
25392: 4600:
25393: 4601:```java
25394: 4602:// generics/Performs.java
25395: 4603:
25396: 4604:public interface Performs {
25397: 4605:    void speak();
25398: 4606:    void sit();
25399: 4607:}
25400: 4608:```
25401: 4609:
25402: 4610:```java
25403: 4611:// generics/DogsAndRobots.java
25404: 4612:// No (direct) latent typing in Java
25405: 4613:import typeinfo.pets.*;
25406: 4614:
25407: 4615:class PerformingDog extends Dog implements Performs {
25408: 4616:    @Override
25409: 4617:    public void speak() { System.out.println("Woof!"); }
25410: 4618:    @Override
25411: 4619:    public void sit() { System.out.println("Sitting"); }
25412: 4620:    public void reproduce() {}
25413: 4621:}
25414: 4622:
25415: 4623:class Robot implements Performs {
25416: 4624:    public void speak() { System.out.println("Click!"); }
25417: 4625:    public void sit() { System.out.println("Clank!"); }
25418: 4626:    public void oilChange() {}
25419: 4627:}
25420: 4628:
25421: 4629:class Communicate {
25422: 4630:    public static <T extends Performs>
25423: 4631:      void perform(T performer) {
25424: 4632:        performer.speak();
25425: 4633:        performer.sit();
25426: 4634:    }
25427: 4635:}
25428: 4636:
25429: 4637:public class DogsAndRobots {
25430: 4638:    public static void main(String[] args) {
25431: 4639:        Communicate.perform(new PerformingDog());
25432: 4640:        Communicate.perform(new Robot());
25433: 4641:    }
25434: 4642:}
25435: 4643:/* Output:
25436: 4644:Woof!
25437: 4645:Sitting
25438: 4646:Click!
25439: 4647:Clank!
25440: 4648:*/
25441: 4649:```
25442: 4650:
25443: 4651:但是要注意，`perform()` 不需要使用泛型来工作，它可以被简单地指定为接受一个 **Performs** 对象：
25444: 4652:
25445: 4653:```java
25446: 4654:// generics/SimpleDogsAndRobots.java
25447: 4655:// Removing the generic; code still works
25448: 4656:
25449: 4657:class CommunicateSimply {
25450: 4658:    static void perform(Performs performer) {
25451: 4659:        performer.speak();
25452: 4660:        performer.sit();
25453: 4661:    }
25454: 4662:}
25455: 4663:
25456: 4664:public class SimpleDogsAndRobots {
25457: 4665:    public static void main(String[] args) {
25458: 4666:        CommunicateSimply.perform(new PerformingDog());
25459: 4667:        CommunicateSimply.perform(new Robot());
25460: 4668:    }
25461: 4669:}
25462: 4670:/* Output:
25463: 4671:Woof!
25464: 4672:Sitting
25465: 4673:Click!
25466: 4674:Clank!
25467: 4675:*/
25468: 4676:```
25469: 4677:
25470: 4678:在本例中，泛型不是必需的，因为这些类已经被强制要求实现 **Performs** 接口。
25471: 4679:
25472: 4680:<!-- Compensating for the Lack of (Direct) Latent -->
25473: 4681:
25474: 4682:## 对缺乏潜在类型机制的补偿
25475: 4683:
25476: 4684:尽管 Java 不直接支持潜在类型机制，但是这并不意味着泛型代码不能在不同的类型层次结构之间应用。也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。
25477: 4685:
25478: 4686:### 反射
25479: 4687:
25480: 4688:可以使用的一种方式是反射，下面的 `perform()` 方法就是用了潜在类型机制：
25481: 4689:
25482: 4690:```java
25483: 4691:// generics/LatentReflection.java
25484: 4692:// Using reflection for latent typing
25485: 4693:import java.lang.reflect.*;
25486: 4694:
25487: 4695:// Does not implement Performs:
25488: 4696:class Mime {
25489: 4697:    public void walkAgainstTheWind() {}
25490: 4698:    public void sit() {
25491: 4699:        System.out.println("Pretending to sit");
25492: 4700:    }
25493: 4701:    public void pushInvisibleWalls() {}
25494: 4702:    @Override
25495: 4703:    public String toString() { return "Mime"; }
25496: 4704:}
25497: 4705:
25498: 4706:// Does not implement Performs:
25499: 4707:class SmartDog {
25500: 4708:    public void speak() { System.out.println("Woof!"); }
25501: 4709:    public void sit() { System.out.println("Sitting"); }
25502: 4710:    public void reproduce() {}
25503: 4711:}
25504: 4712:
25505: 4713:class CommunicateReflectively {
25506: 4714:    public static void perform(Object speaker) {
25507: 4715:        Class<?> spkr = speaker.getClass();
25508: 4716:        try {
25509: 4717:            try {
25510: 4718:                Method speak = spkr.getMethod("speak");
25511: 4719:                speak.invoke(speaker);
25512: 4720:            } catch(NoSuchMethodException e) {
25513: 4721:                System.out.println(speaker + " cannot speak");
25514: 4722:            }
25515: 4723:            try {
25516: 4724:                Method sit = spkr.getMethod("sit");
25517: 4725:                sit.invoke(speaker);
25518: 4726:            } catch(NoSuchMethodException e) {
25519: 4727:                System.out.println(speaker + " cannot sit");
25520: 4728:            }
25521: 4729:        } catch(SecurityException |
25522: 4730:            IllegalAccessException |
25523: 4731:            IllegalArgumentException |
25524: 4732:            InvocationTargetException e) {
25525: 4733:            throw new RuntimeException(speaker.toString(), e);
25526: 4734:        }
25527: 4735:    }
25528: 4736:}
25529: 4737:
25530: 4738:public class LatentReflection {
25531: 4739:    public static void main(String[] args) {
25532: 4740:        CommunicateReflectively.perform(new SmartDog());
25533: 4741:        CommunicateReflectively.perform(new Robot());
25534: 4742:        CommunicateReflectively.perform(new Mime());
25535: 4743:    }
25536: 4744:}
25537: 4745:/* Output:
25538: 4746:Woof!
25539: 4747:Sitting
25540: 4748:Click!
25541: 4749:Clank!
25542: 4750:Mime cannot speak
25543: 4751:Pretending to sit
25544: 4752:*/
25545: 4753:```
25546: 4754:
25547: 4755:上例中，这些类完全是彼此分离的，没有任何公共基类（除了 **Object** ）或接口。通过反射, `CommunicateReflectively.perform()` 能够动态地确定所需要的方法是否可用并调用它们。它甚至能够处理 **Mime** 只具有一个必需的方法这一事实，并能够部分实现其目标。
25548: 4756:
25549: 4757:### 将一个方法应用于序列
25550: 4758:
25551: 4759:反射提供了一些有用的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。但是有可能实现编译期类型检查和潜在类型机制吗？
25552: 4760:
25553: 4761:让我们看一个说明这个问题的示例。假设想要创建一个 `apply()` 方法，它能够将任何方法应用于某个序列中的所有对象。这种情况下使用接口不适合，因为你想要将任何方法应用于一个对象集合，而接口不可能描述任何方法。如何用 Java 来实现这个需求呢？
25554: 4762:
25555: 4763:最初，我们可以用反射来解决这个问题，由于有了 Java 的可变参数，这种方式被证明是相当优雅的：
25556: 4764:
25557: 4765:```java
25558: 4766:// generics/Apply.java
25559: 4767:
25560: 4768:import java.lang.reflect.*;
25561: 4769:import java.util.*;
25562: 4770:
25563: 4771:public class Apply {
25564: 4772:    public static <T, S extends Iterable<T>>
25565: 4773:      void apply(S seq, Method f, Object... args) {
25566: 4774:        try {
25567: 4775:            for(T t: seq)
25568: 4776:                f.invoke(t, args);
25569: 4777:        } catch(IllegalAccessException |
25570: 4778:            IllegalArgumentException |
25571: 4779:            InvocationTargetException e) {
25572: 4780:            // Failures are programmer errors
25573: 4781:            throw new RuntimeException(e);
25574: 4782:        }
25575: 4783:    }
25576: 4784:}
25577: 4785:```
25578: 4786:
25579: 4787:在 **Apply.java** 中，异常被转换为 **RuntimeException** ，因为没有多少办法可以从这种异常中恢复——在这种情况下，它们实际上代表着程序员的错误。
25580: 4788:
25581: 4789:为什么我们不只使用 Java 8 方法参考（稍后显示）而不是反射方法 **f** ？ 注意，`invoke()` 和 `apply()` 的优点是它们可以接受任意数量的参数。 在某些情况下，灵活性可能至关重要。
25582: 4790:
25583: 4791:为了测试 **Apply** ，我们首先创建一个 **Shape** 类：
25584: 4792:
25585: 4793:```java
25586: 4794:// generics/Shape.java
25587: 4795:
25588: 4796:public class Shape {
25589: 4797:    private static long counter = 0;
25590: 4798:    private final long id = counter++;
25591: 4799:    @Override
25592: 4800:    public String toString() {
25593: 4801:        return getClass().getSimpleName() + " " + id;
25594: 4802:    }
25595: 4803:    public void rotate() {
25596: 4804:        System.out.println(this + " rotate");
25597: 4805:    }
25598: 4806:    public void resize(int newSize) {
25599: 4807:        System.out.println(this + " resize " + newSize);
25600: 4808:    }
25601: 4809:}
25602: 4810:```
25603: 4811:
25604: 4812:被一个子类 **Square** 继承：
25605: 4813:
25606: 4814:```java
25607: 4815:// generics/Square.java
25608: 4816:
25609: 4817:public class Square extends Shape {}
25610: 4818:```
25611: 4819:
25612: 4820:通过这些，我们可以测试 **Apply**：
25613: 4821:
25614: 4822:```java
25615: 4823:// generics/ApplyTest.java
25616: 4824:
25617: 4825:import java.util.*;
25618: 4826:import java.util.function.*;
25619: 4827:import onjava.*;
25620: 4828:
25621: 4829:public class ApplyTest {
25622: 4830:    public static
25623: 4831:    void main(String[] args) throws Exception {
25624: 4832:        List<Shape> shapes =
25625: 4833:          Suppliers.create(ArrayList::new, Shape::new, 3);
25626: 4834:        Apply.apply(shapes, Shape.class.getMethod("rotate"));
25627: 4835:        Apply.apply(shapes, Shape.class.getMethod("resize", int.class), 7);
25628: 4836:
25629: 4837:        List<Square> squares =
25630: 4838:          Suppliers.create(ArrayList::new, Square::new, 3);
25631: 4839:        Apply.apply(squares, Shape.class.getMethod("rotate"));
25632: 4840:        Apply.apply(squares, Shape.class.getMethod("resize", int.class), 7);
25633: 4841:
25634: 4842:        Apply.apply(new FilledList<>(Shape::new, 3),
25635: 4843:          Shape.class.getMethod("rotate"));
25636: 4844:        Apply.apply(new FilledList<>(Square::new, 3),
25637: 4845:          Shape.class.getMethod("rotate"));
25638: 4846:
25639: 4847:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
25640: 4848:          new SimpleQueue<>(), SimpleQueue::add,
25641: 4849:          Shape::new, 3);
25642: 4850:        Suppliers.fill(shapeQ, SimpleQueue::add,
25643: 4851:          Square::new, 3);
25644: 4852:        Apply.apply(shapeQ, Shape.class.getMethod("rotate"));
25645: 4853:    }
25646: 4854:}
25647: 4855:/* Output:
25648: 4856:Shape 0 rotate
25649: 4857:Shape 1 rotate
25650: 4858:Shape 2 rotate
25651: 4859:Shape 0 resize 7
25652: 4860:Shape 1 resize 7
25653: 4861:Shape 2 resize 7
25654: 4862:Square 3 rotate
25655: 4863:Square 4 rotate
25656: 4864:Square 5 rotate
25657: 4865:Square 3 resize 7
25658: 4866:Square 4 resize 7
25659: 4867:Square 5 resize 7
25660: 4868:Shape 6 rotate
25661: 4869:Shape 7 rotate
25662: 4870:Shape 8 rotate
25663: 4871:Square 9 rotate
25664: 4872:Square 10 rotate
25665: 4873:Square 11 rotate
25666: 4874:Shape 12 rotate
25667: 4875:Shape 13 rotate
25668: 4876:Shape 14 rotate
25669: 4877:Square 15 rotate
25670: 4878:Square 16 rotate
25671: 4879:Square 17 rotate
25672: 4880:*/
25673: 4881:```
25674: 4882:
25675: 4883:在 **Apply** 中，我们运气很好，因为碰巧在 Java 中内建了一个由 Java 集合类库使用的 **Iterable** 接口。正由于此， `apply()` 方法可以接受任何实现了 **Iterable** 接口的事物，包括诸如 **List** 这样的所有 **Collection** 类。但是它还可以接受其他任何事物，只要能够使这些事物是 **Iterable** 的——例如，在 `main()` 中使用下面定义的 **SimpleQueue** 类：
25676: 4884:
25677: 4885:```java
25678: 4886:// generics/SimpleQueue.java
25679: 4887:
25680: 4888:// A different kind of Iterable collection
25681: 4889:import java.util.*;
25682: 4890:
25683: 4891:public class SimpleQueue<T> implements Iterable<T> {
25684: 4892:    private LinkedList<T> storage = new LinkedList<>();
25685: 4893:    public void add(T t) { storage.offer(t); }
25686: 4894:    public T get() { return storage.poll(); }
25687: 4895:    @Override
25688: 4896:    public Iterator<T> iterator() {
25689: 4897:        return storage.iterator();
25690: 4898:    }
25691: 4899:}
25692: 4900:```
25693: 4901:
25694: 4902:正如反射解决方案看起来那样优雅，我们必须观察到反射（尽管在 Java 的最新版本中得到了显着改进）通常比非反射实现要慢，因为在运行时发生了很多事情。 但它不应阻止您尝试这种解决方案，这依然是值得考虑的一点。
25695: 4903:
25696: 4904:几乎可以肯定，你会首先使用 Java 8 的函数式方法，并且只有在解决了特殊需求时才诉诸反射。 这里对 **ApplyTest.java** 进行了重写，以利用 Java 8 的流和函数工具：
25697: 4905:
25698: 4906:```java
25699: 4907:// generics/ApplyFunctional.java
25700: 4908:
25701: 4909:import java.util.*;
25702: 4910:import java.util.stream.*;
25703: 4911:import java.util.function.*;
25704: 4912:import onjava.*;
25705: 4913:
25706: 4914:public class ApplyFunctional {
25707: 4915:    public static void main(String[] args) {
25708: 4916:        Stream.of(
25709: 4917:          Stream.generate(Shape::new).limit(2),
25710: 4918:          Stream.generate(Square::new).limit(2))
25711: 4919:        .flatMap(c -> c) // flatten into one stream
25712: 4920:        .peek(Shape::rotate)
25713: 4921:        .forEach(s -> s.resize(7));
25714: 4922:
25715: 4923:        new FilledList<>(Shape::new, 2)
25716: 4924:          .forEach(Shape::rotate);
25717: 4925:        new FilledList<>(Square::new, 2)
25718: 4926:          .forEach(Shape::rotate);
25719: 4927:
25720: 4928:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
25721: 4929:          new SimpleQueue<>(), SimpleQueue::add,
25722: 4930:          Shape::new, 2);
25723: 4931:        Suppliers.fill(shapeQ, SimpleQueue::add,
25724: 4932:          Square::new, 2);
25725: 4933:        shapeQ.forEach(Shape::rotate);
25726: 4934:    }
25727: 4935:}
25728: 4936:/* Output:
25729: 4937:Shape 0 rotate
25730: 4938:Shape 0 resize 7
25731: 4939:Shape 1 rotate
25732: 4940:Shape 1 resize 7
25733: 4941:Square 2 rotate
25734: 4942:Square 2 resize 7
25735: 4943:Square 3 rotate
25736: 4944:Square 3 resize 7
25737: 4945:Shape 4 rotate
25738: 4946:Shape 5 rotate
25739: 4947:Square 6 rotate
25740: 4948:Square 7 rotate
25741: 4949:Shape 8 rotate
25742: 4950:Shape 9 rotate
25743: 4951:Square 10 rotate
25744: 4952:Square 11 rotate
25745: 4953:*/
25746: 4954:```
25747: 4955:
25748: 4956:由于使用 Java 8，因此不需要 `Apply.apply()` 。
25749: 4957:
25750: 4958:我们首先生成两个 **Stream** ： 一个是 **Shape** ，一个是 **Square** ，并将它们展平为单个流。 尽管 Java 缺少功能语言中经常出现的 `flatten()` ，但是我们可以使用 `flatMap(c-> c)` 产生相同的结果，后者使用身份映射将操作简化为“  **flatten** ”。
25751: 4959:
25752: 4960:我们使用 `peek()` 当做对 `rotate()` 的调用，因为 `peek()` 执行一个操作（此处是出于副作用），并在未更改的情况下传递对象。
25753: 4961:
25754: 4962:注意，使用 **FilledList** 和 **shapeQ** 调用 `forEach()` 比 `Apply.apply()` 代码整洁得多。 在代码简单性和可读性方面，结果比以前的方法好得多。 并且，现在也不可能从  `main()` 引发异常。
25755: 4963:
25756: 4964:<!-- Assisted Latent Typing in Java 8 -->
25757: 4965:
25758: 4966:## Java8 中的辅助潜在类型
25759: 4967:
25760: 4968:先前声明关于 Java 缺乏对潜在类型的支持在 Java 8 之前是完全正确的。但是，Java 8 中的非绑定方法引用使我们能够产生一种潜在类型的形式，以满足创建一段可工作在不相干类型上的代码。因为 Java 最初并不是如此设计，所以结果可想而知，比其他语言中要尴尬一些。但是，至少现在成为了可能，只是缺乏令人惊艳之处。
25761: 4969:
25762: 4970:我在其他地方从没遇过这种技术，因此我将其称为辅助潜在类型。
25763: 4971:
25764: 4972:我们将重写 **DogsAndRobots.java** 来演示该技术。 为使外观看起来与原始示例尽可能相似，我仅向每个原始类名添加了 **A**：
25765: 4973:
25766: 4974:```java
25767: 4975:// generics/DogsAndRobotMethodReferences.java
25768: 4976:
25769: 4977:// "Assisted Latent Typing"
25770: 4978:import typeinfo.pets.*;
25771: 4979:import java.util.function.*;
25772: 4980:
25773: 4981:class PerformingDogA extends Dog {
25774: 4982:    public void speak() { System.out.println("Woof!"); }
25775: 4983:    public void sit() { System.out.println("Sitting"); }
25776: 4984:    public void reproduce() {}
25777: 4985:}
25778: 4986:
25779: 4987:class RobotA {
25780: 4988:    public void speak() { System.out.println("Click!"); }
25781: 4989:    public void sit() { System.out.println("Clank!"); }
25782: 4990:    public void oilChange() {}
25783: 4991:}
25784: 4992:
25785: 4993:class CommunicateA {
25786: 4994:    public static <P> void perform(P performer,
25787: 4995:      Consumer<P> action1, Consumer<P> action2) {
25788: 4996:        action1.accept(performer);
25789: 4997:        action2.accept(performer);
25790: 4998:    }
25791: 4999:}
25792: 5000:
25793: 5001:public class DogsAndRobotMethodReferences {
25794: 5002:    public static void main(String[] args) {
25795: 5003:        CommunicateA.perform(new PerformingDogA(),
25796: 5004:          PerformingDogA::speak, PerformingDogA::sit);
25797: 5005:        CommunicateA.perform(new RobotA(),
25798: 5006:          RobotA::speak, RobotA::sit);
25799: 5007:        CommunicateA.perform(new Mime(),
25800: 5008:          Mime::walkAgainstTheWind,
25801: 5009:          Mime::pushInvisibleWalls);
25802: 5010:    }
25803: 5011:}
25804: 5012:/* Output:
25805: 5013:Woof!
25806: 5014:Sitting
25807: 5015:Click!
25808: 5016:Clank!
25809: 5017:*/
25810: 5018:```
25811: 5019:
25812: 5020:**PerformingDogA** 和 **RobotA** 与 **DogsAndRobots.java** 中的相同，不同之处在于它们不继承通用接口 **Performs** ，因此它们没有通用性。
25813: 5021:
25814: 5022:`CommunicateA.perform()` 在没有约束的 **P** 上生成。 只要可以使用 `Consumer <P>`，它在这里就可以是任何东西，这些 `Consumer<P>` 代表不带参数的 **P** 方法的未绑定方法引用。当您调用 **Consumer**  的 `accept()` 方法时，它将方法引用绑定到执行者对象并调用该方法。 由于 [函数式编程](book/13-Functional-Programming.md) 一章中描述的“魔术”，我们可以将任何符合签名的未绑定方法引用传递给 `CommunicateA.perform()` 。
25815: 5023:
25816: 5024:之所以称其为“辅助”，是因为您必须显式地为 `perform()` 提供要使用的方法引用。 它不能只按名称调用方法。
25817: 5025:
25818: 5026:尽管传递未绑定的方法引用似乎要花很多力气，但潜在类型的最终目标还是可以实现的。 我们创建了一个代码片段 `CommunicateA.perform()` ，该代码可用于任何具有符合签名的方法引用的类型。 请注意，这与我们看到的其他语言中的潜在类型有所不同，因为这些语言不仅需要签名以符合规范，还需要方法名称。 因此，该技术可以说产生了更多的通用代码。
25819: 5027:
25820: 5028:为了证明这一点，我还从 **LatentReflection.java** 中引入了 **Mime**。
25821: 5029:
25822: 5030:### 使用**Suppliers**类的通用方法
25823: 5031:
25824: 5032:通过辅助潜在类型，我们可以定义本章其他部分中使用的 **Suppliers** 类。 此类包含使用生成器填充 **Collection** 的工具方法。 泛化这些操作很有意义：
25825: 5033:
25826: 5034:```java
25827: 5035:// onjava/Suppliers.java
25828: 5036:
25829: 5037:// A utility to use with Suppliers
25830: 5038:package onjava;
25831: 5039:import java.util.*;
25832: 5040:import java.util.function.*;
25833: 5041:import java.util.stream.*;
25834: 5042:
25835: 5043:public class Suppliers {
25836: 5044:    // Create a collection and fill it:
25837: 5045:    public static <T, C extends Collection<T>> C
25838: 5046:      create(Supplier<C> factory, Supplier<T> gen, int n) {
25839: 5047:        return Stream.generate(gen)
25840: 5048:            .limit(n)
25841: 5049:            .collect(factory, C::add, C::addAll);
25842: 5050:    }
25843: 5051:    
25844: 5052:    // Fill an existing collection:
25845: 5053:    public static <T, C extends Collection<T>>
25846: 5054:      C fill(C coll, Supplier<T> gen, int n) {
25847: 5055:        Stream.generate(gen)
25848: 5056:            .limit(n)
25849: 5057:            .forEach(coll::add);
25850: 5058:        return coll;
25851: 5059:    }
25852: 5060:    
25853: 5061:    // Use an unbound method reference to
25854: 5062:    // produce a more general method:
25855: 5063:    public static <H, A> H fill(H holder,
25856: 5064:      BiConsumer<H, A> adder, Supplier<A> gen, int n) {
25857: 5065:        Stream.generate(gen)
25858: 5066:            .limit(n)
25859: 5067:            .forEach(a -> adder.accept(holder, a));
25860: 5068:        return holder;
25861: 5069:    }
25862: 5070:}
25863: 5071:```
25864: 5072:
25865: 5073:`create()` 为你创建一个新的 **Collection** 子类型，而 `fill()` 的第一个版本将元素放入 **Collection** 的现有子类型中。 请注意，还会返回传入的容器的确切类型，因此不会丢失类型信息。[^6]
25866: 5074:
25867: 5075:前两种方法一般都受约束，只能与 **Collection** 子类型一起使用。`fill()` 的第二个版本适用于任何类型的 **holder** 。 它需要一个附加参数：未绑定方法引用 `adder. fill()` ，使用辅助潜在类型来使其与任何具有添加元素方法的 **holder** 类型一起使用。因为此未绑定方法 **adder** 必须带有一个参数（要添加到 **holder** 的元素），所以 **adder** 必须是 `BiConsumer <H，A>` ，其中 **H** 是要绑定到的 **holder** 对象的类型，而 **A** 是要被添加的绑定元素类型。 对 `accept()` 的调用将使用参数 a 调用对象 **holder** 上的未绑定方法 **holder**。
25868: 5076:
25869: 5077:在一个稍作模拟的测试中对 **Suppliers** 工具程序进行了测试，该仿真还使用了本章前面定义的 **RandomList** ：
25870: 5078:
25871: 5079:```java
25872: 5080:// generics/BankTeller.java
25873: 5081:
25874: 5082:// A very simple bank teller simulation
25875: 5083:import java.util.*;
25876: 5084:import onjava.*;
25877: 5085:
25878: 5086:class Customer {
25879: 5087:    private static long counter = 1;
25880: 5088:    private final long id = counter++;
25881: 5089:    @Override
25882: 5090:    public String toString() {
25883: 5091:        return "Customer " + id;
25884: 5092:    }
25885: 5093:}
25886: 5094:
25887: 5095:class Teller {
25888: 5096:    private static long counter = 1;
25889: 5097:    private final long id = counter++;
25890: 5098:    @Override
25891: 5099:    public String toString() {
25892: 5100:        return "Teller " + id;
25893: 5101:    }
25894: 5102:}
25895: 5103:
25896: 5104:class Bank {
25897: 5105:    private List<BankTeller> tellers =
25898: 5106:        new ArrayList<>();
25899: 5107:    public void put(BankTeller bt) {
25900: 5108:        tellers.add(bt);
25901: 5109:    }
25902: 5110:}
25903: 5111:
25904: 5112:public class BankTeller {
25905: 5113:    public static void serve(Teller t, Customer c) {
25906: 5114:        System.out.println(t + " serves " + c);
25907: 5115:    }
25908: 5116:    public static void main(String[] args) {
25909: 5117:        // Demonstrate create():
25910: 5118:        RandomList<Teller> tellers =
25911: 5119:            Suppliers.create(
25912: 5120:            RandomList::new, Teller::new, 4);
25913: 5121:        // Demonstrate fill():
25914: 5122:        List<Customer> customers = Suppliers.fill(
25915: 5123:            new ArrayList<>(), Customer::new, 12);
25916: 5124:        customers.forEach(c ->
25917: 5125:            serve(tellers.select(), c));
25918: 5126:        // Demonstrate assisted latent typing:
25919: 5127:        Bank bank = Suppliers.fill(
25920: 5128:            new Bank(), Bank::put, BankTeller::new, 3);
25921: 5129:        // Can also use second version of fill():
25922: 5130:        List<Customer> customers2 = Suppliers.fill(
25923: 5131:            new ArrayList<>(),
25924: 5132:            List::add, Customer::new, 12);
25925: 5133:    }
25926: 5134:}
25927: 5135:/* Output:
25928: 5136:Teller 3 serves Customer 1
25929: 5137:Teller 2 serves Customer 2
25930: 5138:Teller 3 serves Customer 3
25931: 5139:Teller 1 serves Customer 4
25932: 5140:Teller 1 serves Customer 5
25933: 5141:Teller 3 serves Customer 6
25934: 5142:Teller 1 serves Customer 7
25935: 5143:Teller 2 serves Customer 8
25936: 5144:Teller 3 serves Customer 9
25937: 5145:Teller 3 serves Customer 10
25938: 5146:Teller 2 serves Customer 11
25939: 5147:Teller 4 serves Customer 12
25940: 5148:*/
25941: 5149:```
25942: 5150:
25943: 5151:可以看到 `create()` 生成一个新的 **Collection** 对象，而 `fill()` 添加到现有 **Collection** 中。第二个版本`fill()` 显示，它不仅与无关的新类型 **Bank** 一起使用，还能与 **List** 一起使用。因此，从技术上讲，`fill()` 的第一个版本在技术上不是必需的，但在使用 **Collection** 时提供了较短的语法。
25944: 5152:
25945: 5153:<!-- Summary: Is Casting Really So Bad? -->
25946: 5154:
25947: 5155:## 总结：类型转换真的如此之糟吗？
25948: 5156:
25949: 5157:自从 C++ 模版出现以来，我就一直在致力于解释它，我可能比大多数人都更早地提出了下面的论点。直到最近，我才停下来，去思考这个论点到底在多少时间内是有效的——我将要描述的问题到底有多少次可以穿越障碍得以解决。
25950: 5158:
25951: 5159:这个论点就是：使用泛型类型机制的最吸引人的地方，就是在使用集合类的地方，这些类包括诸如各种 **List** 、各种 **Set** 、各种 **Map** 等你在 [集合](book/12-Collections.md) 和 [附录：集合主题](book/Appendix-Collection-Topics.md) 这两章所见。在 Java 5 之前，当你将一个对象放置到集合中时，这个对象就会被向上转型为 **Object** ，因此你会丢失类型信息。当你想要将这个对象从集合中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。我用的示例是持有 **Cat** 的 **List** （这个示例的一种使用苹果和桔子的变体在 [集合](book/12-Collections.md) 章节的开头展示过）。如果没有 Java 5 泛型版本的集合，你放到容集里和从集合中取回的都是 **Object** 。因此，我们很可能会将一个 **Dog** 放置到 **Cat** 的 **List** 中。
25952: 5160:
25953: 5161:但是，泛型出现之前的 Java 并不会让你误用放入到集合中的对象。如果将一个 **Dog** 扔到 **Cat** 的集合中，并且试图将这个集合中的所有东西都当作 **Cat** 处理，那么当你从这个 **Cat** 集合中取回那个 **Dog** 引用，并试图将其转型为 **Cat** 时，就会得到一个 **RuntimeException** 。你仍旧可以发现问题，但是是在运行时而非编译期发现它的。
25954: 5162:
25955: 5163:在本书以前的版本中，我曾经说过：
25956: 5164:
25957: 5165:> 这不止令人恼火，它还可能会产生难以发现的缺陷。如果这个程序的某个部分（或数个部分）向集合中插入了对象，并且通过异常，你在程序的另一个独立的部分中发现有不良对象被放置到了集合中，那么必须发现这个不良插入到底是在何处发生的。
25958: 5166:
25959: 5167:但是，随着对这个论点的进一步检查，我开始怀疑它了。首先，这会多么频繁地发生呢？我记得这类事情从未发生在我身上，并且当我在会议上询问其他人时，我也从来没有听说过有人碰上过。另一本书使用了一个称为 **files** 的 list 示例，它包含 **String** 对象。在这个示例中，向 **files** 中添加一个 **File** 对象看起来相当自然，因此这个对象的名字可能叫 **fileNames** 更好。无论 Java 提供了多少类型检查，仍旧可能会写出晦涩的程序，而编写差劲儿的程序即便可以编译，它仍旧是编写差劲儿的程序。可能大多数人都会使用命名良好的集合，例如 **cats** ，因为它们可以向试图添加非 **Cat** 对象的程序员提供可视的警告。并且即便这类事情发生了，它真正又能潜伏多久呢？只要你开始用真实数据来运行测试，就会非常快地看到异常。
25960: 5168:
25961: 5169:有一位作者甚至断言，这样的缺陷将“*潜伏数年*”。但是我不记得有任何大量的相关报告，来说明人们在查找“狗在猫列表中”这类缺陷时困难重重，或者是说明人们会非常频繁地产生这种错误。然而，你将在 [多线程编程](book/24-Concurrent-Programming.md) 章节中看到，在使用线程时，出现那些可能看起来极罕见的缺陷，是很寻常并容易发生的事，而且，对于到底出了什么错，这些缺陷只能给你一个很模糊的概念。因此，对于泛型是添加到 Java 中的非常显著和相当复杂的特性这一点，“狗在猫列表中”这个论据真的能够成为它的理由吗？
25962: 5170:我相信被称为*泛型*的通用语言特性（并非必须是其在 Java 中的特定实现）的目的在于可表达性，而不仅仅是为了创建类型安全的集合。类型安全的集合是能够创建更通用代码这一能力所带来的副作用。
25963: 5171:因此，即便“狗在猫列表中”这个论据经常被用来证明泛型是必要的，但是它仍旧是有问题的。就像我在本章开头声称的，我不相信这就是泛型这个概念真正的含义。相反，泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。正如你在本章中看到的，编写真正泛化的“持有器”类（ Java 的容器就是这种类）相当简单，但是编写出能够操作其泛型类型的泛化代码就需要额外的努力了，这些努力需要类创建者和类消费者共同付出，他们必须理解这些代码的概念和实现。这些额外的努力会增加使用这种特性的难度，并可能会因此而使其在某些场合缺乏可应用性，而在这些场合中，它可能会带来附加的价值。
25964: 5172:
25965: 5173:还要注意到，因为泛型是后来添加到 Java 中，而不是从一开始就设计到这种语言中的，所以某些容器无法达到它们应该具备的健壮性。例如，观察一下 **Map** ，在特定的方法 `containsKey(Object key) `和 `get(Object key)` 中就包含这类情况。如果这些类是使用在它们之前就存在的泛型设计的，那么这些方法将会使用参数化类型而不是 **Object** ，因此也就可以提供这些泛型假设会提供的编译期检查。例如，在 C++ 的 **map** 中，键的类型总是在编译期检查的。
25966: 5174:
25967: 5175:有一件事很明显：在一种语言已经被广泛应用之后，在其较新的版本中引入任何种类的泛型机制，都会是一项非常非常棘手的任务，并且是一项不付出艰辛就无法完成的任务。在 C++ 中，模版是在其最初的 ISO 版本中就引入的（即便如此，也引发了阵痛，因为在第一个标准 C++ 出现之前，有很多非模版版本在使用），因此实际上模版一直都是这种语言的一部分。在 Java 中，泛型是在这种语言首次发布大约 10 年之后才引入的，因此向泛型迁移的问题特别多，并且对泛型的设计产生了明显的影响。其结果就是，程序员将承受这些痛苦，而这一切都是由于 Java 设计者在设计 1.0 版本时所表现出来的短视造成的。当 Java 最初被创建时，它的设计者们当然了解 C++ 的模版，他们甚至考虑将其囊括到 Java 语言中，但是出于这样或那样的原因，他们决定将模版排除在外（其迹象就是他们过于匆忙）。因此， Java 语言和使用它的程序员都将承受这些痛苦。只有时间将会说明 Java 的泛型方式对这种语言所造成的最终影响。
25968: 5176:某些语言，已经融入了更简洁、影响更小的方式，来实现参数化类型。我们不可能不去想象这样的语言将会成为 Java 的继任者，因为它们采用的方式，与 C++ 通过 C 来实现的方式相同：按原样使用它，然后对其进行改进。
25969: 5177:
25970: 5178:## 进阶阅读
25971: 5179:
25972: 5180:泛型的入门文档是 《Generics in the Java Programming Language》，作者是 Gilad Bracha，可以从 http://java.oracle.com 获取。
25973: 5181:
25974: 5182:Angelika Langer 的《Java Generics FAQs》是一份非常有帮助的资料，可以从 http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html 获取。
25975: 5183:
25976: 5184:你可以从 《Adding Wildcards to the Java Programming Language》中学到更多关于通配符的知识，作者是 Torgerson、Ernst、Hansen、von der Ahe、Bracha 和 Gafter，地址是 http://www.jot.fm/issues/issue_2004_12/article5。
25977: 5185:
25978: 5186:Neal After 对于 Java 问题（尤其是擦除）的看法可以从这里找到：http://www.infoq.com/articles/neal-gafter-on-java。
25979: 5187:
25980: 5188:[^1]: 在编写本章期间，Angelika Langer的 Java 泛型常见问题解答以及她的其他著作（与Klaus Kreft一起）是非常宝贵的。
25981: 5189:[^2]: [http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html](http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html)
25982: 5190:[^3]: 参见本章章末引文。
25983: 5191:[^4]: 注意，一些编程环境，如 Eclipse 和 IntelliJ IDEA，将会自动生成委托代码。
25984: 5192:[^5]: 因为可以使用转型，有效地禁止了类型系统，一些人就认为 C++ 是弱类型，但这太极端了。一种可能更好的说法是 C++ 是有一道暗门的强类型语言。
25985: 5193:[^6]: 我再次从 Brian Goetz 那获得帮助。
25986: 5194:
25987: 5195:<!-- 分页 -->
25988: 5196:
25989: 5197:<div style="page-break-after: always;"></div>
25990: 
25991: 1:[TOC]
25992: 2:
25993: 3:<!-- Generics -->
25994: 4:
25995: 5:# 第二十章 泛型
25996: 6:
25997: 7:> 普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。
25998: 8:
25999: 9:多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。除了 `final` 类（或只提供私有构造函数的类）任何类型都可被扩展，所以大部分时候这种灵活性是自带的。
26000: 10:
26001: 11:拘泥于单一的继承体系太过局限，因为只有继承体系中的对象才能适用基类作为参数的方法中。如果方法以接口而不是类作为参数，限制就宽松多了，只要实现了接口就可以。这给予调用方一种选项，通过调整现有的类来实现接口，满足方法参数要求。接口可以突破继承体系的限制。
26002: 12:
26003: 13:即便是接口也还是有诸多限制。一旦指定了接口，它就要求你的代码必须使用特定的接口。而我们希望编写更通用的代码，能够适用“非特定的类型”，而不是一个具体的接口或类。
26004: 14:
26005: 15:这就是泛型的概念，是 Java 5 的重大变化之一。泛型实现了*参数化类型*，这样你编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。随后你会发现 Java 中泛型的实现并没有那么“泛”，你可能会质疑“泛型”这个词是否合适用来描述这一功能。
26006: 16:
26007: 17:如果你从未接触过参数化类型机制，你会发现泛型对 Java 语言确实是个很有益的补充。在你实例化一个类型参数时，编译器会负责转型并确保类型的正确性。这是一大进步。
26008: 18:
26009: 19:然而，如果你了解其他语言（例如 C++ ）的参数化机制，你会发现，Java 泛型并不能满足所有的预期。使用别人创建好的泛型相对容易，但是创建自己的泛型时，就会遇到很多意料之外的麻烦。
26010: 20:
26011: 21:这并不是说 Java 泛型毫无用处。在很多情况下，它可以使代码更直接更优雅。不过，如果你见识过那种实现了更纯粹的泛型的编程语言，那么，Java 可能会令你失望。本章会介绍 Java 泛型的优点与局限。我会解释 Java 的泛型是如何发展成现在这样的，希望能够帮助你更有效地使用这个特性。[^1]
26012: 22:
26013: 23:### 与 C++ 的比较
26014: 24:
26015: 25:Java 的设计者曾说过，这门语言的灵感主要来自 C++ 。尽管如此，学习 Java 时基本不用参考 C++ 。
26016: 26:
26017: 27:但是，Java 中的泛型需要与 C++ 进行对比，理由有两个：首先，理解 C++ *模板*（泛型的主要灵感来源，包括基本语法）的某些特性，有助于理解泛型的基础理念。同时，非常重要的一点是，你可以了解 Java 泛型的局限是什么，以及为什么会有这些局限。最终的目标是明确 Java 泛型的边界，让你成为一个程序高手。只有知道了某个技术不能做什么，你才能更好地做到所能做的（部分原因是，不必浪费时间在死胡同里）。
26018: 28:
26019: 29:第二个原因是，在 Java 社区中，大家普遍对 C++ 模板有一种误解，而这种误解可能会令你在理解泛型的意图时产生偏差。
26020: 30:
26021: 31:因此，本章中会介绍少量 C++ 模板的例子，仅当它们确实可以加深理解时才会引入。
26022: 32:
26023: 33:<!-- Simple Generics -->
26024: 34:
26025: 35:## 简单泛型
26026: 36:
26027: 37:促成泛型出现的最主要的动机之一是为了创建*集合类*，参见 [集合](book/12-Collections.md) 章节。集合用于存放要使用到的对象。数组也是如此，不过集合比数组更加灵活，功能更丰富。几乎所有程序在运行过程中都会涉及到一组对象，因此集合是可复用性最高的类库之一。
26028: 38:
26029: 39:我们先看一个只能持有单个对象的类。这个类可以明确指定其持有的对象的类型：
26030: 40:
26031: 41:```java
26032: 42:// generics/Holder1.java
26033: 43:
26034: 44:class Automobile {}
26035: 45:
26036: 46:public class Holder1 {
26037: 47:    private Automobile a;
26038: 48:    public Holder1(Automobile a) { this.a = a; }
26039: 49:    Automobile get() { return a; }
26040: 50:}
26041: 51:```
26042: 52:
26043: 53:这个类的可复用性不高，它无法持有其他类型的对象。我们可不希望为碰到的每个类型都编写一个新的类。
26044: 54:
26045: 55:在 Java 5 之前，我们可以让这个类直接持有 `Object` 类型的对象：
26046: 56:
26047: 57:```java
26048: 58:// generics/ObjectHolder.java
26049: 59:
26050: 60:public class ObjectHolder {
26051: 61:    private Object a;
26052: 62:    public ObjectHolder(Object a) { this.a = a; }
26053: 63:    public void set(Object a) { this.a = a; }
26054: 64:    public Object get() { return a; }
26055: 65:    
26056: 66:    public static void main(String[] args) {
26057: 67:        ObjectHolder h2 = new ObjectHolder(new Automobile());
26058: 68:        Automobile a = (Automobile)h2.get();
26059: 69:        h2.set("Not an Automobile");
26060: 70:        String s = (String)h2.get();
26061: 71:        h2.set(1); // 自动装箱为 Integer
26062: 72:        Integer x = (Integer)h2.get();
26063: 73:    }
26064: 74:}
26065: 75:```
26066: 76:
26067: 77:现在，`ObjectHolder` 可以持有任何类型的对象，在上面的示例中，一个 `ObjectHolder` 先后持有了三种不同类型的对象。
26068: 78:
26069: 79:一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。
26070: 80:
26071: 81:因此，与其使用 `Object` ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用*类型参数*，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，`T` 就是类型参数：
26072: 82:
26073: 83:```java
26074: 84:// generics/GenericHolder.java
26075: 85:
26076: 86:public class GenericHolder<T> {
26077: 87:    private T a;
26078: 88:    public GenericHolder() {}
26079: 89:    public void set(T a) { this.a = a; }
26080: 90:    public T get() { return a; }
26081: 91:    
26082: 92:    public static void main(String[] args) {
26083: 93:        GenericHolder<Automobile> h3 = new GenericHolder<Automobile>();
26084: 94:        h3.set(new Automobile()); // 此处有类型校验
26085: 95:        Automobile a = h3.get();  // 无需类型转换
26086: 96:        //- h3.set("Not an Automobile"); // 报错
26087: 97:        //- h3.set(1);  // 报错
26088: 98:    }
26089: 99:}
26090: 100:```
26091: 101:
26092: 102:创建 `GenericHolder` 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 `main()` 中那样使用。然后，你就只能在 `GenericHolder` 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当你调用 `get()` 取值时，直接就是正确的类型。
26093: 103:
26094: 104:这就是 Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。
26095: 105:
26096: 106:你可能注意到 `h3` 的定义非常繁复。在 `=` 左边有 `GenericHolder<Automobile>`, 右边又重复了一次。在 Java 5 中，这种写法被解释成“必要的”，但在 Java 7 中设计者修正了这个问题（新的简写语法随后成为备受欢迎的特性）。以下是简写的例子：
26097: 107:
26098: 108:```java
26099: 109:// generics/Diamond.java
26100: 110:
26101: 111:class Bob {}
26102: 112:
26103: 113:public class Diamond<T> {
26104: 114:    public static void main(String[] args) {
26105: 115:        GenericHolder<Bob> h3 = new GenericHolder<>();
26106: 116:        h3.set(new Bob());
26107: 117:    }
26108: 118:}
26109: 119:```
26110: 120:
26111: 121:注意，在 `h3` 的定义处，`=` 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。在本书剩余部分都会使用这种语法。
26112: 122:
26113: 123:一般来说，你可以认为泛型和其他类型差不多，只不过它们碰巧有类型参数罢了。在使用泛型时，你只需要指定它们的名称和类型参数列表即可。
26114: 124:
26115: 125:### 一个元组类库
26116: 126:
26117: 127:有时一个方法需要能返回多个对象。而 **return** 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得了编译时的类型安全。
26118: 128:
26119: 129:这个概念称为*元组*，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 *数据传输对象* 或 *信使* ）。
26120: 130:
26121: 131:通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组：
26122: 132:
26123: 133:```java
26124: 134:// onjava/Tuple2.java
26125: 135:package onjava;
26126: 136:
26127: 137:public class Tuple2<A, B> {
26128: 138:    public final A a1;
26129: 139:    public final B a2;
26130: 140:    public Tuple2(A a, B b) { a1 = a; a2 = b; }
26131: 141:    public String rep() { return a1 + ", " + a2; }
26132: 142:  
26133: 143:    @Override
26134: 144:    public String toString() {
26135: 145:        return "(" + rep() + ")";
26136: 146:    }
26137: 147:}
26138: 148:```
26139: 149:
26140: 150:构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。
26141: 151:
26142: 152:初次阅读上面的代码时，你可能认为这违反了 Java 编程的封装原则。`a1` 和 `a2` 应该声明为 **private**，然后提供 `getFirst()` 和 `getSecond()` 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取 `a1` 和 `a2` 然后对它们执行任何操作，但无法对 `a1` 和 `a2` 重新赋值。例子中的 `final` 可以实现同样的效果，并且更为简洁明了。
26143: 153:
26144: 154:另一种设计思路是允许元组的用户给 `a1` 和 `a2` 重新赋值。然而，采用上例中的形式无疑更加安全，如果用户想存储不同的元素，就会强制他们创建新的 `Tuple2` 对象。
26145: 155:
26146: 156:我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了：
26147: 157:
26148: 158:```java
26149: 159:// onjava/Tuple3.java
26150: 160:package onjava;
26151: 161:
26152: 162:public class Tuple3<A, B, C> extends Tuple2<A, B> {
26153: 163:    public final C a3;
26154: 164:    public Tuple3(A a, B b, C c) {
26155: 165:        super(a, b);
26156: 166:        a3 = c;
26157: 167:    }
26158: 168:    
26159: 169:    @Override
26160: 170:    public String rep() {
26161: 171:        return super.rep() + ", " + a3;
26162: 172:    }
26163: 173:}
26164: 174:
26165: 175:// onjava/Tuple4.java
26166: 176:package onjava;
26167: 177:
26168: 178:public class Tuple4<A, B, C, D>
26169: 179:  extends Tuple3<A, B, C> {
26170: 180:    public final D a4;
26171: 181:    public Tuple4(A a, B b, C c, D d) {
26172: 182:        super(a, b, c);
26173: 183:        a4 = d;
26174: 184:    }
26175: 185:    
26176: 186:    @Override
26177: 187:    public String rep() {
26178: 188:        return super.rep() + ", " + a4;
26179: 189:    }
26180: 190:}
26181: 191:
26182: 192:// onjava/Tuple5.java
26183: 193:package onjava;
26184: 194:
26185: 195:public class Tuple5<A, B, C, D, E>
26186: 196:  extends Tuple4<A, B, C, D> {
26187: 197:    public final E a5;
26188: 198:    public Tuple5(A a, B b, C c, D d, E e) {
26189: 199:        super(a, b, c, d);
26190: 200:        a5 = e;
26191: 201:    }
26192: 202:    
26193: 203:    @Override
26194: 204:    public String rep() {
26195: 205:        return super.rep() + ", " + a5;
26196: 206:    }
26197: 207:}
26198: 208:```
26199: 209:
26200: 210:演示需要，再定义两个类：
26201: 211:
26202: 212:```java
26203: 213:// generics/Amphibian.java
26204: 214:public class Amphibian {}
26205: 215:
26206: 216:// generics/Vehicle.java
26207: 217:public class Vehicle {}
26208: 218:```
26209: 219:
26210: 220:使用元组时，你只需要定义一个长度适合的元组，将其作为返回值即可。注意下面例子中方法的返回类型：
26211: 221:
26212: 222:```java
26213: 223:// generics/TupleTest.java
26214: 224:import onjava.*;
26215: 225:
26216: 226:public class TupleTest {
26217: 227:    static Tuple2<String, Integer> f() {
26218: 228:        // 47 自动装箱为 Integer
26219: 229:        return new Tuple2<>("hi", 47);
26220: 230:    }
26221: 231:  
26222: 232:    static Tuple3<Amphibian, String, Integer> g() {
26223: 233:        return new Tuple3<>(new Amphibian(), "hi", 47);
26224: 234:    }
26225: 235:  
26226: 236:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
26227: 237:        return new Tuple4<>(new Vehicle(), new Amphibian(), "hi", 47);
26228: 238:    }
26229: 239:  
26230: 240:    static Tuple5<Vehicle, Amphibian, String, Integer, Double> k() {
26231: 241:        return new Tuple5<>(new Vehicle(), new Amphibian(), "hi", 47, 11.1);
26232: 242:    }
26233: 243:  
26234: 244:    public static void main(String[] args) {
26235: 245:        Tuple2<String, Integer> ttsi = f();
26236: 246:        System.out.println(ttsi);
26237: 247:        // ttsi.a1 = "there"; // 编译错误，因为 final 不能重新赋值
26238: 248:        System.out.println(g());
26239: 249:        System.out.println(h());
26240: 250:        System.out.println(k());
26241: 251:    }
26242: 252:}
26243: 253:
26244: 254:/* 输出：
26245: 255: (hi, 47)
26246: 256: (Amphibian@1540e19d, hi, 47)
26247: 257: (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47)
26248: 258: (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1)
26249: 259: */
26250: 260:```
26251: 261:
26252: 262:有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。
26253: 263:
26254: 264:通过 `ttsi.a1 = "there"` 语句的报错，我们可以看出，**final** 声明确实可以确保 **public** 字段在对象被构造出来之后就不能重新赋值了。
26255: 265:
26256: 266:在上面的程序中，`new` 表达式有些啰嗦。本章稍后会介绍，如何利用 *泛型方法* 简化它们。
26257: 267:
26258: 268:### 一个堆栈类
26259: 269:
26260: 270:接下来我们看一个稍微复杂一点的例子：堆栈。在 [集合](book/12-Collections.md) 一章中，我们用 `LinkedList` 实现了 `onjava.Stack` 类。在那个例子中，`LinkedList` 本身已经具备了创建堆栈所需的方法。`Stack` 是通过两个泛型类 `Stack<T>` 和 `LinkedList<T>` 的组合来创建。我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。
26261: 271:
26262: 272:这次我们不用 `LinkedList` 来实现自己的内部链式存储机制。
26263: 273:
26264: 274:```java
26265: 275:// generics/LinkedStack.java
26266: 276:// 用链式结构实现的堆栈
26267: 277:
26268: 278:public class LinkedStack<T> {
26269: 279:    private static class Node<U> {
26270: 280:        U item;
26271: 281:        Node<U> next;
26272: 282:    
26273: 283:        Node() { item = null; next = null; }
26274: 284:        
26275: 285:        Node(U item, Node<U> next) {
26276: 286:            this.item = item;
26277: 287:            this.next = next;
26278: 288:        }
26279: 289:    
26280: 290:        boolean end() {
26281: 291:            return item == null && next == null;
26282: 292:        }
26283: 293:    }
26284: 294:  
26285: 295:    private Node<T> top = new Node<>();  // 栈顶
26286: 296:  
26287: 297:    public void push(T item) {
26288: 298:        top = new Node<>(item, top);
26289: 299:    }
26290: 300:  
26291: 301:    public T pop() {
26292: 302:        T result = top.item;
26293: 303:        if (!top.end()) {
26294: 304:            top = top.next;
26295: 305:        }
26296: 306:        return result;
26297: 307:    }
26298: 308:  
26299: 309:    public static void main(String[] args) {
26300: 310:        LinkedStack<String> lss = new LinkedStack<>();
26301: 311:        for (String s : "Phasers on stun!".split(" ")) {
26302: 312:            lss.push(s);
26303: 313:        }
26304: 314:        String s;
26305: 315:        while ((s = lss.pop()) != null) {
26306: 316:            System.out.println(s);
26307: 317:        }
26308: 318:    }
26309: 319:}
26310: 320:```
26311: 321:
26312: 322:输出结果：
26313: 323:
26314: 324:```java
26315: 325:stun!
26316: 326:on
26317: 327:Phasers
26318: 328:```
26319: 329:
26320: 330:内部类 `Node` 也是一个泛型，它拥有自己的类型参数。
26321: 331:
26322: 332:这个例子使用了一个 *末端标识* (end sentinel) 来判断栈何时为空。这个末端标识是在构造 `LinkedStack` 时创建的。然后，每次调用 `push()` 就会创建一个 `Node<T>` 对象，并将其链接到前一个 `Node<T>` 对象。当你调用 `pop()` 方法时，总是返回 `top.item`，然后丢弃当前 `top` 所指向的 `Node<T>`，并将 `top` 指向下一个 `Node<T>`，除非到达末端标识，这时就不能再移动 `top` 了。如果已经到达末端，程序还继续调用 `pop()` 方法，它只能得到 `null`，说明栈已经空了。
26323: 333:
26324: 334:### RandomList
26325: 335:
26326: 336:作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 `select()` 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型：
26327: 337:
26328: 338:```java
26329: 339:// generics/RandomList.java
26330: 340:import java.util.*;
26331: 341:import java.util.stream.*;
26332: 342:
26333: 343:public class RandomList<T> extends ArrayList<T> {
26334: 344:    private Random rand = new Random(47);
26335: 345:  
26336: 346:    public T select() {
26337: 347:        return get(rand.nextInt(size()));
26338: 348:    }
26339: 349:  
26340: 350:    public static void main(String[] args) {
26341: 351:        RandomList<String> rs = new RandomList<>();
26342: 352:        Arrays.stream("The quick brown fox jumped over the lazy brown dog".split(" ")).forEach(rs::add);
26343: 353:        IntStream.range(0, 11).forEach(i -> 
26344: 354:            System.out.print(rs.select() + " "));
26345: 355:    }
26346: 356:}
26347: 357:```
26348: 358:
26349: 359:输出结果：
26350: 360:
26351: 361:```java
26352: 362:brown over fox quick quick dog brown The brown lazy brown
26353: 363:```
26354: 364:
26355: 365:`RandomList` 继承了 `ArrayList` 的所有方法。本例中只添加了 `select()` 这个方法。
26356: 366:
26357: 367:<!-- Generic Interfaces -->
26358: 368:
26359: 369:## 泛型接口
26360: 370:
26361: 371:泛型也可以应用于接口。例如 *生成器*，这是一种专门负责创建对象的类。实际上，这是 *工厂方法* 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。
26362: 372:
26363: 373:一般而言，一个生成器只定义一个方法，用于创建对象。例如 `java.util.function` 类库中的 `Supplier` 就是一个生成器，调用其 `get()` 获取对象。`get()` 是泛型方法，返回值为类型参数 `T`。
26364: 374:
26365: 375:为了演示 `Supplier`，我们需要定义几个类。下面是个咖啡相关的继承体系：
26366: 376:
26367: 377:```java
26368: 378:// generics/coffee/Coffee.java
26369: 379:package generics.coffee;
26370: 380:
26371: 381:public class Coffee {
26372: 382:    private static long counter = 0;
26373: 383:    private final long id = counter++;
26374: 384:  
26375: 385:    @Override
26376: 386:    public String toString() {
26377: 387:        return getClass().getSimpleName() + " " + id;
26378: 388:    }
26379: 389:}
26380: 390:
26381: 391:
26382: 392:// generics/coffee/Latte.java
26383: 393:package generics.coffee;
26384: 394:public class Latte extends Coffee {}
26385: 395:
26386: 396:
26387: 397:// generics/coffee/Mocha.java
26388: 398:package generics.coffee;
26389: 399:public class Mocha extends Coffee {}
26390: 400:
26391: 401:
26392: 402:// generics/coffee/Cappuccino.java
26393: 403:package generics.coffee;
26394: 404:public class Cappuccino extends Coffee {}
26395: 405:
26396: 406:
26397: 407:// generics/coffee/Americano.java
26398: 408:package generics.coffee;
26399: 409:public class Americano extends Coffee {}
26400: 410:
26401: 411:
26402: 412:// generics/coffee/Breve.java
26403: 413:package generics.coffee;
26404: 414:public class Breve extends Coffee {}
26405: 415:```
26406: 416:
26407: 417:现在，我们可以编写一个类，实现 `Supplier<Coffee>` 接口，它能够随机生成不同类型的 `Coffee` 对象：
26408: 418:
26409: 419:```java
26410: 420:// generics/coffee/CoffeeSupplier.java
26411: 421:// {java generics.coffee.CoffeeSupplier}
26412: 422:package generics.coffee;
26413: 423:import java.util.*;
26414: 424:import java.util.function.*;
26415: 425:import java.util.stream.*;
26416: 426:
26417: 427:public class CoffeeSupplier
26418: 428:implements Supplier<Coffee>, Iterable<Coffee> {
26419: 429:    private Class<?>[] types = { Latte.class, Mocha.class, 
26420: 430:        Cappuccino.class, Americano.class, Breve.class };
26421: 431:    private static Random rand = new Random(47);
26422: 432:  
26423: 433:    public CoffeeSupplier() {}
26424: 434:    // For iteration:
26425: 435:    private int size = 0;
26426: 436:    public CoffeeSupplier(int sz) { size = sz; }
26427: 437:  
26428: 438:    @Override
26429: 439:    public Coffee get() {
26430: 440:        try {
26431: 441:            return (Coffee) types[rand.nextInt(types.length)].newInstance();
26432: 442:        } catch (InstantiationException | IllegalAccessException e) {
26433: 443:            throw new RuntimeException(e);
26434: 444:        }
26435: 445:    }
26436: 446:  
26437: 447:    class CoffeeIterator implements Iterator<Coffee> {
26438: 448:        int count = size;
26439: 449:        @Override
26440: 450:        public boolean hasNext() { return count > 0; }
26441: 451:        @Override
26442: 452:        public Coffee next() {
26443: 453:            count--;
26444: 454:            return CoffeeSupplier.this.get();
26445: 455:        }
26446: 456:        @Override
26447: 457:        public void remove() {
26448: 458:            throw new UnsupportedOperationException();
26449: 459:        }
26450: 460:    }
26451: 461:  
26452: 462:    @Override
26453: 463:    public Iterator<Coffee> iterator() {
26454: 464:        return new CoffeeIterator();
26455: 465:    }
26456: 466:  
26457: 467:    public static void main(String[] args) {
26458: 468:        Stream.generate(new CoffeeSupplier())
26459: 469:              .limit(5)
26460: 470:              .forEach(System.out::println);
26461: 471:        for (Coffee c : new CoffeeSupplier(5)) {
26462: 472:            System.out.println(c);
26463: 473:        }
26464: 474:    }
26465: 475:}
26466: 476:```
26467: 477:
26468: 478:输出结果：
26469: 479:
26470: 480:```java
26471: 481:Americano 0
26472: 482:Latte 1
26473: 483:Americano 2
26474: 484:Mocha 3
26475: 485:Mocha 4
26476: 486:Breve 5
26477: 487:Americano 6
26478: 488:Latte 7
26479: 489:Cappuccino 8
26480: 490:Cappuccino 9
26481: 491:```
26482: 492:
26483: 493:参数化的 `Supplier` 接口确保 `get()` 返回值是参数的类型。`CoffeeSupplier` 同时还实现了 `Iterable` 接口，所以能用于 *for-in* 语句。不过，它还需要知道何时终止循环，这正是第二个构造函数的作用。
26484: 494:
26485: 495:下面是另一个实现 `Supplier<T>` 接口的例子，它负责生成 Fibonacci 数列：
26486: 496:
26487: 497:```java
26488: 498:// generics/Fibonacci.java
26489: 499:// Generate a Fibonacci sequence
26490: 500:import java.util.function.*;
26491: 501:import java.util.stream.*;
26492: 502:
26493: 503:public class Fibonacci implements Supplier<Integer> {
26494: 504:    private int count = 0;
26495: 505:    @Override
26496: 506:    public Integer get() { return fib(count++); }
26497: 507:  
26498: 508:    private int fib(int n) {
26499: 509:        if(n < 2) return 1;
26500: 510:        return fib(n-2) + fib(n-1);
26501: 511:    }
26502: 512:  
26503: 513:    public static void main(String[] args) {
26504: 514:        Stream.generate(new Fibonacci())
26505: 515:              .limit(18)
26506: 516:              .map(n -> n + " ")
26507: 517:              .forEach(System.out::print);
26508: 518:    }
26509: 519:}
26510: 520:```
26511: 521:
26512: 522:输出结果：
26513: 523:
26514: 524:```java
26515: 525:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
26516: 526:```
26517: 527:
26518: 528:虽然我们在 `Fibonacci` 类的里里外外使用的都是 `int` 类型，但是其参数类型却是 `Integer`。这个例子引出了 Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备自动装箱和拆箱的功能，可以很方便地在基本类型和相应的包装类之间进行转换。通过这个例子中 `Fibonacci` 类对 `int` 的使用，我们已经看到了这种效果。
26519: 529:
26520: 530:如果还想更进一步，编写一个实现了 `Iterable` 的 `Fibnoacci` 生成器。我们的一个选择是重写这个类，令其实现 `Iterable` 接口。不过，你并不是总能拥有源代码的控制权，并且，除非必须这么做，否则，我们也不愿意重写一个类。而且我们还有另一种选择，就是创建一个 *适配器* (Adapter) 来实现所需的接口，我们在前面介绍过这个设计模式。
26521: 531:
26522: 532:有多种方法可以实现适配器。例如，可以通过继承来创建适配器类：
26523: 533:
26524: 534:```java
26525: 535:// generics/IterableFibonacci.java
26526: 536:// Adapt the Fibonacci class to make it Iterable
26527: 537:import java.util.*;
26528: 538:
26529: 539:public class IterableFibonacci
26530: 540:extends Fibonacci implements Iterable<Integer> {
26531: 541:    private int n;
26532: 542:    public IterableFibonacci(int count) { n = count; }
26533: 543:  
26534: 544:    @Override
26535: 545:    public Iterator<Integer> iterator() {
26536: 546:        return new Iterator<Integer>() {
26537: 547:            @Override
26538: 548:            public boolean hasNext() { return n > 0; }
26539: 549:            @Override
26540: 550:            public Integer next() {
26541: 551:                n--;
26542: 552:                return IterableFibonacci.this.get();
26543: 553:            }
26544: 554:            @Override
26545: 555:            public void remove() { // Not implemented
26546: 556:                throw new UnsupportedOperationException();
26547: 557:            }
26548: 558:        };
26549: 559:    }
26550: 560:  
26551: 561:    public static void main(String[] args) {
26552: 562:        for(int i : new IterableFibonacci(18))
26553: 563:            System.out.print(i + " ");
26554: 564:    }
26555: 565:}
26556: 566:```
26557: 567:
26558: 568:输出结果：
26559: 569:
26560: 570:```java
26561: 571:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
26562: 572:```
26563: 573:
26564: 574:在 *for-in* 语句中使用 `IterableFibonacci`，必须在构造函数中提供一个边界值，这样 `hasNext()` 才知道何时返回 **false**，结束循环。
26565: 575:
26566: 576:<!-- Generic Methods -->
26567: 577:
26568: 578:## 泛型方法
26569: 579:
26570: 580:到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。
26571: 581:
26572: 582:泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。
26573: 583:
26574: 584:如果方法是 **static** 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型类型参数，则它必须是泛型方法。
26575: 585:
26576: 586:要定义泛型方法，请将泛型参数列表放置在返回值之前，如下所示：
26577: 587:
26578: 588:```java
26579: 589:// generics/GenericMethods.java
26580: 590:
26581: 591:public class GenericMethods {
26582: 592:    public <T> void f(T x) {
26583: 593:        System.out.println(x.getClass().getName());
26584: 594:    }
26585: 595:
26586: 596:    public static void main(String[] args) {
26587: 597:        GenericMethods gm = new GenericMethods();
26588: 598:        gm.f("");
26589: 599:        gm.f(1);
26590: 600:        gm.f(1.0);
26591: 601:        gm.f(1.0F);
26592: 602:        gm.f('c');
26593: 603:        gm.f(gm);
26594: 604:    }
26595: 605:}
26596: 606:/* Output:
26597: 607:java.lang.String
26598: 608:java.lang.Integer
26599: 609:java.lang.Double
26600: 610:java.lang.Float
26601: 611:java.lang.Character
26602: 612:GenericMethods
26603: 613:*/
26604: 614:```
26605: 615:
26606: 616:尽管可以同时对类及其方法进行参数化，但这里未将 **GenericMethods** 类参数化。只有方法 `f()` 具有类型参数，该参数由方法返回类型之前的参数列表指示。
26607: 617:
26608: 618:对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 *类型参数推断*。因此，对 `f()` 的调用看起来像普通的方法调用，并且 `f()` 看起来像被重载了无数次一样。它甚至会接受 **GenericMethods** 类型的参数。
26609: 619:
26610: 620:如果使用基本类型调用 `f()` ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。
26611: 621:
26612: 622:<!-- Varargs and Generic Methods -->
26613: 623:
26614: 624:### 变长参数和泛型方法
26615: 625:
26616: 626:泛型方法和变长参数列表可以很好地共存：
26617: 627:
26618: 628:```java
26619: 629:// generics/GenericVarargs.java
26620: 630:
26621: 631:import java.util.ArrayList;
26622: 632:import java.util.List;
26623: 633:
26624: 634:public class GenericVarargs {
26625: 635:    @SafeVarargs
26626: 636:    public static <T> List<T> makeList(T... args) {
26627: 637:        List<T> result = new ArrayList<>();
26628: 638:        for (T item : args)
26629: 639:            result.add(item);
26630: 640:        return result;
26631: 641:    }
26632: 642:
26633: 643:    public static void main(String[] args) {
26634: 644:        List<String> ls = makeList("A");
26635: 645:        System.out.println(ls);
26636: 646:        ls = makeList("A", "B", "C");
26637: 647:        System.out.println(ls);
26638: 648:        ls = makeList(
26639: 649:                "ABCDEFFHIJKLMNOPQRSTUVWXYZ".split(""));
26640: 650:        System.out.println(ls);
26641: 651:    }
26642: 652:}
26643: 653:/* Output:
26644: 654:[A]
26645: 655:[A, B, C]
26646: 656:[A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R,
26647: 657:S, T, U, V, W, X, Y, Z]
26648: 658:*/
26649: 659:```
26650: 660:
26651: 661:此处显示的 `makeList()` 方法产生的功能与标准库的 `java.util.Arrays.asList()` 方法相同。
26652: 662:
26653: 663:`@SafeVarargs` 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。
26654: 664:
26655: 665:<!-- A General-Purpose Supplier -->
26656: 666:
26657: 667:### 一个泛型的 Supplier
26658: 668:
26659: 669:这是一个为任意具有无参构造方法的类生成 **Supplier** 的类。为了减少键入，它还包括一个用于生成 **BasicSupplier** 的泛型方法：
26660: 670:
26661: 671:```java
26662: 672:// onjava/BasicSupplier.java
26663: 673:// Supplier from a class with a no-arg constructor
26664: 674:package onjava;
26665: 675:
26666: 676:import java.util.function.Supplier;
26667: 677:
26668: 678:public class BasicSupplier<T> implements Supplier<T> {
26669: 679:    private Class<T> type;
26670: 680:
26671: 681:    public BasicSupplier(Class<T> type) {
26672: 682:        this.type = type;
26673: 683:    }
26674: 684:
26675: 685:    @Override
26676: 686:    public T get() {
26677: 687:        try {
26678: 688:            // Assumes type is a public class:
26679: 689:            return type.newInstance();
26680: 690:        } catch (InstantiationException |
26681: 691:                IllegalAccessException e) {
26682: 692:            throw new RuntimeException(e);
26683: 693:        }
26684: 694:    }
26685: 695:
26686: 696:    // Produce a default Supplier from a type token:
26687: 697:    public static <T> Supplier<T> create(Class<T> type) {
26688: 698:        return new BasicSupplier<>(type);
26689: 699:    }
26690: 700:}
26691: 701:```
26692: 702:
26693: 703:此类提供了产生以下对象的基本实现：
26694: 704:
26695: 705:1. 是 **public** 的。 因为 **BasicSupplier** 在单独的包中，所以相关的类必须具有 **public** 权限，而不仅仅是包级访问权限。
26696: 706:
26697: 707:2. 具有无参构造方法。要创建一个这样的 **BasicSupplier** 对象，请调用 `create()` 方法，并将要生成类型的类型令牌传递给它。通用的 `create()` 方法提供了 `BasicSupplier.create(MyType.class)` 这种较简洁的语法来代替较笨拙的 `new BasicSupplier <MyType>(MyType.class)`。
26698: 708:
26699: 709:例如，这是一个具有无参构造方法的简单类：
26700: 710:
26701: 711:```java
26702: 712:// generics/CountedObject.java
26703: 713:
26704: 714:public class CountedObject {
26705: 715:    private static long counter = 0;
26706: 716:    private final long id = counter++;
26707: 717:
26708: 718:    public long id() {
26709: 719:        return id;
26710: 720:    }
26711: 721:
26712: 722:    @Override
26713: 723:    public String toString() {
26714: 724:        return "CountedObject " + id;
26715: 725:    }
26716: 726:}
26717: 727:```
26718: 728:
26719: 729:**CountedObject** 类可以跟踪自身创建了多少个实例，并通过 `toString()` 报告这些实例的数量。 **BasicSupplier** 可以轻松地为 **CountedObject** 创建 **Supplier**：
26720: 730:
26721: 731:```java
26722: 732:  // generics/BasicSupplierDemo.java
26723: 733:
26724: 734:import onjava.BasicSupplier;
26725: 735:
26726: 736:import java.util.stream.Stream;
26727: 737:
26728: 738:public class BasicSupplierDemo {
26729: 739:    public static void main(String[] args) {
26730: 740:        Stream.generate(
26731: 741:                BasicSupplier.create(CountedObject.class))
26732: 742:                .limit(5)
26733: 743:                .forEach(System.out::println);
26734: 744:    }
26735: 745:}
26736: 746:/* Output:
26737: 747:CountedObject 0
26738: 748:CountedObject 1
26739: 749:CountedObject 2
26740: 750:CountedObject 3
26741: 751:CountedObject 4
26742: 752:*/
26743: 753:```
26744: 754:
26745: 755:泛型方法减少了产生 **Supplier** 对象所需的代码量。 Java 泛型强制传递 **Class** 对象，以便在 `create()` 方法中将其用于类型推断。
26746: 756:
26747: 757:<!-- Simplifying Tuple Use -->
26748: 758:
26749: 759:### 简化元组的使用
26750: 760:
26751: 761:使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库。在这里，我们使用重载的静态方法创建元组：
26752: 762:
26753: 763:```java
26754: 764:// onjava/Tuple.java
26755: 765:// Tuple library using type argument inference
26756: 766:package onjava;
26757: 767:
26758: 768:public class Tuple {
26759: 769:    public static <A, B> Tuple2<A, B> tuple(A a, B b) {
26760: 770:        return new Tuple2<>(a, b);
26761: 771:    }
26762: 772:
26763: 773:    public static <A, B, C> Tuple3<A, B, C>
26764: 774:    tuple(A a, B b, C c) {
26765: 775:        return new Tuple3<>(a, b, c);
26766: 776:    }
26767: 777:
26768: 778:    public static <A, B, C, D> Tuple4<A, B, C, D>
26769: 779:    tuple(A a, B b, C c, D d) {
26770: 780:        return new Tuple4<>(a, b, c, d);
26771: 781:    }
26772: 782:
26773: 783:    public static <A, B, C, D, E>
26774: 784:    Tuple5<A, B, C, D, E> tuple(A a, B b, C c, D d, E e) {
26775: 785:        return new Tuple5<>(a, b, c, d, e);
26776: 786:    }
26777: 787:}
26778: 788:```
26779: 789:
26780: 790:我们修改 **TupleTest.java** 来测试 **Tuple.java** :
26781: 791:
26782: 792:```java
26783: 793:// generics/TupleTest2.java
26784: 794:
26785: 795:import onjava.Tuple2;
26786: 796:import onjava.Tuple3;
26787: 797:import onjava.Tuple4;
26788: 798:import onjava.Tuple5;
26789: 799:
26790: 800:import static onjava.Tuple.tuple;
26791: 801:
26792: 802:public class TupleTest2 {
26793: 803:    static Tuple2<String, Integer> f() {
26794: 804:        return tuple("hi", 47);
26795: 805:    }
26796: 806:
26797: 807:    static Tuple2 f2() {
26798: 808:        return tuple("hi", 47);
26799: 809:    }
26800: 810:
26801: 811:    static Tuple3<Amphibian, String, Integer> g() {
26802: 812:        return tuple(new Amphibian(), "hi", 47);
26803: 813:    }
26804: 814:
26805: 815:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
26806: 816:        return tuple(
26807: 817:                new Vehicle(), new Amphibian(), "hi", 47);
26808: 818:    }
26809: 819:
26810: 820:    static Tuple5<Vehicle, Amphibian,
26811: 821:            String, Integer, Double> k() {
26812: 822:        return tuple(new Vehicle(), new Amphibian(),
26813: 823:                "hi", 47, 11.1);
26814: 824:    }
26815: 825:
26816: 826:    public static void main(String[] args) {
26817: 827:        Tuple2<String, Integer> ttsi = f();
26818: 828:        System.out.println(ttsi);
26819: 829:        System.out.println(f2());
26820: 830:        System.out.println(g());
26821: 831:        System.out.println(h());
26822: 832:        System.out.println(k());
26823: 833:    }
26824: 834:}
26825: 835:/* Output:
26826: 836:(hi, 47)
26827: 837:(hi, 47)
26828: 838:(Amphibian@14ae5a5, hi, 47)
26829: 839:(Vehicle@135fbaa4, Amphibian@45ee12a7, hi, 47)
26830: 840:(Vehicle@4b67cf4d, Amphibian@7ea987ac, hi, 47, 11.1)
26831: 841:*/
26832: 842:```
26833: 843:
26834: 844:请注意，`f()` 返回一个参数化的 **Tuple2** 对象，而 `f2()` 返回一个未参数化的 **Tuple2** 对象。编译器不会在这里警告 `f2()` ，因为返回值未以参数化方式使用。从某种意义上说，它被“向上转型”为一个未参数化的 **Tuple2** 。 但是，如果尝试将 `f2()` 的结果放入到参数化的 **Tuple2** 中，则编译器将发出警告。
26835: 845:
26836: 846:<!-- A Set Utility -->
26837: 847:
26838: 848:### 一个 Set 工具
26839: 849:
26840: 850:对于泛型方法的另一个示例，请考虑由 **Set** 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法：
26841: 851:
26842: 852:```java
26843: 853:// onjava/Sets.java
26844: 854:
26845: 855:package onjava;
26846: 856:
26847: 857:import java.util.HashSet;
26848: 858:import java.util.Set;
26849: 859:
26850: 860:public class Sets {
26851: 861:    public static <T> Set<T> union(Set<T> a, Set<T> b) {
26852: 862:        Set<T> result = new HashSet<>(a);
26853: 863:        result.addAll(b);
26854: 864:        return result;
26855: 865:    }
26856: 866:
26857: 867:    public static <T>
26858: 868:    Set<T> intersection(Set<T> a, Set<T> b) {
26859: 869:        Set<T> result = new HashSet<>(a);
26860: 870:        result.retainAll(b);
26861: 871:        return result;
26862: 872:    }
26863: 873:
26864: 874:    // Subtract subset from superset:
26865: 875:    public static <T> Set<T>
26866: 876:    difference(Set<T> superset, Set<T> subset) {
26867: 877:        Set<T> result = new HashSet<>(superset);
26868: 878:        result.removeAll(subset);
26869: 879:        return result;
26870: 880:    }
26871: 881:
26872: 882:    // Reflexive--everything not in the intersection:
26873: 883:    public static <T> Set<T> complement(Set<T> a, Set<T> b) {
26874: 884:        return difference(union(a, b), intersection(a, b));
26875: 885:    }
26876: 886:}
26877: 887:```
26878: 888:
26879: 889:前三个方法通过将第一个参数的引用复制到新的 **HashSet** 对象中来复制第一个参数，因此不会直接修改参数集合。因此，返回值是一个新的 **Set** 对象。
26880: 890:
26881: 891:这四种方法代表数学集合操作： `union()` 返回一个包含两个参数并集的 **Set** ， `intersection()` 返回一个包含两个参数集合交集的 **Set** ， `difference()` 从 **superset** 中减去 **subset** 的元素 ，而 `complement()` 返回所有不在交集中的元素的 **Set**。作为显示这些方法效果的简单示例的一部分，下面是一个包含不同水彩名称的 **enum** ：
26882: 892:
26883: 893:```java
26884: 894:// generics/watercolors/Watercolors.java
26885: 895:
26886: 896:package watercolors;
26887: 897:
26888: 898:public enum Watercolors {
26889: 899:    ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW,
26890: 900:    ORANGE, BRILLIANT_RED, CRIMSON, MAGENTA,
26891: 901:    ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE,
26892: 902:    PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE,
26893: 903:    PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN,
26894: 904:    YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
26895: 905:    BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK
26896: 906:}
26897: 907:```
26898: 908:
26899: 909:为了方便起见（不必全限定所有名称），将其静态导入到以下示例中。本示例使用 **EnumSet** 轻松从 **enum** 中创建 **Set** 。（可以在[第二十二章 枚举](book/22-Enumerations.md)一章中了解有关 **EnumSet** 的更多信息。）在这里，静态方法 `EnumSet.range()` 要求提供所要在结果 **Set** 中创建的元素范围的第一个和最后一个元素：
26900: 910:
26901: 911:```java
26902: 912:// generics/WatercolorSets.java
26903: 913:
26904: 914:import watercolors.*;
26905: 915:
26906: 916:import java.util.EnumSet;
26907: 917:import java.util.Set;
26908: 918:
26909: 919:import static watercolors.Watercolors.*;
26910: 920:import static onjava.Sets.*;
26911: 921:
26912: 922:public class WatercolorSets {
26913: 923:    public static void main(String[] args) {
26914: 924:        Set<Watercolors> set1 =
26915: 925:                EnumSet.range(BRILLIANT_RED, VIRIDIAN_HUE);
26916: 926:        Set<Watercolors> set2 =
26917: 927:                EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER);
26918: 928:        System.out.println("set1: " + set1);
26919: 929:        System.out.println("set2: " + set2);
26920: 930:        System.out.println(
26921: 931:                "union(set1, set2): " + union(set1, set2));
26922: 932:        Set<Watercolors> subset = intersection(set1, set2);
26923: 933:        System.out.println(
26924: 934:                "intersection(set1, set2): " + subset);
26925: 935:        System.out.println("difference(set1, subset): " +
26926: 936:                difference(set1, subset));
26927: 937:        System.out.println("difference(set2, subset): " +
26928: 938:                difference(set2, subset));
26929: 939:        System.out.println("complement(set1, set2): " +
26930: 940:                complement(set1, set2));
26931: 941:    }
26932: 942:}
26933: 943:/* Output:
26934: 944:set1: [BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER,
26935: 945:VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
26936: 946:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE]
26937: 947:set2: [CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
26938: 948:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE,
26939: 949:SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
26940: 950:BURNT_UMBER]
26941: 951:union(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
26942: 952:YELLOW_OCHRE, MAGENTA, SAP_GREEN, CERULEAN_BLUE_HUE,
26943: 953:ULTRAMARINE, VIRIDIAN_HUE, VIOLET, RAW_UMBER,
26944: 954:ROSE_MADDER, PERMANENT_GREEN, BURNT_UMBER,
26945: 955:PHTHALO_BLUE, CRIMSON, COBALT_BLUE_HUE]
26946: 956:intersection(set1, set2): [PERMANENT_GREEN,
26947: 957:CERULEAN_BLUE_HUE, ULTRAMARINE, VIRIDIAN_HUE,
26948: 958:PHTHALO_BLUE, COBALT_BLUE_HUE]
26949: 959:difference(set1, subset): [BRILLIANT_RED, MAGENTA,
26950: 960:VIOLET, CRIMSON, ROSE_MADDER]
26951: 961:difference(set2, subset): [BURNT_SIENNA, YELLOW_OCHRE,
26952: 962:BURNT_UMBER, SAP_GREEN, RAW_UMBER]
26953: 963:complement(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
26954: 964:YELLOW_OCHRE, MAGENTA, SAP_GREEN, VIOLET, RAW_UMBER,
26955: 965:ROSE_MADDER, BURNT_UMBER, CRIMSON]
26956: 966:*/
26957: 967:```
26958: 968:
26959: 969:接下来的例子使用 `Sets.difference()` 方法来展示 **java.util** 包中各种 **Collection** 和 **Map** 类之间的方法差异：
26960: 970:
26961: 971:```java
26962: 972:// onjava/CollectionMethodDifferences.java
26963: 973:// {java onjava.CollectionMethodDifferences}
26964: 974:
26965: 975:package onjava;
26966: 976:
26967: 977:import java.lang.reflect.Method;
26968: 978:import java.util.*;
26969: 979:import java.util.stream.Collectors;
26970: 980:
26971: 981:public class CollectionMethodDifferences {
26972: 982:    static Set<String> methodSet(Class<?> type) {
26973: 983:        return Arrays.stream(type.getMethods())
26974: 984:                .map(Method::getName)
26975: 985:                .collect(Collectors.toCollection(TreeSet::new));
26976: 986:    }
26977: 987:
26978: 988:    static void interfaces(Class<?> type) {
26979: 989:        System.out.print("Interfaces in " +
26980: 990:                type.getSimpleName() + ": ");
26981: 991:        System.out.println(
26982: 992:                Arrays.stream(type.getInterfaces())
26983: 993:                        .map(Class::getSimpleName)
26984: 994:                        .collect(Collectors.toList()));
26985: 995:    }
26986: 996:
26987: 997:    static Set<String> object = methodSet(Object.class);
26988: 998:
26989: 999:    static {
26990: 1000:        object.add("clone");
26991: 1001:    }
26992: 1002:
26993: 1003:    static void
26994: 1004:    difference(Class<?> superset, Class<?> subset) {
26995: 1005:        System.out.print(superset.getSimpleName() +
26996: 1006:                " extends " + subset.getSimpleName() +
26997: 1007:                ", adds: ");
26998: 1008:        Set<String> comp = Sets.difference(
26999: 1009:                methodSet(superset), methodSet(subset));
27000: 1010:        comp.removeAll(object); // Ignore 'Object' methods
27001: 1011:        System.out.println(comp);
27002: 1012:        interfaces(superset);
27003: 1013:    }
27004: 1014:
27005: 1015:    public static void main(String[] args) {
27006: 1016:        System.out.println("Collection: " +
27007: 1017:                methodSet(Collection.class));
27008: 1018:        interfaces(Collection.class);
27009: 1019:        difference(Set.class, Collection.class);
27010: 1020:        difference(HashSet.class, Set.class);
27011: 1021:        difference(LinkedHashSet.class, HashSet.class);
27012: 1022:        difference(TreeSet.class, Set.class);
27013: 1023:        difference(List.class, Collection.class);
27014: 1024:        difference(ArrayList.class, List.class);
27015: 1025:        difference(LinkedList.class, List.class);
27016: 1026:        difference(Queue.class, Collection.class);
27017: 1027:        difference(PriorityQueue.class, Queue.class);
27018: 1028:        System.out.println("Map: " + methodSet(Map.class));
27019: 1029:        difference(HashMap.class, Map.class);
27020: 1030:        difference(LinkedHashMap.class, HashMap.class);
27021: 1031:        difference(SortedMap.class, Map.class);
27022: 1032:        difference(TreeMap.class, Map.class);
27023: 1033:    }
27024: 1034:}
27025: 1035:/* Output:
27026: 1036:Collection: [add, addAll, clear, contains, containsAll,
27027: 1037:equals, forEach, hashCode, isEmpty, iterator,
27028: 1038:parallelStream, remove, removeAll, removeIf, retainAll,
27029: 1039:size, spliterator, stream, toArray]
27030: 1040:Interfaces in Collection: [Iterable]
27031: 1041:Set extends Collection, adds: []
27032: 1042:Interfaces in Set: [Collection]
27033: 1043:HashSet extends Set, adds: []
27034: 1044:Interfaces in HashSet: [Set, Cloneable, Serializable]
27035: 1045:LinkedHashSet extends HashSet, adds: []
27036: 1046:Interfaces in LinkedHashSet: [Set, Cloneable,
27037: 1047:Serializable]
27038: 1048:TreeSet extends Set, adds: [headSet,
27039: 1049:descendingIterator, descendingSet, pollLast, subSet,
27040: 1050:floor, tailSet, ceiling, last, lower, comparator,
27041: 1051:pollFirst, first, higher]
27042: 1052:Interfaces in TreeSet: [NavigableSet, Cloneable,
27043: 1053:Serializable]
27044: 1054:List extends Collection, adds: [replaceAll, get,
27045: 1055:indexOf, subList, set, sort, lastIndexOf, listIterator]
27046: 1056:Interfaces in List: [Collection]
27047: 1057:ArrayList extends List, adds: [trimToSize,
27048: 1058:ensureCapacity]
27049: 1059:Interfaces in ArrayList: [List, RandomAccess,
27050: 1060:Cloneable, Serializable]
27051: 1061:LinkedList extends List, adds: [offerFirst, poll,
27052: 1062:getLast, offer, getFirst, removeFirst, element,
27053: 1063:removeLastOccurrence, peekFirst, peekLast, push,
27054: 1064:pollFirst, removeFirstOccurrence, descendingIterator,
27055: 1065:pollLast, removeLast, pop, addLast, peek, offerLast,
27056: 1066:addFirst]
27057: 1067:Interfaces in LinkedList: [List, Deque, Cloneable,
27058: 1068:Serializable]
27059: 1069:Queue extends Collection, adds: [poll, peek, offer,
27060: 1070:element]
27061: 1071:Interfaces in Queue: [Collection]
27062: 1072:PriorityQueue extends Queue, adds: [comparator]
27063: 1073:Interfaces in PriorityQueue: [Serializable]
27064: 1074:Map: [clear, compute, computeIfAbsent,
27065: 1075:computeIfPresent, containsKey, containsValue, entrySet,
27066: 1076:equals, forEach, get, getOrDefault, hashCode, isEmpty,
27067: 1077:keySet, merge, put, putAll, putIfAbsent, remove,
27068: 1078:replace, replaceAll, size, values]
27069: 1079:HashMap extends Map, adds: []
27070: 1080:Interfaces in HashMap: [Map, Cloneable, Serializable]
27071: 1081:LinkedHashMap extends HashMap, adds: []
27072: 1082:Interfaces in LinkedHashMap: [Map]
27073: 1083:SortedMap extends Map, adds: [lastKey, subMap,
27074: 1084:comparator, firstKey, headMap, tailMap]
27075: 1085:Interfaces in SortedMap: [Map]
27076: 1086:TreeMap extends Map, adds: [descendingKeySet,
27077: 1087:navigableKeySet, higherEntry, higherKey, floorKey,
27078: 1088:subMap, ceilingKey, pollLastEntry, firstKey, lowerKey,
27079: 1089:headMap, tailMap, lowerEntry, ceilingEntry,
27080: 1090:descendingMap, pollFirstEntry, lastKey, firstEntry,
27081: 1091:floorEntry, comparator, lastEntry]
27082: 1092:Interfaces in TreeMap: [NavigableMap, Cloneable,
27083: 1093:Serializable]
27084: 1094:*/
27085: 1095:```
27086: 1096:
27087: 1097:在第十二章 [集合的本章小结](book/12-Collections.md#本章小结) 部分将会用到这里的输出结果。
27088: 1098:
27089: 1099:<!-- Building Complex Models -->
27090: 1100:
27091: 1101:## 构建复杂模型
27092: 1102:
27093: 1103:泛型的一个重要好处是能够简单安全地创建复杂模型。例如，我们可以轻松地创建一个元组列表：
27094: 1104:
27095: 1105:```java
27096: 1106:// generics/TupleList.java
27097: 1107:// Combining generic types to make complex generic types
27098: 1108:
27099: 1109:import onjava.Tuple4;
27100: 1110:
27101: 1111:import java.util.ArrayList;
27102: 1112:
27103: 1113:public class TupleList<A, B, C, D>
27104: 1114:        extends ArrayList<Tuple4<A, B, C, D>> {
27105: 1115:    public static void main(String[] args) {
27106: 1116:        TupleList<Vehicle, Amphibian, String, Integer> tl =
27107: 1117:                new TupleList<>();
27108: 1118:        tl.add(TupleTest2.h());
27109: 1119:        tl.add(TupleTest2.h());
27110: 1120:        tl.forEach(System.out::println);
27111: 1121:    }
27112: 1122:}
27113: 1123:/* Output:
27114: 1124:(Vehicle@7cca494b, Amphibian@7ba4f24f, hi, 47)
27115: 1125:(Vehicle@3b9a45b3, Amphibian@7699a589, hi, 47)
27116: 1126:*/
27117: 1127:```
27118: 1128:
27119: 1129:这将产生一个功能强大的数据结构，而无需太多代码。
27120: 1130:
27121: 1131:下面是第二个例子。每个类都是组成块，总体包含很多个块。在这里，该模型是一个具有过道，货架和产品的零售商店：
27122: 1132:
27123: 1133:```java
27124: 1134:// generics/Store.java
27125: 1135:// Building a complex model using generic collections
27126: 1136:
27127: 1137:import onjava.Suppliers;
27128: 1138:
27129: 1139:import java.util.ArrayList;
27130: 1140:import java.util.Random;
27131: 1141:import java.util.function.Supplier;
27132: 1142:
27133: 1143:class Product {
27134: 1144:    private final int id;
27135: 1145:    private String description;
27136: 1146:    private double price;
27137: 1147:
27138: 1148:    Product(int idNumber, String descr, double price) {
27139: 1149:        id = idNumber;
27140: 1150:        description = descr;
27141: 1151:        this.price = price;
27142: 1152:        System.out.println(toString());
27143: 1153:    }
27144: 1154:
27145: 1155:    @Override
27146: 1156:    public String toString() {
27147: 1157:        return id + ": " + description +
27148: 1158:                ", price: $" + price;
27149: 1159:    }
27150: 1160:
27151: 1161:    public void priceChange(double change) {
27152: 1162:        price += change;
27153: 1163:    }
27154: 1164:
27155: 1165:    public static Supplier<Product> generator =
27156: 1166:            new Supplier<Product>() {
27157: 1167:                private Random rand = new Random(47);
27158: 1168:
27159: 1169:                @Override
27160: 1170:                public Product get() {
27161: 1171:                    return new Product(rand.nextInt(1000), "Test",
27162: 1172:                            Math.round(
27163: 1173:                                    rand.nextDouble() * 1000.0) + 0.99);
27164: 1174:                }
27165: 1175:            };
27166: 1176:}
27167: 1177:
27168: 1178:class Shelf extends ArrayList<Product> {
27169: 1179:    Shelf(int nProducts) {
27170: 1180:        Suppliers.fill(this, Product.generator, nProducts);
27171: 1181:    }
27172: 1182:}
27173: 1183:
27174: 1184:class Aisle extends ArrayList<Shelf> {
27175: 1185:    Aisle(int nShelves, int nProducts) {
27176: 1186:        for (int i = 0; i < nShelves; i++)
27177: 1187:            add(new Shelf(nProducts));
27178: 1188:    }
27179: 1189:}
27180: 1190:
27181: 1191:class CheckoutStand {
27182: 1192:}
27183: 1193:
27184: 1194:class Office {
27185: 1195:}
27186: 1196:
27187: 1197:public class Store extends ArrayList<Aisle> {
27188: 1198:    private ArrayList<CheckoutStand> checkouts =
27189: 1199:            new ArrayList<>();
27190: 1200:    private Office office = new Office();
27191: 1201:
27192: 1202:    public Store(
27193: 1203:            int nAisles, int nShelves, int nProducts) {
27194: 1204:        for (int i = 0; i < nAisles; i++)
27195: 1205:            add(new Aisle(nShelves, nProducts));
27196: 1206:    }
27197: 1207:
27198: 1208:    @Override
27199: 1209:    public String toString() {
27200: 1210:        StringBuilder result = new StringBuilder();
27201: 1211:        for (Aisle a : this)
27202: 1212:            for (Shelf s : a)
27203: 1213:                for (Product p : s) {
27204: 1214:                    result.append(p);
27205: 1215:                    result.append("\n");
27206: 1216:                }
27207: 1217:        return result.toString();
27208: 1218:    }
27209: 1219:
27210: 1220:    public static void main(String[] args) {
27211: 1221:        System.out.println(new Store(5, 4, 3));
27212: 1222:    }
27213: 1223:}
27214: 1224:/* Output: (First 8 Lines)
27215: 1225:258: Test, price: $400.99
27216: 1226:861: Test, price: $160.99
27217: 1227:868: Test, price: $417.99
27218: 1228:207: Test, price: $268.99
27219: 1229:551: Test, price: $114.99
27220: 1230:278: Test, price: $804.99
27221: 1231:520: Test, price: $554.99
27222: 1232:140: Test, price: $530.99
27223: 1233:                  ...
27224: 1234:*/
27225: 1235:```
27226: 1236:
27227: 1237:`Store.toString()` 显示了结果：尽管有复杂的层次结构，但多层的集合仍然是类型安全的和可管理的。令人印象深刻的是，组装这样的模型并不需要耗费过多精力。
27228: 1238:
27229: 1239:**Shelf** 使用 `Suppliers.fill()` 这个实用程序，该实用程序接受 **Collection** （第一个参数），并使用 **Supplier** （第二个参数），以元素的数量为 **n** （第三个参数）来填充它。 **Suppliers** 类将会在本章末尾定义，其中的方法都是在执行某种填充操作，并在本章的其他示例中使用。
27230: 1240:
27231: 1241:<!-- The Mystery of Erasure -->
27232: 1242:
27233: 1243:## 泛型擦除
27234: 1244:
27235: 1245:当你开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的。例如，尽管可以说  `ArrayList.class`，但不能说成 `ArrayList<Integer>.class`。考虑下面的情况：
27236: 1246:
27237: 1247:```java
27238: 1248:// generics/ErasedTypeEquivalence.java
27239: 1249:
27240: 1250:import java.util.*;
27241: 1251:
27242: 1252:public class ErasedTypeEquivalence {
27243: 1253:    
27244: 1254:    public static void main(String[] args) {
27245: 1255:        Class c1 = new ArrayList<String>().getClass();
27246: 1256:        Class c2 = new ArrayList<Integer>().getClass();
27247: 1257:        System.out.println(c1 == c2);
27248: 1258:    }
27249: 1259:    
27250: 1260:}
27251: 1261:/* Output:
27252: 1262:true
27253: 1263:*/
27254: 1264:```
27255: 1265:
27256: 1266:`ArrayList<String>` 和 `ArrayList<Integer>` 应该是不同的类型。不同的类型会有不同的行为。例如，如果尝试向 `ArrayList<String>` 中放入一个 `Integer`，所得到的行为（失败）和向 `ArrayList<Integer>` 中放入一个 `Integer` 所得到的行为（成功）完全不同。然而上面的程序认为它们是相同的类型。
27257: 1267:
27258: 1268:下面的例子是对该谜题的补充：
27259: 1269:
27260: 1270:```java
27261: 1271:// generics/LostInformation.java
27262: 1272:
27263: 1273:import java.util.*;
27264: 1274:
27265: 1275:class Frob {}
27266: 1276:class Fnorkle {}
27267: 1277:class Quark<Q> {}
27268: 1278:
27269: 1279:class Particle<POSITION, MOMENTUM> {}
27270: 1280:
27271: 1281:public class LostInformation {
27272: 1282:
27273: 1283:    public static void main(String[] args) {
27274: 1284:        List<Frob> list = new ArrayList<>();
27275: 1285:        Map<Frob, Fnorkle> map = new HashMap<>();
27276: 1286:        Quark<Fnorkle> quark = new Quark<>();
27277: 1287:        Particle<Long, Double> p = new Particle<>();
27278: 1288:        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));
27279: 1289:        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));
27280: 1290:        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));
27281: 1291:        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));
27282: 1292:    }
27283: 1293:
27284: 1294:}
27285: 1295:/* Output:
27286: 1296:[E]
27287: 1297:[K,V]
27288: 1298:[Q]
27289: 1299:[POSITION,MOMENTUM]
27290: 1300:*/
27291: 1301:```
27292: 1302:
27293: 1303:根据 JDK 文档，**Class.getTypeParameters()** “返回一个 **TypeVariable** 对象数组，表示泛型声明中声明的类型参数...” 这暗示你可以发现这些参数类型。但是正如上例中输出所示，你只能看到用作参数占位符的标识符，这并非有用的信息。
27294: 1304:
27295: 1305:残酷的现实是：
27296: 1306:
27297: 1307:在泛型代码内部，无法获取任何有关泛型参数类型的信息。
27298: 1308:
27299: 1309:因此，你可以知道如类型参数标识符和泛型边界这些信息，但无法得知实际的类型参数从而用来创建特定的实例。如果你曾是 C++ 程序员，那么这个事实会让你很沮丧，在使用 Java 泛型工作时，它是必须处理的最基本的问题。
27300: 1310:
27301: 1311:Java 泛型是使用擦除实现的。这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此，`List<String>` 和 `List<Integer>` 在运行时实际上是相同的类型。它们都被擦除成原生类型 `List`。
27302: 1312:
27303: 1313:理解擦除并知道如何处理它，是你在学习 Java 泛型时面临的最大障碍之一。这也是本节将要探讨的内容。
27304: 1314:
27305: 1315:### C++ 的方式
27306: 1316:
27307: 1317:下面是使用模版的 C++ 示例。你会看到类型参数的语法十分相似，因为 Java 是受 C++ 启发的：
27308: 1318:
27309: 1319:```c++
27310: 1320:// generics/Templates.cpp
27311: 1321:
27312: 1322:#include <iostream>
27313: 1323:using namespace std;
27314: 1324:
27315: 1325:template<class T> class Manipulator {
27316: 1326:    T obj;
27317: 1327:public:
27318: 1328:    Manipulator(T x) { obj = x; }
27319: 1329:    void manipulate() { obj.f(); }
27320: 1330:};
27321: 1331:
27322: 1332:class HasF {
27323: 1333:public:
27324: 1334:    void f() { cout << "HasF::f()" << endl; }
27325: 1335:};
27326: 1336:
27327: 1337:int main() {
27328: 1338:    HasF hf;
27329: 1339:    Manipulator<HasF> manipulator(hf);
27330: 1340:    manipulator.manipulate();
27331: 1341:}
27332: 1342:/* Output:
27333: 1343:HasF::f()
27334: 1344:*/
27335: 1345:```
27336: 1346:
27337: 1347:**Manipulator** 类存储了一个 **T** 类型的对象。`manipulate()` 方法会调用 **obj** 上的 `f()` 方法。它是如何知道类型参数 **T** 中存在 `f()` 方法的呢？C++ 编译器会在你实例化模版时进行检查，所以在 `Manipulator<HasF>` 实例化的那一刻，它看到 **HasF** 中含有一个方法 `f()`。如果情况并非如此，你就会得到一个编译期错误，保持类型安全。
27338: 1348:
27339: 1349:用 C++ 编写这种代码很简单，因为当模版被实例化时，模版代码就知道模版参数的类型。Java 泛型就不同了。下面是 **HasF** 的 Java 版本：
27340: 1350:
27341: 1351:```java
27342: 1352:// generics/HasF.java
27343: 1353:
27344: 1354:public class HasF {
27345: 1355:    public void f() {
27346: 1356:        System.out.println("HasF.f()");
27347: 1357:    }
27348: 1358:}
27349: 1359:```
27350: 1360:
27351: 1361:如果我们将示例的其余代码用 Java 实现，就不会通过编译：
27352: 1362:
27353: 1363:```java
27354: 1364:// generics/Manipulation.java
27355: 1365:// {WillNotCompile}
27356: 1366:
27357: 1367:class Manipulator<T> {
27358: 1368:    private T obj;
27359: 1369:    
27360: 1370:    Manipulator(T x) {
27361: 1371:        obj = x;
27362: 1372:    }
27363: 1373:    
27364: 1374:    // Error: cannot find symbol: method f():
27365: 1375:    public void manipulate() {
27366: 1376:        obj.f();
27367: 1377:    }
27368: 1378:}
27369: 1379:
27370: 1380:public class Manipulation {
27371: 1381:	public static void main(String[] args) {
27372: 1382:        HasF hf = new HasF();
27373: 1383:        Manipulator<HasF> manipulator = new Manipulator<>(hf);
27374: 1384:        manipulator.manipulate();
27375: 1385:    }
27376: 1386:}
27377: 1387:```
27378: 1388:
27379: 1389:因为擦除，Java 编译器无法将 `manipulate()` 方法必须能调用 **obj** 的 `f()` 方法这一需求映射到 HasF 具有 `f()` 方法这个事实上。为了调用 `f()`，我们必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。这里重用了 **extends** 关键字。由于有了边界，下面的代码就能通过编译：
27380: 1390:
27381: 1391:```java
27382: 1392:public class Manipulator2<T extends HasF> {
27383: 1393:    private T obj;
27384: 1394:
27385: 1395:    Manipulator2(T x) {
27386: 1396:        obj = x;
27387: 1397:    }
27388: 1398:
27389: 1399:    public void manipulate() {
27390: 1400:        obj.f();
27391: 1401:    }
27392: 1402:}
27393: 1403:```
27394: 1404:
27395: 1405:边界 `<T extends HasF>` 声明 T 必须是 HasF 类型或其子类。如果情况确实如此，就可以安全地在 **obj** 上调用 `f()` 方法。
27396: 1406:
27397: 1407:我们说泛型类型参数会擦除到它的第一个边界（可能有多个边界，稍后你将看到）。我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的示例，**T** 擦除到了 **HasF**，就像在类的声明中用 **HasF** 替换了 **T** 一样。
27398: 1408:
27399: 1409:你可能正确地观察到了泛型在 **Manipulator2.java** 中没有贡献任何事。你可以很轻松地自己去执行擦除，生成没有泛型的类：
27400: 1410:
27401: 1411:```java
27402: 1412:// generics/Manipulator3.java
27403: 1413:
27404: 1414:class Manipulator3 {
27405: 1415:    private HasF obj;
27406: 1416:    
27407: 1417:    Manipulator3(HasF x) {
27408: 1418:        obj = x;
27409: 1419:    }
27410: 1420:    
27411: 1421:    public void manipulate() {
27412: 1422:        obj.f();
27413: 1423:    }
27414: 1424:}
27415: 1425:```
27416: 1426:
27417: 1427:这提出了很重要的一点：泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用。因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换更加复杂。但是，不能因此认为使用 `<T extends HasF>` 形式就是有缺陷的。例如，如果某个类有一个返回 **T** 的方法，那么泛型就有所帮助，因为它们之后将返回确切的类型：
27418: 1428:
27419: 1429:```java
27420: 1430:// generics/ReturnGenericType.java
27421: 1431:
27422: 1432:public class ReturnGenericType<T extends HasF> {
27423: 1433:    private T obj;
27424: 1434:    
27425: 1435:    ReturnGenericType(T x) {
27426: 1436:        obj = x;
27427: 1437:    }
27428: 1438:    
27429: 1439:    public T get() {
27430: 1440:        return obj;
27431: 1441:    }
27432: 1442:}
27433: 1443:```
27434: 1444:
27435: 1445:你必须查看所有的代码，从而确定代码是否复杂到必须使用泛型的程度。
27436: 1446:
27437: 1447:我们将在本章稍后看到有关边界的更多细节。
27438: 1448:
27439: 1449:### 迁移兼容性
27440: 1450:
27441: 1451:为了减少潜在的关于擦除的困惑，你必须清楚地认识到这不是一个语言特性。它是 Java 实现泛型的一种妥协，因为泛型不是 Java 语言出现时就有的，所以就有了这种妥协。它会使你痛苦，因此你需要尽早习惯它并了解为什么它会这样。
27442: 1452:
27443: 1453:如果 Java 1.0 就含有泛型的话，那么这个特性就不会使用擦除来实现——它会使用具体化，保持参数类型为第一类实体，因此你就能在类型参数上执行基于类型的语言操作和反射操作。本章稍后你会看到，擦除减少了泛型的泛化性。泛型在 Java 中仍然是有用的，只是不如它们本来设想的那么有用，而原因就是擦除。
27444: 1454:
27445: 1455:在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文使用泛型类型。泛型类型只有在静态类型检测期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如， `List<T>` 这样的类型注解会被擦除为 **List**，普通的类型变量在未指定边界的情况下会被擦除为 **Object**。
27446: 1456:
27447: 1457:擦除的核心动机是你可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称为“迁移兼容性”。在理想情况下，所有事物将在指定的某天被泛化。在现实中，即使程序员只编写泛型代码，他们也必须处理 Java 5 之前编写的非泛型类库。这些类库的作者可能从没想过要泛化他们的代码，或许他们可能刚刚开始接触泛型。
27448: 1458:
27449: 1459:因此 Java 泛型不仅必须支持向后兼容性——现有的代码和类文件仍然合法，继续保持之前的含义——而且还必须支持迁移兼容性，使得类库能按照它们自己的步调变为泛型，当某个类库变为泛型时，不会破坏依赖于它的代码和应用。在确定了这个目标后，Java 设计者们和从事此问题相关工作的各个团队决策认为擦除是唯一可行的解决方案。擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。
27450: 1460:
27451: 1461:例如，假设一个应用使用了两个类库 **X** 和 **Y**，**Y** 使用了类库 **Z**。随着 Java 5 的出现，这个应用和这些类库的创建者最终可能希望迁移到泛型上。但是当进行迁移时，它们有着不同的动机和限制。为了实现迁移兼容性，每个类库与应用必须与其他所有的部分是否使用泛型无关。因此，它们不能探测其他类库是否使用了泛型。因此，某个特定的类库使用了泛型这样的证据必须被”擦除“。
27452: 1462:
27453: 1463:如果没有某种类型的迁移途径，所有已经构建了很长时间的类库就需要与希望迁移到 Java 泛型上的开发者们说再见了。类库毫无争议是编程语言的一部分，对生产效率有着极大的影响，所以这种代码无法接受。擦除是否是最佳的或唯一的迁移途径，还待时间来证明。
27454: 1464:
27455: 1465:### 擦除的问题
27456: 1466:
27457: 1467:因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。擦除允许你继续使用现有的非泛型客户端代码，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会骤然破坏所有现有的代码。
27458: 1468:
27459: 1469:擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作中，例如转型、**instanceof** 操作和 **new** 表达式。因为所有关于参数的类型信息都丢失了，当你在编写泛型代码时，必须时刻提醒自己，你只是看起来拥有有关参数的类型信息而已。
27460: 1470:
27461: 1471:考虑如下的代码段：
27462: 1472:
27463: 1473:```java
27464: 1474:class Foo<T> {
27465: 1475:    T var;
27466: 1476:}
27467: 1477:```
27468: 1478:
27469: 1479:看上去当你创建一个 **Foo** 实例时：
27470: 1480:
27471: 1481:```java
27472: 1482:Foo<Cat> f = new Foo<>();
27473: 1483:```
27474: 1484:
27475: 1485:**class** **Foo** 中的代码应该知道现在工作于 **Cat** 之上。泛型语法也在强烈暗示整个类中所有 T 出现的地方都被替换，就像在 C++ 中一样。但是事实并非如此，当你在编写这个类的代码时，必须提醒自己：“不，这只是一个 **Object**“。
27476: 1486:
27477: 1487:另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管你可能希望这样：
27478: 1488:
27479: 1489:```java
27480: 1490:// generics/ErasureAndInheritance.java
27481: 1491:
27482: 1492:class GenericBase<T> {
27483: 1493:    private T element;
27484: 1494:    
27485: 1495:    public void set(T arg) {
27486: 1496:        element = arg;
27487: 1497:    }
27488: 1498:    
27489: 1499:    public T get() {
27490: 1500:        return element;
27491: 1501:    }
27492: 1502:}
27493: 1503:
27494: 1504:class Derived1<T> extends GenericBase<T> {}
27495: 1505:
27496: 1506:class Derived2 extends GenericBase {} // No warning
27497: 1507:
27498: 1508:// class Derived3 extends GenericBase<?> {}
27499: 1509:// Strange error:
27500: 1510:// unexpected type
27501: 1511:// required: class or interface without bounds
27502: 1512:public class ErasureAndInteritance {
27503: 1513:    @SuppressWarnings("unchecked")
27504: 1514:    public static void main(String[] args) {
27505: 1515:        Derived2 d2 = new Derived2();
27506: 1516:        Object obj = d2.get();
27507: 1517:        d2.set(obj); // Warning here!
27508: 1518:    }
27509: 1519:}
27510: 1520:```
27511: 1521:
27512: 1522:**Derived2** 继承自 **GenericBase**，但是没有任何类型参数，编译器没有发出任何警告。直到调用 `set()` 方法时才出现警告。
27513: 1523:
27514: 1524:为了关闭警告，Java 提供了一个注解，我们可以在列表中看到它：
27515: 1525:
27516: 1526:```java
27517: 1527:@SuppressWarnings("unchecked")
27518: 1528:```
27519: 1529:
27520: 1530:这个注解放置在产生警告的方法上，而不是整个类上。当你要关闭警告时，最好尽可能地“聚焦”，这样就不会因为过于宽泛地关闭警告，而导致意外地遮蔽掉真正的问题。
27521: 1531:
27522: 1532:可以推断，**Derived3** 产生的错误意味着编译器期望得到一个原生基类。
27523: 1533:
27524: 1534:当你希望将类型参数不仅仅当作 Object 处理时，就需要付出额外努力来管理边界，并且与在 C++、Ada 和 Eiffel 这样的语言中获得参数化类型相比，你需要付出多得多的努力来获得少得多的回报。这并不是说，对于大多数的编程问题而言，这些语言通常都会比 Java 更得心应手，只是说它们的参数化类型机制相比 Java 更灵活、更强大。
27525: 1535:
27526: 1536:### 边界处的动作
27527: 1537:
27528: 1538:因为擦除，我发现了泛型最令人困惑的方面是可以表示没有任何意义的事物。例如：
27529: 1539:
27530: 1540:```java
27531: 1541:// generics/ArrayMaker.java
27532: 1542:
27533: 1543:import java.lang.reflect.*;
27534: 1544:import java.util.*;
27535: 1545:
27536: 1546:public class ArrayMaker<T> {
27537: 1547:    private Class<T> kind;
27538: 1548:
27539: 1549:    public ArrayMaker(Class<T> kind) {
27540: 1550:        this.kind = kind;
27541: 1551:    }
27542: 1552:
27543: 1553:    @SuppressWarnings("unchecked")
27544: 1554:    T[] create(int size) {
27545: 1555:        return (T[]) Array.newInstance(kind, size);
27546: 1556:    }
27547: 1557:
27548: 1558:    public static void main(String[] args) {
27549: 1559:        ArrayMaker<String> stringMaker = new ArrayMaker<>(String.class);
27550: 1560:        String[] stringArray = stringMaker.create(9);
27551: 1561:        System.out.println(Arrays.toString(stringArray));
27552: 1562:    }
27553: 1563:}
27554: 1564:/* Output
27555: 1565:[null,null,null,null,null,null,null,null,null]
27556: 1566:*/
27557: 1567:```
27558: 1568:
27559: 1569:即使 **kind** 被存储为 `Class<T>`，擦除也意味着它实际被存储为没有任何参数的 **Class**。因此，当你在使用它时，例如创建数组，`Array.newInstance()` 实际上并未拥有 **kind** 所蕴含的类型信息。所以它不会产生具体的结果，因而必须转型，这会产生一条令你无法满意的警告。
27560: 1570:
27561: 1571:注意，对于在泛型中创建数组，使用 `Array.newInstance()` 是推荐的方式。
27562: 1572:
27563: 1573:如果我们创建一个集合而不是数组，情况就不同了：
27564: 1574:
27565: 1575:```java
27566: 1576:// generics/ListMaker.java
27567: 1577:
27568: 1578:import java.util.*;
27569: 1579:
27570: 1580:public class ListMaker<T> {
27571: 1581:    List<T> create() {
27572: 1582:        return new ArrayList<>();
27573: 1583:    }
27574: 1584:    
27575: 1585:    public static void main(String[] args) {
27576: 1586:        ListMaker<String> stringMaker = new ListMaker<>();
27577: 1587:        List<String> stringList = stringMaker.create();
27578: 1588:    }
27579: 1589:}
27580: 1590:```
27581: 1591:
27582: 1592:编译器不会给出任何警告，尽管我们知道（从擦除中）在 `create()` 内部的 `new ArrayList<>()` 中的 `<T>` 被移除了——在运行时，类内部没有任何 `<T>`，因此这看起来毫无意义。但是如果你遵从这种思路，并将这个表达式改为 `new ArrayList()`，编译器就会发出警告。
27583: 1593:
27584: 1594:本例中这么做真的毫无意义吗？如果在创建 **List** 的同时向其中放入一些对象呢，像这样：
27585: 1595:
27586: 1596:```java
27587: 1597:// generics/FilledList.java
27588: 1598:
27589: 1599:import java.util.*;
27590: 1600:import java.util.function.*;
27591: 1601:import onjava.*;
27592: 1602:
27593: 1603:public class FilledList<T> extends ArrayList<T> {
27594: 1604:    FilledList(Supplier<T> gen, int size) {
27595: 1605:        Suppliers.fill(this, gen, size);
27596: 1606:    }
27597: 1607:    
27598: 1608:    public FilledList(T t, int size) {
27599: 1609:        for (int i = 0; i < size; i++) {
27600: 1610:            this.add(t);
27601: 1611:        }
27602: 1612:    }
27603: 1613:    
27604: 1614:    public static void main(String[] args) {
27605: 1615:        List<String> list = new FilledList<>("Hello", 4);
27606: 1616:        System.out.println(list);
27607: 1617:        // Supplier version:
27608: 1618:        List<Integer> ilist = new FilledList<>(() -> 47, 4);
27609: 1619:        System.out.println(ilist);
27610: 1620:    }
27611: 1621:}
27612: 1622:/* Output:
27613: 1623:[Hello,Hello,Hello,Hello]
27614: 1624:[47,47,47,47]
27615: 1625:*/
27616: 1626:```
27617: 1627:
27618: 1628:即使编译器无法得知 `add()` 中的 **T** 的任何信息，但它仍可以在编译期确保你放入 **FilledList** 中的对象是 **T** 类型。因此，即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。
27619: 1629:
27620: 1630:因为擦除移除了方法体中的类型信息，所以在运行时的问题就是*边界*：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。
27621: 1631:
27622: 1632:考虑如下这段非泛型示例：
27623: 1633:
27624: 1634:```java
27625: 1635:// generics/SimpleHolder.java
27626: 1636:
27627: 1637:public class SimpleHolder {
27628: 1638:    private Object obj;
27629: 1639:    
27630: 1640:    public void set(Object obj) {
27631: 1641:        this.obj = obj;
27632: 1642:    }
27633: 1643:    
27634: 1644:    public Object get() {
27635: 1645:        return obj;
27636: 1646:    }
27637: 1647:    
27638: 1648:    public static void main(String[] args) {
27639: 1649:        SimpleHolder holder = new SimpleHolder();
27640: 1650:        holder.set("Item");
27641: 1651:        String s = (String) holder.get();
27642: 1652:    }
27643: 1653:}
27644: 1654:```
27645: 1655:
27646: 1656:如果用 **javap -c SimpleHolder** 反编译这个类，会得到如下内容（经过编辑）：
27647: 1657:
27648: 1658:```java
27649: 1659:public void set(java.lang.Object);
27650: 1660:   0: aload_0
27651: 1661:   1: aload_1
27652: 1662:   2: putfield #2; // Field obj:Object;
27653: 1663:   5: return
27654: 1664:    
27655: 1665:public java.lang.Object get();
27656: 1666:   0: aload_0
27657: 1667:   1: getfield #2; // Field obj:Object;
27658: 1668:   4: areturn
27659: 1669:    
27660: 1670:public static void main(java.lang.String[]);
27661: 1671:   0: new #3; // class SimpleHolder
27662: 1672:   3: dup
27663: 1673:   4: invokespecial #4; // Method "<init>":()V
27664: 1674:   7: astore_1
27665: 1675:   8: aload_1
27666: 1676:   9: ldc #5; // String Item
27667: 1677:   11: invokevirtual #6; // Method set:(Object;)V
27668: 1678:   14: aload_1
27669: 1679:   15: invokevirtual #7; // Method get:()Object;
27670: 1680:   18: checkcast #8; // class java/lang/String
27671: 1681:   21: astore_2
27672: 1682:   22: return
27673: 1683:```
27674: 1684:
27675: 1685:`set()` 和 `get()` 方法存储和产生值，转型在调用 `get()` 时接受检查。
27676: 1686:
27677: 1687:现在将泛型融入上例代码中：
27678: 1688:
27679: 1689:```java
27680: 1690:// generics/GenericHolder2.java
27681: 1691:
27682: 1692:public class GenericHolder2<T> {
27683: 1693:    private T obj;
27684: 1694:
27685: 1695:    public void set(T obj) {
27686: 1696:        this.obj = obj;
27687: 1697:    }
27688: 1698:
27689: 1699:    public T get() {
27690: 1700:        return obj;
27691: 1701:    }
27692: 1702:
27693: 1703:    public static void main(String[] args) {
27694: 1704:        GenericHolder2<String> holder =  new GenericHolder2<>();
27695: 1705:        holder.set("Item");
27696: 1706:        String s = holder.get();
27697: 1707:    }
27698: 1708:}
27699: 1709:```
27700: 1710:
27701: 1711:从 `get()` 返回后的转型消失了，但是我们还知道传递给 `set()` 的值在编译期会被检查。下面是相关的字节码：
27702: 1712:
27703: 1713:```java
27704: 1714:public void set(java.lang.Object);
27705: 1715:   0: aload_0
27706: 1716:   1: aload_1
27707: 1717:   2: putfield #2; // Field obj:Object;
27708: 1718:   5: return
27709: 1719:       
27710: 1720:public java.lang.Object get();
27711: 1721:   0: aload_0
27712: 1722:   1: getfield #2; // Field obj:Object;
27713: 1723:   4: areturn
27714: 1724:       
27715: 1725:public static void main(java.lang.String[]);
27716: 1726:   0: new #3; // class GenericHolder2
27717: 1727:   3: dup
27718: 1728:   4: invokespecial #4; // Method "<init>":()V
27719: 1729:   7: astore_1
27720: 1730:   8: aload_1
27721: 1731:   9: ldc #5; // String Item
27722: 1732:   11: invokevirtual #6; // Method set:(Object;)V
27723: 1733:   14: aload_1
27724: 1734:   15: invokevirtual #7; // Method get:()Object;
27725: 1735:   18: checkcast #8; // class java/lang/String
27726: 1736:   21: astore_2
27727: 1737:   22: return
27728: 1738:```
27729: 1739:
27730: 1740:所产生的字节码是相同的。对进入 `set()` 的类型进行检查是不需要的，因为这将由编译器执行。而对 `get()` 返回的值进行转型仍然是需要的，只不过不需要你来操作，它由编译器自动插入，这样你就不用编写（阅读）杂乱的代码。
27731: 1741:
27732: 1742:`get()` 和 `set()` 产生了相同的字节码，这就告诉我们泛型的所有动作都发生在边界处——对入参的编译器检查和对返回值的转型。这有助于澄清对擦除的困惑，记住：“边界就是动作发生的地方”。
27733: 1743:
27734: 1744:<!-- Compensating for Erasure -->
27735: 1745:
27736: 1746:## 补偿擦除
27737: 1747:
27738: 1748:因为擦除，我们将失去执行泛型代码中某些操作的能力。无法在运行时知道确切类型：
27739: 1749:
27740: 1750:```java
27741: 1751:// generics/Erased.java
27742: 1752:// {WillNotCompile}
27743: 1753:
27744: 1754:public class Erased<T> {
27745: 1755:    private final int SIZE = 100;
27746: 1756:
27747: 1757:    public void f(Object arg) {
27748: 1758:        // error: illegal generic type for instanceof
27749: 1759:        if (arg instanceof T) {
27750: 1760:        }
27751: 1761:        // error: unexpected type
27752: 1762:        T var = new T();
27753: 1763:        // error: generic array creation
27754: 1764:        T[] array = new T[SIZE];
27755: 1765:        // warning: [unchecked] unchecked cast
27756: 1766:        T[] array = (T[]) new Object[SIZE];
27757: 1767:
27758: 1768:    }
27759: 1769:}
27760: 1770:```
27761: 1771:
27762: 1772:有时，我们可以对这些问题进行编程，但是有时必须通过引入类型标签来补偿擦除。这意味着为所需的类型显式传递一个 **Class** 对象，以在类型表达式中使用它。
27763: 1773:
27764: 1774:例如，由于擦除了类型信息，因此在上一个程序中尝试使用 **instanceof** 将会失败。类型标签可以使用动态 `isInstance()` ：
27765: 1775:
27766: 1776:```java
27767: 1777:// generics/ClassTypeCapture.java
27768: 1778:
27769: 1779:class Building {
27770: 1780:}
27771: 1781:
27772: 1782:class House extends Building {
27773: 1783:}
27774: 1784:
27775: 1785:public class ClassTypeCapture<T> {
27776: 1786:    Class<T> kind;
27777: 1787:
27778: 1788:    public ClassTypeCapture(Class<T> kind) {
27779: 1789:        this.kind = kind;
27780: 1790:    }
27781: 1791:
27782: 1792:    public boolean f(Object arg) {
27783: 1793:        return kind.isInstance(arg);
27784: 1794:    }
27785: 1795:
27786: 1796:    public static void main(String[] args) {
27787: 1797:        ClassTypeCapture<Building> ctt1 =
27788: 1798:                new ClassTypeCapture<>(Building.class);
27789: 1799:        System.out.println(ctt1.f(new Building()));
27790: 1800:        System.out.println(ctt1.f(new House()));
27791: 1801:        ClassTypeCapture<House> ctt2 =
27792: 1802:                new ClassTypeCapture<>(House.class);
27793: 1803:        System.out.println(ctt2.f(new Building()));
27794: 1804:        System.out.println(ctt2.f(new House()));
27795: 1805:    }
27796: 1806:}
27797: 1807:/* Output:
27798: 1808:true
27799: 1809:true
27800: 1810:false
27801: 1811:true
27802: 1812:*/
27803: 1813:```
27804: 1814:
27805: 1815:编译器来保证类型标签与泛型参数相匹配。
27806: 1816:
27807: 1817:<!-- Creating Instances of Types -->
27808: 1818:
27809: 1819:### 创建类型的实例
27810: 1820:
27811: 1821:试图在 **Erased.java** 中 `new T()` 是行不通的，部分原因是由于擦除，部分原因是编译器无法验证 **T** 是否具有默认（无参）构造函数。但是在 C++ 中，此操作自然，直接且安全（在编译时检查）：
27812: 1822:
27813: 1823:```C++
27814: 1824:// generics/InstantiateGenericType.cpp
27815: 1825:// C++, not Java!
27816: 1826:
27817: 1827:template<class T> class Foo {
27818: 1828:  T x; // Create a field of type T
27819: 1829:  T* y; // Pointer to T
27820: 1830:public:
27821: 1831:  // Initialize the pointer:
27822: 1832:  Foo() { y = new T(); }
27823: 1833:};
27824: 1834:
27825: 1835:class Bar {};
27826: 1836:
27827: 1837:int main() {
27828: 1838:  Foo<Bar> fb;
27829: 1839:  Foo<int> fi; // ... and it works with primitives
27830: 1840:}
27831: 1841:```
27832: 1842:
27833: 1843:Java 中的解决方案是传入一个工厂对象，并使用该对象创建新实例。方便的工厂对象只是 **Class** 对象，因此，如果使用类型标记，则可以使用 `newInstance()` 创建该类型的新对象：
27834: 1844:
27835: 1845:```java
27836: 1846:// generics/InstantiateGenericType.java
27837: 1847:
27838: 1848:import java.util.function.Supplier;
27839: 1849:
27840: 1850:class ClassAsFactory<T> implements Supplier<T> {
27841: 1851:    Class<T> kind;
27842: 1852:
27843: 1853:    ClassAsFactory(Class<T> kind) {
27844: 1854:        this.kind = kind;
27845: 1855:    }
27846: 1856:
27847: 1857:    @Override
27848: 1858:    public T get() {
27849: 1859:        try {
27850: 1860:            return kind.newInstance();
27851: 1861:        } catch (InstantiationException |
27852: 1862:                IllegalAccessException e) {
27853: 1863:            throw new RuntimeException(e);
27854: 1864:        }
27855: 1865:    }
27856: 1866:}
27857: 1867:
27858: 1868:class Employee {
27859: 1869:    @Override
27860: 1870:    public String toString() {
27861: 1871:        return "Employee";
27862: 1872:    }
27863: 1873:}
27864: 1874:
27865: 1875:public class InstantiateGenericType {
27866: 1876:    public static void main(String[] args) {
27867: 1877:        ClassAsFactory<Employee> fe =
27868: 1878:                new ClassAsFactory<>(Employee.class);
27869: 1879:        System.out.println(fe.get());
27870: 1880:        ClassAsFactory<Integer> fi =
27871: 1881:                new ClassAsFactory<>(Integer.class);
27872: 1882:        try {
27873: 1883:            System.out.println(fi.get());
27874: 1884:        } catch (Exception e) {
27875: 1885:            System.out.println(e.getMessage());
27876: 1886:        }
27877: 1887:    }
27878: 1888:}
27879: 1889:/* Output:
27880: 1890:Employee
27881: 1891:java.lang.InstantiationException: java.lang.Integer
27882: 1892:*/
27883: 1893:```
27884: 1894:
27885: 1895:这样可以编译，但对于 `ClassAsFactory<Integer>` 会失败，这是因为 **Integer** 没有无参构造函数。由于错误不是在编译时捕获的，因此语言创建者不赞成这种方法。他们建议使用显式工厂（**Supplier**）并约束类型，以便只有实现该工厂的类可以这样创建对象。这是创建工厂的两种不同方法：
27886: 1896:
27887: 1897:```java
27888: 1898:// generics/FactoryConstraint.java
27889: 1899:
27890: 1900:import onjava.Suppliers;
27891: 1901:
27892: 1902:import java.util.ArrayList;
27893: 1903:import java.util.List;
27894: 1904:import java.util.function.Supplier;
27895: 1905:
27896: 1906:class IntegerFactory implements Supplier<Integer> {
27897: 1907:    private int i = 0;
27898: 1908:
27899: 1909:    @Override
27900: 1910:    public Integer get() {
27901: 1911:        return ++i;
27902: 1912:    }
27903: 1913:}
27904: 1914:
27905: 1915:class Widget {
27906: 1916:    private int id;
27907: 1917:
27908: 1918:    Widget(int n) {
27909: 1919:        id = n;
27910: 1920:    }
27911: 1921:
27912: 1922:    @Override
27913: 1923:    public String toString() {
27914: 1924:        return "Widget " + id;
27915: 1925:    }
27916: 1926:
27917: 1927:    public static
27918: 1928:    class Factory implements Supplier<Widget> {
27919: 1929:        private int i = 0;
27920: 1930:
27921: 1931:        @Override
27922: 1932:        public Widget get() {
27923: 1933:            return new Widget(++i);
27924: 1934:        }
27925: 1935:    }
27926: 1936:}
27927: 1937:
27928: 1938:class Fudge {
27929: 1939:    private static int count = 1;
27930: 1940:    private int n = count++;
27931: 1941:
27932: 1942:    @Override
27933: 1943:    public String toString() {
27934: 1944:        return "Fudge " + n;
27935: 1945:    }
27936: 1946:}
27937: 1947:
27938: 1948:class Foo2<T> {
27939: 1949:    private List<T> x = new ArrayList<>();
27940: 1950:
27941: 1951:    Foo2(Supplier<T> factory) {
27942: 1952:        Suppliers.fill(x, factory, 5);
27943: 1953:    }
27944: 1954:
27945: 1955:    @Override
27946: 1956:    public String toString() {
27947: 1957:        return x.toString();
27948: 1958:    }
27949: 1959:}
27950: 1960:
27951: 1961:public class FactoryConstraint {
27952: 1962:    public static void main(String[] args) {
27953: 1963:        System.out.println(
27954: 1964:                new Foo2<>(new IntegerFactory()));
27955: 1965:        System.out.println(
27956: 1966:                new Foo2<>(new Widget.Factory()));
27957: 1967:        System.out.println(
27958: 1968:                new Foo2<>(Fudge::new));
27959: 1969:    }
27960: 1970:}
27961: 1971:/* Output:
27962: 1972:[1, 2, 3, 4, 5]
27963: 1973:[Widget 1, Widget 2, Widget 3, Widget 4, Widget 5]
27964: 1974:[Fudge 1, Fudge 2, Fudge 3, Fudge 4, Fudge 5]
27965: 1975:*/
27966: 1976:```
27967: 1977:
27968: 1978:**IntegerFactory** 本身就是通过实现 `Supplier<Integer>` 的工厂。 **Widget** 包含一个内部类，它是一个工厂。还要注意，**Fudge** 并没有做任何类似于工厂的操作，并且传递 `Fudge::new` 仍然会产生工厂行为，因为编译器将对函数方法 `::new` 的调用转换为对 `get()` 的调用。
27969: 1979:
27970: 1980:另一种方法是模板方法设计模式。在以下示例中，`create()` 是模板方法，在子类中被重写以生成该类型的对象：
27971: 1981:
27972: 1982:```java
27973: 1983:// generics/CreatorGeneric.java
27974: 1984:
27975: 1985:abstract class GenericWithCreate<T> {
27976: 1986:    final T element;
27977: 1987:
27978: 1988:    GenericWithCreate() {
27979: 1989:        element = create();
27980: 1990:    }
27981: 1991:
27982: 1992:    abstract T create();
27983: 1993:}
27984: 1994:
27985: 1995:class X {
27986: 1996:}
27987: 1997:
27988: 1998:class XCreator extends GenericWithCreate<X> {
27989: 1999:    @Override
27990: 2000:    X create() {
27991: 2001:        return new X();
27992: 2002:    }
27993: 2003:
27994: 2004:    void f() {
27995: 2005:        System.out.println(
27996: 2006:                element.getClass().getSimpleName());
27997: 2007:    }
27998: 2008:}
27999: 2009:
28000: 2010:public class CreatorGeneric {
28001: 2011:    public static void main(String[] args) {
28002: 2012:        XCreator xc = new XCreator();
28003: 2013:        xc.f();
28004: 2014:    }
28005: 2015:}
28006: 2016:/* Output:
28007: 2017:X
28008: 2018:*/
28009: 2019:```
28010: 2020:
28011: 2021:**GenericWithCreate** 包含 `element` 字段，并通过无参构造函数强制其初始化，该构造函数又调用抽象的 `create()` 方法。这种创建方式可以在子类中定义，同时建立 **T** 的类型。
28012: 2022:
28013: 2023:<!-- Arrays of Generics -->
28014: 2024:
28015: 2025:### 泛型数组
28016: 2026:
28017: 2027:正如在 **Erased.java** 中所看到的，我们无法创建泛型数组。通用解决方案是在试图创建泛型数组的时候使用 **ArrayList** ：
28018: 2028:
28019: 2029:```java
28020: 2030:// generics/ListOfGenerics.java
28021: 2031:
28022: 2032:import java.util.ArrayList;
28023: 2033:import java.util.List;
28024: 2034:
28025: 2035:public class ListOfGenerics<T> {
28026: 2036:    private List<T> array = new ArrayList<>();
28027: 2037:
28028: 2038:    public void add(T item) {
28029: 2039:        array.add(item);
28030: 2040:    }
28031: 2041:
28032: 2042:    public T get(int index) {
28033: 2043:        return array.get(index);
28034: 2044:    }
28035: 2045:}
28036: 2046:```
28037: 2047:
28038: 2048:这样做可以获得数组的行为，并且还具有泛型提供的编译时类型安全性。
28039: 2049:
28040: 2050:有时，仍然会创建泛型类型的数组（例如， **ArrayList** 在内部使用数组）。可以通过使编译器满意的方式定义对数组的通用引用：
28041: 2051:
28042: 2052:```java
28043: 2053:// generics/ArrayOfGenericReference.java
28044: 2054:
28045: 2055:class Generic<T> {
28046: 2056:}
28047: 2057:
28048: 2058:public class ArrayOfGenericReference {
28049: 2059:    static Generic<Integer>[] gia;
28050: 2060:}
28051: 2061:```
28052: 2062:
28053: 2063:编译器接受此操作而不产生警告。但是我们永远无法创建具有该确切类型（包括类型参数）的数组，因此有点令人困惑。由于所有数组，无论它们持有什么类型，都具有相同的结构（每个数组插槽的大小和数组布局），因此似乎可以创建一个 **Object** 数组并将其转换为所需的数组类型。实际上，这确实可以编译，但是会产生 **ClassCastException** ：
28054: 2064:
28055: 2065:```java
28056: 2066:// generics/ArrayOfGeneric.java
28057: 2067:
28058: 2068:public class ArrayOfGeneric {
28059: 2069:    static final int SIZE = 100;
28060: 2070:    static Generic<Integer>[] gia;
28061: 2071:
28062: 2072:    @SuppressWarnings("unchecked")
28063: 2073:    public static void main(String[] args) {
28064: 2074:        try {
28065: 2075:            gia = (Generic<Integer>[]) new Object[SIZE];
28066: 2076:        } catch (ClassCastException e) {
28067: 2077:            System.out.println(e.getMessage());
28068: 2078:        }
28069: 2079:        // Runtime type is the raw (erased) type:
28070: 2080:        gia = (Generic<Integer>[]) new Generic[SIZE];
28071: 2081:        System.out.println(gia.getClass().getSimpleName());
28072: 2082:        gia[0] = new Generic<>();
28073: 2083:        //- gia[1] = new Object(); // Compile-time error
28074: 2084:        // Discovers type mismatch at compile time:
28075: 2085:        //- gia[2] = new Generic<Double>();
28076: 2086:    }
28077: 2087:}
28078: 2088:/* Output:
28079: 2089:[Ljava.lang.Object; cannot be cast to [LGeneric;
28080: 2090:Generic[]
28081: 2091:*/
28082: 2092:```
28083: 2093:
28084: 2094:问题在于数组会跟踪其实际类型，而该类型是在创建数组时建立的。因此，即使 `gia` 被强制转换为 `Generic<Integer>[]` ，该信息也仅在编译时存在（并且没有 **@SuppressWarnings** 注解，将会收到有关该强制转换的警告）。在运行时，它仍然是一个 **Object** 数组，这会引起问题。成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换。
28085: 2095:
28086: 2096:让我们看一个更复杂的示例。考虑一个包装数组的简单泛型包装器：
28087: 2097:
28088: 2098:```java
28089: 2099:// generics/GenericArray.java
28090: 2100:
28091: 2101:public class GenericArray<T> {
28092: 2102:    private T[] array;
28093: 2103:
28094: 2104:    @SuppressWarnings("unchecked")
28095: 2105:    public GenericArray(int sz) {
28096: 2106:        array = (T[]) new Object[sz];
28097: 2107:    }
28098: 2108:
28099: 2109:    public void put(int index, T item) {
28100: 2110:        array[index] = item;
28101: 2111:    }
28102: 2112:
28103: 2113:    public T get(int index) {
28104: 2114:        return array[index];
28105: 2115:    }
28106: 2116:
28107: 2117:    // Method that exposes the underlying representation:
28108: 2118:    public T[] rep() {
28109: 2119:        return array;
28110: 2120:    }
28111: 2121:
28112: 2122:    public static void main(String[] args) {
28113: 2123:        GenericArray<Integer> gai = new GenericArray<>(10);
28114: 2124:        try {
28115: 2125:            Integer[] ia = gai.rep();
28116: 2126:        } catch (ClassCastException e) {
28117: 2127:            System.out.println(e.getMessage());
28118: 2128:        }
28119: 2129:        // This is OK:
28120: 2130:        Object[] oa = gai.rep();
28121: 2131:    }
28122: 2132:}
28123: 2133:/* Output:
28124: 2134:[Ljava.lang.Object; cannot be cast to
28125: 2135:[Ljava.lang.Integer;
28126: 2136:*/
28127: 2137:```
28128: 2138:
28129: 2139:和以前一样，我们不能说 `T[] array = new T[sz]` ，所以我们创建了一个 **Object** 数组并将其强制转换。
28130: 2140:
28131: 2141:`rep()` 方法返回一个 `T[]` ，在主方法中它应该是 `gai` 的 `Integer[]`，但是如果调用它并尝试将结果转换为 `Integer[]` 引用，则会得到 **ClassCastException** ，这再次是因为实际的运行时类型为 `Object[]` 。
28132: 2142:
28133: 2143:如果再注释掉 **@SuppressWarnings** 注解后编译 **GenericArray.java** ，则编译器会产生警告：
28134: 2144:
28135: 2145:```java
28136: 2146:GenericArray.java uses unchecked or unsafe operations.
28137: 2147:Recompile with -Xlint:unchecked for details.
28138: 2148:```
28139: 2149:
28140: 2150:在这里，我们收到了一个警告，我们认为这是有关强制转换的。
28141: 2151:
28142: 2152:但是要真正确定，请使用 `-Xlint：unchecked` 进行编译：
28143: 2153:
28144: 2154:```java
28145: 2155:GenericArray.java:7: warning: [unchecked] unchecked cast    array = (T[])new Object[sz];                 ^  required: T[]  found:    Object[]  where T is a type-variable:    T extends Object declared in class GenericArray 1 warning
28146: 2156:```
28147: 2157:
28148: 2158:确实是在抱怨那个强制转换。由于警告会变成噪音，因此，一旦我们确认预期会出现特定警告，我们可以做的最好的办法就是使用 **@SuppressWarnings** 将其关闭。这样，当警告确实出现时，我们将进行实际调查。
28149: 2159:
28150: 2160:由于擦除，数组的运行时类型只能是 `Object[]` 。 如果我们立即将其转换为 `T[]` ，则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。因此，最好在集合中使用 `Object[]` ，并在使用数组元素时向 **T** 添加强制类型转换。让我们来看看在 **GenericArray.java** 示例中会是怎么样的：
28151: 2161:
28152: 2162:```java
28153: 2163:// generics/GenericArray2.java
28154: 2164:
28155: 2165:public class GenericArray2<T> {
28156: 2166:    private Object[] array;
28157: 2167:
28158: 2168:    public GenericArray2(int sz) {
28159: 2169:        array = new Object[sz];
28160: 2170:    }
28161: 2171:
28162: 2172:    public void put(int index, T item) {
28163: 2173:        array[index] = item;
28164: 2174:    }
28165: 2175:
28166: 2176:    @SuppressWarnings("unchecked")
28167: 2177:    public T get(int index) {
28168: 2178:        return (T) array[index];
28169: 2179:    }
28170: 2180:
28171: 2181:    @SuppressWarnings("unchecked")
28172: 2182:    public T[] rep() {
28173: 2183:        return (T[]) array; // Unchecked cast
28174: 2184:    }
28175: 2185:
28176: 2186:    public static void main(String[] args) {
28177: 2187:        GenericArray2<Integer> gai =
28178: 2188:                new GenericArray2<>(10);
28179: 2189:        for (int i = 0; i < 10; i++)
28180: 2190:            gai.put(i, i);
28181: 2191:        for (int i = 0; i < 10; i++)
28182: 2192:            System.out.print(gai.get(i) + " ");
28183: 2193:        System.out.println();
28184: 2194:        try {
28185: 2195:            Integer[] ia = gai.rep();
28186: 2196:        } catch (Exception e) {
28187: 2197:            System.out.println(e);
28188: 2198:        }
28189: 2199:    }
28190: 2200:}
28191: 2201:/* Output:
28192: 2202:0 1 2 3 4 5 6 7 8 9
28193: 2203:java.lang.ClassCastException: [Ljava.lang.Object;
28194: 2204:cannot be cast to [Ljava.lang.Integer;
28195: 2205:*/
28196: 2206:```
28197: 2207:
28198: 2208:最初，看起来并没有太大不同，只是转换的位置移动了。没有 **@SuppressWarnings** 注解，仍然会收到“unchecked”警告。但是，内部表示现在是 `Object[]` 而不是 `T[]` 。 调用 `get()` 时，它将对象强制转换为 **T** ，实际上这是正确的类型，因此很安全。但是，如果调用 `rep()` ，它将再次尝试将 `Object[]` 强制转换为 `T[]` ，但仍然不正确，并在编译时生成警告，并在运行时生成异常。因此，无法破坏基础数组的类型，该基础数组只能是 `Object[]` 。在内部将数组视为 `Object[]` 而不是 `T[]` 的优点是，我们不太可能会忘记数组的运行时类型并意外地引入了bug，尽管大多数（也许是全部）此类错误会在运行时被迅速检测到。
28199: 2209:
28200: 2210:对于新代码，请传入类型标记。在这种情况下，**GenericArray** 如下所示：
28201: 2211:
28202: 2212:```java
28203: 2213:// generics/GenericArrayWithTypeToken.java
28204: 2214:
28205: 2215:import java.lang.reflect.Array;
28206: 2216:
28207: 2217:public class GenericArrayWithTypeToken<T> {
28208: 2218:    private T[] array;
28209: 2219:
28210: 2220:    @SuppressWarnings("unchecked")
28211: 2221:    public GenericArrayWithTypeToken(Class<T> type, int sz) {
28212: 2222:        array = (T[]) Array.newInstance(type, sz);
28213: 2223:    }
28214: 2224:
28215: 2225:    public void put(int index, T item) {
28216: 2226:        array[index] = item;
28217: 2227:    }
28218: 2228:
28219: 2229:    public T get(int index) {
28220: 2230:        return array[index];
28221: 2231:    }
28222: 2232:
28223: 2233:    // Expose the underlying representation:
28224: 2234:    public T[] rep() {
28225: 2235:        return array;
28226: 2236:    }
28227: 2237:
28228: 2238:    public static void main(String[] args) {
28229: 2239:        GenericArrayWithTypeToken<Integer> gai =
28230: 2240:                new GenericArrayWithTypeToken<>(
28231: 2241:                        Integer.class, 10);
28232: 2242:        // This now works:
28233: 2243:        Integer[] ia = gai.rep();
28234: 2244:    }
28235: 2245:}
28236: 2246:```
28237: 2247:
28238: 2248:类型标记 **Class\<T\>** 被传递到构造函数中以从擦除中恢复，因此尽管必须使用 **@SuppressWarnings** 关闭来自强制类型转换的警告，但我们仍可以创建所需的实际数组类型。一旦获得了实际的类型，就可以返回它并产生所需的结果，如在主方法中看到的那样。数组的运行时类型是确切的类型 `T[]` 。
28239: 2249:
28240: 2250:不幸的是，如果查看 Java 标准库中的源代码，你会发现到处都有从 **Object** 数组到参数化类型的转换。例如，这是**ArrayList** 中，复制一个 **Collection** 的构造函数，这里为了简化，去除了源码中对此不重要的代码：
28241: 2251:
28242: 2252:```java
28243: 2253:public ArrayList(Collection c) {
28244: 2254:  size = c.size();
28245: 2255:  elementData = (E[])new Object[size];
28246: 2256:  c.toArray(elementData);
28247: 2257:}
28248: 2258:```
28249: 2259:
28250: 2260:如果你浏览 **ArrayList.java** 的代码，将会发现很多此类强制转换。当我们编译它时会发生什么？
28251: 2261:
28252: 2262:```java
28253: 2263:Note: ArrayList.java uses unchecked or unsafe operations
28254: 2264:Note: Recompile with -Xlint:unchecked for details.
28255: 2265:```
28256: 2266:
28257: 2267:果然，标准库会产生很多警告。如果你使用过 C 语言，尤其是使用 ANSI C 之前的语言，你会记住警告的特殊效果：发现警告后，可以忽略它们。因此，除非程序员必须对其进行处理，否则最好不要从编译器发出任何类型的消息。
28258: 2268:
28259: 2269:Neal Gafter（Java 5 的主要开发人员之一）在他的博客中[^2]指出，他在重写 Java 库时是很随意、马虎的，我们不应该像他那样做。Neal 还指出，他在不破坏现有接口的情况下无法修复某些 Java 库代码。因此，即使在 Java 库源代码中出现了一些习惯用法，它们也不一定是正确的做法。当查看库代码时，我们不能认为这就是要在自己代码中必须遵循的示例。
28260: 2270:
28261: 2271:请注意，在 Java 文献中推荐使用类型标记技术，例如 Gilad Bracha 的论文《Generics in the Java Programming Language》[^3]，他指出：“例如，这种用法已广泛用于新的 API 中以处理注解。” 我发现此技术在人们对于舒适度的看法方面存在一些不一致之处；有些人强烈喜欢本章前面介绍的工厂方法。
28262: 2272:
28263: 2273:<!-- Bounds -->
28264: 2274:
28265: 2275:## 边界
28266: 2276:
28267: 2277:*边界*（bounds）在本章的前面进行了简要介绍。边界允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法。
28268: 2278:
28269: 2279:由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 **Object** 可用的方法。但是，如果将该参数限制为某类型的子集，则可以调用该子集中的方法。为了应用约束，Java 泛型使用了 `extends` 关键字。
28270: 2280:
28271: 2281:重要的是要理解，当用于限定泛型类型时，`extends` 的含义与通常的意义截然不同。此示例展示边界的基础应用：
28272: 2282:
28273: 2283:```java
28274: 2284:// generics/BasicBounds.java
28275: 2285:
28276: 2286:interface HasColor {
28277: 2287:    java.awt.Color getColor();
28278: 2288:}
28279: 2289:
28280: 2290:class WithColor<T extends HasColor> {
28281: 2291:    T item;
28282: 2292:
28283: 2293:    WithColor(T item) {
28284: 2294:        this.item = item;
28285: 2295:    }
28286: 2296:
28287: 2297:    T getItem() {
28288: 2298:        return item;
28289: 2299:    }
28290: 2300:
28291: 2301:    // The bound allows you to call a method:
28292: 2302:    java.awt.Color color() {
28293: 2303:        return item.getColor();
28294: 2304:    }
28295: 2305:}
28296: 2306:
28297: 2307:class Coord {
28298: 2308:    public int x, y, z;
28299: 2309:}
28300: 2310:
28301: 2311:// This fails. Class must be first, then interfaces:
28302: 2312:// class WithColorCoord<T extends HasColor & Coord> {
28303: 2313:
28304: 2314:// Multiple bounds:
28305: 2315:class WithColorCoord<T extends Coord & HasColor> {
28306: 2316:    T item;
28307: 2317:
28308: 2318:    WithColorCoord(T item) {
28309: 2319:        this.item = item;
28310: 2320:    }
28311: 2321:
28312: 2322:    T getItem() {
28313: 2323:        return item;
28314: 2324:    }
28315: 2325:
28316: 2326:    java.awt.Color color() {
28317: 2327:        return item.getColor();
28318: 2328:    }
28319: 2329:
28320: 2330:    int getX() {
28321: 2331:        return item.x;
28322: 2332:    }
28323: 2333:
28324: 2334:    int getY() {
28325: 2335:        return item.y;
28326: 2336:    }
28327: 2337:
28328: 2338:    int getZ() {
28329: 2339:        return item.z;
28330: 2340:    }
28331: 2341:}
28332: 2342:
28333: 2343:interface Weight {
28334: 2344:    int weight();
28335: 2345:}
28336: 2346:
28337: 2347:// As with inheritance, you can have only one
28338: 2348:// concrete class but multiple interfaces:
28339: 2349:class Solid<T extends Coord & HasColor & Weight> {
28340: 2350:    T item;
28341: 2351:
28342: 2352:    Solid(T item) {
28343: 2353:        this.item = item;
28344: 2354:    }
28345: 2355:
28346: 2356:    T getItem() {
28347: 2357:        return item;
28348: 2358:    }
28349: 2359:
28350: 2360:    java.awt.Color color() {
28351: 2361:        return item.getColor();
28352: 2362:    }
28353: 2363:
28354: 2364:    int getX() {
28355: 2365:        return item.x;
28356: 2366:    }
28357: 2367:
28358: 2368:    int getY() {
28359: 2369:        return item.y;
28360: 2370:    }
28361: 2371:
28362: 2372:    int getZ() {
28363: 2373:        return item.z;
28364: 2374:    }
28365: 2375:
28366: 2376:    int weight() {
28367: 2377:        return item.weight();
28368: 2378:    }
28369: 2379:}
28370: 2380:
28371: 2381:class Bounded
28372: 2382:        extends Coord implements HasColor, Weight {
28373: 2383:    @Override
28374: 2384:    public java.awt.Color getColor() {
28375: 2385:        return null;
28376: 2386:    }
28377: 2387:
28378: 2388:    @Override
28379: 2389:    public int weight() {
28380: 2390:        return 0;
28381: 2391:    }
28382: 2392:}
28383: 2393:
28384: 2394:public class BasicBounds {
28385: 2395:    public static void main(String[] args) {
28386: 2396:        Solid<Bounded> solid =
28387: 2397:                new Solid<>(new Bounded());
28388: 2398:        solid.color();
28389: 2399:        solid.getY();
28390: 2400:        solid.weight();
28391: 2401:    }
28392: 2402:}
28393: 2403:```
28394: 2404:
28395: 2405:你可能会观察到 **BasicBounds.java** 中似乎包含一些冗余，它们可以通过继承来消除。在这里，每个继承级别还添加了边界约束：
28396: 2406:
28397: 2407:```java
28398: 2408:// generics/InheritBounds.java
28399: 2409:
28400: 2410:class HoldItem<T> {
28401: 2411:    T item;
28402: 2412:
28403: 2413:    HoldItem(T item) {
28404: 2414:        this.item = item;
28405: 2415:    }
28406: 2416:
28407: 2417:    T getItem() {
28408: 2418:        return item;
28409: 2419:    }
28410: 2420:}
28411: 2421:
28412: 2422:class WithColor2<T extends HasColor>
28413: 2423:        extends HoldItem<T> {
28414: 2424:    WithColor2(T item) {
28415: 2425:        super(item);
28416: 2426:    }
28417: 2427:
28418: 2428:    java.awt.Color color() {
28419: 2429:        return item.getColor();
28420: 2430:    }
28421: 2431:}
28422: 2432:
28423: 2433:class WithColorCoord2<T extends Coord & HasColor>
28424: 2434:        extends WithColor2<T> {
28425: 2435:    WithColorCoord2(T item) {
28426: 2436:        super(item);
28427: 2437:    }
28428: 2438:
28429: 2439:    int getX() {
28430: 2440:        return item.x;
28431: 2441:    }
28432: 2442:
28433: 2443:    int getY() {
28434: 2444:        return item.y;
28435: 2445:    }
28436: 2446:
28437: 2447:    int getZ() {
28438: 2448:        return item.z;
28439: 2449:    }
28440: 2450:}
28441: 2451:
28442: 2452:class Solid2<T extends Coord & HasColor & Weight>
28443: 2453:        extends WithColorCoord2<T> {
28444: 2454:    Solid2(T item) {
28445: 2455:        super(item);
28446: 2456:    }
28447: 2457:
28448: 2458:    int weight() {
28449: 2459:        return item.weight();
28450: 2460:    }
28451: 2461:}
28452: 2462:
28453: 2463:public class InheritBounds {
28454: 2464:    public static void main(String[] args) {
28455: 2465:        Solid2<Bounded> solid2 =
28456: 2466:                new Solid2<>(new Bounded());
28457: 2467:        solid2.color();
28458: 2468:        solid2.getY();
28459: 2469:        solid2.weight();
28460: 2470:    }
28461: 2471:}
28462: 2472:```
28463: 2473:
28464: 2474:**HoldItem** 拥有一个对象，因此此行为将继承到 **WithColor2** 中，这也需要其参数符合 **HasColor**。 **WithColorCoord2** 和 **Solid2** 进一步扩展了层次结构，并在每个级别添加了边界。现在，这些方法已被继承，并且在每个类中不再重复。
28465: 2475:
28466: 2476:这是一个具有更多层次的示例：
28467: 2477:
28468: 2478:```java
28469: 2479:// generics/EpicBattle.java
28470: 2480:// Bounds in Java generics
28471: 2481:
28472: 2482:import java.util.List;
28473: 2483:
28474: 2484:interface SuperPower {
28475: 2485:}
28476: 2486:
28477: 2487:interface XRayVision extends SuperPower {
28478: 2488:    void seeThroughWalls();
28479: 2489:}
28480: 2490:
28481: 2491:interface SuperHearing extends SuperPower {
28482: 2492:    void hearSubtleNoises();
28483: 2493:}
28484: 2494:
28485: 2495:interface SuperSmell extends SuperPower {
28486: 2496:    void trackBySmell();
28487: 2497:}
28488: 2498:
28489: 2499:class SuperHero<POWER extends SuperPower> {
28490: 2500:    POWER power;
28491: 2501:
28492: 2502:    SuperHero(POWER power) {
28493: 2503:        this.power = power;
28494: 2504:    }
28495: 2505:
28496: 2506:    POWER getPower() {
28497: 2507:        return power;
28498: 2508:    }
28499: 2509:}
28500: 2510:
28501: 2511:class SuperSleuth<POWER extends XRayVision>
28502: 2512:        extends SuperHero<POWER> {
28503: 2513:    SuperSleuth(POWER power) {
28504: 2514:        super(power);
28505: 2515:    }
28506: 2516:
28507: 2517:    void see() {
28508: 2518:        power.seeThroughWalls();
28509: 2519:    }
28510: 2520:}
28511: 2521:
28512: 2522:class
28513: 2523:CanineHero<POWER extends SuperHearing & SuperSmell>
28514: 2524:        extends SuperHero<POWER> {
28515: 2525:    CanineHero(POWER power) {
28516: 2526:        super(power);
28517: 2527:    }
28518: 2528:
28519: 2529:    void hear() {
28520: 2530:        power.hearSubtleNoises();
28521: 2531:    }
28522: 2532:
28523: 2533:    void smell() {
28524: 2534:        power.trackBySmell();
28525: 2535:    }
28526: 2536:}
28527: 2537:
28528: 2538:class SuperHearSmell
28529: 2539:        implements SuperHearing, SuperSmell {
28530: 2540:    @Override
28531: 2541:    public void hearSubtleNoises() {
28532: 2542:    }
28533: 2543:
28534: 2544:    @Override
28535: 2545:    public void trackBySmell() {
28536: 2546:    }
28537: 2547:}
28538: 2548:
28539: 2549:class DogPerson extends CanineHero<SuperHearSmell> {
28540: 2550:    DogPerson() {
28541: 2551:        super(new SuperHearSmell());
28542: 2552:    }
28543: 2553:}
28544: 2554:
28545: 2555:public class EpicBattle {
28546: 2556:    // Bounds in generic methods:
28547: 2557:    static <POWER extends SuperHearing>
28548: 2558:    void useSuperHearing(SuperHero<POWER> hero) {
28549: 2559:        hero.getPower().hearSubtleNoises();
28550: 2560:    }
28551: 2561:
28552: 2562:    static <POWER extends SuperHearing & SuperSmell>
28553: 2563:    void superFind(SuperHero<POWER> hero) {
28554: 2564:        hero.getPower().hearSubtleNoises();
28555: 2565:        hero.getPower().trackBySmell();
28556: 2566:    }
28557: 2567:
28558: 2568:    public static void main(String[] args) {
28559: 2569:        DogPerson dogPerson = new DogPerson();
28560: 2570:        useSuperHearing(dogPerson);
28561: 2571:        superFind(dogPerson);
28562: 2572:        // You can do this:
28563: 2573:        List<? extends SuperHearing> audioPeople;
28564: 2574:        // But you can't do this:
28565: 2575:        // List<? extends SuperHearing & SuperSmell> dogPs;
28566: 2576:    }
28567: 2577:}
28568: 2578:```
28569: 2579:
28570: 2580:接下来将要研究的通配符将会把范围限制在单个类型。
28571: 2581:
28572: 2582:<!-- Wildcards -->
28573: 2583:
28574: 2584:## 通配符
28575: 2585:
28576: 2586:你已经在 [集合](book/12-Collections.md) 章节中看到了一些简单示例使用了通配符——在泛型参数表达式中的问号，在 [类型信息](book/19-Type-Information.md) 一章中这种示例更多。本节将更深入地探讨这个特性。
28577: 2587:
28578: 2588:我们的起始示例要展示数组的一种特殊行为：你可以将派生类的数组赋值给基类的引用：
28579: 2589:
28580: 2590:```java
28581: 2591:// generics/CovariantArrays.java
28582: 2592:
28583: 2593:class Fruit {}
28584: 2594:
28585: 2595:class Apple extends Fruit {}
28586: 2596:
28587: 2597:class Jonathan extends Apple {}
28588: 2598:
28589: 2599:class Orange extends Fruit {}
28590: 2600:
28591: 2601:public class CovariantArrays {
28592: 2602:    
28593: 2603:    public static void main(String[] args) {
28594: 2604:        Fruit[] fruit = new Apple[10];
28595: 2605:        fruit[0] = new Apple(); // OK
28596: 2606:        fruit[1] = new Jonathan(); // OK
28597: 2607:        // Runtime type is Apple[], not Fruit[] or Orange[]:
28598: 2608:        try {
28599: 2609:            // Compiler allows you to add Fruit:
28600: 2610:            fruit[0] = new Fruit(); // ArrayStoreException
28601: 2611:        } catch (Exception e) {
28602: 2612:            System.out.println(e);
28603: 2613:        }
28604: 2614:        try {
28605: 2615:            // Compiler allows you to add Oranges:
28606: 2616:            fruit[0] = new Orange(); // ArrayStoreException
28607: 2617:        } catch (Exception e) {
28608: 2618:            System.out.println(e);
28609: 2619:        }
28610: 2620:    }
28611: 2621:}
28612: 2622:/* Output:
28613: 2623:java.lang.ArrayStoreException: Fruit
28614: 2624:java.lang.ArrayStoreException: Orange
28615: 2625:```
28616: 2626:
28617: 2627:`main()` 中的第一行创建了 **Apple** 数组，并赋值给一个 **Fruit** 数组引用。这是有意义的，因为 **Apple** 也是一种 **Fruit**，因此 **Apple** 数组应该也是一个 **Fruit** 数组。
28618: 2628:
28619: 2629:但是，如果实际的数组类型是 **Apple[]**，你可以在其中放置 **Apple** 或 **Apple** 的子类型，这在编译期和运行时都可以工作。但是你也可以在数组中放置 **Fruit** 对象。这对编译器来说是有意义的，因为它有一个 **Fruit[]** 引用——它有什么理由不允许将 **Fruit** 对象或任何从 **Fruit** 继承出来的对象（比如 **Orange**），放置到这个数组中呢？因此在编译期，这是允许的。然而，运行时的数组机制知道它处理的是 **Apple[]**，因此会在向数组中放置异构类型时抛出异常。
28620: 2630:
28621: 2631:向上转型用在这里不合适。你真正在做的是将一个数组赋值给另一个数组。数组的行为是持有其他对象，这里只是因为我们能够向上转型而已，所以很明显，数组对象可以保留有关它们包含的对象类型的规则。看起来就像数组对它们持有的对象是有意识的，因此在编译期检查和运行时检查之间，你不能滥用它们。
28622: 2632:
28623: 2633:数组的这种赋值并不是那么可怕，因为在运行时你可以发现插入了错误的类型。但是泛型的主要目标之一是将这种错误检测移到编译期。所以当我们试图使用泛型集合代替数组时，会发生什么呢？
28624: 2634:
28625: 2635:```java
28626: 2636:// generics/NonCovariantGenerics.java
28627: 2637:// {WillNotCompile}
28628: 2638:
28629: 2639:import java.util.*;
28630: 2640:
28631: 2641:public class NonCovariantGenerics {
28632: 2642:    // Compile Error: incompatible types:
28633: 2643:    List<Fruit> flist = new ArrayList<Apple>();
28634: 2644:}
28635: 2645:```
28636: 2646:
28637: 2647:尽管你在首次阅读这段代码时会认为“不能将一个 **Apple** 集合赋值给一个 **Fruit** 集合”。记住，泛型不仅仅是关于集合，它真正要表达的是“不能把一个涉及 **Apple** 的泛型赋值给一个涉及 **Fruit** 的泛型”。如果像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及到的集合，那么它可能会留下一些余地。但是它不知道任何有关这方面的信息，因此它拒绝向上转型。然而实际上这也不是向上转型—— **Apple** 的 **List** 不是 **Fruit** 的 **List**。**Apple** 的 **List** 将持有 **Apple** 和 **Apple** 的子类型，**Fruit** 的 **List** 将持有任何类型的 **Fruit**。是的，这包括 **Apple**，但是它不是一个 **Apple** 的 **List**，它仍然是 **Fruit** 的 **List**。**Apple** 的 **List** 在类型上不等价于 **Fruit** 的 **List**，即使 **Apple** 是一种 **Fruit** 类型。
28638: 2648:
28639: 2649:真正的问题是我们在讨论的集合类型，而不是集合持有对象的类型。与数组不同，泛型没有内建的协变类型。这是因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查，但是在使用泛型时，编译器和运行时系统不知道你想用类型做什么，以及应该采用什么规则。
28640: 2650:
28641: 2651:但是，有时你想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。
28642: 2652:
28643: 2653:```java
28644: 2654:// generics/GenericsAndCovariance.java
28645: 2655:
28646: 2656:import java.util.*;
28647: 2657:
28648: 2658:public class GenericsAndCovariance {
28649: 2659:    
28650: 2660:    public static void main(String[] args) {
28651: 2661:        // Wildcards allow covariance:
28652: 2662:        List<? extends Fruit> flist = new ArrayList<>();
28653: 2663:        // Compile Error: can't add any type of object:
28654: 2664:        // flist.add(new Apple());
28655: 2665:        // flist.add(new Fruit());
28656: 2666:        // flist.add(new Object());
28657: 2667:        flist.add(null); // Legal but uninteresting
28658: 2668:        // We know it returns at least Fruit:
28659: 2669:        Fruit f = flist.get(0);
28660: 2670:    }
28661: 2671:    
28662: 2672:}
28663: 2673:```
28664: 2674:
28665: 2675:**flist** 的类型现在是 `List<? extends Fruit>`，你可以读作“一个具有任何从 **Fruit** 继承的类型的列表”。然而，这实际上并不意味着这个 **List** 将持有任何类型的 **Fruit**。通配符引用的是明确的类型，因此它意味着“某种 **flist** 引用没有指定的具体类型”。因此这个被赋值的 **List** 必须持有诸如 **Fruit** 或 **Apple** 这样的指定类型，但是为了向上转型为 **Fruit**，这个类型是什么没人在意。
28666: 2676:
28667: 2677:**List** 必须持有一种具体的 **Fruit** 或 **Fruit** 的子类型，但是如果你不关心具体的类型是什么，那么你能对这样的 **List** 做什么呢？如果不知道 **List** 中持有的对象是什么类型，你怎能保证安全地向其中添加对象呢？就像在 **CovariantArrays.java** 中向上转型一样，你不能，除非编译器而不是运行时系统可以阻止这种操作的发生。你很快就会发现这个问题。
28668: 2678:
28669: 2679:你可能认为事情开始变得有点走极端了，因为现在你甚至不能向刚刚声明过将持有 **Apple** 对象的 **List** 中放入一个 **Apple** 对象。是的，但编译器并不知道这一点。`List<? extends Fruit>` 可能合法地指向一个 `List<Orange>`。一旦执行这种类型的向上转型，你就丢失了向其中传递任何对象的能力，甚至传递 **Object** 也不行。
28670: 2680:
28671: 2681:另一方面，如果你调用了一个返回 **Fruit** 的方法，则是安全的，因为你知道这个 **List** 中的任何对象至少具有 **Fruit** 类型，因此编译器允许这么做。
28672: 2682:
28673: 2683:### 编译器有多聪明
28674: 2684:
28675: 2685:现在你可能会猜想自己不能去调用任何接受参数的方法，但是考虑下面的代码：
28676: 2686:
28677: 2687:```java
28678: 2688:// generics/CompilerIntelligence.java
28679: 2689:
28680: 2690:import java.util.*;
28681: 2691:
28682: 2692:public class CompilerIntelligence {
28683: 2693:    
28684: 2694:    public static void main(String[] args) {
28685: 2695:        List<? extends Fruit> flist = Arrays.asList(new Apple());
28686: 2696:        Apple a = (Apple) flist.get(0); // No warning
28687: 2697:        flist.contains(new Apple()); // Argument is 'Object'
28688: 2698:        flist.indexOf(new Apple()); // Argument is 'Object'
28689: 2699:    }
28690: 2700:    
28691: 2701:}
28692: 2702:```
28693: 2703:
28694: 2704:这里对 `contains()` 和 `indexOf()` 的调用接受 **Apple** 对象作为参数，执行没问题。这是否意味着编译器实际上会检查代码，以查看是否有某个特定的方法修改了它的对象？
28695: 2705:
28696: 2706:通过查看 **ArrayList** 的文档，我们发现编译器没有那么聪明。尽管 `add()` 接受一个泛型参数类型的参数，但 `contains()` 和 `indexOf()` 接受的参数类型是 **Object**。因此当你指定一个 `ArrayList<? extends Fruit>` 时，`add()` 的参数就变成了"**? extends Fruit**"。从这个描述中，编译器无法得知这里需要 **Fruit** 的哪个具体子类型，因此它不会接受任何类型的 **Fruit**。如果你先把 **Apple** 向上转型为 **Fruit**，也没有关系——编译器仅仅会拒绝调用像 `add()` 这样参数列表中涉及通配符的方法。
28697: 2707:
28698: 2708:`contains()` 和 `indexOf()` 的参数类型是 **Object**，不涉及通配符，所以编译器允许调用它们。这意味着将由泛型类的设计者来决定哪些调用是“安全的”，并使用 **Object** 类作为它们的参数类型。为了禁止对类型中使用了通配符的方法调用，需要在参数列表中使用类型参数。
28699: 2709:
28700: 2710:下面展示一个简单的 **Holder** 类：
28701: 2711:
28702: 2712:```java
28703: 2713:// generics/Holder.java
28704: 2714:
28705: 2715:public class Holder<T> {
28706: 2716:
28707: 2717:    private T value;
28708: 2718:
28709: 2719:    public Holder() {}
28710: 2720:
28711: 2721:    public Holder(T val) {
28712: 2722:        value = val;
28713: 2723:    }
28714: 2724:
28715: 2725:    public void set(T val) {
28716: 2726:        value = val;
28717: 2727:    }
28718: 2728:
28719: 2729:    public T get() {
28720: 2730:        return value;
28721: 2731:    }
28722: 2732:
28723: 2733:    @Override
28724: 2734:    public boolean equals(Object o) {
28725: 2735:        return o instanceof Holder && Objects.equals(value, ((Holder) o).value);
28726: 2736:    }
28727: 2737:
28728: 2738:    @Override
28729: 2739:    public int hashCode() {
28730: 2740:        return Objects.hashCode(value);
28731: 2741:    }
28732: 2742:
28733: 2743:    public static void main(String[] args) {
28734: 2744:        Holder<Apple> apple = new Holder<>(new Apple());
28735: 2745:        Apple d = apple.get();
28736: 2746:        apple.set(d);
28737: 2747:        // Holder<Fruit> fruit = apple; // Cannot upcast
28738: 2748:        Holder<? extends Fruit> fruit = apple; // OK
28739: 2749:        Fruit p = fruit.get();
28740: 2750:        d = (Apple) fruit.get();
28741: 2751:        try {
28742: 2752:            Orange c = (Orange) fruit.get(); // No warning
28743: 2753:        } catch (Exception e) {
28744: 2754:            System.out.println(e);
28745: 2755:        }
28746: 2756:        // fruit.set(new Apple()); // Cannot call set()
28747: 2757:        // fruit.set(new Fruit()); // Cannot call set()
28748: 2758:        System.out.println(fruit.equals(d)); // OK
28749: 2759:    }
28750: 2760:}
28751: 2761:/* Output
28752: 2762:java.lang.ClassCastException: Apple cannot be cast to Orange
28753: 2763:false
28754: 2764:*/
28755: 2765:```
28756: 2766:
28757: 2767:**Holder** 有一个接受 **T** 类型对象的 `set()` 方法，一个返回 T 对象的 `get()` 方法和一个接受 Object 对象的 `equals()` 方法。正如你所见，如果创建了一个 `Holder<Apple>`，就不能将其向上转型为 `Holder<Fruit>`，但是可以向上转型为 `Holder<? extends Fruit>`。如果调用 `get()`，只能返回一个 **Fruit**——这就是在给定“任何扩展自 **Fruit** 的对象”这一边界后，它所能知道的一切了。如果你知道更多的信息，就可以将其转型到某种具体的 **Fruit** 而不会导致任何警告，但是存在得到 **ClassCastException** 的风险。`set()` 方法不能工作在 **Apple** 和 **Fruit** 上，因为 `set()` 的参数也是"**? extends Fruit**"，意味着它可以是任何事物，编译器无法验证“任何事物”的类型安全性。
28758: 2768:
28759: 2769:但是，`equals()` 方法可以正常工作，因为它接受的参数是 **Object** 而不是 **T** 类型。因此，编译器只关注传递进来和要返回的对象类型。它不会分析代码，以查看是否执行了任何实际的写入和读取操作。
28760: 2770:
28761: 2771:Java 7 引入了 **java.util.Objects** 库，使创建 `equals()` 和 `hashCode()` 方法变得更加容易，当然还有很多其他功能。`equals()` 方法的标准形式参考 [附录：理解 equals 和 hashCode 方法](book/Appendix-Understanding-equals-and-hashCode) 一章。
28762: 2772:
28763: 2773:### 逆变
28764: 2774:
28765: 2775:还可以走另外一条路，即使用超类型通配符。这里，可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 `<？super MyClass>` ，或者甚至使用类型参数： `<？super T>`（尽管你不能对泛型参数给出一个超类型边界；即不能声明 `<T super MyClass>` ）。这使得你可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，就可以向 **Collection** 写入了：
28766: 2776:
28767: 2777:```java
28768: 2778:// generics/SuperTypeWildcards.java
28769: 2779:import java.util.*;
28770: 2780:public class SuperTypeWildcards {
28771: 2781:    static void writeTo(List<? super Apple> apples) {
28772: 2782:        apples.add(new Apple());
28773: 2783:        apples.add(new Jonathan());
28774: 2784:        // apples.add(new Fruit()); // Error
28775: 2785:    }
28776: 2786:}
28777: 2787:```
28778: 2788:
28779: 2789:参数 **apples** 是 **Apple** 的某种基类型的 **List**，这样你就知道向其中添加 **Apple** 或 **Apple** 的子类型是安全的。但是因为 **Apple** 是下界，所以你知道向这样的 **List** 中添加 **Fruit** 是不安全的，因为这将使这个 **List** 敞开口子，从而可以向其中添加非 **Apple** 类型的对象，而这是违反静态类型安全的。
28780: 2790:下面的示例复习了一下逆变和通配符的的使用：
28781: 2791:
28782: 2792:```java
28783: 2793:// generics/GenericReading.java
28784: 2794:import java.util.*;
28785: 2795:
28786: 2796:public class GenericReading {
28787: 2797:    static List<Apple> apples = Arrays.asList(new Apple());
28788: 2798:    static List<Fruit> fruit = Arrays.asList(new Fruit());
28789: 2799:    
28790: 2800:    static <T> T readExact(List<T> list) {
28791: 2801:        return list.get(0);
28792: 2802:    }
28793: 2803:    
28794: 2804:    // A static method adapts to each call:
28795: 2805:    static void f1() {
28796: 2806:        Apple a = readExact(apples);
28797: 2807:        Fruit f = readExact(fruit);
28798: 2808:        f = readExact(apples);
28799: 2809:    }
28800: 2810:    
28801: 2811:    // A class type is established
28802: 2812:    // when the class is instantiated:
28803: 2813:    static class Reader<T> {
28804: 2814:        T readExact(List<T> list) { 
28805: 2815:            return list.get(0); 
28806: 2816:        }
28807: 2817:    }
28808: 2818:    
28809: 2819:    static void f2() {
28810: 2820:        Reader<Fruit> fruitReader = new Reader<>();
28811: 2821:        Fruit f = fruitReader.readExact(fruit);
28812: 2822:        //- Fruit a = fruitReader.readExact(apples);
28813: 2823:        // error: incompatible types: List<Apple>
28814: 2824:        // cannot be converted to List<Fruit>
28815: 2825:    }
28816: 2826:    
28817: 2827:    static class CovariantReader<T> {
28818: 2828:        T readCovariant(List<? extends T> list) {
28819: 2829:            return list.get(0);
28820: 2830:        }
28821: 2831:    }
28822: 2832:    
28823: 2833:    static void f3() {
28824: 2834:        CovariantReader<Fruit> fruitReader = new CovariantReader<>();
28825: 2835:        Fruit f = fruitReader.readCovariant(fruit);
28826: 2836:        Fruit a = fruitReader.readCovariant(apples);
28827: 2837:    }
28828: 2838:    
28829: 2839:    public static void main(String[] args) {
28830: 2840:        f1(); 
28831: 2841:        f2(); 
28832: 2842:        f3();
28833: 2843:    }
28834: 2844:}
28835: 2845:```
28836: 2846:
28837: 2847:`readExact()` 方法使用了精确的类型。如果使用这个没有任何通配符的精确类型，就可以向 **List** 中写入和读取这个精确类型。另外，对于返回值，静态的泛型方法 `readExact()` 可以有效地“适应”每个方法调用，并能够从 `List<Apple>` 中返回一个 **Apple** ，从 `List<Fruit>` 中返回一个 **Fruit** ，就像在 `f1()` 中看到的那样。因此，如果可以摆脱静态泛型方法，那么在读取时就不需要协变类型了。
28838: 2848:然而对于泛型类来说，当你创建这个类的实例时，就要为这个类确定参数。就像在 `f2()` 中看到的，**fruitReader** 实例可以从 `List<Fruit>` 中读取一个 **Fruit** ，因为这就是它的确切类型。但是 `List<Apple>` 也应该产生 **Fruit** 对象，而 **fruitReader** 不允许这么做。
28839: 2849:为了修正这个问题，`CovariantReader.readCovariant()` 方法将接受 `List<？extends T>` ，因此，从这个列表中读取一个 **T** 是安全的（你知道在这个列表中的所有对象至少是一个 **T** ，并且可能是从 T 导出的某种对象）。在 `f3()` 中，你可以看到现在可以从 `List<Apple>` 中读取 **Fruit** 了。
28840: 2850:
28841: 2851:### 无界通配符
28842: 2852:
28843: 2853:无界通配符 `<?>` 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器初看起来是支持这种判断的：
28844: 2854:
28845: 2855:```java
28846: 2856:// generics/UnboundedWildcards1.java
28847: 2857:import java.util.*;
28848: 2858:
28849: 2859:public class UnboundedWildcards1 {
28850: 2860:    static List list1;
28851: 2861:    static List<?> list2;
28852: 2862:    static List<? extends Object> list3;
28853: 2863:  
28854: 2864:    static void assign1(List list) {
28855: 2865:        list1 = list;
28856: 2866:        list2 = list;
28857: 2867:        //- list3 = list;
28858: 2868:        // warning: [unchecked] unchecked conversion
28859: 2869:        // list3 = list;
28860: 2870:        //         ^
28861: 2871:        // required: List<? extends Object>
28862: 2872:        // found:    List
28863: 2873:    }
28864: 2874:    
28865: 2875:    static void assign2(List<?> list) {
28866: 2876:        list1 = list;
28867: 2877:        list2 = list;
28868: 2878:        list3 = list;
28869: 2879:    }
28870: 2880:    
28871: 2881:    static void assign3(List<? extends Object> list) {
28872: 2882:        list1 = list;
28873: 2883:        list2 = list;
28874: 2884:        list3 = list;
28875: 2885:    }
28876: 2886:    
28877: 2887:    public static void main(String[] args) {
28878: 2888:        assign1(new ArrayList());
28879: 2889:        assign2(new ArrayList());
28880: 2890:        //- assign3(new ArrayList());
28881: 2891:        // warning: [unchecked] unchecked method invocation:
28882: 2892:        // method assign3 in class UnboundedWildcards1
28883: 2893:        // is applied to given types
28884: 2894:        // assign3(new ArrayList());
28885: 2895:        //        ^
28886: 2896:        // required: List<? extends Object>
28887: 2897:        // found: ArrayList
28888: 2898:        // warning: [unchecked] unchecked conversion
28889: 2899:        // assign3(new ArrayList());
28890: 2900:        //         ^
28891: 2901:        // required: List<? extends Object>
28892: 2902:        // found:    ArrayList
28893: 2903:        // 2 warnings
28894: 2904:        assign1(new ArrayList<>());
28895: 2905:        assign2(new ArrayList<>());
28896: 2906:        assign3(new ArrayList<>());
28897: 2907:        // Both forms are acceptable as List<?>:
28898: 2908:        List<?> wildList = new ArrayList();
28899: 2909:        wildList = new ArrayList<>();
28900: 2910:        assign1(wildList);
28901: 2911:        assign2(wildList);
28902: 2912:        assign3(wildList);
28903: 2913:    }
28904: 2914:}
28905: 2915:```
28906: 2916:
28907: 2917:有很多情况都和你在这里看到的情况类似，即编译器很少关心使用的是原生类型还是 `<?>` 。在这些情况中，`<?>` 可以被认为是一种装饰，但是它仍旧是很有价值的，因为，实际上它是在声明：“我是想用 Java 的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型。”
28908: 2918:第二个示例展示了无界通配符的一个重要应用。当你在处理多个泛型参数时，有时允许一个参数可以是任何类型，同时为其他参数确定某种特定类型的这种能力会显得很重要：
28909: 2919:
28910: 2920:```java
28911: 2921:// generics/UnboundedWildcards2.java
28912: 2922:import java.util.*;
28913: 2923:
28914: 2924:public class UnboundedWildcards2 {
28915: 2925:    static Map map1;
28916: 2926:    static Map<?,?> map2;
28917: 2927:    static Map<String,?> map3;
28918: 2928:  
28919: 2929:    static void assign1(Map map) { 
28920: 2930:        map1 = map; 
28921: 2931:    }
28922: 2932:    
28923: 2933:    static void assign2(Map<?,?> map) { 
28924: 2934:        map2 = map; 
28925: 2935:    }
28926: 2936:    
28927: 2937:    static void assign3(Map<String,?> map) { 
28928: 2938:        map3 = map; 
28929: 2939:    }
28930: 2940:    
28931: 2941:    public static void main(String[] args) {
28932: 2942:        assign1(new HashMap());
28933: 2943:        assign2(new HashMap());
28934: 2944:        //- assign3(new HashMap());
28935: 2945:        // warning: [unchecked] unchecked method invocation:
28936: 2946:        // method assign3 in class UnboundedWildcards2
28937: 2947:        // is applied to given types
28938: 2948:        //     assign3(new HashMap());
28939: 2949:        //            ^
28940: 2950:        //   required: Map<String,?>
28941: 2951:        //   found: HashMap
28942: 2952:        // warning: [unchecked] unchecked conversion
28943: 2953:        //     assign3(new HashMap());
28944: 2954:        //             ^
28945: 2955:        //   required: Map<String,?>
28946: 2956:        //   found:    HashMap
28947: 2957:        // 2 warnings
28948: 2958:        assign1(new HashMap<>());
28949: 2959:        assign2(new HashMap<>());
28950: 2960:        assign3(new HashMap<>());
28951: 2961:    }
28952: 2962:}
28953: 2963:```
28954: 2964:
28955: 2965:但是，当你拥有的全都是无界通配符时，就像在 `Map<?,?>` 中看到的那样，编译器看起来就无法将其与原生 **Map** 区分开了。另外， **UnboundedWildcards1.java** 展示了编译器处理  `List<?>` 和 `List<? extends Object>` 是不同的。
28956: 2966:令人困惑的是，编译器并非总是关注像 `List` 和 `List<?>` 之间的这种差异，因此它们看起来就像是相同的事物。事实上，因为泛型参数擦除到它的第一个边界，因此 `List<?>` 看起来等价于 `List<Object>` ，而 **List** 实际上也是 `List<Object>` ——除非这些语句都不为真。**List** 实际上表示“持有任何 **Object** 类型的原生 **List** ”，而 `List<?>` 表示“具有某种特定类型的非原生 **List** ，只是我们不知道类型是什么。”
28957: 2967:编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？下面的示例使用了前面定义的 `Holder<T>` 类，它包含接受 **Holder** 作为参数的各种方法，但是它们具有不同的形式：作为原生类型，具有具体的类型参数以及具有无界通配符参数：
28958: 2968:
28959: 2969:```java
28960: 2970:// generics/Wildcards.java
28961: 2971:// Exploring the meaning of wildcards
28962: 2972:
28963: 2973:public class Wildcards {
28964: 2974:    // Raw argument:
28965: 2975:    static void rawArgs(Holder holder, Object arg) {
28966: 2976:        //- holder.set(arg);
28967: 2977:        // warning: [unchecked] unchecked call to set(T)
28968: 2978:        // as a member of the raw type Holder
28969: 2979:        //     holder.set(arg);
28970: 2980:        //               ^
28971: 2981:        //   where T is a type-variable:
28972: 2982:        //     T extends Object declared in class Holder
28973: 2983:        // 1 warning
28974: 2984:
28975: 2985:        // Can't do this; don't have any 'T':
28976: 2986:        // T t = holder.get();
28977: 2987:
28978: 2988:        // OK, but type information is lost:
28979: 2989:        Object obj = holder.get();
28980: 2990:    }
28981: 2991:    
28982: 2992:    // Like rawArgs(), but errors instead of warnings:
28983: 2993:    static void unboundedArg(Holder<?> holder, Object arg) {
28984: 2994:        //- holder.set(arg);
28985: 2995:        // error: method set in class Holder<T>
28986: 2996:        // cannot be applied to given types;
28987: 2997:        //     holder.set(arg);
28988: 2998:        //           ^
28989: 2999:        //   required: CAP#1
28990: 3000:        //   found: Object
28991: 3001:        //   reason: argument mismatch;
28992: 3002:        //     Object cannot be converted to CAP#1
28993: 3003:        //   where T is a type-variable:
28994: 3004:        //     T extends Object declared in class Holder
28995: 3005:        //   where CAP#1 is a fresh type-variable:
28996: 3006:        //     CAP#1 extends Object from capture of ?
28997: 3007:        // 1 error
28998: 3008:
28999: 3009:        // Can't do this; don't have any 'T':
29000: 3010:        // T t = holder.get();
29001: 3011:
29002: 3012:        // OK, but type information is lost:
29003: 3013:        Object obj = holder.get();
29004: 3014:    }
29005: 3015:    
29006: 3016:    static <T> T exact1(Holder<T> holder) {
29007: 3017:        return holder.get();
29008: 3018:    }
29009: 3019:    
29010: 3020:    static <T> T exact2(Holder<T> holder, T arg) {
29011: 3021:        holder.set(arg);
29012: 3022:        return holder.get();
29013: 3023:    }
29014: 3024:    
29015: 3025:    static <T> T wildSubtype(Holder<? extends T> holder, T arg) {
29016: 3026:        //- holder.set(arg);
29017: 3027:        // error: method set in class Holder<T#2>
29018: 3028:        // cannot be applied to given types;
29019: 3029:        //     holder.set(arg);
29020: 3030:        //           ^
29021: 3031:        //   required: CAP#1
29022: 3032:        //   found: T#1
29023: 3033:        //   reason: argument mismatch;
29024: 3034:        //     T#1 cannot be converted to CAP#1
29025: 3035:        //   where T#1,T#2 are type-variables:
29026: 3036:        //     T#1 extends Object declared in method
29027: 3037:        //     <T#1>wildSubtype(Holder<? extends T#1>,T#1)
29028: 3038:        //     T#2 extends Object declared in class Holder
29029: 3039:        //   where CAP#1 is a fresh type-variable:
29030: 3040:        //     CAP#1 extends T#1 from
29031: 3041:        //       capture of ? extends T#1
29032: 3042:        // 1 error
29033: 3043:        return holder.get();
29034: 3044:    }
29035: 3045:    
29036: 3046:    static <T> void wildSupertype(Holder<? super T> holder, T arg) {
29037: 3047:        holder.set(arg);
29038: 3048:        //- T t = holder.get();
29039: 3049:        // error: incompatible types:
29040: 3050:        // CAP#1 cannot be converted to T
29041: 3051:        //     T t = holder.get();
29042: 3052:        //                     ^
29043: 3053:        //   where T is a type-variable:
29044: 3054:        //     T extends Object declared in method
29045: 3055:        //       <T>wildSupertype(Holder<? super T>,T)
29046: 3056:        //   where CAP#1 is a fresh type-variable:
29047: 3057:        //     CAP#1 extends Object super:
29048: 3058:        //       T from capture of ? super T
29049: 3059:        // 1 error
29050: 3060:
29051: 3061:        // OK, but type information is lost:
29052: 3062:        Object obj = holder.get();
29053: 3063:    }
29054: 3064:    
29055: 3065:    public static void main(String[] args) {
29056: 3066:        Holder raw = new Holder<>();
29057: 3067:        // Or:
29058: 3068:        raw = new Holder();
29059: 3069:        Holder<Long> qualified = new Holder<>();
29060: 3070:        Holder<?> unbounded = new Holder<>();
29061: 3071:        Holder<? extends Long> bounded = new Holder<>();
29062: 3072:        Long lng = 1L;
29063: 3073:
29064: 3074:        rawArgs(raw, lng);
29065: 3075:        rawArgs(qualified, lng);
29066: 3076:        rawArgs(unbounded, lng);
29067: 3077:        rawArgs(bounded, lng);
29068: 3078:
29069: 3079:        unboundedArg(raw, lng);
29070: 3080:        unboundedArg(qualified, lng);
29071: 3081:        unboundedArg(unbounded, lng);
29072: 3082:        unboundedArg(bounded, lng);
29073: 3083:
29074: 3084:        //- Object r1 = exact1(raw);
29075: 3085:        // warning: [unchecked] unchecked method invocation:
29076: 3086:        // method exact1 in class Wildcards is applied
29077: 3087:        // to given types
29078: 3088:        //      Object r1 = exact1(raw);
29079: 3089:        //                        ^
29080: 3090:        //   required: Holder<T>
29081: 3091:        //   found: Holder
29082: 3092:        //   where T is a type-variable:
29083: 3093:        //     T extends Object declared in
29084: 3094:        //     method <T>exact1(Holder<T>)
29085: 3095:        // warning: [unchecked] unchecked conversion
29086: 3096:        //      Object r1 = exact1(raw);
29087: 3097:        //                         ^
29088: 3098:        //   required: Holder<T>
29089: 3099:        //   found:    Holder
29090: 3100:        //   where T is a type-variable:
29091: 3101:        //     T extends Object declared in
29092: 3102:        //     method <T>exact1(Holder<T>)
29093: 3103:        // 2 warnings
29094: 3104:
29095: 3105:        Long r2 = exact1(qualified);
29096: 3106:        Object r3 = exact1(unbounded); // Must return Object
29097: 3107:        Long r4 = exact1(bounded);
29098: 3108:
29099: 3109:        //- Long r5 = exact2(raw, lng);
29100: 3110:        // warning: [unchecked] unchecked method invocation:
29101: 3111:        // method exact2 in class Wildcards is
29102: 3112:        // applied to given types
29103: 3113:        //     Long r5 = exact2(raw, lng);
29104: 3114:        //                     ^
29105: 3115:        //   required: Holder<T>,T
29106: 3116:        //   found: Holder,Long
29107: 3117:        //   where T is a type-variable:
29108: 3118:        //     T extends Object declared in
29109: 3119:        //       method <T>exact2(Holder<T>,T)
29110: 3120:        // warning: [unchecked] unchecked conversion
29111: 3121:        //     Long r5 = exact2(raw, lng);
29112: 3122:        //                      ^
29113: 3123:        //   required: Holder<T>
29114: 3124:        //   found:    Holder
29115: 3125:        //   where T is a type-variable:
29116: 3126:        //     T extends Object declared in
29117: 3127:        //       method <T>exact2(Holder<T>,T)
29118: 3128:        // 2 warnings
29119: 3129:
29120: 3130:        Long r6 = exact2(qualified, lng);
29121: 3131:
29122: 3132:        //- Long r7 = exact2(unbounded, lng);
29123: 3133:        // error: method exact2 in class Wildcards
29124: 3134:        // cannot be applied to given types;
29125: 3135:        //     Long r7 = exact2(unbounded, lng);
29126: 3136:        //               ^
29127: 3137:        //   required: Holder<T>,T
29128: 3138:        //   found: Holder<CAP#1>,Long
29129: 3139:        //   reason: inference variable T has
29130: 3140:        //     incompatible bounds
29131: 3141:        //     equality constraints: CAP#1
29132: 3142:        //     lower bounds: Long
29133: 3143:        //   where T is a type-variable:
29134: 3144:        //     T extends Object declared in
29135: 3145:        //       method <T>exact2(Holder<T>,T)
29136: 3146:        //   where CAP#1 is a fresh type-variable:
29137: 3147:        //     CAP#1 extends Object from capture of ?
29138: 3148:        // 1 error
29139: 3149:
29140: 3150:        //- Long r8 = exact2(bounded, lng);
29141: 3151:        // error: method exact2 in class Wildcards
29142: 3152:        // cannot be applied to given types;
29143: 3153:        //      Long r8 = exact2(bounded, lng);
29144: 3154:        //                ^
29145: 3155:        //   required: Holder<T>,T
29146: 3156:        //   found: Holder<CAP#1>,Long
29147: 3157:        //   reason: inference variable T
29148: 3158:        //     has incompatible bounds
29149: 3159:        //     equality constraints: CAP#1
29150: 3160:        //     lower bounds: Long
29151: 3161:        //   where T is a type-variable:
29152: 3162:        //     T extends Object declared in
29153: 3163:        //       method <T>exact2(Holder<T>,T)
29154: 3164:        //   where CAP#1 is a fresh type-variable:
29155: 3165:        //     CAP#1 extends Long from
29156: 3166:        //       capture of ? extends Long
29157: 3167:        // 1 error
29158: 3168:
29159: 3169:        //- Long r9 = wildSubtype(raw, lng);
29160: 3170:        // warning: [unchecked] unchecked method invocation:
29161: 3171:        // method wildSubtype in class Wildcards
29162: 3172:        // is applied to given types
29163: 3173:        //     Long r9 = wildSubtype(raw, lng);
29164: 3174:        //                          ^
29165: 3175:        //   required: Holder<? extends T>,T
29166: 3176:        //   found: Holder,Long
29167: 3177:        //   where T is a type-variable:
29168: 3178:        //     T extends Object declared in
29169: 3179:        //     method <T>wildSubtype(Holder<? extends T>,T)
29170: 3180:        // warning: [unchecked] unchecked conversion
29171: 3181:        //     Long r9 = wildSubtype(raw, lng);
29172: 3182:        //                           ^
29173: 3183:        //   required: Holder<? extends T>
29174: 3184:        //   found:    Holder
29175: 3185:        //   where T is a type-variable:
29176: 3186:        //     T extends Object declared in
29177: 3187:        //     method <T>wildSubtype(Holder<? extends T>,T)
29178: 3188:        // 2 warnings
29179: 3189:
29180: 3190:        Long r10 = wildSubtype(qualified, lng);
29181: 3191:        // OK, but can only return Object:
29182: 3192:        Object r11 = wildSubtype(unbounded, lng);
29183: 3193:        Long r12 = wildSubtype(bounded, lng);
29184: 3194:
29185: 3195:        //- wildSupertype(raw, lng);
29186: 3196:        // warning: [unchecked] unchecked method invocation:
29187: 3197:        //   method wildSupertype in class Wildcards
29188: 3198:        //   is applied to given types
29189: 3199:        //     wildSupertype(raw, lng);
29190: 3200:        //                  ^
29191: 3201:        //   required: Holder<? super T>,T
29192: 3202:        //   found: Holder,Long
29193: 3203:        //   where T is a type-variable:
29194: 3204:        //     T extends Object declared in
29195: 3205:        //     method <T>wildSupertype(Holder<? super T>,T)
29196: 3206:        // warning: [unchecked] unchecked conversion
29197: 3207:        //     wildSupertype(raw, lng);
29198: 3208:        //                   ^
29199: 3209:        //   required: Holder<? super T>
29200: 3210:        //   found:    Holder
29201: 3211:        //   where T is a type-variable:
29202: 3212:        //     T extends Object declared in
29203: 3213:        //     method <T>wildSupertype(Holder<? super T>,T)
29204: 3214:        // 2 warnings
29205: 3215:
29206: 3216:        wildSupertype(qualified, lng);
29207: 3217:
29208: 3218:        //- wildSupertype(unbounded, lng);
29209: 3219:        // error: method wildSupertype in class Wildcards
29210: 3220:        // cannot be applied to given types;
29211: 3221:        //     wildSupertype(unbounded, lng);
29212: 3222:        //     ^
29213: 3223:        //   required: Holder<? super T>,T
29214: 3224:        //   found: Holder<CAP#1>,Long
29215: 3225:        //   reason: cannot infer type-variable(s) T
29216: 3226:        //     (argument mismatch; Holder<CAP#1>
29217: 3227:        //     cannot be converted to Holder<? super T>)
29218: 3228:        //   where T is a type-variable:
29219: 3229:        //     T extends Object declared in
29220: 3230:        //     method <T>wildSupertype(Holder<? super T>,T)
29221: 3231:        //   where CAP#1 is a fresh type-variable:
29222: 3232:        //     CAP#1 extends Object from capture of ?
29223: 3233:        // 1 error
29224: 3234:
29225: 3235:        //- wildSupertype(bounded, lng);
29226: 3236:        // error: method wildSupertype in class Wildcards
29227: 3237:        // cannot be applied to given types;
29228: 3238:        //     wildSupertype(bounded, lng);
29229: 3239:        //     ^
29230: 3240:        //   required: Holder<? super T>,T
29231: 3241:        //   found: Holder<CAP#1>,Long
29232: 3242:        //   reason: cannot infer type-variable(s) T
29233: 3243:        //     (argument mismatch; Holder<CAP#1>
29234: 3244:        //     cannot be converted to Holder<? super T>)
29235: 3245:        //   where T is a type-variable:
29236: 3246:        //     T extends Object declared in
29237: 3247:        //     method <T>wildSupertype(Holder<? super T>,T)
29238: 3248:        //   where CAP#1 is a fresh type-variable:
29239: 3249:        //     CAP#1 extends Long from capture of
29240: 3250:        //     ? extends Long
29241: 3251:        // 1 error
29242: 3252:    }
29243: 3253:}
29244: 3254:```
29245: 3255:
29246: 3256:在 `rawArgs()` 中，编译器知道 `Holder` 是一个泛型类型，因此即使它在这里被表示成一个原生类型，编译器仍旧知道向 `set()` 传递一个 **Object** 是不安全的。由于它是原生类型，你可以将任何类型的对象传递给 `set()` ，而这个对象将被向上转型为 **Object** 。因此无论何时，只要使用了原生类型，都会放弃编译期检查。对 `get()` 的调用说明了相同的问题：没有任何 **T** 类型的对象，因此结果只能是一个 **Object**。
29247: 3257:人们很自然地会开始考虑原生 `Holder` 与 `Holder<?>` 是大致相同的事物。但是 `unboundedArg()` 强调它们是不同的——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，因为原生 **Holder** 将持有任何类型的组合，而 `Holder<?>` 将持有具有某种具体类型的同构集合，因此不能只是向其中传递 **Object** 。
29248: 3258:在 `exact1()` 和 `exact2()` 中，你可以看到使用了确切的泛型参数——没有任何通配符。你将看到，`exact2()`与 `exact1()` 具有不同的限制，因为它有额外的参数。
29249: 3259:在 `wildSubtype()` 中，在 **Holder** 类型上的限制被放松为包括持有任何扩展自 **T** 的对象的 **Holder** 。这还是意味着如果 T 是 **Fruit** ，那么 `holder` 可以是 `Holder<Apple>` ，这是合法的。为了防止将 **Orange** 放置到 `Holder<Apple>` 中，对 `set()` 的调用（或者对任何接受这个类型参数为参数的方法的调用）都是不允许的。但是，你仍旧知道任何来自 `Holder<？extends Fruit>` 的对象至少是 **Fruit** ，因此 `get()` （或者任何将产生具有这个类型参数的返回值的方法）都是允许的。
29250: 3260:`wildSupertype()` 展示了超类型通配符，这个方法展示了与 `wildSubtype()` 相反的行为：`holder` 可以是持有任何 T 的基类型的容器。因此， `set()` 可以接受 **T** ，因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是 **T** ）。但是，尝试着调用 `get()` 是没有用的，因为由 `holder` 持有的类型可以是任何超类型，因此唯一安全的类型就是 **Object** 。
29251: 3261:这个示例还展示了对于在 `unbounded()` 中使用无界通配符能够做什么不能做什么所做出的限制：因为你没有 **T**，所以你不能将 `set()` 或 `get()` 作用于 **T** 上。
29252: 3262:
29253: 3263:在 `main()` 方法中你看到了某些方法在接受某些类型的参数时没有报错和警告。为了迁移兼容性，`rawArgs()`  将接受所有 **Holder** 的不同变体，而不会产生警告。`unboundedArg()` 方法也可以接受相同的所有类型，尽管如前所述，它在方法体内部处理这些类型的方式并不相同。
29254: 3264:
29255: 3265:如果向接受“确切”泛型类型（没有通配符）的方法传递一个原生 **Holder** 引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息。如果向 `exact1()` 传递一个无界引用，就不会有任何可以确定返回类型的类型信息。
29256: 3266:可以看到，`exact2()` 具有最多的限制，因为它希望精确地得到一个 `Holder<T>` ，以及一个具有类型 **T** 的参数，正由于此，它将产生错误或警告，除非提供确切的参数。有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决于是否想要从泛型参数中返回类型确定的返回值（就像在 `wildSubtype()` 中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在 `wildSupertype()` 中看到的那样）。
29257: 3267:因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合你的需求的方法。
29258: 3268:
29259: 3269:### 捕获转换
29260: 3270:
29261: 3271:有一种特殊情况需要使用 `<?>` 而不是原生类型。如果向一个使用 `<?>` 的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。下面的示例演示了这种技术，它被称为捕获转换，因为未指定的通配符类型被捕获，并被转换为确切类型。这里，有关警告的注释只有在 `@SuppressWarnings` 注解被移除之后才能起作用：
29262: 3272:
29263: 3273:```java
29264: 3274:// generics/CaptureConversion.java
29265: 3275:
29266: 3276:public class CaptureConversion {
29267: 3277:    static <T> void f1(Holder<T> holder) {
29268: 3278:        T t = holder.get();
29269: 3279:        System.out.println(t.getClass().getSimpleName());
29270: 3280:    }
29271: 3281:  
29272: 3282:    static void f2(Holder<?> holder) {
29273: 3283:        f1(holder); // Call with captured type
29274: 3284:    }
29275: 3285:    
29276: 3286:    @SuppressWarnings("unchecked")
29277: 3287:    public static void main(String[] args) {
29278: 3288:        Holder raw = new Holder<>(1);
29279: 3289:        f1(raw);
29280: 3290:        // warning: [unchecked] unchecked method invocation:
29281: 3291:        // method f1 in class CaptureConversion
29282: 3292:        // is applied to given types
29283: 3293:        //     f1(raw);
29284: 3294:        //       ^
29285: 3295:        //   required: Holder<T>
29286: 3296:        //   found: Holder
29287: 3297:        //   where T is a type-variable:
29288: 3298:        //     T extends Object declared in
29289: 3299:        //     method <T>f1(Holder<T>)
29290: 3300:        // warning: [unchecked] unchecked conversion
29291: 3301:        //     f1(raw);
29292: 3302:        //        ^
29293: 3303:        //   required: Holder<T>
29294: 3304:        //   found:    Holder
29295: 3305:        //   where T is a type-variable:
29296: 3306:        //     T extends Object declared in
29297: 3307:        //     method <T>f1(Holder<T>)
29298: 3308:        // 2 warnings
29299: 3309:        f2(raw); // No warnings
29300: 3310:        
29301: 3311:        Holder rawBasic = new Holder();
29302: 3312:        rawBasic.set(new Object());
29303: 3313:        // warning: [unchecked] unchecked call to set(T)
29304: 3314:        // as a member of the raw type Holder
29305: 3315:        //     rawBasic.set(new Object());
29306: 3316:        //                 ^
29307: 3317:        //   where T is a type-variable:
29308: 3318:        //     T extends Object declared in class Holder
29309: 3319:        // 1 warning
29310: 3320:        f2(rawBasic); // No warnings
29311: 3321:        
29312: 3322:        // Upcast to Holder<?>, still figures it out:
29313: 3323:        Holder<?> wildcarded = new Holder<>(1.0);
29314: 3324:        f2(wildcarded);
29315: 3325:    }
29316: 3326:}
29317: 3327:/* Output:
29318: 3328:Integer
29319: 3329:Integer
29320: 3330:Object
29321: 3331:Double
29322: 3332:*/
29323: 3333:```
29324: 3334:
29325: 3335:`f1()` 中的类型参数都是确切的，没有通配符或边界。在 `f2()` 中，**Holder** 参数是一个无界通配符，因此它看起来是未知的。但是，在 `f2()` 中调用了 `f1()`，而 `f1()` 需要一个已知参数。这里所发生的是：在调用 `f2()` 的过程中捕获了参数类型，并在调用 `f1()` 时使用了这种类型。
29326: 3336:你可能想知道这项技术是否可以用于写入，但是这要求在传递 `Holder<?>` 时同时传递一个具体类型。捕获转换只有在这样的情况下可以工作：即在方法内部，你需要使用确切的类型。注意，不能从 `f2()` 中返回 **T**，因为 **T** 对于 `f2()` 来说是未知的。捕获转换十分有趣，但是非常受限。
29327: 3337:
29328: 3338:<!-- Issues -->
29329: 3339:
29330: 3340:## 问题
29331: 3341:
29332: 3342:本节将阐述在使用 Java 泛型时会出现的各类问题。
29333: 3343:
29334: 3344:### 任何基本类型都不能作为类型参数
29335: 3345:
29336: 3346:正如本章早先提到的，Java 泛型的限制之一是不能将基本类型用作类型参数。因此，不能创建  `ArrayList<int>` 之类的东西。
29337: 3347:解决方法是使用基本类型的包装器类以及自动装箱机制。如果创建一个 `ArrayList<Integer>`，并将基本类型 **int** 应用于这个集合，那么你将发现自动装箱机制将自动地实现 **int** 到 **Integer** 的双向转换——因此，这几乎就像是有一个 `ArrayList<int>` 一样：
29338: 3348:
29339: 3349:```java
29340: 3350:// generics/ListOfInt.java
29341: 3351:// Autoboxing compensates for the inability
29342: 3352:// to use primitives in generics
29343: 3353:import java.util.*;
29344: 3354:import java.util.stream.*;
29345: 3355:
29346: 3356:public class ListOfInt {
29347: 3357:    public static void main(String[] args) {
29348: 3358:        List<Integer> li = IntStream.range(38, 48)
29349: 3359:            .boxed() // Converts ints to Integers
29350: 3360:            .collect(Collectors.toList());
29351: 3361:        System.out.println(li);
29352: 3362:    }
29353: 3363:}
29354: 3364:/* Output:
29355: 3365:[38, 39, 40, 41, 42, 43, 44, 45, 46, 47]
29356: 3366:*/
29357: 3367:```
29358: 3368:
29359: 3369:通常，这种解决方案工作得很好——能够成功地存储和读取 **int**，自动装箱隐藏了转换的过程。但是如果性能成为问题的话，就需要使用专门为基本类型适配的特殊版本的集合；一个开源版本的实现是 **org.apache.commons.collections.primitives**。
29360: 3370:下面是另外一种方式，它可以创建持有 **Byte** 的 **Set**：
29361: 3371:
29362: 3372:```java
29363: 3373:// generics/ByteSet.java
29364: 3374:import java.util.*;
29365: 3375:
29366: 3376:public class ByteSet {
29367: 3377:    Byte[] possibles = { 1,2,3,4,5,6,7,8,9 };
29368: 3378:    Set<Byte> mySet = new HashSet<>(Arrays.asList(possibles));
29369: 3379:    // But you can't do this:
29370: 3380:    // Set<Byte> mySet2 = new HashSet<>(
29371: 3381:    // Arrays.<Byte>asList(1,2,3,4,5,6,7,8,9));
29372: 3382:}
29373: 3383:```
29374: 3384:
29375: 3385:自动装箱机制解决了一些问题，但并没有解决所有问题。
29376: 3386:
29377: 3387:在下面的示例中，**FillArray** 接口包含一些通用方法，这些方法使用 **Supplier** 来用对象填充数组（这使得类泛型在本例中无法工作，因为这个方法是静态的）。**Supplier** 实现来自 [数组](book/21-Arrays.md) 一章,并且在 `main()` 中，可以看到 `FillArray.fill()` 使用对象填充了数组：
29378: 3388:
29379: 3389:```java
29380: 3390:// generics/PrimitiveGenericTest.java
29381: 3391:import onjava.*;
29382: 3392:import java.util.*;
29383: 3393:import java.util.function.*;
29384: 3394:
29385: 3395:// Fill an array using a generator:
29386: 3396:interface FillArray {
29387: 3397:    static <T> T[] fill(T[] a, Supplier<T> gen) {
29388: 3398:        Arrays.setAll(a, n -> gen.get());
29389: 3399:        return a;
29390: 3400:    }
29391: 3401:    
29392: 3402:    static int[] fill(int[] a, IntSupplier gen) {
29393: 3403:        Arrays.setAll(a, n -> gen.getAsInt());
29394: 3404:        return a;
29395: 3405:    }
29396: 3406:    
29397: 3407:    static long[] fill(long[] a, LongSupplier gen) {
29398: 3408:        Arrays.setAll(a, n -> gen.getAsLong());
29399: 3409:        return a;
29400: 3410:    }
29401: 3411:    
29402: 3412:    static double[] fill(double[] a, DoubleSupplier gen) {
29403: 3413:        Arrays.setAll(a, n -> gen.getAsDouble());
29404: 3414:        return a;
29405: 3415:    }
29406: 3416:}
29407: 3417:
29408: 3418:public class PrimitiveGenericTest {
29409: 3419:    public static void main(String[] args) {
29410: 3420:        String[] strings = FillArray.fill(
29411: 3421:            new String[5], new Rand.String(9));
29412: 3422:        System.out.println(Arrays.toString(strings));
29413: 3423:        int[] integers = FillArray.fill(
29414: 3424:            new int[9], new Rand.Pint());
29415: 3425:        System.out.println(Arrays.toString(integers));
29416: 3426:    }
29417: 3427:}
29418: 3428:/* Output:
29419: 3429:[btpenpccu, xszgvgmei, nneeloztd, vewcippcy, gpoalkljl]
29420: 3430:[635, 8737, 3941, 4720, 6177, 8479, 6656, 3768, 4948]
29421: 3431:*/
29422: 3432:```
29423: 3433:
29424: 3434:自动装箱不适用于数组，因此我们必须创建 `FillArray.fill()` 的重载版本，或创建产生 **Wrapped** 输出的生成器。 **FillArray** 仅比 `java.util.Arrays.setAll()` 有用一点，因为它返回填充的数组。
29425: 3435:
29426: 3436:### 实现参数化接口
29427: 3437:
29428: 3438:一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。下面是产生这种冲突的情况：
29429: 3439:
29430: 3440:```java
29431: 3441:// generics/MultipleInterfaceVariants.java
29432: 3442:// {WillNotCompile}
29433: 3443:package generics;
29434: 3444:
29435: 3445:interface Payable<T> {}
29436: 3446:
29437: 3447:class Employee implements Payable<Employee> {}
29438: 3448:
29439: 3449:class Hourly extends Employee implements Payable<Hourly> {}
29440: 3450:```
29441: 3451:
29442: 3452:**Hourly** 不能编译，因为擦除会将  `Payable<Employe>` 和 `Payable<Hourly>` 简化为相同的类 **Payable**，这样，上面的代码就意味着在重复两次地实现相同的接口。十分有趣的是，如果从 **Payable** 的两种用法中都移除掉泛型参数（就像编译器在擦除阶段所做的那样）这段代码就可以编译。
29443: 3453:
29444: 3454:在使用某些更基本的 Java 接口，例如 `Comparable<T>` 时，这个问题可能会变得十分令人恼火，就像你在本节稍后看到的那样。
29445: 3455:
29446: 3456:### 转型和警告
29447: 3457:
29448: 3458:使用带有泛型类型参数的转型或 **instanceof** 不会有任何效果。下面的集合在内部将各个值存储为 **Object**，并在获取这些值时，再将它们转型回 **T**：
29449: 3459:
29450: 3460:```java
29451: 3461:// generics/GenericCast.java
29452: 3462:import java.util.*;
29453: 3463:import java.util.stream.*;
29454: 3464:
29455: 3465:class FixedSizeStack<T> {
29456: 3466:    private final int size;
29457: 3467:    private Object[] storage;
29458: 3468:    private int index = 0;
29459: 3469:    
29460: 3470:    FixedSizeStack(int size) {
29461: 3471:        this.size = size;
29462: 3472:        storage = new Object[size];
29463: 3473:    }
29464: 3474:    
29465: 3475:    public void push(T item) {
29466: 3476:        if(index < size)
29467: 3477:            storage[index++] = item;
29468: 3478:    }
29469: 3479:    
29470: 3480:    @SuppressWarnings("unchecked")
29471: 3481:    public T pop() {
29472: 3482:        return index == 0 ? null : (T)storage[--index];
29473: 3483:    }
29474: 3484:    
29475: 3485:    @SuppressWarnings("unchecked")
29476: 3486:    Stream<T> stream() {
29477: 3487:        return (Stream<T>)Arrays.stream(storage);
29478: 3488:    }
29479: 3489:}
29480: 3490:
29481: 3491:public class GenericCast {
29482: 3492:    static String[] letters = "ABCDEFGHIJKLMNOPQRS".split("");
29483: 3493:  
29484: 3494:    public static void main(String[] args) {
29485: 3495:        FixedSizeStack<String> strings =
29486: 3496:            new FixedSizeStack<>(letters.length);
29487: 3497:        Arrays.stream("ABCDEFGHIJKLMNOPQRS".split(""))
29488: 3498:            .forEach(strings::push);
29489: 3499:        System.out.println(strings.pop());
29490: 3500:        strings.stream()
29491: 3501:            .map(s -> s + " ")
29492: 3502:            .forEach(System.out::print);
29493: 3503:    }
29494: 3504:}
29495: 3505:/* Output:
29496: 3506:S
29497: 3507:A B C D E F G H I J K L M N O P Q R S
29498: 3508:*/
29499: 3509:```
29500: 3510:
29501: 3511:如果没有 **@SuppressWarnings** 注解，编译器将对 `pop()` 产生 “unchecked cast” 警告。由于擦除的原因，编译器无法知道这个转型是否是安全的，并且 `pop()` 方法实际上并没有执行任何转型。
29502: 3512:这是因为，**T** 被擦除到它的第一个边界，默认情况下是 **Object** ，因此 `pop()` 实际上只是将 **Object** 转型为 **Object**。
29503: 3513:有时，泛型没有消除对转型的需要，这就会由编译器产生警告，而这个警告是不恰当的。例如：
29504: 3514:
29505: 3515:```java
29506: 3516:// generics/NeedCasting.java
29507: 3517:import java.io.*;
29508: 3518:import java.util.*;
29509: 3519:
29510: 3520:public class NeedCasting {
29511: 3521:    @SuppressWarnings("unchecked")
29512: 3522:    public void f(String[] args) throws Exception {
29513: 3523:        ObjectInputStream in = new ObjectInputStream(
29514: 3524:            new FileInputStream(args[0]));
29515: 3525:        List<Widget> shapes = (List<Widget>)in.readObject();
29516: 3526:    }
29517: 3527:}
29518: 3528:```
29519: 3529:
29520: 3530:正如你将在 [附录：对象序列化](book/Appendix-Object-Serialization.md) 中学到的那样，`readObject()` 无法知道它正在读取的是什么，因此它返回的是必须转型的对象。但是当注释掉 **@SuppressWarnings** 注解并编译这个程序时，就会得到下面的警告。
29521: 3531:
29522: 3532:```
29523: 3533:NeedCasting.java uses unchecked or unsafe operations.
29524: 3534:Recompile with -Xlint:unchecked for details.
29525: 3535:
29526: 3536:And if you follow the instructions and recompile with  -
29527: 3537:Xlint:unchecked :(如果遵循这条指示，使用-Xlint:unchecked来重新编译：)
29528: 3538:
29529: 3539:NeedCasting.java:10: warning: [unchecked] unchecked cast
29530: 3540:    List<Widget> shapes = (List<Widget>)in.readObject();
29531: 3541:    required: List<Widget>
29532: 3542:    found: Object
29533: 3543:1 warning
29534: 3544:```
29535: 3545:
29536: 3546:你会被强制要求转型，但是又被告知不应该转型。为了解决这个问题，必须使用 Java 5 引入的新的转型形式，即通过泛型类来转型：
29537: 3547:
29538: 3548:```java
29539: 3549:// generics/ClassCasting.java
29540: 3550:import java.io.*;
29541: 3551:import java.util.*;
29542: 3552:
29543: 3553:public class ClassCasting {
29544: 3554:    @SuppressWarnings("unchecked")
29545: 3555:    public void f(String[] args) throws Exception {
29546: 3556:        ObjectInputStream in = new ObjectInputStream(
29547: 3557:            new FileInputStream(args[0]));
29548: 3558:        // Won't Compile:
29549: 3559:        //    List<Widget> lw1 =
29550: 3560:        //    List<>.class.cast(in.readObject());
29551: 3561:        List<Widget> lw2 = List.class.cast(in.readObject());
29552: 3562:    }
29553: 3563:}
29554: 3564:```
29555: 3565:
29556: 3566:但是，不能转型到实际类型（ `List<Widget>` ）。也就是说，不能声明：
29557: 3567:
29558: 3568:```
29559: 3569:List<Widget>.class.cast(in.readobject())
29560: 3570:```
29561: 3571:
29562: 3572:甚至当你添加一个像下面这样的另一个转型时：
29563: 3573:
29564: 3574:```
29565: 3575:(List<Widget>)List.class.cast(in.readobject())
29566: 3576:```
29567: 3577:
29568: 3578:仍旧会得到一个警告。
29569: 3579:
29570: 3580:### 重载
29571: 3581:
29572: 3582:下面的程序是不能编译的，即使它看起来是合理的：
29573: 3583:
29574: 3584:```java
29575: 3585:// generics/UseList.java
29576: 3586:// {WillNotCompile}
29577: 3587:import java.util.*;
29578: 3588:
29579: 3589:public class UseList<W, T> {
29580: 3590:    void f(List<T> v) {}
29581: 3591:    void f(List<W> v) {}
29582: 3592:}
29583: 3593:```
29584: 3594:
29585: 3595:因为擦除，所以重载方法产生了相同的类型签名。
29586: 3596:
29587: 3597:因而，当擦除后的参数不能产生唯一的参数列表时，你必须提供不同的方法名：
29588: 3598:
29589: 3599:```java
29590: 3600:// generics/UseList2.java
29591: 3601:
29592: 3602:import java.util.*;
29593: 3603:
29594: 3604:public class UseList2<W, T> {
29595: 3605:    void f1(List<T> v) {}
29596: 3606:    void f2(List<W> v) {}
29597: 3607:}
29598: 3608:```
29599: 3609:
29600: 3610:幸运的是，编译器可以检测到这类问题。
29601: 3611:
29602: 3612:### 基类劫持接口
29603: 3613:
29604: 3614:假设你有一个实现了 **Comparable** 接口的 **Pet** 类：
29605: 3615:
29606: 3616:```java
29607: 3617:// generics/ComparablePet.java
29608: 3618:
29609: 3619:public class ComparablePet implements Comparable<ComparablePet> {
29610: 3620:    @Override
29611: 3621:    public int compareTo(ComparablePet o) {
29612: 3622:        return 0;
29613: 3623:    }
29614: 3624:}
29615: 3625:```
29616: 3626:
29617: 3627:尝试缩小 **ComparablePet** 子类的比较类型是有意义的。例如，**Cat** 类可以与其他的 **Cat** 比较：
29618: 3628:
29619: 3629:```java
29620: 3630:// generics/HijackedInterface.java
29621: 3631:// {WillNotCompile}
29622: 3632:
29623: 3633:class Cat extends ComparablePet implements Comparable<Cat> {
29624: 3634:    // error: Comparable cannot be inherited with
29625: 3635:    // different arguments: <Cat> and <ComparablePet>
29626: 3636:    // class Cat
29627: 3637:    // ^
29628: 3638:    // 1 error
29629: 3639:    public int compareTo(Cat arg) {
29630: 3640:        return 0;
29631: 3641:    }
29632: 3642:}
29633: 3643:```
29634: 3644:
29635: 3645:不幸的是，这不能工作。一旦 **Comparable** 的类型参数设置为 **ComparablePet**，其他的实现类只能比较 **ComparablePet**：
29636: 3646:
29637: 3647:```java
29638: 3648:// generics/RestrictedComparablePets.java
29639: 3649:
29640: 3650:public class Hamster extends ComparablePet implements Comparable<ComparablePet> {
29641: 3651:
29642: 3652:    @Override
29643: 3653:    public int compareTo(ComparablePet arg) {
29644: 3654:        return 0;
29645: 3655:    }
29646: 3656:}
29647: 3657:// Or just:
29648: 3658:class Gecko extends ComparablePet {
29649: 3659:    public int compareTo(ComparablePet arg) {
29650: 3660:        return 0;
29651: 3661:    }
29652: 3662:}
29653: 3663:```
29654: 3664:
29655: 3665:**Hamster** 显示了重新实现 **ComparablePet** 中相同的接口是可能的，只要接口完全相同，包括参数类型。然而正如 **Gecko** 中所示，这与直接覆写基类的方法完全相同。
29656: 3666:
29657: 3667:<!-- Self-Bounded Types -->
29658: 3668:
29659: 3669:## 自限定的类型
29660: 3670:
29661: 3671:在 Java 泛型中，有一个似乎经常性出现的惯用法，它相当令人费解：
29662: 3672:
29663: 3673:```java
29664: 3674:class SelfBounded<T extends SelfBounded<T>> { // ...
29665: 3675:```
29666: 3676:
29667: 3677:这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。**SelfBounded** 类接受泛型参数 **T**，而 **T** 由一个边界类限定，这个边界就是拥有 **T** 作为其参数的 **SelfBounded**。
29668: 3678:
29669: 3679:当你首次看到它时，很难去解析它，它强调的是当 **extends** 关键字用于边界与用来创建子类明显是不同的。
29670: 3680:
29671: 3681:### 古怪的循环泛型
29672: 3682:
29673: 3683:为了理解自限定类型的含义，我们从这个惯用法的一个简单版本入手，它没有自限定的边界。
29674: 3684:
29675: 3685:不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类。也就是说，可以声明：
29676: 3686:
29677: 3687:```java
29678: 3688:// generics/CuriouslyRecurringGeneric.java
29679: 3689:
29680: 3690:class GenericType<T> {}
29681: 3691:
29682: 3692:public class CuriouslyRecurringGeneric
29683: 3693:  extends GenericType<CuriouslyRecurringGeneric> {}
29684: 3694:```
29685: 3695:
29686: 3696:这可以按照 Jim Coplien 在 C++ 中的*古怪的循环模版模式*的命名方式，称为古怪的循环泛型（CRG）。“古怪的循环”是指类相当古怪地出现在它自己的基类中这一事实。
29687: 3697:为了理解其含义，努力大声说：“我在创建一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为其参数。”当给出导出类的名字时，这个泛型基类能够实现什么呢？好吧，Java 中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为其参数和返回类型的基类。它还能将导出类型用作其域类型，尽管这些将被擦除为 **Object** 的类型。下面是表示了这种情况的一个泛型类：
29688: 3698:
29689: 3699:```java
29690: 3700:// generics/BasicHolder.java
29691: 3701:
29692: 3702:public class BasicHolder<T> {
29693: 3703:    T element;
29694: 3704:    void set(T arg) { element = arg; }
29695: 3705:    T get() { return element; }
29696: 3706:    void f() {
29697: 3707:        System.out.println(element.getClass().getSimpleName());
29698: 3708:    }
29699: 3709:}
29700: 3710:```
29701: 3711:
29702: 3712:这是一个普通的泛型类型，它的一些方法将接受和产生具有其参数类型的对象，还有一个方法在其存储的域上执行操作（尽管只是在这个域上执行 **Object** 操作）。
29703: 3713:我们可以在一个古怪的循环泛型中使用 **BasicHolder**：
29704: 3714:
29705: 3715:```java
29706: 3716:// generics/CRGWithBasicHolder.java
29707: 3717:
29708: 3718:class Subtype extends BasicHolder<Subtype> {}
29709: 3719:
29710: 3720:public class CRGWithBasicHolder {
29711: 3721:    public static void main(String[] args) {
29712: 3722:        Subtype st1 = new Subtype(), st2 = new Subtype();
29713: 3723:        st1.set(st2);
29714: 3724:        Subtype st3 = st1.get();
29715: 3725:        st1.f();
29716: 3726:    }
29717: 3727:}
29718: 3728:/* Output:
29719: 3729:Subtype
29720: 3730:*/
29721: 3731:```
29722: 3732:
29723: 3733:注意，这里有些东西很重要：新类 **Subtype** 接受的参数和返回的值具有 **Subtype** 类型而不仅仅是基类 **BasicHolder** 类型。这就是 CRG 的本质：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型。也就是说，在所产生的类中将使用确切类型而不是基类型。因此，在**Subtype** 中，传递给 `set()` 的参数和从 `get()` 返回的类型都是确切的 **Subtype**。
29724: 3734:
29725: 3735:### 自限定
29726: 3736:
29727: 3737:**BasicHolder** 可以使用任何类型作为其泛型参数，就像下面看到的那样：
29728: 3738:
29729: 3739:```java
29730: 3740:// generics/Unconstrained.java
29731: 3741:// (c)2017 MindView LLC: see Copyright.txt
29732: 3742:// We make no guarantees that this code is fit for any purpose.
29733: 3743:// Visit http://OnJava8.com for more book information.
29734: 3744:
29735: 3745:class Other {}
29736: 3746:class BasicOther extends BasicHolder<Other> {}
29737: 3747:
29738: 3748:public class Unconstrained {
29739: 3749:    public static void main(String[] args) {
29740: 3750:        BasicOther b = new BasicOther();
29741: 3751:        BasicOther b2 = new BasicOther();
29742: 3752:        b.set(new Other());
29743: 3753:        Other other = b.get();
29744: 3754:        b.f();
29745: 3755:    }
29746: 3756:}
29747: 3757:/* Output:
29748: 3758:Other
29749: 3759:*/
29750: 3760:```
29751: 3761:
29752: 3762:限定将采取额外的步骤，强制泛型当作其自身的边界参数来使用。观察所产生的类可以如何使用以及不可以如何使用：
29753: 3763:
29754: 3764:```java
29755: 3765:// generics/SelfBounding.java
29756: 3766:
29757: 3767:class SelfBounded<T extends SelfBounded<T>> {
29758: 3768:    T element;
29759: 3769:    SelfBounded<T> set(T arg) {
29760: 3770:        element = arg;
29761: 3771:        return this;
29762: 3772:    }
29763: 3773:    T get() { return element; }
29764: 3774:}
29765: 3775:
29766: 3776:class A extends SelfBounded<A> {}
29767: 3777:class B extends SelfBounded<A> {} // Also OK
29768: 3778:
29769: 3779:class C extends SelfBounded<C> {
29770: 3780:    C setAndGet(C arg) { 
29771: 3781:        set(arg); 
29772: 3782:        return get();
29773: 3783:    }
29774: 3784:}
29775: 3785:
29776: 3786:class D {}
29777: 3787:// Can't do this:
29778: 3788:// class E extends SelfBounded<D> {}
29779: 3789:// Compile error:
29780: 3790://   Type parameter D is not within its bound
29781: 3791:
29782: 3792:// Alas, you can do this, so you cannot force the idiom:
29783: 3793:class F extends SelfBounded {}
29784: 3794:
29785: 3795:public class SelfBounding {
29786: 3796:    public static void main(String[] args) {
29787: 3797:        A a = new A();
29788: 3798:        a.set(new A());
29789: 3799:        a = a.set(new A()).get();
29790: 3800:        a = a.get();
29791: 3801:        C c = new C();
29792: 3802:        c = c.setAndGet(new C());
29793: 3803:    }
29794: 3804:}
29795: 3805:```
29796: 3806:
29797: 3807:自限定所做的，就是要求在继承关系中，像下面这样使用这个类：
29798: 3808:
29799: 3809:```java
29800: 3810:class A extends SelfBounded<A>{}
29801: 3811:```
29802: 3812:
29803: 3813:这会强制要求将正在定义的类当作参数传递给基类。
29804: 3814:
29805: 3815:自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。正如你在 B 类的定义中所看到的，还可以从使用了另一个 **SelfBounded** 参数的 **SelfBounded** 中导出，尽管在 **A** 类看到的用法看起来是主要的用法。对定义 **E** 的尝试说明不能使用不是 **SelfBounded** 的类型参数。
29806: 3816:遗憾的是， **F** 可以编译，不会有任何警告，因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型。
29807: 3817:注意，可以移除自限定这个限制，这样所有的类仍旧是可以编译的，但是 **E** 也会因此而变得可编译：
29808: 3818:
29809: 3819:```java
29810: 3820:// generics/NotSelfBounded.java
29811: 3821:
29812: 3822:public class NotSelfBounded<T> {
29813: 3823:    T element;
29814: 3824:    NotSelfBounded<T> set(T arg) {
29815: 3825:        element = arg;
29816: 3826:        return this;
29817: 3827:    }
29818: 3828:    T get() { return element; }
29819: 3829:} 
29820: 3830:
29821: 3831:class A2 extends NotSelfBounded<A2> {}
29822: 3832:class B2 extends NotSelfBounded<A2> {}
29823: 3833:
29824: 3834:class C2 extends NotSelfBounded<C2> {
29825: 3835:    C2 setAndGet(C2 arg) { 
29826: 3836:        set(arg); 
29827: 3837:        return get(); 
29828: 3838:    }
29829: 3839:}
29830: 3840:
29831: 3841:class D2 {}
29832: 3842:// Now this is OK:
29833: 3843:class E2 extends NotSelfBounded<D2> {}
29834: 3844:```
29835: 3845:
29836: 3846:因此很明显，自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。这会强制要求使用这个类的每个人都要遵循这种形式。
29837: 3847:还可以将自限定用于泛型方法：
29838: 3848:
29839: 3849:```java
29840: 3850:// generics/SelfBoundingMethods.java
29841: 3851:// (c)2017 MindView LLC: see Copyright.txt
29842: 3852:// We make no guarantees that this code is fit for any purpose.
29843: 3853:// Visit http://OnJava8.com for more book information.
29844: 3854:
29845: 3855:public class SelfBoundingMethods {
29846: 3856:    static <T extends SelfBounded<T>> T f(T arg) {
29847: 3857:        return arg.set(arg).get();
29848: 3858:    }
29849: 3859:    
29850: 3860:    public static void main(String[] args) {
29851: 3861:        A a = f(new A());
29852: 3862:    }
29853: 3863:}
29854: 3864:```
29855: 3865:
29856: 3866:这可以防止这个方法被应用于除上述形式的自限定参数之外的任何事物上。
29857: 3867:
29858: 3868:### 参数协变
29859: 3869:
29860: 3870:自限定类型的价值在于它们可以产生*协变参数类型*——方法参数类型会随子类而变化。
29861: 3871:
29862: 3872:尽管自限定类型还可以产生与子类类型相同的返回类型，但是这并不十分重要，因为*协变返回类型*是在 Java 5 引入：
29863: 3873:
29864: 3874:```java
29865: 3875:// generics/CovariantReturnTypes.java
29866: 3876:
29867: 3877:class Base {}
29868: 3878:class Derived extends Base {}
29869: 3879:
29870: 3880:interface OrdinaryGetter {
29871: 3881:    Base get();
29872: 3882:}
29873: 3883:
29874: 3884:interface DerivedGetter extends OrdinaryGetter {
29875: 3885:    // Overridden method return type can vary:
29876: 3886:    @Override
29877: 3887:    Derived get();
29878: 3888:}
29879: 3889:
29880: 3890:public class CovariantReturnTypes {
29881: 3891:    void test(DerivedGetter d) {
29882: 3892:        Derived d2 = d.get();
29883: 3893:    }
29884: 3894:}
29885: 3895:```
29886: 3896:
29887: 3897:**DerivedGetter** 中的 `get()` 方法覆盖了 **OrdinaryGetter** 中的 `get()` ，并返回了一个从 `OrdinaryGetter.get()` 的返回类型中导出的类型。尽管这是完全合乎逻辑的事情（导出类方法应该能够返回比它覆盖的基类方法更具体的类型）但是这在早先的 Java 版本中是不合法的。
29888: 3898:
29889: 3899:自限定泛型事实上将产生确切的导出类型作为其返回值，就像在 `get()` 中所看到的一样：
29890: 3900:
29891: 3901:```java
29892: 3902:// generics/GenericsAndReturnTypes.java
29893: 3903:
29894: 3904:interface GenericGetter<T extends GenericGetter<T>> {
29895: 3905:    T get();
29896: 3906:}
29897: 3907:
29898: 3908:interface Getter extends GenericGetter<Getter> {}
29899: 3909:
29900: 3910:public class GenericsAndReturnTypes {
29901: 3911:    void test(Getter g) {
29902: 3912:        Getter result = g.get();
29903: 3913:        GenericGetter gg = g.get(); // Also the base type
29904: 3914:    }
29905: 3915:}
29906: 3916:```
29907: 3917:
29908: 3918:注意，这段代码不能编译，除非是使用囊括了协变返回类型的 Java 5。
29909: 3919:
29910: 3920:然而，在非泛型代码中，参数类型不能随子类型发生变化：
29911: 3921:
29912: 3922:```java
29913: 3923:// generics/OrdinaryArguments.java
29914: 3924:
29915: 3925:class OrdinarySetter {
29916: 3926:    void set(Base base) {
29917: 3927:        System.out.println("OrdinarySetter.set(Base)");
29918: 3928:    }
29919: 3929:}
29920: 3930:
29921: 3931:class DerivedSetter extends OrdinarySetter {
29922: 3932:    void set(Derived derived) {
29923: 3933:        System.out.println("DerivedSetter.set(Derived)");
29924: 3934:    }
29925: 3935:}
29926: 3936:
29927: 3937:public class OrdinaryArguments {
29928: 3938:    public static void main(String[] args) {
29929: 3939:        Base base = new Base();
29930: 3940:        Derived derived = new Derived();
29931: 3941:        DerivedSetter ds = new DerivedSetter();
29932: 3942:        ds.set(derived);
29933: 3943:        // Compiles--overloaded, not overridden!:
29934: 3944:        ds.set(base);
29935: 3945:    }
29936: 3946:}
29937: 3947:/* Output:
29938: 3948:DerivedSetter.set(Derived)
29939: 3949:OrdinarySetter.set(Base)
29940: 3950:*/
29941: 3951:```
29942: 3952:
29943: 3953:`set(derived)` 和 `set(base)` 都是合法的，因此 `DerivedSetter.set()` 没有覆盖 `OrdinarySetter.set()` ，而是重载了这个方法。从输出中可以看到，在 **DerivedSetter** 中有两个方法，因此基类版本仍旧是可用的，因此可以证明它被重载过。
29944: 3954:但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类型而不是基类型为参数：
29945: 3955:
29946: 3956:```java
29947: 3957:// generics/SelfBoundingAndCovariantArguments.java
29948: 3958:
29949: 3959:interface SelfBoundSetter<T extends SelfBoundSetter<T>> {
29950: 3960:    void set(T arg);
29951: 3961:}
29952: 3962:
29953: 3963:interface Setter extends SelfBoundSetter<Setter> {}
29954: 3964:
29955: 3965:public class SelfBoundingAndCovariantArguments {
29956: 3966:    void
29957: 3967:    testA(Setter s1, Setter s2, SelfBoundSetter sbs) {
29958: 3968:        s1.set(s2);
29959: 3969:        //- s1.set(sbs);
29960: 3970:        // error: method set in interface SelfBoundSetter<T>
29961: 3971:        // cannot be applied to given types;
29962: 3972:        //     s1.set(sbs);
29963: 3973:        //       ^
29964: 3974:        //   required: Setter
29965: 3975:        //   found: SelfBoundSetter
29966: 3976:        //   reason: argument mismatch;
29967: 3977:        // SelfBoundSetter cannot be converted to Setter
29968: 3978:        //   where T is a type-variable:
29969: 3979:        //     T extends SelfBoundSetter<T> declared in
29970: 3980:        //     interface SelfBoundSetter
29971: 3981:        // 1 error
29972: 3982:    }
29973: 3983:}
29974: 3984:```
29975: 3985:
29976: 3986:编译器不能识别将基类型当作参数传递给 `set()` 的尝试，因为没有任何方法具有这样的签名。实际上，这个参数已经被覆盖。
29977: 3987:如果不使用自限定类型，普通的继承机制就会介入，而你将能够重载，就像在非泛型的情况下一样：
29978: 3988:
29979: 3989:```java
29980: 3990:// generics/PlainGenericInheritance.java
29981: 3991:
29982: 3992:class GenericSetter<T> { // Not self-bounded
29983: 3993:    void set(T arg) {
29984: 3994:        System.out.println("GenericSetter.set(Base)");
29985: 3995:    }
29986: 3996:}
29987: 3997:
29988: 3998:class DerivedGS extends GenericSetter<Base> {
29989: 3999:    void set(Derived derived) {
29990: 4000:        System.out.println("DerivedGS.set(Derived)");
29991: 4001:    }
29992: 4002:}
29993: 4003:
29994: 4004:public class PlainGenericInheritance {
29995: 4005:    public static void main(String[] args) {
29996: 4006:        Base base = new Base();
29997: 4007:        Derived derived = new Derived();
29998: 4008:        DerivedGS dgs = new DerivedGS();
29999: 4009:        dgs.set(derived);
30000: 4010:        dgs.set(base); // Overloaded, not overridden!
30001: 4011:    }
30002: 4012:}
30003: 4013:/* Output:
30004: 4014:DerivedGS.set(Derived)
30005: 4015:GenericSetter.set(Base)
30006: 4016:*/
30007: 4017:```
30008: 4018:
30009: 4019:这段代码在模仿 **OrdinaryArguments.java**；在那个示例中，**DerivedSetter** 继承自包含一个 `set(Base)` 的**OrdinarySetter** 。而这里，**DerivedGS** 继承自泛型创建的也包含有一个 `set(Base)`的 `GenericSetter<Base>`。就像 **OrdinaryArguments.java** 一样，你可以从输出中看到， **DerivedGS** 包含两个  `set()` 的重载版本。如果不使用自限定，将重载参数类型。如果使用了自限定，只能获得方法的一个版本，它将接受确切的参数类型。
30010: 4020:
30011: 4021:<!-- Dynamic Type Safety -->
30012: 4022:
30013: 4023:## 动态类型安全
30014: 4024:
30015: 4025:因为可以向 Java 5 之前的代码传递泛型集合，所以旧式代码仍旧有可能会破坏你的集合。Java 5 的 **java.util.Collections** 中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：静态方法 `checkedCollection()` 、`checkedList()`、 `checkedMap()` 、 `checkedSet()` 、`checkedSortedMap()`和 `checkedSortedSet()`。这些方法每一个都会将你希望动态检查的集合当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。
30016: 4026:
30017: 4027:受检查的集合在你试图插入类型不正确的对象时抛出 **ClassCastException** ，这与泛型之前的（原生）集合形成了对比，对于后者来说，当你将对象从集合中取出时，才会通知你出现了问题。在后一种情况中，你知道存在问题，但是不知道罪魁祸首在哪里，如果使用受检查的集合，就可以发现谁在试图插入不良对象。
30018: 4028:让我们用受检查的集合来看看“将猫插入到狗列表中”这个问题。这里，`oldStyleMethod()` 表示遗留代码，因为它接受的是原生的 **List** ，而 **@SuppressWarnings（“unchecked”）** 注解对于压制所产生的警告是必需的：
30019: 4029:
30020: 4030:```java
30021: 4031:// generics/CheckedList.java
30022: 4032:// Using Collection.checkedList()
30023: 4033:import typeinfo.pets.*;
30024: 4034:import java.util.*;
30025: 4035:
30026: 4036:public class CheckedList {
30027: 4037:    @SuppressWarnings("unchecked")
30028: 4038:    static void oldStyleMethod(List probablyDogs) {
30029: 4039:        probablyDogs.add(new Cat());
30030: 4040:    }
30031: 4041:    
30032: 4042:    public static void main(String[] args) {
30033: 4043:        List<Dog> dogs1 = new ArrayList<>();
30034: 4044:        oldStyleMethod(dogs1); // Quietly accepts a Cat
30035: 4045:        List<Dog> dogs2 = Collections.checkedList(
30036: 4046:            new ArrayList<>(), Dog.class);
30037: 4047:        try {
30038: 4048:            oldStyleMethod(dogs2); // Throws an exception
30039: 4049:        } catch(Exception e) {
30040: 4050:            System.out.println("Expected: " + e);
30041: 4051:        }
30042: 4052:        // Derived types work fine:
30043: 4053:        List<Pet> pets = Collections.checkedList(
30044: 4054:            new ArrayList<>(), Pet.class);
30045: 4055:        pets.add(new Dog());
30046: 4056:        pets.add(new Cat());
30047: 4057:    }
30048: 4058:}
30049: 4059:/* Output:
30050: 4060:Expected: java.lang.ClassCastException: Attempt to
30051: 4061:insert class typeinfo.pets.Cat element into collection
30052: 4062:with element type class typeinfo.pets.Dog
30053: 4063:*/
30054: 4064:```
30055: 4065:
30056: 4066:运行这个程序时，你会发现插入一个 **Cat** 对于 **dogs1** 来说没有任何问题，而 **dogs2** 立即会在这个错误类型的插入操作上抛出一个异常。还可以看到，将导出类型的对象放置到将要检查基类型的受检查容器中是没有问题的。
30057: 4067:
30058: 4068:<!-- Exceptions -->
30059: 4069:
30060: 4070:## 泛型异常
30061: 4071:
30062: 4072:由于擦除的原因，**catch** 语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承自 **Throwable**（这将进一步阻止你去定义不能捕获的泛型异常）。
30063: 4073:但是，类型参数可能会在一个方法的 **throws** 子句中用到。这使得你可以编写随检查型异常类型变化的泛型代码：
30064: 4074:
30065: 4075:```java
30066: 4076:// generics/ThrowGenericException.java
30067: 4077:
30068: 4078:import java.util.*;
30069: 4079:
30070: 4080:interface Processor<T, E extends Exception> {
30071: 4081:    void process(List<T> resultCollector) throws E;
30072: 4082:}
30073: 4083:
30074: 4084:class ProcessRunner<T, E extends Exception>
30075: 4085:extends ArrayList<Processor<T, E>> {
30076: 4086:    List<T> processAll() throws E {
30077: 4087:        List<T> resultCollector = new ArrayList<>();
30078: 4088:        for(Processor<T, E> processor : this)
30079: 4089:            processor.process(resultCollector);
30080: 4090:        return resultCollector;
30081: 4091:    }
30082: 4092:}
30083: 4093:
30084: 4094:class Failure1 extends Exception {}
30085: 4095:
30086: 4096:class Processor1
30087: 4097:implements Processor<String, Failure1> {
30088: 4098:    static int count = 3;
30089: 4099:    @Override
30090: 4100:    public void process(List<String> resultCollector)
30091: 4101:    throws Failure1 {
30092: 4102:        if(count-- > 1)
30093: 4103:            resultCollector.add("Hep!");
30094: 4104:        else
30095: 4105:            resultCollector.add("Ho!");
30096: 4106:        if(count < 0)
30097: 4107:            throw new Failure1();
30098: 4108:    }
30099: 4109:}
30100: 4110:
30101: 4111:class Failure2 extends Exception {}
30102: 4112:
30103: 4113:class Processor2
30104: 4114:implements Processor<Integer, Failure2> {
30105: 4115:    static int count = 2;
30106: 4116:    @Override
30107: 4117:    public void process(List<Integer> resultCollector)
30108: 4118:    throws Failure2 {
30109: 4119:        if(count-- == 0)
30110: 4120:            resultCollector.add(47);
30111: 4121:        else {
30112: 4122:            resultCollector.add(11);
30113: 4123:        }
30114: 4124:        if(count < 0)
30115: 4125:            throw new Failure2();
30116: 4126:    }
30117: 4127:}
30118: 4128:
30119: 4129:public class ThrowGenericException {
30120: 4130:    public static void main(String[] args) {
30121: 4131:        ProcessRunner<String, Failure1> runner =
30122: 4132:            new ProcessRunner<>();
30123: 4133:        for(int i = 0; i < 3; i++)
30124: 4134:            runner.add(new Processor1());
30125: 4135:        try {
30126: 4136:            System.out.println(runner.processAll());
30127: 4137:        } catch(Failure1 e) {
30128: 4138:            System.out.println(e);
30129: 4139:        }
30130: 4140:
30131: 4141:        ProcessRunner<Integer, Failure2> runner2 =
30132: 4142:            new ProcessRunner<>();
30133: 4143:        for(int i = 0; i < 3; i++)
30134: 4144:            runner2.add(new Processor2());
30135: 4145:        try {
30136: 4146:            System.out.println(runner2.processAll());
30137: 4147:        } catch(Failure2 e) {
30138: 4148:            System.out.println(e);
30139: 4149:        }
30140: 4150:    }
30141: 4151:}
30142: 4152:/* Output:
30143: 4153:[Hep!, Hep!, Ho!]
30144: 4154:Failure2
30145: 4155:*/
30146: 4156:```
30147: 4157:
30148: 4158:**Processor** 执行 `process()` 方法，并且可能会抛出具有类型 **E** 的异常。`process()` 的结果存储在 `List<T>resultCollector` 中（这被称为*收集参数*）。**ProcessRunner** 有一个 `processAll()` 方法，它会在所持有的每个 **Process** 对象执行，并返回 **resultCollector** 。
30149: 4159:如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出这种泛化的代码。
30150: 4160:
30151: 4161:<!-- Mixins -->
30152: 4162:
30153: 4163:## 混型
30154: 4164:
30155: 4165:术语*混型*随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是你最后的手段，它将使组装多个类变得简单易行。
30156: 4166:混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点*面向切面编程* （AOP） 的味道，而切面经常被建议用来解决混型问题。
30157: 4167:
30158: 4168:### C++ 中的混型
30159: 4169:
30160: 4170:在 C++ 中，使用多重继承的最大理由，就是为了使用混型。但是，对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为混型就是继承自其类型参数的类。在 C++ 中，可以很容易地创建混型，因为 C++ 能够记住其模版参数的类型。
30161: 4171:下面是一个 C++ 示例，它有两个混型类型：一个使得你可以在每个对象中混入拥有一个时间戳这样的属性，而另一个可以混入一个序列号。
30162: 4172:
30163: 4173:```c++
30164: 4174:// generics/Mixins.cpp
30165: 4175:
30166: 4176:#include <string>
30167: 4177:#include <ctime>
30168: 4178:#include <iostream>
30169: 4179:using namespace std;
30170: 4180:
30171: 4181:template<class T> class TimeStamped : public T {
30172: 4182:    long timeStamp;
30173: 4183:public:
30174: 4184:    TimeStamped() { timeStamp = time(0); }
30175: 4185:    long getStamp() { return timeStamp; }
30176: 4186:};
30177: 4187:
30178: 4188:template<class T> class SerialNumbered : public T {
30179: 4189:    long serialNumber;
30180: 4190:    static long counter;
30181: 4191:public:
30182: 4192:    SerialNumbered() { serialNumber = counter++; }
30183: 4193:    long getSerialNumber() { return serialNumber; }
30184: 4194:};
30185: 4195:
30186: 4196:// Define and initialize the static storage:
30187: 4197:template<class T> long SerialNumbered<T>::counter = 1;
30188: 4198:
30189: 4199:class Basic {
30190: 4200:    string value;
30191: 4201:public:
30192: 4202:    void set(string val) { value = val; }
30193: 4203:    string get() { return value; }
30194: 4204:};
30195: 4205:
30196: 4206:int main() {
30197: 4207:    TimeStamped<SerialNumbered<Basic>> mixin1, mixin2;
30198: 4208:    mixin1.set("test string 1");
30199: 4209:    mixin2.set("test string 2");
30200: 4210:    cout << mixin1.get() << " " << mixin1.getStamp() <<
30201: 4211:      " " << mixin1.getSerialNumber() << endl;
30202: 4212:    cout << mixin2.get() << " " << mixin2.getStamp() <<
30203: 4213:      " " << mixin2.getSerialNumber() << endl;
30204: 4214:}
30205: 4215:/* Output:
30206: 4216:test string 1 1452987605 1
30207: 4217:test string 2 1452987605 2
30208: 4218:*/
30209: 4219:```
30210: 4220:
30211: 4221:在 `main()` 中， **mixin1** 和 **mixin2** 所产生的类型拥有所混入类型的所有方法。可以将混型看作是一种功能，它可以将现有类映射到新的子类上。注意，使用这种技术来创建一个混型是多么的轻而易举。基本上，只需要声明“这就是我想要的”，紧跟着它就发生了：
30212: 4222:
30213: 4223:```c++
30214: 4224:TimeStamped<SerialNumbered<Basic>> mixin1，mixin2；
30215: 4225:```
30216: 4226:
30217: 4227:遗憾的是，Java 泛型不允许这样。擦除会忘记基类类型，因此
30218: 4228:
30219: 4229:>  泛型类不能直接继承自一个泛型参数
30220: 4230:
30221: 4231:这突显了许多我在 Java 语言设计决策（以及与这些功能一起发布）中遇到的一大问题：处理一件事很有希望，但是当您实际尝试做一些有趣的事情时，您会发现自己做不到。
30222: 4232:
30223: 4233:### 与接口混合
30224: 4234:
30225: 4235:一种更常见的推荐解决方案是使用接口来产生混型效果，就像下面这样：
30226: 4236:
30227: 4237:```java
30228: 4238:// generics/Mixins.java
30229: 4239:
30230: 4240:import java.util.*;
30231: 4241:
30232: 4242:interface TimeStamped { long getStamp(); }
30233: 4243:
30234: 4244:class TimeStampedImp implements TimeStamped {
30235: 4245:    private final long timeStamp;
30236: 4246:    TimeStampedImp() {
30237: 4247:        timeStamp = new Date().getTime();
30238: 4248:    }
30239: 4249:    @Override
30240: 4250:    public long getStamp() { return timeStamp; }
30241: 4251:}
30242: 4252:
30243: 4253:interface SerialNumbered { long getSerialNumber(); }
30244: 4254:
30245: 4255:class SerialNumberedImp implements SerialNumbered {
30246: 4256:    private static long counter = 1;
30247: 4257:    private final long serialNumber = counter++;
30248: 4258:    @Override
30249: 4259:    public long getSerialNumber() { return serialNumber; }
30250: 4260:}
30251: 4261:
30252: 4262:interface Basic {
30253: 4263:    void set(String val);
30254: 4264:    String get();
30255: 4265:}
30256: 4266:
30257: 4267:class BasicImp implements Basic {
30258: 4268:    private String value;
30259: 4269:    @Override
30260: 4270:    public void set(String val) { value = val; }
30261: 4271:    @Override
30262: 4272:    public String get() { return value; }
30263: 4273:}
30264: 4274:
30265: 4275:class Mixin extends BasicImp
30266: 4276:implements TimeStamped, SerialNumbered {
30267: 4277:    private TimeStamped timeStamp = new TimeStampedImp();
30268: 4278:    private SerialNumbered serialNumber =
30269: 4279:        new SerialNumberedImp();
30270: 4280:    @Override
30271: 4281:    public long getStamp() {
30272: 4282:        return timeStamp.getStamp();
30273: 4283:    }
30274: 4284:    @Override
30275: 4285:    public long getSerialNumber() {
30276: 4286:        return serialNumber.getSerialNumber();
30277: 4287:    }
30278: 4288:}
30279: 4289:
30280: 4290:public class Mixins {
30281: 4291:    public static void main(String[] args) {
30282: 4292:        Mixin mixin1 = new Mixin(), mixin2 = new Mixin();
30283: 4293:        mixin1.set("test string 1");
30284: 4294:        mixin2.set("test string 2");
30285: 4295:        System.out.println(mixin1.get() + " " +
30286: 4296:            mixin1.getStamp() +  " " + mixin1.getSerialNumber());
30287: 4297:        System.out.println(mixin2.get() + " " +
30288: 4298:            mixin2.getStamp() +  " " + mixin2.getSerialNumber());
30289: 4299:    }
30290: 4300:}
30291: 4301:/* Output:
30292: 4302:test string 1 1494331663026 1
30293: 4303:test string 2 1494331663027 2
30294: 4304:*/
30295: 4305:```
30296: 4306:
30297: 4307:**Mixin** 类基本上是在使用*委托*，因此每个混入类型都要求在 **Mixin** 中有一个相应的域，而你必须在 **Mixin** 中编写所有必需的方法，将方法调用转发给恰当的对象。这个示例使用了非常简单的类，但是当使用更复杂的混型时，代码数量会急速增加。[^4]
30298: 4308:
30299: 4309:### 使用装饰器模式
30300: 4310:
30301: 4311:当你观察混型的使用方式时，就会发现混型概念好像与*装饰器*设计模式关系很近。装饰器经常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的。
30302: 4312:装饰器模式使用分层对象来动态透明地向单个对象中添加责任。装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。某些事物是可装饰的，可以通过将其他类包装在这个可装饰对象的四周，来将功能分层。这使得对装饰器的使用是透明的——无论对象是否被装饰，你都拥有一个可以向对象发送的公共消息集。装饰类也可以添加新方法，但是正如你所见，这将是受限的。
30303: 4313:装饰器是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。
30304: 4314:前面的示例可以被改写为使用装饰器：
30305: 4315:
30306: 4316:```java
30307: 4317:// generics/decorator/Decoration.java
30308: 4318:
30309: 4319:// {java generics.decorator.Decoration}
30310: 4320:package generics.decorator;
30311: 4321:import java.util.*;
30312: 4322:
30313: 4323:class Basic {
30314: 4324:    private String value;
30315: 4325:    public void set(String val) { value = val; }
30316: 4326:    public String get() { return value; }
30317: 4327:}
30318: 4328:
30319: 4329:class Decorator extends Basic {
30320: 4330:    protected Basic basic;
30321: 4331:    Decorator(Basic basic) { this.basic = basic; }
30322: 4332:    @Override
30323: 4333:    public void set(String val) { basic.set(val); }
30324: 4334:    @Override
30325: 4335:    public String get() { return basic.get(); }
30326: 4336:}
30327: 4337:
30328: 4338:class TimeStamped extends Decorator {
30329: 4339:    private final long timeStamp;
30330: 4340:    TimeStamped(Basic basic) {
30331: 4341:        super(basic);
30332: 4342:        timeStamp = new Date().getTime();
30333: 4343:    }
30334: 4344:    public long getStamp() { return timeStamp; }
30335: 4345:}
30336: 4346:
30337: 4347:class SerialNumbered extends Decorator {
30338: 4348:    private static long counter = 1;
30339: 4349:    private final long serialNumber = counter++;
30340: 4350:    SerialNumbered(Basic basic) { super(basic); }
30341: 4351:    public long getSerialNumber() { return serialNumber; }
30342: 4352:}
30343: 4353:
30344: 4354:public class Decoration {
30345: 4355:    public static void main(String[] args) {
30346: 4356:        TimeStamped t = new TimeStamped(new Basic());
30347: 4357:        TimeStamped t2 = new TimeStamped(
30348: 4358:            new SerialNumbered(new Basic()));
30349: 4359:        //- t2.getSerialNumber(); // Not available
30350: 4360:        SerialNumbered s = new SerialNumbered(new Basic());
30351: 4361:        SerialNumbered s2 = new SerialNumbered(
30352: 4362:            new TimeStamped(new Basic()));
30353: 4363:        //- s2.getStamp(); // Not available
30354: 4364:  }
30355: 4365:}
30356: 4366:```
30357: 4367:
30358: 4368:产生自泛型的类包含所有感兴趣的方法，但是由使用装饰器所产生的对象类型是最后被装饰的类型。也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。因此，装饰器只是对由混型提出的问题的一种局限的解决方案。
30359: 4369:
30360: 4370:### 与动态代理混合
30361: 4371:
30362: 4372:可以使用动态代理来创建一种比装饰器更贴近混型模型的机制（查看 [类型信息](book/19-Type-Information.md) 一章中关于 Java 的动态代理如何工作的解释）。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。
30363: 4373:由于动态代理的限制，每个被混入的类都必须是某个接口的实现：
30364: 4374:
30365: 4375:```java
30366: 4376:// generics/DynamicProxyMixin.java
30367: 4377:
30368: 4378:import java.lang.reflect.*;
30369: 4379:import java.util.*;
30370: 4380:import onjava.*;
30371: 4381:import static onjava.Tuple.*;
30372: 4382:
30373: 4383:class MixinProxy implements InvocationHandler {
30374: 4384:    Map<String, Object> delegatesByMethod;
30375: 4385:    @SuppressWarnings("unchecked")
30376: 4386:    MixinProxy(Tuple2<Object, Class<?>>... pairs) {
30377: 4387:        delegatesByMethod = new HashMap<>();
30378: 4388:        for(Tuple2<Object, Class<?>> pair : pairs) {
30379: 4389:            for(Method method : pair.a2.getMethods()) {
30380: 4390:                String methodName = method.getName();
30381: 4391:                // The first interface in the map
30382: 4392:                // implements the method.
30383: 4393:                if(!delegatesByMethod.containsKey(methodName))
30384: 4394:                    delegatesByMethod.put(methodName, pair.a1);
30385: 4395:            }
30386: 4396:        }
30387: 4397:    }
30388: 4398:    @Override
30389: 4399:    public Object invoke(Object proxy, Method method,
30390: 4400:      Object[] args) throws Throwable {
30391: 4401:        String methodName = method.getName();
30392: 4402:        Object delegate = delegatesByMethod.get(methodName);
30393: 4403:        return method.invoke(delegate, args);
30394: 4404:    }
30395: 4405:    
30396: 4406:    @SuppressWarnings("unchecked")
30397: 4407:    public static Object newInstance(Tuple2... pairs) {
30398: 4408:        Class[] interfaces = new Class[pairs.length];
30399: 4409:        for(int i = 0; i < pairs.length; i++) {
30400: 4410:            interfaces[i] = (Class)pairs[i].a2;
30401: 4411:        }
30402: 4412:        ClassLoader cl = pairs[0].a1.getClass().getClassLoader();
30403: 4413:        return Proxy.newProxyInstance(cl, interfaces, new MixinProxy(pairs));
30404: 4414:    }
30405: 4415:}
30406: 4416:
30407: 4417:public class DynamicProxyMixin {
30408: 4418:    public static void main(String[] args) {
30409: 4419:        Object mixin = MixinProxy.newInstance(
30410: 4420:          tuple(new BasicImp(), Basic.class),
30411: 4421:          tuple(new TimeStampedImp(), TimeStamped.class),
30412: 4422:          tuple(new SerialNumberedImp(), SerialNumbered.class));
30413: 4423:        Basic b = (Basic)mixin;
30414: 4424:        TimeStamped t = (TimeStamped)mixin;
30415: 4425:        SerialNumbered s = (SerialNumbered)mixin;
30416: 4426:        b.set("Hello");
30417: 4427:        System.out.println(b.get());
30418: 4428:        System.out.println(t.getStamp());
30419: 4429:        System.out.println(s.getSerialNumber());
30420: 4430:    }
30421: 4431:}
30422: 4432:/* Output:
30423: 4433:Hello
30424: 4434:1494331653339
30425: 4435:1
30426: 4436:*/
30427: 4437:```
30428: 4438:
30429: 4439:因为只有动态类型而不是静态类型才包含所有的混入类型，因此这仍旧不如 C++ 的方式好，因为可以在具有这些类型的对象上调用方法之前，你被强制要求必须先将这些对象向下转型到恰当的类型。但是，它明显地更接近于真正的混型。
30430: 4440:为了让 Java 支持混型，人们已经做了大量的工作朝着这个目标努力，包括创建了至少一种附加语言（ Jam 语言），它是专门用来支持混型的。
30431: 4441:
30432: 4442:<!-- Latent Typing -->
30433: 4443:
30434: 4444:## 潜在类型机制
30435: 4445:
30436: 4446:在本章的开头介绍过这样的思想，即要编写能够尽可能广泛地应用的代码。为了实现这一点，我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处。然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码。
30437: 4447:
30438: 4448:Java 泛型看起来是向这一方向迈进了一步。当你在编写或使用只是持有对象的泛型时，这些代码将可以工作于任何类型（除了基本类型，尽管正如你所见到的，自动装箱机制可以克服这一点）。或者，换个角度讲，“持有器”泛型能够声明：“我不关心你是什么类型”。如果代码不关心它将要作用的类型，那么这种代码就可以真正地应用于任何地方，并因此而相当泛化。
30439: 4449:
30440: 4450:还是正如你所见到的，当要在泛型类型上执行操作（即调用 **Object** 方法之外的方法）时，就会产生问题。擦除强制要求指定可能会用到的泛型类型的边界，以安全地调用代码中的泛型对象上的具体方法。这是对“泛化”概念的一种明显的限制，因为必须限制你的泛型类型，使它们继承自特定的类，或者实现特定的接口。在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类或接口没有任何区别。
30441: 4451:
30442: 4452:某些编程语言提供的一种解决方案称为*潜在类型机制*或*结构化类型机制*，而更古怪的术语称为*鸭子类型机制*，即“如果它走起来像鸭子，并且叫起来也像鸭子，那么你就可以将它当作鸭子对待。”鸭子类型机制变成了一种相当流行的术语，可能是因为它不像其他的术语那样承载着历史的包袱。
30443: 4453:
30444: 4454:泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得你可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以 `speak()` 和 `sit()` 即可。”由于不要求具体类型，因此代码就可以更加泛化。
30445: 4455:
30446: 4456:潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方。
30447: 4457:
30448: 4458:支持潜在类型机制的语言包括 Python（可以从 www.Python.org 免费下载）、C++、Ruby、SmallTalk 和 Go。Python 是动态类型语言（几乎所有的类型检查都发生在运行时），而 C++ 和 Go 是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查。
30449: 4459:
30450: 4460:### pyhton 中的潜在类型
30451: 4461:
30452: 4462:如果我们将上面的描述用 Python 来表示，如下所示：
30453: 4463:
30454: 4464:```python
30455: 4465:# generics/DogsAndRobots.py
30456: 4466:
30457: 4467:class Dog:
30458: 4468:    def speak(self):
30459: 4469:        print("Arf!")
30460: 4470:    def sit(self):
30461: 4471:        print("Sitting")
30462: 4472:    def reproduce(self):
30463: 4473:        pass
30464: 4474:
30465: 4475:class Robot:
30466: 4476:    def speak(self):
30467: 4477:        print("Click!")
30468: 4478:    def sit(self):
30469: 4479:        print("Clank!")
30470: 4480:    def oilChange(self):
30471: 4481:        pass
30472: 4482:
30473: 4483:def perform(anything):
30474: 4484:    anything.speak()
30475: 4485:    anything.sit()
30476: 4486:
30477: 4487:a = Dog()
30478: 4488:b = Robot()
30479: 4489:perform(a)
30480: 4490:perform(b)
30481: 4491:
30482: 4492:output = """
30483: 4493:Arf!
30484: 4494:Sitting
30485: 4495:Click!
30486: 4496:Clank!
30487: 4497:"""
30488: 4498:```
30489: 4499:
30490: 4500:Python 使用缩进来确定作用域（因此不需要任何花括号），而冒号将表示新的作用域的开始。“**#**” 表示注释到行尾，就像Java中的 “ **//** ”。类的方法需要显式地指定 **this** 引用的等价物作为第一个参数，按惯例成为 **self** 。构造器调用不要求任何类型的“ **new** ”关键字，并且 Python 允许普通（非成员）函数，就像 `perform()` 所表明的那样。注意，在 `perform(anything)` 中，没有任何针对 **anything** 的类型，**anything** 只是一个标识符，它必须能够执行 `perform()` 期望它执行的操作，因此这里隐含着一个接口。但是你从来都不必显式地写出这个接口——它是潜在的。`perform()` 不关心其参数的类型，因此我可以向它传递任何对象，只要该对象支持  `speak()` 和 `sit()` 方法。如果传递给 `perform()` 的对象不支持这些操作，那么将会得到运行时异常。
30491: 4501:
30492: 4502:输出规定使用三重引号创建带有内嵌换行符的字符串。
30493: 4503:
30494: 4504:### C++ 中的潜在类型
30495: 4505:
30496: 4506:我们可以用 C++ 产生相同的效果：
30497: 4507:
30498: 4508:```c++
30499: 4509:// generics/DogsAndRobots.cpp
30500: 4510:
30501: 4511:#include <iostream>
30502: 4512:using namespace std;
30503: 4513:
30504: 4514:class Dog {
30505: 4515:public:
30506: 4516:    void speak() { cout << "Arf!" << endl; }
30507: 4517:    void sit() { cout << "Sitting" << endl; }
30508: 4518:    void reproduce() {}
30509: 4519:};
30510: 4520:
30511: 4521:class Robot {
30512: 4522:public:
30513: 4523:    void speak() { cout << "Click!" << endl; }
30514: 4524:    void sit() { cout << "Clank!" << endl; }
30515: 4525:    void oilChange() {}
30516: 4526:};
30517: 4527:
30518: 4528:template<class T> void perform(T anything) {
30519: 4529:    anything.speak();
30520: 4530:    anything.sit();
30521: 4531:}
30522: 4532:
30523: 4533:int main() {
30524: 4534:    Dog d;
30525: 4535:    Robot r;
30526: 4536:    perform(d);
30527: 4537:    perform(r);
30528: 4538:}
30529: 4539:/* Output:
30530: 4540:Arf!
30531: 4541:Sitting
30532: 4542:Click!
30533: 4543:Clank!
30534: 4544:*/
30535: 4545:```
30536: 4546:
30537: 4547:在 Python 和 C++ 中，**Dog** 和 **Robot** 没有任何共同的东西，只是碰巧有两个方法具有相同的签名。从类型的观点看，它们是完全不同的类型。但是，`perform()` 不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。
30538: 4548:C++ 确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给你一个错误消息（这些错误消息从历史上看是相当可怕和冗长的，是 C++ 的模版名声欠佳的主要原因）。尽管它们是在不同时期实现这一点的，C++ 在编译期，而 Python 在运行时，但是这两种语言都可以确保类型不会被误用，因此被认为是强类型的。[^5]潜在类型机制没有损害强类型机制。
30539: 4549:
30540: 4550:### Go 中的潜在类型
30541: 4551:
30542: 4552:这里用 Go 语言编写相同的程序：
30543: 4553:
30544: 4554:```go
30545: 4555:// generics/dogsandrobots.go
30546: 4556:
30547: 4557:package main
30548: 4558:import "fmt"
30549: 4559:
30550: 4560:type Dog struct {}
30551: 4561:func (this Dog) speak() { fmt.Printf("Arf!\n")}
30552: 4562:func (this Dog) sit() { fmt.Printf("Sitting\n")}
30553: 4563:func (this Dog) reproduce() {}
30554: 4564:
30555: 4565:type Robot struct {}
30556: 4566:func (this Robot) speak() { fmt.Printf("Click!\n") }
30557: 4567:func (this Robot) sit() { fmt.Printf("Clank!\n") }
30558: 4568:func (this Robot) oilChange() {}
30559: 4569:
30560: 4570:func perform(speaker interface { speak(); sit() }) {
30561: 4571:  speaker.speak();
30562: 4572:  speaker.sit();
30563: 4573:}
30564: 4574:
30565: 4575:func main() {
30566: 4576:  perform(Dog{})
30567: 4577:  perform(Robot{})
30568: 4578:}
30569: 4579:/* Output:
30570: 4580:Arf!
30571: 4581:Sitting
30572: 4582:Click!
30573: 4583:Clank!
30574: 4584:*/
30575: 4585:```
30576: 4586:
30577: 4587:Go 没有 **class** 关键字，但是可以使用上述形式创建等效的基本类：它通常不定义为类，而是定义为 **struct** ，在其中定义数据字段（此处不存在）。 对于每种方法，都以 **func** 关键字开头，然后（为了将该方法附加到您的类上）放在括号中，该括号包含对象引用，该对象引用可以是任何标识符，但是我在这里使用 **this** 来提醒您，就像在 C ++ 或 Java 中的 **this** 一样。 然后，在Go中像这样定义其余的函数。
30578: 4588:
30579: 4589:Go也没有继承关系，因此这种“面向对象的目标”形式是相对原始的，并且可能是我无法花更多的时间来学习该语言的主要原因。 但是，Go 的组成很简单。
30580: 4590:
30581: 4591:`perform()` 函数使用潜在类型：参数的确切类型并不重要，只要它包含了 `speak()` 和  `sit()` 方法即可。 该接口在此处匿名定义，内联，如 `perform()` 的参数列表所示。
30582: 4592:
30583: 4593:`main()` 证明 `perform()` 确实对其参数的确切类型不在乎，只要可以在该参数上调用 `talk()` 和 `sit()` 即可。 但是，就像 C ++ 模板函数一样，在编译时检查类型。
30584: 4594:
30585: 4595:语法 **Dog {}** 和 **Robot {}** 创建匿名的 **Dog** 和 **Robot** 结构。
30586: 4596:
30587: 4597:### java中的直接潜在类型
30588: 4598:
30589: 4599:因为泛型是在这场竞赛的后期才添加到 Java 中，因此没有任何机会可以去实现任何类型的潜在类型机制，因此 Java 没有对这种特性的支持。所以，初看起来，Java 的泛型机制比支持潜在类型机制的语言更“缺乏泛化性”。（使用擦除来实现 Java 泛型的实现有时称为第二类泛型类型）例如，在 Java 8  之前如果我们试图用 Java 实现上面 dogs-and-robots 的示例，那么就会被强制要求使用一个类或接口，并在边界表达式中指定它：
30590: 4600:
30591: 4601:```java
30592: 4602:// generics/Performs.java
30593: 4603:
30594: 4604:public interface Performs {
30595: 4605:    void speak();
30596: 4606:    void sit();
30597: 4607:}
30598: 4608:```
30599: 4609:
30600: 4610:```java
30601: 4611:// generics/DogsAndRobots.java
30602: 4612:// No (direct) latent typing in Java
30603: 4613:import typeinfo.pets.*;
30604: 4614:
30605: 4615:class PerformingDog extends Dog implements Performs {
30606: 4616:    @Override
30607: 4617:    public void speak() { System.out.println("Woof!"); }
30608: 4618:    @Override
30609: 4619:    public void sit() { System.out.println("Sitting"); }
30610: 4620:    public void reproduce() {}
30611: 4621:}
30612: 4622:
30613: 4623:class Robot implements Performs {
30614: 4624:    public void speak() { System.out.println("Click!"); }
30615: 4625:    public void sit() { System.out.println("Clank!"); }
30616: 4626:    public void oilChange() {}
30617: 4627:}
30618: 4628:
30619: 4629:class Communicate {
30620: 4630:    public static <T extends Performs>
30621: 4631:      void perform(T performer) {
30622: 4632:        performer.speak();
30623: 4633:        performer.sit();
30624: 4634:    }
30625: 4635:}
30626: 4636:
30627: 4637:public class DogsAndRobots {
30628: 4638:    public static void main(String[] args) {
30629: 4639:        Communicate.perform(new PerformingDog());
30630: 4640:        Communicate.perform(new Robot());
30631: 4641:    }
30632: 4642:}
30633: 4643:/* Output:
30634: 4644:Woof!
30635: 4645:Sitting
30636: 4646:Click!
30637: 4647:Clank!
30638: 4648:*/
30639: 4649:```
30640: 4650:
30641: 4651:但是要注意，`perform()` 不需要使用泛型来工作，它可以被简单地指定为接受一个 **Performs** 对象：
30642: 4652:
30643: 4653:```java
30644: 4654:// generics/SimpleDogsAndRobots.java
30645: 4655:// Removing the generic; code still works
30646: 4656:
30647: 4657:class CommunicateSimply {
30648: 4658:    static void perform(Performs performer) {
30649: 4659:        performer.speak();
30650: 4660:        performer.sit();
30651: 4661:    }
30652: 4662:}
30653: 4663:
30654: 4664:public class SimpleDogsAndRobots {
30655: 4665:    public static void main(String[] args) {
30656: 4666:        CommunicateSimply.perform(new PerformingDog());
30657: 4667:        CommunicateSimply.perform(new Robot());
30658: 4668:    }
30659: 4669:}
30660: 4670:/* Output:
30661: 4671:Woof!
30662: 4672:Sitting
30663: 4673:Click!
30664: 4674:Clank!
30665: 4675:*/
30666: 4676:```
30667: 4677:
30668: 4678:在本例中，泛型不是必需的，因为这些类已经被强制要求实现 **Performs** 接口。
30669: 4679:
30670: 4680:<!-- Compensating for the Lack of (Direct) Latent -->
30671: 4681:
30672: 4682:## 对缺乏潜在类型机制的补偿
30673: 4683:
30674: 4684:尽管 Java 不直接支持潜在类型机制，但是这并不意味着泛型代码不能在不同的类型层次结构之间应用。也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。
30675: 4685:
30676: 4686:### 反射
30677: 4687:
30678: 4688:可以使用的一种方式是反射，下面的 `perform()` 方法就是用了潜在类型机制：
30679: 4689:
30680: 4690:```java
30681: 4691:// generics/LatentReflection.java
30682: 4692:// Using reflection for latent typing
30683: 4693:import java.lang.reflect.*;
30684: 4694:
30685: 4695:// Does not implement Performs:
30686: 4696:class Mime {
30687: 4697:    public void walkAgainstTheWind() {}
30688: 4698:    public void sit() {
30689: 4699:        System.out.println("Pretending to sit");
30690: 4700:    }
30691: 4701:    public void pushInvisibleWalls() {}
30692: 4702:    @Override
30693: 4703:    public String toString() { return "Mime"; }
30694: 4704:}
30695: 4705:
30696: 4706:// Does not implement Performs:
30697: 4707:class SmartDog {
30698: 4708:    public void speak() { System.out.println("Woof!"); }
30699: 4709:    public void sit() { System.out.println("Sitting"); }
30700: 4710:    public void reproduce() {}
30701: 4711:}
30702: 4712:
30703: 4713:class CommunicateReflectively {
30704: 4714:    public static void perform(Object speaker) {
30705: 4715:        Class<?> spkr = speaker.getClass();
30706: 4716:        try {
30707: 4717:            try {
30708: 4718:                Method speak = spkr.getMethod("speak");
30709: 4719:                speak.invoke(speaker);
30710: 4720:            } catch(NoSuchMethodException e) {
30711: 4721:                System.out.println(speaker + " cannot speak");
30712: 4722:            }
30713: 4723:            try {
30714: 4724:                Method sit = spkr.getMethod("sit");
30715: 4725:                sit.invoke(speaker);
30716: 4726:            } catch(NoSuchMethodException e) {
30717: 4727:                System.out.println(speaker + " cannot sit");
30718: 4728:            }
30719: 4729:        } catch(SecurityException |
30720: 4730:            IllegalAccessException |
30721: 4731:            IllegalArgumentException |
30722: 4732:            InvocationTargetException e) {
30723: 4733:            throw new RuntimeException(speaker.toString(), e);
30724: 4734:        }
30725: 4735:    }
30726: 4736:}
30727: 4737:
30728: 4738:public class LatentReflection {
30729: 4739:    public static void main(String[] args) {
30730: 4740:        CommunicateReflectively.perform(new SmartDog());
30731: 4741:        CommunicateReflectively.perform(new Robot());
30732: 4742:        CommunicateReflectively.perform(new Mime());
30733: 4743:    }
30734: 4744:}
30735: 4745:/* Output:
30736: 4746:Woof!
30737: 4747:Sitting
30738: 4748:Click!
30739: 4749:Clank!
30740: 4750:Mime cannot speak
30741: 4751:Pretending to sit
30742: 4752:*/
30743: 4753:```
30744: 4754:
30745: 4755:上例中，这些类完全是彼此分离的，没有任何公共基类（除了 **Object** ）或接口。通过反射, `CommunicateReflectively.perform()` 能够动态地确定所需要的方法是否可用并调用它们。它甚至能够处理 **Mime** 只具有一个必需的方法这一事实，并能够部分实现其目标。
30746: 4756:
30747: 4757:### 将一个方法应用于序列
30748: 4758:
30749: 4759:反射提供了一些有用的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。但是有可能实现编译期类型检查和潜在类型机制吗？
30750: 4760:
30751: 4761:让我们看一个说明这个问题的示例。假设想要创建一个 `apply()` 方法，它能够将任何方法应用于某个序列中的所有对象。这种情况下使用接口不适合，因为你想要将任何方法应用于一个对象集合，而接口不可能描述任何方法。如何用 Java 来实现这个需求呢？
30752: 4762:
30753: 4763:最初，我们可以用反射来解决这个问题，由于有了 Java 的可变参数，这种方式被证明是相当优雅的：
30754: 4764:
30755: 4765:```java
30756: 4766:// generics/Apply.java
30757: 4767:
30758: 4768:import java.lang.reflect.*;
30759: 4769:import java.util.*;
30760: 4770:
30761: 4771:public class Apply {
30762: 4772:    public static <T, S extends Iterable<T>>
30763: 4773:      void apply(S seq, Method f, Object... args) {
30764: 4774:        try {
30765: 4775:            for(T t: seq)
30766: 4776:                f.invoke(t, args);
30767: 4777:        } catch(IllegalAccessException |
30768: 4778:            IllegalArgumentException |
30769: 4779:            InvocationTargetException e) {
30770: 4780:            // Failures are programmer errors
30771: 4781:            throw new RuntimeException(e);
30772: 4782:        }
30773: 4783:    }
30774: 4784:}
30775: 4785:```
30776: 4786:
30777: 4787:在 **Apply.java** 中，异常被转换为 **RuntimeException** ，因为没有多少办法可以从这种异常中恢复——在这种情况下，它们实际上代表着程序员的错误。
30778: 4788:
30779: 4789:为什么我们不只使用 Java 8 方法参考（稍后显示）而不是反射方法 **f** ？ 注意，`invoke()` 和 `apply()` 的优点是它们可以接受任意数量的参数。 在某些情况下，灵活性可能至关重要。
30780: 4790:
30781: 4791:为了测试 **Apply** ，我们首先创建一个 **Shape** 类：
30782: 4792:
30783: 4793:```java
30784: 4794:// generics/Shape.java
30785: 4795:
30786: 4796:public class Shape {
30787: 4797:    private static long counter = 0;
30788: 4798:    private final long id = counter++;
30789: 4799:    @Override
30790: 4800:    public String toString() {
30791: 4801:        return getClass().getSimpleName() + " " + id;
30792: 4802:    }
30793: 4803:    public void rotate() {
30794: 4804:        System.out.println(this + " rotate");
30795: 4805:    }
30796: 4806:    public void resize(int newSize) {
30797: 4807:        System.out.println(this + " resize " + newSize);
30798: 4808:    }
30799: 4809:}
30800: 4810:```
30801: 4811:
30802: 4812:被一个子类 **Square** 继承：
30803: 4813:
30804: 4814:```java
30805: 4815:// generics/Square.java
30806: 4816:
30807: 4817:public class Square extends Shape {}
30808: 4818:```
30809: 4819:
30810: 4820:通过这些，我们可以测试 **Apply**：
30811: 4821:
30812: 4822:```java
30813: 4823:// generics/ApplyTest.java
30814: 4824:
30815: 4825:import java.util.*;
30816: 4826:import java.util.function.*;
30817: 4827:import onjava.*;
30818: 4828:
30819: 4829:public class ApplyTest {
30820: 4830:    public static
30821: 4831:    void main(String[] args) throws Exception {
30822: 4832:        List<Shape> shapes =
30823: 4833:          Suppliers.create(ArrayList::new, Shape::new, 3);
30824: 4834:        Apply.apply(shapes, Shape.class.getMethod("rotate"));
30825: 4835:        Apply.apply(shapes, Shape.class.getMethod("resize", int.class), 7);
30826: 4836:
30827: 4837:        List<Square> squares =
30828: 4838:          Suppliers.create(ArrayList::new, Square::new, 3);
30829: 4839:        Apply.apply(squares, Shape.class.getMethod("rotate"));
30830: 4840:        Apply.apply(squares, Shape.class.getMethod("resize", int.class), 7);
30831: 4841:
30832: 4842:        Apply.apply(new FilledList<>(Shape::new, 3),
30833: 4843:          Shape.class.getMethod("rotate"));
30834: 4844:        Apply.apply(new FilledList<>(Square::new, 3),
30835: 4845:          Shape.class.getMethod("rotate"));
30836: 4846:
30837: 4847:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
30838: 4848:          new SimpleQueue<>(), SimpleQueue::add,
30839: 4849:          Shape::new, 3);
30840: 4850:        Suppliers.fill(shapeQ, SimpleQueue::add,
30841: 4851:          Square::new, 3);
30842: 4852:        Apply.apply(shapeQ, Shape.class.getMethod("rotate"));
30843: 4853:    }
30844: 4854:}
30845: 4855:/* Output:
30846: 4856:Shape 0 rotate
30847: 4857:Shape 1 rotate
30848: 4858:Shape 2 rotate
30849: 4859:Shape 0 resize 7
30850: 4860:Shape 1 resize 7
30851: 4861:Shape 2 resize 7
30852: 4862:Square 3 rotate
30853: 4863:Square 4 rotate
30854: 4864:Square 5 rotate
30855: 4865:Square 3 resize 7
30856: 4866:Square 4 resize 7
30857: 4867:Square 5 resize 7
30858: 4868:Shape 6 rotate
30859: 4869:Shape 7 rotate
30860: 4870:Shape 8 rotate
30861: 4871:Square 9 rotate
30862: 4872:Square 10 rotate
30863: 4873:Square 11 rotate
30864: 4874:Shape 12 rotate
30865: 4875:Shape 13 rotate
30866: 4876:Shape 14 rotate
30867: 4877:Square 15 rotate
30868: 4878:Square 16 rotate
30869: 4879:Square 17 rotate
30870: 4880:*/
30871: 4881:```
30872: 4882:
30873: 4883:在 **Apply** 中，我们运气很好，因为碰巧在 Java 中内建了一个由 Java 集合类库使用的 **Iterable** 接口。正由于此， `apply()` 方法可以接受任何实现了 **Iterable** 接口的事物，包括诸如 **List** 这样的所有 **Collection** 类。但是它还可以接受其他任何事物，只要能够使这些事物是 **Iterable** 的——例如，在 `main()` 中使用下面定义的 **SimpleQueue** 类：
30874: 4884:
30875: 4885:```java
30876: 4886:// generics/SimpleQueue.java
30877: 4887:
30878: 4888:// A different kind of Iterable collection
30879: 4889:import java.util.*;
30880: 4890:
30881: 4891:public class SimpleQueue<T> implements Iterable<T> {
30882: 4892:    private LinkedList<T> storage = new LinkedList<>();
30883: 4893:    public void add(T t) { storage.offer(t); }
30884: 4894:    public T get() { return storage.poll(); }
30885: 4895:    @Override
30886: 4896:    public Iterator<T> iterator() {
30887: 4897:        return storage.iterator();
30888: 4898:    }
30889: 4899:}
30890: 4900:```
30891: 4901:
30892: 4902:正如反射解决方案看起来那样优雅，我们必须观察到反射（尽管在 Java 的最新版本中得到了显着改进）通常比非反射实现要慢，因为在运行时发生了很多事情。 但它不应阻止您尝试这种解决方案，这依然是值得考虑的一点。
30893: 4903:
30894: 4904:几乎可以肯定，你会首先使用 Java 8 的函数式方法，并且只有在解决了特殊需求时才诉诸反射。 这里对 **ApplyTest.java** 进行了重写，以利用 Java 8 的流和函数工具：
30895: 4905:
30896: 4906:```java
30897: 4907:// generics/ApplyFunctional.java
30898: 4908:
30899: 4909:import java.util.*;
30900: 4910:import java.util.stream.*;
30901: 4911:import java.util.function.*;
30902: 4912:import onjava.*;
30903: 4913:
30904: 4914:public class ApplyFunctional {
30905: 4915:    public static void main(String[] args) {
30906: 4916:        Stream.of(
30907: 4917:          Stream.generate(Shape::new).limit(2),
30908: 4918:          Stream.generate(Square::new).limit(2))
30909: 4919:        .flatMap(c -> c) // flatten into one stream
30910: 4920:        .peek(Shape::rotate)
30911: 4921:        .forEach(s -> s.resize(7));
30912: 4922:
30913: 4923:        new FilledList<>(Shape::new, 2)
30914: 4924:          .forEach(Shape::rotate);
30915: 4925:        new FilledList<>(Square::new, 2)
30916: 4926:          .forEach(Shape::rotate);
30917: 4927:
30918: 4928:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
30919: 4929:          new SimpleQueue<>(), SimpleQueue::add,
30920: 4930:          Shape::new, 2);
30921: 4931:        Suppliers.fill(shapeQ, SimpleQueue::add,
30922: 4932:          Square::new, 2);
30923: 4933:        shapeQ.forEach(Shape::rotate);
30924: 4934:    }
30925: 4935:}
30926: 4936:/* Output:
30927: 4937:Shape 0 rotate
30928: 4938:Shape 0 resize 7
30929: 4939:Shape 1 rotate
30930: 4940:Shape 1 resize 7
30931: 4941:Square 2 rotate
30932: 4942:Square 2 resize 7
30933: 4943:Square 3 rotate
30934: 4944:Square 3 resize 7
30935: 4945:Shape 4 rotate
30936: 4946:Shape 5 rotate
30937: 4947:Square 6 rotate
30938: 4948:Square 7 rotate
30939: 4949:Shape 8 rotate
30940: 4950:Shape 9 rotate
30941: 4951:Square 10 rotate
30942: 4952:Square 11 rotate
30943: 4953:*/
30944: 4954:```
30945: 4955:
30946: 4956:由于使用 Java 8，因此不需要 `Apply.apply()` 。
30947: 4957:
30948: 4958:我们首先生成两个 **Stream** ： 一个是 **Shape** ，一个是 **Square** ，并将它们展平为单个流。 尽管 Java 缺少功能语言中经常出现的 `flatten()` ，但是我们可以使用 `flatMap(c-> c)` 产生相同的结果，后者使用身份映射将操作简化为“  **flatten** ”。
30949: 4959:
30950: 4960:我们使用 `peek()` 当做对 `rotate()` 的调用，因为 `peek()` 执行一个操作（此处是出于副作用），并在未更改的情况下传递对象。
30951: 4961:
30952: 4962:注意，使用 **FilledList** 和 **shapeQ** 调用 `forEach()` 比 `Apply.apply()` 代码整洁得多。 在代码简单性和可读性方面，结果比以前的方法好得多。 并且，现在也不可能从  `main()` 引发异常。
30953: 4963:
30954: 4964:<!-- Assisted Latent Typing in Java 8 -->
30955: 4965:
30956: 4966:## Java8 中的辅助潜在类型
30957: 4967:
30958: 4968:先前声明关于 Java 缺乏对潜在类型的支持在 Java 8 之前是完全正确的。但是，Java 8 中的非绑定方法引用使我们能够产生一种潜在类型的形式，以满足创建一段可工作在不相干类型上的代码。因为 Java 最初并不是如此设计，所以结果可想而知，比其他语言中要尴尬一些。但是，至少现在成为了可能，只是缺乏令人惊艳之处。
30959: 4969:
30960: 4970:我在其他地方从没遇过这种技术，因此我将其称为辅助潜在类型。
30961: 4971:
30962: 4972:我们将重写 **DogsAndRobots.java** 来演示该技术。 为使外观看起来与原始示例尽可能相似，我仅向每个原始类名添加了 **A**：
30963: 4973:
30964: 4974:```java
30965: 4975:// generics/DogsAndRobotMethodReferences.java
30966: 4976:
30967: 4977:// "Assisted Latent Typing"
30968: 4978:import typeinfo.pets.*;
30969: 4979:import java.util.function.*;
30970: 4980:
30971: 4981:class PerformingDogA extends Dog {
30972: 4982:    public void speak() { System.out.println("Woof!"); }
30973: 4983:    public void sit() { System.out.println("Sitting"); }
30974: 4984:    public void reproduce() {}
30975: 4985:}
30976: 4986:
30977: 4987:class RobotA {
30978: 4988:    public void speak() { System.out.println("Click!"); }
30979: 4989:    public void sit() { System.out.println("Clank!"); }
30980: 4990:    public void oilChange() {}
30981: 4991:}
30982: 4992:
30983: 4993:class CommunicateA {
30984: 4994:    public static <P> void perform(P performer,
30985: 4995:      Consumer<P> action1, Consumer<P> action2) {
30986: 4996:        action1.accept(performer);
30987: 4997:        action2.accept(performer);
30988: 4998:    }
30989: 4999:}
30990: 5000:
30991: 5001:public class DogsAndRobotMethodReferences {
30992: 5002:    public static void main(String[] args) {
30993: 5003:        CommunicateA.perform(new PerformingDogA(),
30994: 5004:          PerformingDogA::speak, PerformingDogA::sit);
30995: 5005:        CommunicateA.perform(new RobotA(),
30996: 5006:          RobotA::speak, RobotA::sit);
30997: 5007:        CommunicateA.perform(new Mime(),
30998: 5008:          Mime::walkAgainstTheWind,
30999: 5009:          Mime::pushInvisibleWalls);
31000: 5010:    }
31001: 5011:}
31002: 5012:/* Output:
31003: 5013:Woof!
31004: 5014:Sitting
31005: 5015:Click!
31006: 5016:Clank!
31007: 5017:*/
31008: 5018:```
31009: 5019:
31010: 5020:**PerformingDogA** 和 **RobotA** 与 **DogsAndRobots.java** 中的相同，不同之处在于它们不继承通用接口 **Performs** ，因此它们没有通用性。
31011: 5021:
31012: 5022:`CommunicateA.perform()` 在没有约束的 **P** 上生成。 只要可以使用 `Consumer <P>`，它在这里就可以是任何东西，这些 `Consumer<P>` 代表不带参数的 **P** 方法的未绑定方法引用。当您调用 **Consumer**  的 `accept()` 方法时，它将方法引用绑定到执行者对象并调用该方法。 由于 [函数式编程](book/13-Functional-Programming.md) 一章中描述的“魔术”，我们可以将任何符合签名的未绑定方法引用传递给 `CommunicateA.perform()` 。
31013: 5023:
31014: 5024:之所以称其为“辅助”，是因为您必须显式地为 `perform()` 提供要使用的方法引用。 它不能只按名称调用方法。
31015: 5025:
31016: 5026:尽管传递未绑定的方法引用似乎要花很多力气，但潜在类型的最终目标还是可以实现的。 我们创建了一个代码片段 `CommunicateA.perform()` ，该代码可用于任何具有符合签名的方法引用的类型。 请注意，这与我们看到的其他语言中的潜在类型有所不同，因为这些语言不仅需要签名以符合规范，还需要方法名称。 因此，该技术可以说产生了更多的通用代码。
31017: 5027:
31018: 5028:为了证明这一点，我还从 **LatentReflection.java** 中引入了 **Mime**。
31019: 5029:
31020: 5030:### 使用**Suppliers**类的通用方法
31021: 5031:
31022: 5032:通过辅助潜在类型，我们可以定义本章其他部分中使用的 **Suppliers** 类。 此类包含使用生成器填充 **Collection** 的工具方法。 泛化这些操作很有意义：
31023: 5033:
31024: 5034:```java
31025: 5035:// onjava/Suppliers.java
31026: 5036:
31027: 5037:// A utility to use with Suppliers
31028: 5038:package onjava;
31029: 5039:import java.util.*;
31030: 5040:import java.util.function.*;
31031: 5041:import java.util.stream.*;
31032: 5042:
31033: 5043:public class Suppliers {
31034: 5044:    // Create a collection and fill it:
31035: 5045:    public static <T, C extends Collection<T>> C
31036: 5046:      create(Supplier<C> factory, Supplier<T> gen, int n) {
31037: 5047:        return Stream.generate(gen)
31038: 5048:            .limit(n)
31039: 5049:            .collect(factory, C::add, C::addAll);
31040: 5050:    }
31041: 5051:    
31042: 5052:    // Fill an existing collection:
31043: 5053:    public static <T, C extends Collection<T>>
31044: 5054:      C fill(C coll, Supplier<T> gen, int n) {
31045: 5055:        Stream.generate(gen)
31046: 5056:            .limit(n)
31047: 5057:            .forEach(coll::add);
31048: 5058:        return coll;
31049: 5059:    }
31050: 5060:    
31051: 5061:    // Use an unbound method reference to
31052: 5062:    // produce a more general method:
31053: 5063:    public static <H, A> H fill(H holder,
31054: 5064:      BiConsumer<H, A> adder, Supplier<A> gen, int n) {
31055: 5065:        Stream.generate(gen)
31056: 5066:            .limit(n)
31057: 5067:            .forEach(a -> adder.accept(holder, a));
31058: 5068:        return holder;
31059: 5069:    }
31060: 5070:}
31061: 5071:```
31062: 5072:
31063: 5073:`create()` 为你创建一个新的 **Collection** 子类型，而 `fill()` 的第一个版本将元素放入 **Collection** 的现有子类型中。 请注意，还会返回传入的容器的确切类型，因此不会丢失类型信息。[^6]
31064: 5074:
31065: 5075:前两种方法一般都受约束，只能与 **Collection** 子类型一起使用。`fill()` 的第二个版本适用于任何类型的 **holder** 。 它需要一个附加参数：未绑定方法引用 `adder. fill()` ，使用辅助潜在类型来使其与任何具有添加元素方法的 **holder** 类型一起使用。因为此未绑定方法 **adder** 必须带有一个参数（要添加到 **holder** 的元素），所以 **adder** 必须是 `BiConsumer <H，A>` ，其中 **H** 是要绑定到的 **holder** 对象的类型，而 **A** 是要被添加的绑定元素类型。 对 `accept()` 的调用将使用参数 a 调用对象 **holder** 上的未绑定方法 **holder**。
31066: 5076:
31067: 5077:在一个稍作模拟的测试中对 **Suppliers** 工具程序进行了测试，该仿真还使用了本章前面定义的 **RandomList** ：
31068: 5078:
31069: 5079:```java
31070: 5080:// generics/BankTeller.java
31071: 5081:
31072: 5082:// A very simple bank teller simulation
31073: 5083:import java.util.*;
31074: 5084:import onjava.*;
31075: 5085:
31076: 5086:class Customer {
31077: 5087:    private static long counter = 1;
31078: 5088:    private final long id = counter++;
31079: 5089:    @Override
31080: 5090:    public String toString() {
31081: 5091:        return "Customer " + id;
31082: 5092:    }
31083: 5093:}
31084: 5094:
31085: 5095:class Teller {
31086: 5096:    private static long counter = 1;
31087: 5097:    private final long id = counter++;
31088: 5098:    @Override
31089: 5099:    public String toString() {
31090: 5100:        return "Teller " + id;
31091: 5101:    }
31092: 5102:}
31093: 5103:
31094: 5104:class Bank {
31095: 5105:    private List<BankTeller> tellers =
31096: 5106:        new ArrayList<>();
31097: 5107:    public void put(BankTeller bt) {
31098: 5108:        tellers.add(bt);
31099: 5109:    }
31100: 5110:}
31101: 5111:
31102: 5112:public class BankTeller {
31103: 5113:    public static void serve(Teller t, Customer c) {
31104: 5114:        System.out.println(t + " serves " + c);
31105: 5115:    }
31106: 5116:    public static void main(String[] args) {
31107: 5117:        // Demonstrate create():
31108: 5118:        RandomList<Teller> tellers =
31109: 5119:            Suppliers.create(
31110: 5120:            RandomList::new, Teller::new, 4);
31111: 5121:        // Demonstrate fill():
31112: 5122:        List<Customer> customers = Suppliers.fill(
31113: 5123:            new ArrayList<>(), Customer::new, 12);
31114: 5124:        customers.forEach(c ->
31115: 5125:            serve(tellers.select(), c));
31116: 5126:        // Demonstrate assisted latent typing:
31117: 5127:        Bank bank = Suppliers.fill(
31118: 5128:            new Bank(), Bank::put, BankTeller::new, 3);
31119: 5129:        // Can also use second version of fill():
31120: 5130:        List<Customer> customers2 = Suppliers.fill(
31121: 5131:            new ArrayList<>(),
31122: 5132:            List::add, Customer::new, 12);
31123: 5133:    }
31124: 5134:}
31125: 5135:/* Output:
31126: 5136:Teller 3 serves Customer 1
31127: 5137:Teller 2 serves Customer 2
31128: 5138:Teller 3 serves Customer 3
31129: 5139:Teller 1 serves Customer 4
31130: 5140:Teller 1 serves Customer 5
31131: 5141:Teller 3 serves Customer 6
31132: 5142:Teller 1 serves Customer 7
31133: 5143:Teller 2 serves Customer 8
31134: 5144:Teller 3 serves Customer 9
31135: 5145:Teller 3 serves Customer 10
31136: 5146:Teller 2 serves Customer 11
31137: 5147:Teller 4 serves Customer 12
31138: 5148:*/
31139: 5149:```
31140: 5150:
31141: 5151:可以看到 `create()` 生成一个新的 **Collection** 对象，而 `fill()` 添加到现有 **Collection** 中。第二个版本`fill()` 显示，它不仅与无关的新类型 **Bank** 一起使用，还能与 **List** 一起使用。因此，从技术上讲，`fill()` 的第一个版本在技术上不是必需的，但在使用 **Collection** 时提供了较短的语法。
31142: 5152:
31143: 5153:<!-- Summary: Is Casting Really So Bad? -->
31144: 5154:
31145: 5155:## 总结：类型转换真的如此之糟吗？
31146: 5156:
31147: 5157:自从 C++ 模版出现以来，我就一直在致力于解释它，我可能比大多数人都更早地提出了下面的论点。直到最近，我才停下来，去思考这个论点到底在多少时间内是有效的——我将要描述的问题到底有多少次可以穿越障碍得以解决。
31148: 5158:
31149: 5159:这个论点就是：使用泛型类型机制的最吸引人的地方，就是在使用集合类的地方，这些类包括诸如各种 **List** 、各种 **Set** 、各种 **Map** 等你在 [集合](book/12-Collections.md) 和 [附录：集合主题](book/Appendix-Collection-Topics.md) 这两章所见。在 Java 5 之前，当你将一个对象放置到集合中时，这个对象就会被向上转型为 **Object** ，因此你会丢失类型信息。当你想要将这个对象从集合中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。我用的示例是持有 **Cat** 的 **List** （这个示例的一种使用苹果和桔子的变体在 [集合](book/12-Collections.md) 章节的开头展示过）。如果没有 Java 5 泛型版本的集合，你放到容集里和从集合中取回的都是 **Object** 。因此，我们很可能会将一个 **Dog** 放置到 **Cat** 的 **List** 中。
31150: 5160:
31151: 5161:但是，泛型出现之前的 Java 并不会让你误用放入到集合中的对象。如果将一个 **Dog** 扔到 **Cat** 的集合中，并且试图将这个集合中的所有东西都当作 **Cat** 处理，那么当你从这个 **Cat** 集合中取回那个 **Dog** 引用，并试图将其转型为 **Cat** 时，就会得到一个 **RuntimeException** 。你仍旧可以发现问题，但是是在运行时而非编译期发现它的。
31152: 5162:
31153: 5163:在本书以前的版本中，我曾经说过：
31154: 5164:
31155: 5165:> 这不止令人恼火，它还可能会产生难以发现的缺陷。如果这个程序的某个部分（或数个部分）向集合中插入了对象，并且通过异常，你在程序的另一个独立的部分中发现有不良对象被放置到了集合中，那么必须发现这个不良插入到底是在何处发生的。
31156: 5166:
31157: 5167:但是，随着对这个论点的进一步检查，我开始怀疑它了。首先，这会多么频繁地发生呢？我记得这类事情从未发生在我身上，并且当我在会议上询问其他人时，我也从来没有听说过有人碰上过。另一本书使用了一个称为 **files** 的 list 示例，它包含 **String** 对象。在这个示例中，向 **files** 中添加一个 **File** 对象看起来相当自然，因此这个对象的名字可能叫 **fileNames** 更好。无论 Java 提供了多少类型检查，仍旧可能会写出晦涩的程序，而编写差劲儿的程序即便可以编译，它仍旧是编写差劲儿的程序。可能大多数人都会使用命名良好的集合，例如 **cats** ，因为它们可以向试图添加非 **Cat** 对象的程序员提供可视的警告。并且即便这类事情发生了，它真正又能潜伏多久呢？只要你开始用真实数据来运行测试，就会非常快地看到异常。
31158: 5168:
31159: 5169:有一位作者甚至断言，这样的缺陷将“*潜伏数年*”。但是我不记得有任何大量的相关报告，来说明人们在查找“狗在猫列表中”这类缺陷时困难重重，或者是说明人们会非常频繁地产生这种错误。然而，你将在 [多线程编程](book/24-Concurrent-Programming.md) 章节中看到，在使用线程时，出现那些可能看起来极罕见的缺陷，是很寻常并容易发生的事，而且，对于到底出了什么错，这些缺陷只能给你一个很模糊的概念。因此，对于泛型是添加到 Java 中的非常显著和相当复杂的特性这一点，“狗在猫列表中”这个论据真的能够成为它的理由吗？
31160: 5170:我相信被称为*泛型*的通用语言特性（并非必须是其在 Java 中的特定实现）的目的在于可表达性，而不仅仅是为了创建类型安全的集合。类型安全的集合是能够创建更通用代码这一能力所带来的副作用。
31161: 5171:因此，即便“狗在猫列表中”这个论据经常被用来证明泛型是必要的，但是它仍旧是有问题的。就像我在本章开头声称的，我不相信这就是泛型这个概念真正的含义。相反，泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。正如你在本章中看到的，编写真正泛化的“持有器”类（ Java 的容器就是这种类）相当简单，但是编写出能够操作其泛型类型的泛化代码就需要额外的努力了，这些努力需要类创建者和类消费者共同付出，他们必须理解这些代码的概念和实现。这些额外的努力会增加使用这种特性的难度，并可能会因此而使其在某些场合缺乏可应用性，而在这些场合中，它可能会带来附加的价值。
31162: 5172:
31163: 5173:还要注意到，因为泛型是后来添加到 Java 中，而不是从一开始就设计到这种语言中的，所以某些容器无法达到它们应该具备的健壮性。例如，观察一下 **Map** ，在特定的方法 `containsKey(Object key) `和 `get(Object key)` 中就包含这类情况。如果这些类是使用在它们之前就存在的泛型设计的，那么这些方法将会使用参数化类型而不是 **Object** ，因此也就可以提供这些泛型假设会提供的编译期检查。例如，在 C++ 的 **map** 中，键的类型总是在编译期检查的。
31164: 5174:
31165: 5175:有一件事很明显：在一种语言已经被广泛应用之后，在其较新的版本中引入任何种类的泛型机制，都会是一项非常非常棘手的任务，并且是一项不付出艰辛就无法完成的任务。在 C++ 中，模版是在其最初的 ISO 版本中就引入的（即便如此，也引发了阵痛，因为在第一个标准 C++ 出现之前，有很多非模版版本在使用），因此实际上模版一直都是这种语言的一部分。在 Java 中，泛型是在这种语言首次发布大约 10 年之后才引入的，因此向泛型迁移的问题特别多，并且对泛型的设计产生了明显的影响。其结果就是，程序员将承受这些痛苦，而这一切都是由于 Java 设计者在设计 1.0 版本时所表现出来的短视造成的。当 Java 最初被创建时，它的设计者们当然了解 C++ 的模版，他们甚至考虑将其囊括到 Java 语言中，但是出于这样或那样的原因，他们决定将模版排除在外（其迹象就是他们过于匆忙）。因此， Java 语言和使用它的程序员都将承受这些痛苦。只有时间将会说明 Java 的泛型方式对这种语言所造成的最终影响。
31166: 5176:某些语言，已经融入了更简洁、影响更小的方式，来实现参数化类型。我们不可能不去想象这样的语言将会成为 Java 的继任者，因为它们采用的方式，与 C++ 通过 C 来实现的方式相同：按原样使用它，然后对其进行改进。
31167: 5177:
31168: 5178:## 进阶阅读
31169: 5179:
31170: 5180:泛型的入门文档是 《Generics in the Java Programming Language》，作者是 Gilad Bracha，可以从 http://java.oracle.com 获取。
31171: 5181:
31172: 5182:Angelika Langer 的《Java Generics FAQs》是一份非常有帮助的资料，可以从 http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html 获取。
31173: 5183:
31174: 5184:你可以从 《Adding Wildcards to the Java Programming Language》中学到更多关于通配符的知识，作者是 Torgerson、Ernst、Hansen、von der Ahe、Bracha 和 Gafter，地址是 http://www.jot.fm/issues/issue_2004_12/article5。
31175: 5185:
31176: 5186:Neal After 对于 Java 问题（尤其是擦除）的看法可以从这里找到：http://www.infoq.com/articles/neal-gafter-on-java。
31177: 5187:
31178: 5188:[^1]: 在编写本章期间，Angelika Langer的 Java 泛型常见问题解答以及她的其他著作（与Klaus Kreft一起）是非常宝贵的。
31179: 5189:[^2]: [http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html](http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html)
31180: 5190:[^3]: 参见本章章末引文。
31181: 5191:[^4]: 注意，一些编程环境，如 Eclipse 和 IntelliJ IDEA，将会自动生成委托代码。
31182: 5192:[^5]: 因为可以使用转型，有效地禁止了类型系统，一些人就认为 C++ 是弱类型，但这太极端了。一种可能更好的说法是 C++ 是有一道暗门的强类型语言。
31183: 5193:[^6]: 我再次从 Brian Goetz 那获得帮助。
31184: 5194:
31185: 5195:<!-- 分页 -->
31186: 5196:
31187: 5197:<div style="page-break-after: always;"></div>
31188: 
31189: 1:[TOC]
31190: 2:
31191: 3:<!-- Generics -->
31192: 4:
31193: 5:# 第二十章 泛型
31194: 6:
31195: 7:> 普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。
31196: 8:
31197: 9:多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。除了 `final` 类（或只提供私有构造函数的类）任何类型都可被扩展，所以大部分时候这种灵活性是自带的。
31198: 10:
31199: 11:拘泥于单一的继承体系太过局限，因为只有继承体系中的对象才能适用基类作为参数的方法中。如果方法以接口而不是类作为参数，限制就宽松多了，只要实现了接口就可以。这给予调用方一种选项，通过调整现有的类来实现接口，满足方法参数要求。接口可以突破继承体系的限制。
31200: 12:
31201: 13:即便是接口也还是有诸多限制。一旦指定了接口，它就要求你的代码必须使用特定的接口。而我们希望编写更通用的代码，能够适用“非特定的类型”，而不是一个具体的接口或类。
31202: 14:
31203: 15:这就是泛型的概念，是 Java 5 的重大变化之一。泛型实现了*参数化类型*，这样你编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。随后你会发现 Java 中泛型的实现并没有那么“泛”，你可能会质疑“泛型”这个词是否合适用来描述这一功能。
31204: 16:
31205: 17:如果你从未接触过参数化类型机制，你会发现泛型对 Java 语言确实是个很有益的补充。在你实例化一个类型参数时，编译器会负责转型并确保类型的正确性。这是一大进步。
31206: 18:
31207: 19:然而，如果你了解其他语言（例如 C++ ）的参数化机制，你会发现，Java 泛型并不能满足所有的预期。使用别人创建好的泛型相对容易，但是创建自己的泛型时，就会遇到很多意料之外的麻烦。
31208: 20:
31209: 21:这并不是说 Java 泛型毫无用处。在很多情况下，它可以使代码更直接更优雅。不过，如果你见识过那种实现了更纯粹的泛型的编程语言，那么，Java 可能会令你失望。本章会介绍 Java 泛型的优点与局限。我会解释 Java 的泛型是如何发展成现在这样的，希望能够帮助你更有效地使用这个特性。[^1]
31210: 22:
31211: 23:### 与 C++ 的比较
31212: 24:
31213: 25:Java 的设计者曾说过，这门语言的灵感主要来自 C++ 。尽管如此，学习 Java 时基本不用参考 C++ 。
31214: 26:
31215: 27:但是，Java 中的泛型需要与 C++ 进行对比，理由有两个：首先，理解 C++ *模板*（泛型的主要灵感来源，包括基本语法）的某些特性，有助于理解泛型的基础理念。同时，非常重要的一点是，你可以了解 Java 泛型的局限是什么，以及为什么会有这些局限。最终的目标是明确 Java 泛型的边界，让你成为一个程序高手。只有知道了某个技术不能做什么，你才能更好地做到所能做的（部分原因是，不必浪费时间在死胡同里）。
31216: 28:
31217: 29:第二个原因是，在 Java 社区中，大家普遍对 C++ 模板有一种误解，而这种误解可能会令你在理解泛型的意图时产生偏差。
31218: 30:
31219: 31:因此，本章中会介绍少量 C++ 模板的例子，仅当它们确实可以加深理解时才会引入。
31220: 32:
31221: 33:<!-- Simple Generics -->
31222: 34:
31223: 35:## 简单泛型
31224: 36:
31225: 37:促成泛型出现的最主要的动机之一是为了创建*集合类*，参见 [集合](book/12-Collections.md) 章节。集合用于存放要使用到的对象。数组也是如此，不过集合比数组更加灵活，功能更丰富。几乎所有程序在运行过程中都会涉及到一组对象，因此集合是可复用性最高的类库之一。
31226: 38:
31227: 39:我们先看一个只能持有单个对象的类。这个类可以明确指定其持有的对象的类型：
31228: 40:
31229: 41:```java
31230: 42:// generics/Holder1.java
31231: 43:
31232: 44:class Automobile {}
31233: 45:
31234: 46:public class Holder1 {
31235: 47:    private Automobile a;
31236: 48:    public Holder1(Automobile a) { this.a = a; }
31237: 49:    Automobile get() { return a; }
31238: 50:}
31239: 51:```
31240: 52:
31241: 53:这个类的可复用性不高，它无法持有其他类型的对象。我们可不希望为碰到的每个类型都编写一个新的类。
31242: 54:
31243: 55:在 Java 5 之前，我们可以让这个类直接持有 `Object` 类型的对象：
31244: 56:
31245: 57:```java
31246: 58:// generics/ObjectHolder.java
31247: 59:
31248: 60:public class ObjectHolder {
31249: 61:    private Object a;
31250: 62:    public ObjectHolder(Object a) { this.a = a; }
31251: 63:    public void set(Object a) { this.a = a; }
31252: 64:    public Object get() { return a; }
31253: 65:    
31254: 66:    public static void main(String[] args) {
31255: 67:        ObjectHolder h2 = new ObjectHolder(new Automobile());
31256: 68:        Automobile a = (Automobile)h2.get();
31257: 69:        h2.set("Not an Automobile");
31258: 70:        String s = (String)h2.get();
31259: 71:        h2.set(1); // 自动装箱为 Integer
31260: 72:        Integer x = (Integer)h2.get();
31261: 73:    }
31262: 74:}
31263: 75:```
31264: 76:
31265: 77:现在，`ObjectHolder` 可以持有任何类型的对象，在上面的示例中，一个 `ObjectHolder` 先后持有了三种不同类型的对象。
31266: 78:
31267: 79:一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。
31268: 80:
31269: 81:因此，与其使用 `Object` ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用*类型参数*，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，`T` 就是类型参数：
31270: 82:
31271: 83:```java
31272: 84:// generics/GenericHolder.java
31273: 85:
31274: 86:public class GenericHolder<T> {
31275: 87:    private T a;
31276: 88:    public GenericHolder() {}
31277: 89:    public void set(T a) { this.a = a; }
31278: 90:    public T get() { return a; }
31279: 91:    
31280: 92:    public static void main(String[] args) {
31281: 93:        GenericHolder<Automobile> h3 = new GenericHolder<Automobile>();
31282: 94:        h3.set(new Automobile()); // 此处有类型校验
31283: 95:        Automobile a = h3.get();  // 无需类型转换
31284: 96:        //- h3.set("Not an Automobile"); // 报错
31285: 97:        //- h3.set(1);  // 报错
31286: 98:    }
31287: 99:}
31288: 100:```
31289: 101:
31290: 102:创建 `GenericHolder` 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 `main()` 中那样使用。然后，你就只能在 `GenericHolder` 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当你调用 `get()` 取值时，直接就是正确的类型。
31291: 103:
31292: 104:这就是 Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。
31293: 105:
31294: 106:你可能注意到 `h3` 的定义非常繁复。在 `=` 左边有 `GenericHolder<Automobile>`, 右边又重复了一次。在 Java 5 中，这种写法被解释成“必要的”，但在 Java 7 中设计者修正了这个问题（新的简写语法随后成为备受欢迎的特性）。以下是简写的例子：
31295: 107:
31296: 108:```java
31297: 109:// generics/Diamond.java
31298: 110:
31299: 111:class Bob {}
31300: 112:
31301: 113:public class Diamond<T> {
31302: 114:    public static void main(String[] args) {
31303: 115:        GenericHolder<Bob> h3 = new GenericHolder<>();
31304: 116:        h3.set(new Bob());
31305: 117:    }
31306: 118:}
31307: 119:```
31308: 120:
31309: 121:注意，在 `h3` 的定义处，`=` 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。在本书剩余部分都会使用这种语法。
31310: 122:
31311: 123:一般来说，你可以认为泛型和其他类型差不多，只不过它们碰巧有类型参数罢了。在使用泛型时，你只需要指定它们的名称和类型参数列表即可。
31312: 124:
31313: 125:### 一个元组类库
31314: 126:
31315: 127:有时一个方法需要能返回多个对象。而 **return** 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得了编译时的类型安全。
31316: 128:
31317: 129:这个概念称为*元组*，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 *数据传输对象* 或 *信使* ）。
31318: 130:
31319: 131:通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组：
31320: 132:
31321: 133:```java
31322: 134:// onjava/Tuple2.java
31323: 135:package onjava;
31324: 136:
31325: 137:public class Tuple2<A, B> {
31326: 138:    public final A a1;
31327: 139:    public final B a2;
31328: 140:    public Tuple2(A a, B b) { a1 = a; a2 = b; }
31329: 141:    public String rep() { return a1 + ", " + a2; }
31330: 142:  
31331: 143:    @Override
31332: 144:    public String toString() {
31333: 145:        return "(" + rep() + ")";
31334: 146:    }
31335: 147:}
31336: 148:```
31337: 149:
31338: 150:构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。
31339: 151:
31340: 152:初次阅读上面的代码时，你可能认为这违反了 Java 编程的封装原则。`a1` 和 `a2` 应该声明为 **private**，然后提供 `getFirst()` 和 `getSecond()` 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取 `a1` 和 `a2` 然后对它们执行任何操作，但无法对 `a1` 和 `a2` 重新赋值。例子中的 `final` 可以实现同样的效果，并且更为简洁明了。
31341: 153:
31342: 154:另一种设计思路是允许元组的用户给 `a1` 和 `a2` 重新赋值。然而，采用上例中的形式无疑更加安全，如果用户想存储不同的元素，就会强制他们创建新的 `Tuple2` 对象。
31343: 155:
31344: 156:我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了：
31345: 157:
31346: 158:```java
31347: 159:// onjava/Tuple3.java
31348: 160:package onjava;
31349: 161:
31350: 162:public class Tuple3<A, B, C> extends Tuple2<A, B> {
31351: 163:    public final C a3;
31352: 164:    public Tuple3(A a, B b, C c) {
31353: 165:        super(a, b);
31354: 166:        a3 = c;
31355: 167:    }
31356: 168:    
31357: 169:    @Override
31358: 170:    public String rep() {
31359: 171:        return super.rep() + ", " + a3;
31360: 172:    }
31361: 173:}
31362: 174:
31363: 175:// onjava/Tuple4.java
31364: 176:package onjava;
31365: 177:
31366: 178:public class Tuple4<A, B, C, D>
31367: 179:  extends Tuple3<A, B, C> {
31368: 180:    public final D a4;
31369: 181:    public Tuple4(A a, B b, C c, D d) {
31370: 182:        super(a, b, c);
31371: 183:        a4 = d;
31372: 184:    }
31373: 185:    
31374: 186:    @Override
31375: 187:    public String rep() {
31376: 188:        return super.rep() + ", " + a4;
31377: 189:    }
31378: 190:}
31379: 191:
31380: 192:// onjava/Tuple5.java
31381: 193:package onjava;
31382: 194:
31383: 195:public class Tuple5<A, B, C, D, E>
31384: 196:  extends Tuple4<A, B, C, D> {
31385: 197:    public final E a5;
31386: 198:    public Tuple5(A a, B b, C c, D d, E e) {
31387: 199:        super(a, b, c, d);
31388: 200:        a5 = e;
31389: 201:    }
31390: 202:    
31391: 203:    @Override
31392: 204:    public String rep() {
31393: 205:        return super.rep() + ", " + a5;
31394: 206:    }
31395: 207:}
31396: 208:```
31397: 209:
31398: 210:演示需要，再定义两个类：
31399: 211:
31400: 212:```java
31401: 213:// generics/Amphibian.java
31402: 214:public class Amphibian {}
31403: 215:
31404: 216:// generics/Vehicle.java
31405: 217:public class Vehicle {}
31406: 218:```
31407: 219:
31408: 220:使用元组时，你只需要定义一个长度适合的元组，将其作为返回值即可。注意下面例子中方法的返回类型：
31409: 221:
31410: 222:```java
31411: 223:// generics/TupleTest.java
31412: 224:import onjava.*;
31413: 225:
31414: 226:public class TupleTest {
31415: 227:    static Tuple2<String, Integer> f() {
31416: 228:        // 47 自动装箱为 Integer
31417: 229:        return new Tuple2<>("hi", 47);
31418: 230:    }
31419: 231:  
31420: 232:    static Tuple3<Amphibian, String, Integer> g() {
31421: 233:        return new Tuple3<>(new Amphibian(), "hi", 47);
31422: 234:    }
31423: 235:  
31424: 236:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
31425: 237:        return new Tuple4<>(new Vehicle(), new Amphibian(), "hi", 47);
31426: 238:    }
31427: 239:  
31428: 240:    static Tuple5<Vehicle, Amphibian, String, Integer, Double> k() {
31429: 241:        return new Tuple5<>(new Vehicle(), new Amphibian(), "hi", 47, 11.1);
31430: 242:    }
31431: 243:  
31432: 244:    public static void main(String[] args) {
31433: 245:        Tuple2<String, Integer> ttsi = f();
31434: 246:        System.out.println(ttsi);
31435: 247:        // ttsi.a1 = "there"; // 编译错误，因为 final 不能重新赋值
31436: 248:        System.out.println(g());
31437: 249:        System.out.println(h());
31438: 250:        System.out.println(k());
31439: 251:    }
31440: 252:}
31441: 253:
31442: 254:/* 输出：
31443: 255: (hi, 47)
31444: 256: (Amphibian@1540e19d, hi, 47)
31445: 257: (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47)
31446: 258: (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1)
31447: 259: */
31448: 260:```
31449: 261:
31450: 262:有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。
31451: 263:
31452: 264:通过 `ttsi.a1 = "there"` 语句的报错，我们可以看出，**final** 声明确实可以确保 **public** 字段在对象被构造出来之后就不能重新赋值了。
31453: 265:
31454: 266:在上面的程序中，`new` 表达式有些啰嗦。本章稍后会介绍，如何利用 *泛型方法* 简化它们。
31455: 267:
31456: 268:### 一个堆栈类
31457: 269:
31458: 270:接下来我们看一个稍微复杂一点的例子：堆栈。在 [集合](book/12-Collections.md) 一章中，我们用 `LinkedList` 实现了 `onjava.Stack` 类。在那个例子中，`LinkedList` 本身已经具备了创建堆栈所需的方法。`Stack` 是通过两个泛型类 `Stack<T>` 和 `LinkedList<T>` 的组合来创建。我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。
31459: 271:
31460: 272:这次我们不用 `LinkedList` 来实现自己的内部链式存储机制。
31461: 273:
31462: 274:```java
31463: 275:// generics/LinkedStack.java
31464: 276:// 用链式结构实现的堆栈
31465: 277:
31466: 278:public class LinkedStack<T> {
31467: 279:    private static class Node<U> {
31468: 280:        U item;
31469: 281:        Node<U> next;
31470: 282:    
31471: 283:        Node() { item = null; next = null; }
31472: 284:        
31473: 285:        Node(U item, Node<U> next) {
31474: 286:            this.item = item;
31475: 287:            this.next = next;
31476: 288:        }
31477: 289:    
31478: 290:        boolean end() {
31479: 291:            return item == null && next == null;
31480: 292:        }
31481: 293:    }
31482: 294:  
31483: 295:    private Node<T> top = new Node<>();  // 栈顶
31484: 296:  
31485: 297:    public void push(T item) {
31486: 298:        top = new Node<>(item, top);
31487: 299:    }
31488: 300:  
31489: 301:    public T pop() {
31490: 302:        T result = top.item;
31491: 303:        if (!top.end()) {
31492: 304:            top = top.next;
31493: 305:        }
31494: 306:        return result;
31495: 307:    }
31496: 308:  
31497: 309:    public static void main(String[] args) {
31498: 310:        LinkedStack<String> lss = new LinkedStack<>();
31499: 311:        for (String s : "Phasers on stun!".split(" ")) {
31500: 312:            lss.push(s);
31501: 313:        }
31502: 314:        String s;
31503: 315:        while ((s = lss.pop()) != null) {
31504: 316:            System.out.println(s);
31505: 317:        }
31506: 318:    }
31507: 319:}
31508: 320:```
31509: 321:
31510: 322:输出结果：
31511: 323:
31512: 324:```java
31513: 325:stun!
31514: 326:on
31515: 327:Phasers
31516: 328:```
31517: 329:
31518: 330:内部类 `Node` 也是一个泛型，它拥有自己的类型参数。
31519: 331:
31520: 332:这个例子使用了一个 *末端标识* (end sentinel) 来判断栈何时为空。这个末端标识是在构造 `LinkedStack` 时创建的。然后，每次调用 `push()` 就会创建一个 `Node<T>` 对象，并将其链接到前一个 `Node<T>` 对象。当你调用 `pop()` 方法时，总是返回 `top.item`，然后丢弃当前 `top` 所指向的 `Node<T>`，并将 `top` 指向下一个 `Node<T>`，除非到达末端标识，这时就不能再移动 `top` 了。如果已经到达末端，程序还继续调用 `pop()` 方法，它只能得到 `null`，说明栈已经空了。
31521: 333:
31522: 334:### RandomList
31523: 335:
31524: 336:作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 `select()` 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型：
31525: 337:
31526: 338:```java
31527: 339:// generics/RandomList.java
31528: 340:import java.util.*;
31529: 341:import java.util.stream.*;
31530: 342:
31531: 343:public class RandomList<T> extends ArrayList<T> {
31532: 344:    private Random rand = new Random(47);
31533: 345:  
31534: 346:    public T select() {
31535: 347:        return get(rand.nextInt(size()));
31536: 348:    }
31537: 349:  
31538: 350:    public static void main(String[] args) {
31539: 351:        RandomList<String> rs = new RandomList<>();
31540: 352:        Arrays.stream("The quick brown fox jumped over the lazy brown dog".split(" ")).forEach(rs::add);
31541: 353:        IntStream.range(0, 11).forEach(i -> 
31542: 354:            System.out.print(rs.select() + " "));
31543: 355:    }
31544: 356:}
31545: 357:```
31546: 358:
31547: 359:输出结果：
31548: 360:
31549: 361:```java
31550: 362:brown over fox quick quick dog brown The brown lazy brown
31551: 363:```
31552: 364:
31553: 365:`RandomList` 继承了 `ArrayList` 的所有方法。本例中只添加了 `select()` 这个方法。
31554: 366:
31555: 367:<!-- Generic Interfaces -->
31556: 368:
31557: 369:## 泛型接口
31558: 370:
31559: 371:泛型也可以应用于接口。例如 *生成器*，这是一种专门负责创建对象的类。实际上，这是 *工厂方法* 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。
31560: 372:
31561: 373:一般而言，一个生成器只定义一个方法，用于创建对象。例如 `java.util.function` 类库中的 `Supplier` 就是一个生成器，调用其 `get()` 获取对象。`get()` 是泛型方法，返回值为类型参数 `T`。
31562: 374:
31563: 375:为了演示 `Supplier`，我们需要定义几个类。下面是个咖啡相关的继承体系：
31564: 376:
31565: 377:```java
31566: 378:// generics/coffee/Coffee.java
31567: 379:package generics.coffee;
31568: 380:
31569: 381:public class Coffee {
31570: 382:    private static long counter = 0;
31571: 383:    private final long id = counter++;
31572: 384:  
31573: 385:    @Override
31574: 386:    public String toString() {
31575: 387:        return getClass().getSimpleName() + " " + id;
31576: 388:    }
31577: 389:}
31578: 390:
31579: 391:
31580: 392:// generics/coffee/Latte.java
31581: 393:package generics.coffee;
31582: 394:public class Latte extends Coffee {}
31583: 395:
31584: 396:
31585: 397:// generics/coffee/Mocha.java
31586: 398:package generics.coffee;
31587: 399:public class Mocha extends Coffee {}
31588: 400:
31589: 401:
31590: 402:// generics/coffee/Cappuccino.java
31591: 403:package generics.coffee;
31592: 404:public class Cappuccino extends Coffee {}
31593: 405:
31594: 406:
31595: 407:// generics/coffee/Americano.java
31596: 408:package generics.coffee;
31597: 409:public class Americano extends Coffee {}
31598: 410:
31599: 411:
31600: 412:// generics/coffee/Breve.java
31601: 413:package generics.coffee;
31602: 414:public class Breve extends Coffee {}
31603: 415:```
31604: 416:
31605: 417:现在，我们可以编写一个类，实现 `Supplier<Coffee>` 接口，它能够随机生成不同类型的 `Coffee` 对象：
31606: 418:
31607: 419:```java
31608: 420:// generics/coffee/CoffeeSupplier.java
31609: 421:// {java generics.coffee.CoffeeSupplier}
31610: 422:package generics.coffee;
31611: 423:import java.util.*;
31612: 424:import java.util.function.*;
31613: 425:import java.util.stream.*;
31614: 426:
31615: 427:public class CoffeeSupplier
31616: 428:implements Supplier<Coffee>, Iterable<Coffee> {
31617: 429:    private Class<?>[] types = { Latte.class, Mocha.class, 
31618: 430:        Cappuccino.class, Americano.class, Breve.class };
31619: 431:    private static Random rand = new Random(47);
31620: 432:  
31621: 433:    public CoffeeSupplier() {}
31622: 434:    // For iteration:
31623: 435:    private int size = 0;
31624: 436:    public CoffeeSupplier(int sz) { size = sz; }
31625: 437:  
31626: 438:    @Override
31627: 439:    public Coffee get() {
31628: 440:        try {
31629: 441:            return (Coffee) types[rand.nextInt(types.length)].newInstance();
31630: 442:        } catch (InstantiationException | IllegalAccessException e) {
31631: 443:            throw new RuntimeException(e);
31632: 444:        }
31633: 445:    }
31634: 446:  
31635: 447:    class CoffeeIterator implements Iterator<Coffee> {
31636: 448:        int count = size;
31637: 449:        @Override
31638: 450:        public boolean hasNext() { return count > 0; }
31639: 451:        @Override
31640: 452:        public Coffee next() {
31641: 453:            count--;
31642: 454:            return CoffeeSupplier.this.get();
31643: 455:        }
31644: 456:        @Override
31645: 457:        public void remove() {
31646: 458:            throw new UnsupportedOperationException();
31647: 459:        }
31648: 460:    }
31649: 461:  
31650: 462:    @Override
31651: 463:    public Iterator<Coffee> iterator() {
31652: 464:        return new CoffeeIterator();
31653: 465:    }
31654: 466:  
31655: 467:    public static void main(String[] args) {
31656: 468:        Stream.generate(new CoffeeSupplier())
31657: 469:              .limit(5)
31658: 470:              .forEach(System.out::println);
31659: 471:        for (Coffee c : new CoffeeSupplier(5)) {
31660: 472:            System.out.println(c);
31661: 473:        }
31662: 474:    }
31663: 475:}
31664: 476:```
31665: 477:
31666: 478:输出结果：
31667: 479:
31668: 480:```java
31669: 481:Americano 0
31670: 482:Latte 1
31671: 483:Americano 2
31672: 484:Mocha 3
31673: 485:Mocha 4
31674: 486:Breve 5
31675: 487:Americano 6
31676: 488:Latte 7
31677: 489:Cappuccino 8
31678: 490:Cappuccino 9
31679: 491:```
31680: 492:
31681: 493:参数化的 `Supplier` 接口确保 `get()` 返回值是参数的类型。`CoffeeSupplier` 同时还实现了 `Iterable` 接口，所以能用于 *for-in* 语句。不过，它还需要知道何时终止循环，这正是第二个构造函数的作用。
31682: 494:
31683: 495:下面是另一个实现 `Supplier<T>` 接口的例子，它负责生成 Fibonacci 数列：
31684: 496:
31685: 497:```java
31686: 498:// generics/Fibonacci.java
31687: 499:// Generate a Fibonacci sequence
31688: 500:import java.util.function.*;
31689: 501:import java.util.stream.*;
31690: 502:
31691: 503:public class Fibonacci implements Supplier<Integer> {
31692: 504:    private int count = 0;
31693: 505:    @Override
31694: 506:    public Integer get() { return fib(count++); }
31695: 507:  
31696: 508:    private int fib(int n) {
31697: 509:        if(n < 2) return 1;
31698: 510:        return fib(n-2) + fib(n-1);
31699: 511:    }
31700: 512:  
31701: 513:    public static void main(String[] args) {
31702: 514:        Stream.generate(new Fibonacci())
31703: 515:              .limit(18)
31704: 516:              .map(n -> n + " ")
31705: 517:              .forEach(System.out::print);
31706: 518:    }
31707: 519:}
31708: 520:```
31709: 521:
31710: 522:输出结果：
31711: 523:
31712: 524:```java
31713: 525:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
31714: 526:```
31715: 527:
31716: 528:虽然我们在 `Fibonacci` 类的里里外外使用的都是 `int` 类型，但是其参数类型却是 `Integer`。这个例子引出了 Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备自动装箱和拆箱的功能，可以很方便地在基本类型和相应的包装类之间进行转换。通过这个例子中 `Fibonacci` 类对 `int` 的使用，我们已经看到了这种效果。
31717: 529:
31718: 530:如果还想更进一步，编写一个实现了 `Iterable` 的 `Fibnoacci` 生成器。我们的一个选择是重写这个类，令其实现 `Iterable` 接口。不过，你并不是总能拥有源代码的控制权，并且，除非必须这么做，否则，我们也不愿意重写一个类。而且我们还有另一种选择，就是创建一个 *适配器* (Adapter) 来实现所需的接口，我们在前面介绍过这个设计模式。
31719: 531:
31720: 532:有多种方法可以实现适配器。例如，可以通过继承来创建适配器类：
31721: 533:
31722: 534:```java
31723: 535:// generics/IterableFibonacci.java
31724: 536:// Adapt the Fibonacci class to make it Iterable
31725: 537:import java.util.*;
31726: 538:
31727: 539:public class IterableFibonacci
31728: 540:extends Fibonacci implements Iterable<Integer> {
31729: 541:    private int n;
31730: 542:    public IterableFibonacci(int count) { n = count; }
31731: 543:  
31732: 544:    @Override
31733: 545:    public Iterator<Integer> iterator() {
31734: 546:        return new Iterator<Integer>() {
31735: 547:            @Override
31736: 548:            public boolean hasNext() { return n > 0; }
31737: 549:            @Override
31738: 550:            public Integer next() {
31739: 551:                n--;
31740: 552:                return IterableFibonacci.this.get();
31741: 553:            }
31742: 554:            @Override
31743: 555:            public void remove() { // Not implemented
31744: 556:                throw new UnsupportedOperationException();
31745: 557:            }
31746: 558:        };
31747: 559:    }
31748: 560:  
31749: 561:    public static void main(String[] args) {
31750: 562:        for(int i : new IterableFibonacci(18))
31751: 563:            System.out.print(i + " ");
31752: 564:    }
31753: 565:}
31754: 566:```
31755: 567:
31756: 568:输出结果：
31757: 569:
31758: 570:```java
31759: 571:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
31760: 572:```
31761: 573:
31762: 574:在 *for-in* 语句中使用 `IterableFibonacci`，必须在构造函数中提供一个边界值，这样 `hasNext()` 才知道何时返回 **false**，结束循环。
31763: 575:
31764: 576:<!-- Generic Methods -->
31765: 577:
31766: 578:## 泛型方法
31767: 579:
31768: 580:到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。
31769: 581:
31770: 582:泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。
31771: 583:
31772: 584:如果方法是 **static** 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型类型参数，则它必须是泛型方法。
31773: 585:
31774: 586:要定义泛型方法，请将泛型参数列表放置在返回值之前，如下所示：
31775: 587:
31776: 588:```java
31777: 589:// generics/GenericMethods.java
31778: 590:
31779: 591:public class GenericMethods {
31780: 592:    public <T> void f(T x) {
31781: 593:        System.out.println(x.getClass().getName());
31782: 594:    }
31783: 595:
31784: 596:    public static void main(String[] args) {
31785: 597:        GenericMethods gm = new GenericMethods();
31786: 598:        gm.f("");
31787: 599:        gm.f(1);
31788: 600:        gm.f(1.0);
31789: 601:        gm.f(1.0F);
31790: 602:        gm.f('c');
31791: 603:        gm.f(gm);
31792: 604:    }
31793: 605:}
31794: 606:/* Output:
31795: 607:java.lang.String
31796: 608:java.lang.Integer
31797: 609:java.lang.Double
31798: 610:java.lang.Float
31799: 611:java.lang.Character
31800: 612:GenericMethods
31801: 613:*/
31802: 614:```
31803: 615:
31804: 616:尽管可以同时对类及其方法进行参数化，但这里未将 **GenericMethods** 类参数化。只有方法 `f()` 具有类型参数，该参数由方法返回类型之前的参数列表指示。
31805: 617:
31806: 618:对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 *类型参数推断*。因此，对 `f()` 的调用看起来像普通的方法调用，并且 `f()` 看起来像被重载了无数次一样。它甚至会接受 **GenericMethods** 类型的参数。
31807: 619:
31808: 620:如果使用基本类型调用 `f()` ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。
31809: 621:
31810: 622:<!-- Varargs and Generic Methods -->
31811: 623:
31812: 624:### 变长参数和泛型方法
31813: 625:
31814: 626:泛型方法和变长参数列表可以很好地共存：
31815: 627:
31816: 628:```java
31817: 629:// generics/GenericVarargs.java
31818: 630:
31819: 631:import java.util.ArrayList;
31820: 632:import java.util.List;
31821: 633:
31822: 634:public class GenericVarargs {
31823: 635:    @SafeVarargs
31824: 636:    public static <T> List<T> makeList(T... args) {
31825: 637:        List<T> result = new ArrayList<>();
31826: 638:        for (T item : args)
31827: 639:            result.add(item);
31828: 640:        return result;
31829: 641:    }
31830: 642:
31831: 643:    public static void main(String[] args) {
31832: 644:        List<String> ls = makeList("A");
31833: 645:        System.out.println(ls);
31834: 646:        ls = makeList("A", "B", "C");
31835: 647:        System.out.println(ls);
31836: 648:        ls = makeList(
31837: 649:                "ABCDEFFHIJKLMNOPQRSTUVWXYZ".split(""));
31838: 650:        System.out.println(ls);
31839: 651:    }
31840: 652:}
31841: 653:/* Output:
31842: 654:[A]
31843: 655:[A, B, C]
31844: 656:[A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R,
31845: 657:S, T, U, V, W, X, Y, Z]
31846: 658:*/
31847: 659:```
31848: 660:
31849: 661:此处显示的 `makeList()` 方法产生的功能与标准库的 `java.util.Arrays.asList()` 方法相同。
31850: 662:
31851: 663:`@SafeVarargs` 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。
31852: 664:
31853: 665:<!-- A General-Purpose Supplier -->
31854: 666:
31855: 667:### 一个泛型的 Supplier
31856: 668:
31857: 669:这是一个为任意具有无参构造方法的类生成 **Supplier** 的类。为了减少键入，它还包括一个用于生成 **BasicSupplier** 的泛型方法：
31858: 670:
31859: 671:```java
31860: 672:// onjava/BasicSupplier.java
31861: 673:// Supplier from a class with a no-arg constructor
31862: 674:package onjava;
31863: 675:
31864: 676:import java.util.function.Supplier;
31865: 677:
31866: 678:public class BasicSupplier<T> implements Supplier<T> {
31867: 679:    private Class<T> type;
31868: 680:
31869: 681:    public BasicSupplier(Class<T> type) {
31870: 682:        this.type = type;
31871: 683:    }
31872: 684:
31873: 685:    @Override
31874: 686:    public T get() {
31875: 687:        try {
31876: 688:            // Assumes type is a public class:
31877: 689:            return type.newInstance();
31878: 690:        } catch (InstantiationException |
31879: 691:                IllegalAccessException e) {
31880: 692:            throw new RuntimeException(e);
31881: 693:        }
31882: 694:    }
31883: 695:
31884: 696:    // Produce a default Supplier from a type token:
31885: 697:    public static <T> Supplier<T> create(Class<T> type) {
31886: 698:        return new BasicSupplier<>(type);
31887: 699:    }
31888: 700:}
31889: 701:```
31890: 702:
31891: 703:此类提供了产生以下对象的基本实现：
31892: 704:
31893: 705:1. 是 **public** 的。 因为 **BasicSupplier** 在单独的包中，所以相关的类必须具有 **public** 权限，而不仅仅是包级访问权限。
31894: 706:
31895: 707:2. 具有无参构造方法。要创建一个这样的 **BasicSupplier** 对象，请调用 `create()` 方法，并将要生成类型的类型令牌传递给它。通用的 `create()` 方法提供了 `BasicSupplier.create(MyType.class)` 这种较简洁的语法来代替较笨拙的 `new BasicSupplier <MyType>(MyType.class)`。
31896: 708:
31897: 709:例如，这是一个具有无参构造方法的简单类：
31898: 710:
31899: 711:```java
31900: 712:// generics/CountedObject.java
31901: 713:
31902: 714:public class CountedObject {
31903: 715:    private static long counter = 0;
31904: 716:    private final long id = counter++;
31905: 717:
31906: 718:    public long id() {
31907: 719:        return id;
31908: 720:    }
31909: 721:
31910: 722:    @Override
31911: 723:    public String toString() {
31912: 724:        return "CountedObject " + id;
31913: 725:    }
31914: 726:}
31915: 727:```
31916: 728:
31917: 729:**CountedObject** 类可以跟踪自身创建了多少个实例，并通过 `toString()` 报告这些实例的数量。 **BasicSupplier** 可以轻松地为 **CountedObject** 创建 **Supplier**：
31918: 730:
31919: 731:```java
31920: 732:  // generics/BasicSupplierDemo.java
31921: 733:
31922: 734:import onjava.BasicSupplier;
31923: 735:
31924: 736:import java.util.stream.Stream;
31925: 737:
31926: 738:public class BasicSupplierDemo {
31927: 739:    public static void main(String[] args) {
31928: 740:        Stream.generate(
31929: 741:                BasicSupplier.create(CountedObject.class))
31930: 742:                .limit(5)
31931: 743:                .forEach(System.out::println);
31932: 744:    }
31933: 745:}
31934: 746:/* Output:
31935: 747:CountedObject 0
31936: 748:CountedObject 1
31937: 749:CountedObject 2
31938: 750:CountedObject 3
31939: 751:CountedObject 4
31940: 752:*/
31941: 753:```
31942: 754:
31943: 755:泛型方法减少了产生 **Supplier** 对象所需的代码量。 Java 泛型强制传递 **Class** 对象，以便在 `create()` 方法中将其用于类型推断。
31944: 756:
31945: 757:<!-- Simplifying Tuple Use -->
31946: 758:
31947: 759:### 简化元组的使用
31948: 760:
31949: 761:使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库。在这里，我们使用重载的静态方法创建元组：
31950: 762:
31951: 763:```java
31952: 764:// onjava/Tuple.java
31953: 765:// Tuple library using type argument inference
31954: 766:package onjava;
31955: 767:
31956: 768:public class Tuple {
31957: 769:    public static <A, B> Tuple2<A, B> tuple(A a, B b) {
31958: 770:        return new Tuple2<>(a, b);
31959: 771:    }
31960: 772:
31961: 773:    public static <A, B, C> Tuple3<A, B, C>
31962: 774:    tuple(A a, B b, C c) {
31963: 775:        return new Tuple3<>(a, b, c);
31964: 776:    }
31965: 777:
31966: 778:    public static <A, B, C, D> Tuple4<A, B, C, D>
31967: 779:    tuple(A a, B b, C c, D d) {
31968: 780:        return new Tuple4<>(a, b, c, d);
31969: 781:    }
31970: 782:
31971: 783:    public static <A, B, C, D, E>
31972: 784:    Tuple5<A, B, C, D, E> tuple(A a, B b, C c, D d, E e) {
31973: 785:        return new Tuple5<>(a, b, c, d, e);
31974: 786:    }
31975: 787:}
31976: 788:```
31977: 789:
31978: 790:我们修改 **TupleTest.java** 来测试 **Tuple.java** :
31979: 791:
31980: 792:```java
31981: 793:// generics/TupleTest2.java
31982: 794:
31983: 795:import onjava.Tuple2;
31984: 796:import onjava.Tuple3;
31985: 797:import onjava.Tuple4;
31986: 798:import onjava.Tuple5;
31987: 799:
31988: 800:import static onjava.Tuple.tuple;
31989: 801:
31990: 802:public class TupleTest2 {
31991: 803:    static Tuple2<String, Integer> f() {
31992: 804:        return tuple("hi", 47);
31993: 805:    }
31994: 806:
31995: 807:    static Tuple2 f2() {
31996: 808:        return tuple("hi", 47);
31997: 809:    }
31998: 810:
31999: 811:    static Tuple3<Amphibian, String, Integer> g() {
32000: 812:        return tuple(new Amphibian(), "hi", 47);
32001: 813:    }
32002: 814:
32003: 815:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
32004: 816:        return tuple(
32005: 817:                new Vehicle(), new Amphibian(), "hi", 47);
32006: 818:    }
32007: 819:
32008: 820:    static Tuple5<Vehicle, Amphibian,
32009: 821:            String, Integer, Double> k() {
32010: 822:        return tuple(new Vehicle(), new Amphibian(),
32011: 823:                "hi", 47, 11.1);
32012: 824:    }
32013: 825:
32014: 826:    public static void main(String[] args) {
32015: 827:        Tuple2<String, Integer> ttsi = f();
32016: 828:        System.out.println(ttsi);
32017: 829:        System.out.println(f2());
32018: 830:        System.out.println(g());
32019: 831:        System.out.println(h());
32020: 832:        System.out.println(k());
32021: 833:    }
32022: 834:}
32023: 835:/* Output:
32024: 836:(hi, 47)
32025: 837:(hi, 47)
32026: 838:(Amphibian@14ae5a5, hi, 47)
32027: 839:(Vehicle@135fbaa4, Amphibian@45ee12a7, hi, 47)
32028: 840:(Vehicle@4b67cf4d, Amphibian@7ea987ac, hi, 47, 11.1)
32029: 841:*/
32030: 842:```
32031: 843:
32032: 844:请注意，`f()` 返回一个参数化的 **Tuple2** 对象，而 `f2()` 返回一个未参数化的 **Tuple2** 对象。编译器不会在这里警告 `f2()` ，因为返回值未以参数化方式使用。从某种意义上说，它被“向上转型”为一个未参数化的 **Tuple2** 。 但是，如果尝试将 `f2()` 的结果放入到参数化的 **Tuple2** 中，则编译器将发出警告。
32033: 845:
32034: 846:<!-- A Set Utility -->
32035: 847:
32036: 848:### 一个 Set 工具
32037: 849:
32038: 850:对于泛型方法的另一个示例，请考虑由 **Set** 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法：
32039: 851:
32040: 852:```java
32041: 853:// onjava/Sets.java
32042: 854:
32043: 855:package onjava;
32044: 856:
32045: 857:import java.util.HashSet;
32046: 858:import java.util.Set;
32047: 859:
32048: 860:public class Sets {
32049: 861:    public static <T> Set<T> union(Set<T> a, Set<T> b) {
32050: 862:        Set<T> result = new HashSet<>(a);
32051: 863:        result.addAll(b);
32052: 864:        return result;
32053: 865:    }
32054: 866:
32055: 867:    public static <T>
32056: 868:    Set<T> intersection(Set<T> a, Set<T> b) {
32057: 869:        Set<T> result = new HashSet<>(a);
32058: 870:        result.retainAll(b);
32059: 871:        return result;
32060: 872:    }
32061: 873:
32062: 874:    // Subtract subset from superset:
32063: 875:    public static <T> Set<T>
32064: 876:    difference(Set<T> superset, Set<T> subset) {
32065: 877:        Set<T> result = new HashSet<>(superset);
32066: 878:        result.removeAll(subset);
32067: 879:        return result;
32068: 880:    }
32069: 881:
32070: 882:    // Reflexive--everything not in the intersection:
32071: 883:    public static <T> Set<T> complement(Set<T> a, Set<T> b) {
32072: 884:        return difference(union(a, b), intersection(a, b));
32073: 885:    }
32074: 886:}
32075: 887:```
32076: 888:
32077: 889:前三个方法通过将第一个参数的引用复制到新的 **HashSet** 对象中来复制第一个参数，因此不会直接修改参数集合。因此，返回值是一个新的 **Set** 对象。
32078: 890:
32079: 891:这四种方法代表数学集合操作： `union()` 返回一个包含两个参数并集的 **Set** ， `intersection()` 返回一个包含两个参数集合交集的 **Set** ， `difference()` 从 **superset** 中减去 **subset** 的元素 ，而 `complement()` 返回所有不在交集中的元素的 **Set**。作为显示这些方法效果的简单示例的一部分，下面是一个包含不同水彩名称的 **enum** ：
32080: 892:
32081: 893:```java
32082: 894:// generics/watercolors/Watercolors.java
32083: 895:
32084: 896:package watercolors;
32085: 897:
32086: 898:public enum Watercolors {
32087: 899:    ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW,
32088: 900:    ORANGE, BRILLIANT_RED, CRIMSON, MAGENTA,
32089: 901:    ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE,
32090: 902:    PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE,
32091: 903:    PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN,
32092: 904:    YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
32093: 905:    BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK
32094: 906:}
32095: 907:```
32096: 908:
32097: 909:为了方便起见（不必全限定所有名称），将其静态导入到以下示例中。本示例使用 **EnumSet** 轻松从 **enum** 中创建 **Set** 。（可以在[第二十二章 枚举](book/22-Enumerations.md)一章中了解有关 **EnumSet** 的更多信息。）在这里，静态方法 `EnumSet.range()` 要求提供所要在结果 **Set** 中创建的元素范围的第一个和最后一个元素：
32098: 910:
32099: 911:```java
32100: 912:// generics/WatercolorSets.java
32101: 913:
32102: 914:import watercolors.*;
32103: 915:
32104: 916:import java.util.EnumSet;
32105: 917:import java.util.Set;
32106: 918:
32107: 919:import static watercolors.Watercolors.*;
32108: 920:import static onjava.Sets.*;
32109: 921:
32110: 922:public class WatercolorSets {
32111: 923:    public static void main(String[] args) {
32112: 924:        Set<Watercolors> set1 =
32113: 925:                EnumSet.range(BRILLIANT_RED, VIRIDIAN_HUE);
32114: 926:        Set<Watercolors> set2 =
32115: 927:                EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER);
32116: 928:        System.out.println("set1: " + set1);
32117: 929:        System.out.println("set2: " + set2);
32118: 930:        System.out.println(
32119: 931:                "union(set1, set2): " + union(set1, set2));
32120: 932:        Set<Watercolors> subset = intersection(set1, set2);
32121: 933:        System.out.println(
32122: 934:                "intersection(set1, set2): " + subset);
32123: 935:        System.out.println("difference(set1, subset): " +
32124: 936:                difference(set1, subset));
32125: 937:        System.out.println("difference(set2, subset): " +
32126: 938:                difference(set2, subset));
32127: 939:        System.out.println("complement(set1, set2): " +
32128: 940:                complement(set1, set2));
32129: 941:    }
32130: 942:}
32131: 943:/* Output:
32132: 944:set1: [BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER,
32133: 945:VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
32134: 946:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE]
32135: 947:set2: [CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
32136: 948:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE,
32137: 949:SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
32138: 950:BURNT_UMBER]
32139: 951:union(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
32140: 952:YELLOW_OCHRE, MAGENTA, SAP_GREEN, CERULEAN_BLUE_HUE,
32141: 953:ULTRAMARINE, VIRIDIAN_HUE, VIOLET, RAW_UMBER,
32142: 954:ROSE_MADDER, PERMANENT_GREEN, BURNT_UMBER,
32143: 955:PHTHALO_BLUE, CRIMSON, COBALT_BLUE_HUE]
32144: 956:intersection(set1, set2): [PERMANENT_GREEN,
32145: 957:CERULEAN_BLUE_HUE, ULTRAMARINE, VIRIDIAN_HUE,
32146: 958:PHTHALO_BLUE, COBALT_BLUE_HUE]
32147: 959:difference(set1, subset): [BRILLIANT_RED, MAGENTA,
32148: 960:VIOLET, CRIMSON, ROSE_MADDER]
32149: 961:difference(set2, subset): [BURNT_SIENNA, YELLOW_OCHRE,
32150: 962:BURNT_UMBER, SAP_GREEN, RAW_UMBER]
32151: 963:complement(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
32152: 964:YELLOW_OCHRE, MAGENTA, SAP_GREEN, VIOLET, RAW_UMBER,
32153: 965:ROSE_MADDER, BURNT_UMBER, CRIMSON]
32154: 966:*/
32155: 967:```
32156: 968:
32157: 969:接下来的例子使用 `Sets.difference()` 方法来展示 **java.util** 包中各种 **Collection** 和 **Map** 类之间的方法差异：
32158: 970:
32159: 971:```java
32160: 972:// onjava/CollectionMethodDifferences.java
32161: 973:// {java onjava.CollectionMethodDifferences}
32162: 974:
32163: 975:package onjava;
32164: 976:
32165: 977:import java.lang.reflect.Method;
32166: 978:import java.util.*;
32167: 979:import java.util.stream.Collectors;
32168: 980:
32169: 981:public class CollectionMethodDifferences {
32170: 982:    static Set<String> methodSet(Class<?> type) {
32171: 983:        return Arrays.stream(type.getMethods())
32172: 984:                .map(Method::getName)
32173: 985:                .collect(Collectors.toCollection(TreeSet::new));
32174: 986:    }
32175: 987:
32176: 988:    static void interfaces(Class<?> type) {
32177: 989:        System.out.print("Interfaces in " +
32178: 990:                type.getSimpleName() + ": ");
32179: 991:        System.out.println(
32180: 992:                Arrays.stream(type.getInterfaces())
32181: 993:                        .map(Class::getSimpleName)
32182: 994:                        .collect(Collectors.toList()));
32183: 995:    }
32184: 996:
32185: 997:    static Set<String> object = methodSet(Object.class);
32186: 998:
32187: 999:    static {
32188: 1000:        object.add("clone");
32189: 1001:    }
32190: 1002:
32191: 1003:    static void
32192: 1004:    difference(Class<?> superset, Class<?> subset) {
32193: 1005:        System.out.print(superset.getSimpleName() +
32194: 1006:                " extends " + subset.getSimpleName() +
32195: 1007:                ", adds: ");
32196: 1008:        Set<String> comp = Sets.difference(
32197: 1009:                methodSet(superset), methodSet(subset));
32198: 1010:        comp.removeAll(object); // Ignore 'Object' methods
32199: 1011:        System.out.println(comp);
32200: 1012:        interfaces(superset);
32201: 1013:    }
32202: 1014:
32203: 1015:    public static void main(String[] args) {
32204: 1016:        System.out.println("Collection: " +
32205: 1017:                methodSet(Collection.class));
32206: 1018:        interfaces(Collection.class);
32207: 1019:        difference(Set.class, Collection.class);
32208: 1020:        difference(HashSet.class, Set.class);
32209: 1021:        difference(LinkedHashSet.class, HashSet.class);
32210: 1022:        difference(TreeSet.class, Set.class);
32211: 1023:        difference(List.class, Collection.class);
32212: 1024:        difference(ArrayList.class, List.class);
32213: 1025:        difference(LinkedList.class, List.class);
32214: 1026:        difference(Queue.class, Collection.class);
32215: 1027:        difference(PriorityQueue.class, Queue.class);
32216: 1028:        System.out.println("Map: " + methodSet(Map.class));
32217: 1029:        difference(HashMap.class, Map.class);
32218: 1030:        difference(LinkedHashMap.class, HashMap.class);
32219: 1031:        difference(SortedMap.class, Map.class);
32220: 1032:        difference(TreeMap.class, Map.class);
32221: 1033:    }
32222: 1034:}
32223: 1035:/* Output:
32224: 1036:Collection: [add, addAll, clear, contains, containsAll,
32225: 1037:equals, forEach, hashCode, isEmpty, iterator,
32226: 1038:parallelStream, remove, removeAll, removeIf, retainAll,
32227: 1039:size, spliterator, stream, toArray]
32228: 1040:Interfaces in Collection: [Iterable]
32229: 1041:Set extends Collection, adds: []
32230: 1042:Interfaces in Set: [Collection]
32231: 1043:HashSet extends Set, adds: []
32232: 1044:Interfaces in HashSet: [Set, Cloneable, Serializable]
32233: 1045:LinkedHashSet extends HashSet, adds: []
32234: 1046:Interfaces in LinkedHashSet: [Set, Cloneable,
32235: 1047:Serializable]
32236: 1048:TreeSet extends Set, adds: [headSet,
32237: 1049:descendingIterator, descendingSet, pollLast, subSet,
32238: 1050:floor, tailSet, ceiling, last, lower, comparator,
32239: 1051:pollFirst, first, higher]
32240: 1052:Interfaces in TreeSet: [NavigableSet, Cloneable,
32241: 1053:Serializable]
32242: 1054:List extends Collection, adds: [replaceAll, get,
32243: 1055:indexOf, subList, set, sort, lastIndexOf, listIterator]
32244: 1056:Interfaces in List: [Collection]
32245: 1057:ArrayList extends List, adds: [trimToSize,
32246: 1058:ensureCapacity]
32247: 1059:Interfaces in ArrayList: [List, RandomAccess,
32248: 1060:Cloneable, Serializable]
32249: 1061:LinkedList extends List, adds: [offerFirst, poll,
32250: 1062:getLast, offer, getFirst, removeFirst, element,
32251: 1063:removeLastOccurrence, peekFirst, peekLast, push,
32252: 1064:pollFirst, removeFirstOccurrence, descendingIterator,
32253: 1065:pollLast, removeLast, pop, addLast, peek, offerLast,
32254: 1066:addFirst]
32255: 1067:Interfaces in LinkedList: [List, Deque, Cloneable,
32256: 1068:Serializable]
32257: 1069:Queue extends Collection, adds: [poll, peek, offer,
32258: 1070:element]
32259: 1071:Interfaces in Queue: [Collection]
32260: 1072:PriorityQueue extends Queue, adds: [comparator]
32261: 1073:Interfaces in PriorityQueue: [Serializable]
32262: 1074:Map: [clear, compute, computeIfAbsent,
32263: 1075:computeIfPresent, containsKey, containsValue, entrySet,
32264: 1076:equals, forEach, get, getOrDefault, hashCode, isEmpty,
32265: 1077:keySet, merge, put, putAll, putIfAbsent, remove,
32266: 1078:replace, replaceAll, size, values]
32267: 1079:HashMap extends Map, adds: []
32268: 1080:Interfaces in HashMap: [Map, Cloneable, Serializable]
32269: 1081:LinkedHashMap extends HashMap, adds: []
32270: 1082:Interfaces in LinkedHashMap: [Map]
32271: 1083:SortedMap extends Map, adds: [lastKey, subMap,
32272: 1084:comparator, firstKey, headMap, tailMap]
32273: 1085:Interfaces in SortedMap: [Map]
32274: 1086:TreeMap extends Map, adds: [descendingKeySet,
32275: 1087:navigableKeySet, higherEntry, higherKey, floorKey,
32276: 1088:subMap, ceilingKey, pollLastEntry, firstKey, lowerKey,
32277: 1089:headMap, tailMap, lowerEntry, ceilingEntry,
32278: 1090:descendingMap, pollFirstEntry, lastKey, firstEntry,
32279: 1091:floorEntry, comparator, lastEntry]
32280: 1092:Interfaces in TreeMap: [NavigableMap, Cloneable,
32281: 1093:Serializable]
32282: 1094:*/
32283: 1095:```
32284: 1096:
32285: 1097:在第十二章 [集合的本章小结](book/12-Collections.md#本章小结) 部分将会用到这里的输出结果。
32286: 1098:
32287: 1099:<!-- Building Complex Models -->
32288: 1100:
32289: 1101:## 构建复杂模型
32290: 1102:
32291: 1103:泛型的一个重要好处是能够简单安全地创建复杂模型。例如，我们可以轻松地创建一个元组列表：
32292: 1104:
32293: 1105:```java
32294: 1106:// generics/TupleList.java
32295: 1107:// Combining generic types to make complex generic types
32296: 1108:
32297: 1109:import onjava.Tuple4;
32298: 1110:
32299: 1111:import java.util.ArrayList;
32300: 1112:
32301: 1113:public class TupleList<A, B, C, D>
32302: 1114:        extends ArrayList<Tuple4<A, B, C, D>> {
32303: 1115:    public static void main(String[] args) {
32304: 1116:        TupleList<Vehicle, Amphibian, String, Integer> tl =
32305: 1117:                new TupleList<>();
32306: 1118:        tl.add(TupleTest2.h());
32307: 1119:        tl.add(TupleTest2.h());
32308: 1120:        tl.forEach(System.out::println);
32309: 1121:    }
32310: 1122:}
32311: 1123:/* Output:
32312: 1124:(Vehicle@7cca494b, Amphibian@7ba4f24f, hi, 47)
32313: 1125:(Vehicle@3b9a45b3, Amphibian@7699a589, hi, 47)
32314: 1126:*/
32315: 1127:```
32316: 1128:
32317: 1129:这将产生一个功能强大的数据结构，而无需太多代码。
32318: 1130:
32319: 1131:下面是第二个例子。每个类都是组成块，总体包含很多个块。在这里，该模型是一个具有过道，货架和产品的零售商店：
32320: 1132:
32321: 1133:```java
32322: 1134:// generics/Store.java
32323: 1135:// Building a complex model using generic collections
32324: 1136:
32325: 1137:import onjava.Suppliers;
32326: 1138:
32327: 1139:import java.util.ArrayList;
32328: 1140:import java.util.Random;
32329: 1141:import java.util.function.Supplier;
32330: 1142:
32331: 1143:class Product {
32332: 1144:    private final int id;
32333: 1145:    private String description;
32334: 1146:    private double price;
32335: 1147:
32336: 1148:    Product(int idNumber, String descr, double price) {
32337: 1149:        id = idNumber;
32338: 1150:        description = descr;
32339: 1151:        this.price = price;
32340: 1152:        System.out.println(toString());
32341: 1153:    }
32342: 1154:
32343: 1155:    @Override
32344: 1156:    public String toString() {
32345: 1157:        return id + ": " + description +
32346: 1158:                ", price: $" + price;
32347: 1159:    }
32348: 1160:
32349: 1161:    public void priceChange(double change) {
32350: 1162:        price += change;
32351: 1163:    }
32352: 1164:
32353: 1165:    public static Supplier<Product> generator =
32354: 1166:            new Supplier<Product>() {
32355: 1167:                private Random rand = new Random(47);
32356: 1168:
32357: 1169:                @Override
32358: 1170:                public Product get() {
32359: 1171:                    return new Product(rand.nextInt(1000), "Test",
32360: 1172:                            Math.round(
32361: 1173:                                    rand.nextDouble() * 1000.0) + 0.99);
32362: 1174:                }
32363: 1175:            };
32364: 1176:}
32365: 1177:
32366: 1178:class Shelf extends ArrayList<Product> {
32367: 1179:    Shelf(int nProducts) {
32368: 1180:        Suppliers.fill(this, Product.generator, nProducts);
32369: 1181:    }
32370: 1182:}
32371: 1183:
32372: 1184:class Aisle extends ArrayList<Shelf> {
32373: 1185:    Aisle(int nShelves, int nProducts) {
32374: 1186:        for (int i = 0; i < nShelves; i++)
32375: 1187:            add(new Shelf(nProducts));
32376: 1188:    }
32377: 1189:}
32378: 1190:
32379: 1191:class CheckoutStand {
32380: 1192:}
32381: 1193:
32382: 1194:class Office {
32383: 1195:}
32384: 1196:
32385: 1197:public class Store extends ArrayList<Aisle> {
32386: 1198:    private ArrayList<CheckoutStand> checkouts =
32387: 1199:            new ArrayList<>();
32388: 1200:    private Office office = new Office();
32389: 1201:
32390: 1202:    public Store(
32391: 1203:            int nAisles, int nShelves, int nProducts) {
32392: 1204:        for (int i = 0; i < nAisles; i++)
32393: 1205:            add(new Aisle(nShelves, nProducts));
32394: 1206:    }
32395: 1207:
32396: 1208:    @Override
32397: 1209:    public String toString() {
32398: 1210:        StringBuilder result = new StringBuilder();
32399: 1211:        for (Aisle a : this)
32400: 1212:            for (Shelf s : a)
32401: 1213:                for (Product p : s) {
32402: 1214:                    result.append(p);
32403: 1215:                    result.append("\n");
32404: 1216:                }
32405: 1217:        return result.toString();
32406: 1218:    }
32407: 1219:
32408: 1220:    public static void main(String[] args) {
32409: 1221:        System.out.println(new Store(5, 4, 3));
32410: 1222:    }
32411: 1223:}
32412: 1224:/* Output: (First 8 Lines)
32413: 1225:258: Test, price: $400.99
32414: 1226:861: Test, price: $160.99
32415: 1227:868: Test, price: $417.99
32416: 1228:207: Test, price: $268.99
32417: 1229:551: Test, price: $114.99
32418: 1230:278: Test, price: $804.99
32419: 1231:520: Test, price: $554.99
32420: 1232:140: Test, price: $530.99
32421: 1233:                  ...
32422: 1234:*/
32423: 1235:```
32424: 1236:
32425: 1237:`Store.toString()` 显示了结果：尽管有复杂的层次结构，但多层的集合仍然是类型安全的和可管理的。令人印象深刻的是，组装这样的模型并不需要耗费过多精力。
32426: 1238:
32427: 1239:**Shelf** 使用 `Suppliers.fill()` 这个实用程序，该实用程序接受 **Collection** （第一个参数），并使用 **Supplier** （第二个参数），以元素的数量为 **n** （第三个参数）来填充它。 **Suppliers** 类将会在本章末尾定义，其中的方法都是在执行某种填充操作，并在本章的其他示例中使用。
32428: 1240:
32429: 1241:<!-- The Mystery of Erasure -->
32430: 1242:
32431: 1243:## 泛型擦除
32432: 1244:
32433: 1245:当你开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的。例如，尽管可以说  `ArrayList.class`，但不能说成 `ArrayList<Integer>.class`。考虑下面的情况：
32434: 1246:
32435: 1247:```java
32436: 1248:// generics/ErasedTypeEquivalence.java
32437: 1249:
32438: 1250:import java.util.*;
32439: 1251:
32440: 1252:public class ErasedTypeEquivalence {
32441: 1253:    
32442: 1254:    public static void main(String[] args) {
32443: 1255:        Class c1 = new ArrayList<String>().getClass();
32444: 1256:        Class c2 = new ArrayList<Integer>().getClass();
32445: 1257:        System.out.println(c1 == c2);
32446: 1258:    }
32447: 1259:    
32448: 1260:}
32449: 1261:/* Output:
32450: 1262:true
32451: 1263:*/
32452: 1264:```
32453: 1265:
32454: 1266:`ArrayList<String>` 和 `ArrayList<Integer>` 应该是不同的类型。不同的类型会有不同的行为。例如，如果尝试向 `ArrayList<String>` 中放入一个 `Integer`，所得到的行为（失败）和向 `ArrayList<Integer>` 中放入一个 `Integer` 所得到的行为（成功）完全不同。然而上面的程序认为它们是相同的类型。
32455: 1267:
32456: 1268:下面的例子是对该谜题的补充：
32457: 1269:
32458: 1270:```java
32459: 1271:// generics/LostInformation.java
32460: 1272:
32461: 1273:import java.util.*;
32462: 1274:
32463: 1275:class Frob {}
32464: 1276:class Fnorkle {}
32465: 1277:class Quark<Q> {}
32466: 1278:
32467: 1279:class Particle<POSITION, MOMENTUM> {}
32468: 1280:
32469: 1281:public class LostInformation {
32470: 1282:
32471: 1283:    public static void main(String[] args) {
32472: 1284:        List<Frob> list = new ArrayList<>();
32473: 1285:        Map<Frob, Fnorkle> map = new HashMap<>();
32474: 1286:        Quark<Fnorkle> quark = new Quark<>();
32475: 1287:        Particle<Long, Double> p = new Particle<>();
32476: 1288:        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));
32477: 1289:        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));
32478: 1290:        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));
32479: 1291:        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));
32480: 1292:    }
32481: 1293:
32482: 1294:}
32483: 1295:/* Output:
32484: 1296:[E]
32485: 1297:[K,V]
32486: 1298:[Q]
32487: 1299:[POSITION,MOMENTUM]
32488: 1300:*/
32489: 1301:```
32490: 1302:
32491: 1303:根据 JDK 文档，**Class.getTypeParameters()** “返回一个 **TypeVariable** 对象数组，表示泛型声明中声明的类型参数...” 这暗示你可以发现这些参数类型。但是正如上例中输出所示，你只能看到用作参数占位符的标识符，这并非有用的信息。
32492: 1304:
32493: 1305:残酷的现实是：
32494: 1306:
32495: 1307:在泛型代码内部，无法获取任何有关泛型参数类型的信息。
32496: 1308:
32497: 1309:因此，你可以知道如类型参数标识符和泛型边界这些信息，但无法得知实际的类型参数从而用来创建特定的实例。如果你曾是 C++ 程序员，那么这个事实会让你很沮丧，在使用 Java 泛型工作时，它是必须处理的最基本的问题。
32498: 1310:
32499: 1311:Java 泛型是使用擦除实现的。这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此，`List<String>` 和 `List<Integer>` 在运行时实际上是相同的类型。它们都被擦除成原生类型 `List`。
32500: 1312:
32501: 1313:理解擦除并知道如何处理它，是你在学习 Java 泛型时面临的最大障碍之一。这也是本节将要探讨的内容。
32502: 1314:
32503: 1315:### C++ 的方式
32504: 1316:
32505: 1317:下面是使用模版的 C++ 示例。你会看到类型参数的语法十分相似，因为 Java 是受 C++ 启发的：
32506: 1318:
32507: 1319:```c++
32508: 1320:// generics/Templates.cpp
32509: 1321:
32510: 1322:#include <iostream>
32511: 1323:using namespace std;
32512: 1324:
32513: 1325:template<class T> class Manipulator {
32514: 1326:    T obj;
32515: 1327:public:
32516: 1328:    Manipulator(T x) { obj = x; }
32517: 1329:    void manipulate() { obj.f(); }
32518: 1330:};
32519: 1331:
32520: 1332:class HasF {
32521: 1333:public:
32522: 1334:    void f() { cout << "HasF::f()" << endl; }
32523: 1335:};
32524: 1336:
32525: 1337:int main() {
32526: 1338:    HasF hf;
32527: 1339:    Manipulator<HasF> manipulator(hf);
32528: 1340:    manipulator.manipulate();
32529: 1341:}
32530: 1342:/* Output:
32531: 1343:HasF::f()
32532: 1344:*/
32533: 1345:```
32534: 1346:
32535: 1347:**Manipulator** 类存储了一个 **T** 类型的对象。`manipulate()` 方法会调用 **obj** 上的 `f()` 方法。它是如何知道类型参数 **T** 中存在 `f()` 方法的呢？C++ 编译器会在你实例化模版时进行检查，所以在 `Manipulator<HasF>` 实例化的那一刻，它看到 **HasF** 中含有一个方法 `f()`。如果情况并非如此，你就会得到一个编译期错误，保持类型安全。
32536: 1348:
32537: 1349:用 C++ 编写这种代码很简单，因为当模版被实例化时，模版代码就知道模版参数的类型。Java 泛型就不同了。下面是 **HasF** 的 Java 版本：
32538: 1350:
32539: 1351:```java
32540: 1352:// generics/HasF.java
32541: 1353:
32542: 1354:public class HasF {
32543: 1355:    public void f() {
32544: 1356:        System.out.println("HasF.f()");
32545: 1357:    }
32546: 1358:}
32547: 1359:```
32548: 1360:
32549: 1361:如果我们将示例的其余代码用 Java 实现，就不会通过编译：
32550: 1362:
32551: 1363:```java
32552: 1364:// generics/Manipulation.java
32553: 1365:// {WillNotCompile}
32554: 1366:
32555: 1367:class Manipulator<T> {
32556: 1368:    private T obj;
32557: 1369:    
32558: 1370:    Manipulator(T x) {
32559: 1371:        obj = x;
32560: 1372:    }
32561: 1373:    
32562: 1374:    // Error: cannot find symbol: method f():
32563: 1375:    public void manipulate() {
32564: 1376:        obj.f();
32565: 1377:    }
32566: 1378:}
32567: 1379:
32568: 1380:public class Manipulation {
32569: 1381:	public static void main(String[] args) {
32570: 1382:        HasF hf = new HasF();
32571: 1383:        Manipulator<HasF> manipulator = new Manipulator<>(hf);
32572: 1384:        manipulator.manipulate();
32573: 1385:    }
32574: 1386:}
32575: 1387:```
32576: 1388:
32577: 1389:因为擦除，Java 编译器无法将 `manipulate()` 方法必须能调用 **obj** 的 `f()` 方法这一需求映射到 HasF 具有 `f()` 方法这个事实上。为了调用 `f()`，我们必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。这里重用了 **extends** 关键字。由于有了边界，下面的代码就能通过编译：
32578: 1390:
32579: 1391:```java
32580: 1392:public class Manipulator2<T extends HasF> {
32581: 1393:    private T obj;
32582: 1394:
32583: 1395:    Manipulator2(T x) {
32584: 1396:        obj = x;
32585: 1397:    }
32586: 1398:
32587: 1399:    public void manipulate() {
32588: 1400:        obj.f();
32589: 1401:    }
32590: 1402:}
32591: 1403:```
32592: 1404:
32593: 1405:边界 `<T extends HasF>` 声明 T 必须是 HasF 类型或其子类。如果情况确实如此，就可以安全地在 **obj** 上调用 `f()` 方法。
32594: 1406:
32595: 1407:我们说泛型类型参数会擦除到它的第一个边界（可能有多个边界，稍后你将看到）。我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的示例，**T** 擦除到了 **HasF**，就像在类的声明中用 **HasF** 替换了 **T** 一样。
32596: 1408:
32597: 1409:你可能正确地观察到了泛型在 **Manipulator2.java** 中没有贡献任何事。你可以很轻松地自己去执行擦除，生成没有泛型的类：
32598: 1410:
32599: 1411:```java
32600: 1412:// generics/Manipulator3.java
32601: 1413:
32602: 1414:class Manipulator3 {
32603: 1415:    private HasF obj;
32604: 1416:    
32605: 1417:    Manipulator3(HasF x) {
32606: 1418:        obj = x;
32607: 1419:    }
32608: 1420:    
32609: 1421:    public void manipulate() {
32610: 1422:        obj.f();
32611: 1423:    }
32612: 1424:}
32613: 1425:```
32614: 1426:
32615: 1427:这提出了很重要的一点：泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用。因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换更加复杂。但是，不能因此认为使用 `<T extends HasF>` 形式就是有缺陷的。例如，如果某个类有一个返回 **T** 的方法，那么泛型就有所帮助，因为它们之后将返回确切的类型：
32616: 1428:
32617: 1429:```java
32618: 1430:// generics/ReturnGenericType.java
32619: 1431:
32620: 1432:public class ReturnGenericType<T extends HasF> {
32621: 1433:    private T obj;
32622: 1434:    
32623: 1435:    ReturnGenericType(T x) {
32624: 1436:        obj = x;
32625: 1437:    }
32626: 1438:    
32627: 1439:    public T get() {
32628: 1440:        return obj;
32629: 1441:    }
32630: 1442:}
32631: 1443:```
32632: 1444:
32633: 1445:你必须查看所有的代码，从而确定代码是否复杂到必须使用泛型的程度。
32634: 1446:
32635: 1447:我们将在本章稍后看到有关边界的更多细节。
32636: 1448:
32637: 1449:### 迁移兼容性
32638: 1450:
32639: 1451:为了减少潜在的关于擦除的困惑，你必须清楚地认识到这不是一个语言特性。它是 Java 实现泛型的一种妥协，因为泛型不是 Java 语言出现时就有的，所以就有了这种妥协。它会使你痛苦，因此你需要尽早习惯它并了解为什么它会这样。
32640: 1452:
32641: 1453:如果 Java 1.0 就含有泛型的话，那么这个特性就不会使用擦除来实现——它会使用具体化，保持参数类型为第一类实体，因此你就能在类型参数上执行基于类型的语言操作和反射操作。本章稍后你会看到，擦除减少了泛型的泛化性。泛型在 Java 中仍然是有用的，只是不如它们本来设想的那么有用，而原因就是擦除。
32642: 1454:
32643: 1455:在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文使用泛型类型。泛型类型只有在静态类型检测期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如， `List<T>` 这样的类型注解会被擦除为 **List**，普通的类型变量在未指定边界的情况下会被擦除为 **Object**。
32644: 1456:
32645: 1457:擦除的核心动机是你可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称为“迁移兼容性”。在理想情况下，所有事物将在指定的某天被泛化。在现实中，即使程序员只编写泛型代码，他们也必须处理 Java 5 之前编写的非泛型类库。这些类库的作者可能从没想过要泛化他们的代码，或许他们可能刚刚开始接触泛型。
32646: 1458:
32647: 1459:因此 Java 泛型不仅必须支持向后兼容性——现有的代码和类文件仍然合法，继续保持之前的含义——而且还必须支持迁移兼容性，使得类库能按照它们自己的步调变为泛型，当某个类库变为泛型时，不会破坏依赖于它的代码和应用。在确定了这个目标后，Java 设计者们和从事此问题相关工作的各个团队决策认为擦除是唯一可行的解决方案。擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。
32648: 1460:
32649: 1461:例如，假设一个应用使用了两个类库 **X** 和 **Y**，**Y** 使用了类库 **Z**。随着 Java 5 的出现，这个应用和这些类库的创建者最终可能希望迁移到泛型上。但是当进行迁移时，它们有着不同的动机和限制。为了实现迁移兼容性，每个类库与应用必须与其他所有的部分是否使用泛型无关。因此，它们不能探测其他类库是否使用了泛型。因此，某个特定的类库使用了泛型这样的证据必须被”擦除“。
32650: 1462:
32651: 1463:如果没有某种类型的迁移途径，所有已经构建了很长时间的类库就需要与希望迁移到 Java 泛型上的开发者们说再见了。类库毫无争议是编程语言的一部分，对生产效率有着极大的影响，所以这种代码无法接受。擦除是否是最佳的或唯一的迁移途径，还待时间来证明。
32652: 1464:
32653: 1465:### 擦除的问题
32654: 1466:
32655: 1467:因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。擦除允许你继续使用现有的非泛型客户端代码，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会骤然破坏所有现有的代码。
32656: 1468:
32657: 1469:擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作中，例如转型、**instanceof** 操作和 **new** 表达式。因为所有关于参数的类型信息都丢失了，当你在编写泛型代码时，必须时刻提醒自己，你只是看起来拥有有关参数的类型信息而已。
32658: 1470:
32659: 1471:考虑如下的代码段：
32660: 1472:
32661: 1473:```java
32662: 1474:class Foo<T> {
32663: 1475:    T var;
32664: 1476:}
32665: 1477:```
32666: 1478:
32667: 1479:看上去当你创建一个 **Foo** 实例时：
32668: 1480:
32669: 1481:```java
32670: 1482:Foo<Cat> f = new Foo<>();
32671: 1483:```
32672: 1484:
32673: 1485:**class** **Foo** 中的代码应该知道现在工作于 **Cat** 之上。泛型语法也在强烈暗示整个类中所有 T 出现的地方都被替换，就像在 C++ 中一样。但是事实并非如此，当你在编写这个类的代码时，必须提醒自己：“不，这只是一个 **Object**“。
32674: 1486:
32675: 1487:另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管你可能希望这样：
32676: 1488:
32677: 1489:```java
32678: 1490:// generics/ErasureAndInheritance.java
32679: 1491:
32680: 1492:class GenericBase<T> {
32681: 1493:    private T element;
32682: 1494:    
32683: 1495:    public void set(T arg) {
32684: 1496:        element = arg;
32685: 1497:    }
32686: 1498:    
32687: 1499:    public T get() {
32688: 1500:        return element;
32689: 1501:    }
32690: 1502:}
32691: 1503:
32692: 1504:class Derived1<T> extends GenericBase<T> {}
32693: 1505:
32694: 1506:class Derived2 extends GenericBase {} // No warning
32695: 1507:
32696: 1508:// class Derived3 extends GenericBase<?> {}
32697: 1509:// Strange error:
32698: 1510:// unexpected type
32699: 1511:// required: class or interface without bounds
32700: 1512:public class ErasureAndInteritance {
32701: 1513:    @SuppressWarnings("unchecked")
32702: 1514:    public static void main(String[] args) {
32703: 1515:        Derived2 d2 = new Derived2();
32704: 1516:        Object obj = d2.get();
32705: 1517:        d2.set(obj); // Warning here!
32706: 1518:    }
32707: 1519:}
32708: 1520:```
32709: 1521:
32710: 1522:**Derived2** 继承自 **GenericBase**，但是没有任何类型参数，编译器没有发出任何警告。直到调用 `set()` 方法时才出现警告。
32711: 1523:
32712: 1524:为了关闭警告，Java 提供了一个注解，我们可以在列表中看到它：
32713: 1525:
32714: 1526:```java
32715: 1527:@SuppressWarnings("unchecked")
32716: 1528:```
32717: 1529:
32718: 1530:这个注解放置在产生警告的方法上，而不是整个类上。当你要关闭警告时，最好尽可能地“聚焦”，这样就不会因为过于宽泛地关闭警告，而导致意外地遮蔽掉真正的问题。
32719: 1531:
32720: 1532:可以推断，**Derived3** 产生的错误意味着编译器期望得到一个原生基类。
32721: 1533:
32722: 1534:当你希望将类型参数不仅仅当作 Object 处理时，就需要付出额外努力来管理边界，并且与在 C++、Ada 和 Eiffel 这样的语言中获得参数化类型相比，你需要付出多得多的努力来获得少得多的回报。这并不是说，对于大多数的编程问题而言，这些语言通常都会比 Java 更得心应手，只是说它们的参数化类型机制相比 Java 更灵活、更强大。
32723: 1535:
32724: 1536:### 边界处的动作
32725: 1537:
32726: 1538:因为擦除，我发现了泛型最令人困惑的方面是可以表示没有任何意义的事物。例如：
32727: 1539:
32728: 1540:```java
32729: 1541:// generics/ArrayMaker.java
32730: 1542:
32731: 1543:import java.lang.reflect.*;
32732: 1544:import java.util.*;
32733: 1545:
32734: 1546:public class ArrayMaker<T> {
32735: 1547:    private Class<T> kind;
32736: 1548:
32737: 1549:    public ArrayMaker(Class<T> kind) {
32738: 1550:        this.kind = kind;
32739: 1551:    }
32740: 1552:
32741: 1553:    @SuppressWarnings("unchecked")
32742: 1554:    T[] create(int size) {
32743: 1555:        return (T[]) Array.newInstance(kind, size);
32744: 1556:    }
32745: 1557:
32746: 1558:    public static void main(String[] args) {
32747: 1559:        ArrayMaker<String> stringMaker = new ArrayMaker<>(String.class);
32748: 1560:        String[] stringArray = stringMaker.create(9);
32749: 1561:        System.out.println(Arrays.toString(stringArray));
32750: 1562:    }
32751: 1563:}
32752: 1564:/* Output
32753: 1565:[null,null,null,null,null,null,null,null,null]
32754: 1566:*/
32755: 1567:```
32756: 1568:
32757: 1569:即使 **kind** 被存储为 `Class<T>`，擦除也意味着它实际被存储为没有任何参数的 **Class**。因此，当你在使用它时，例如创建数组，`Array.newInstance()` 实际上并未拥有 **kind** 所蕴含的类型信息。所以它不会产生具体的结果，因而必须转型，这会产生一条令你无法满意的警告。
32758: 1570:
32759: 1571:注意，对于在泛型中创建数组，使用 `Array.newInstance()` 是推荐的方式。
32760: 1572:
32761: 1573:如果我们创建一个集合而不是数组，情况就不同了：
32762: 1574:
32763: 1575:```java
32764: 1576:// generics/ListMaker.java
32765: 1577:
32766: 1578:import java.util.*;
32767: 1579:
32768: 1580:public class ListMaker<T> {
32769: 1581:    List<T> create() {
32770: 1582:        return new ArrayList<>();
32771: 1583:    }
32772: 1584:    
32773: 1585:    public static void main(String[] args) {
32774: 1586:        ListMaker<String> stringMaker = new ListMaker<>();
32775: 1587:        List<String> stringList = stringMaker.create();
32776: 1588:    }
32777: 1589:}
32778: 1590:```
32779: 1591:
32780: 1592:编译器不会给出任何警告，尽管我们知道（从擦除中）在 `create()` 内部的 `new ArrayList<>()` 中的 `<T>` 被移除了——在运行时，类内部没有任何 `<T>`，因此这看起来毫无意义。但是如果你遵从这种思路，并将这个表达式改为 `new ArrayList()`，编译器就会发出警告。
32781: 1593:
32782: 1594:本例中这么做真的毫无意义吗？如果在创建 **List** 的同时向其中放入一些对象呢，像这样：
32783: 1595:
32784: 1596:```java
32785: 1597:// generics/FilledList.java
32786: 1598:
32787: 1599:import java.util.*;
32788: 1600:import java.util.function.*;
32789: 1601:import onjava.*;
32790: 1602:
32791: 1603:public class FilledList<T> extends ArrayList<T> {
32792: 1604:    FilledList(Supplier<T> gen, int size) {
32793: 1605:        Suppliers.fill(this, gen, size);
32794: 1606:    }
32795: 1607:    
32796: 1608:    public FilledList(T t, int size) {
32797: 1609:        for (int i = 0; i < size; i++) {
32798: 1610:            this.add(t);
32799: 1611:        }
32800: 1612:    }
32801: 1613:    
32802: 1614:    public static void main(String[] args) {
32803: 1615:        List<String> list = new FilledList<>("Hello", 4);
32804: 1616:        System.out.println(list);
32805: 1617:        // Supplier version:
32806: 1618:        List<Integer> ilist = new FilledList<>(() -> 47, 4);
32807: 1619:        System.out.println(ilist);
32808: 1620:    }
32809: 1621:}
32810: 1622:/* Output:
32811: 1623:[Hello,Hello,Hello,Hello]
32812: 1624:[47,47,47,47]
32813: 1625:*/
32814: 1626:```
32815: 1627:
32816: 1628:即使编译器无法得知 `add()` 中的 **T** 的任何信息，但它仍可以在编译期确保你放入 **FilledList** 中的对象是 **T** 类型。因此，即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。
32817: 1629:
32818: 1630:因为擦除移除了方法体中的类型信息，所以在运行时的问题就是*边界*：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。
32819: 1631:
32820: 1632:考虑如下这段非泛型示例：
32821: 1633:
32822: 1634:```java
32823: 1635:// generics/SimpleHolder.java
32824: 1636:
32825: 1637:public class SimpleHolder {
32826: 1638:    private Object obj;
32827: 1639:    
32828: 1640:    public void set(Object obj) {
32829: 1641:        this.obj = obj;
32830: 1642:    }
32831: 1643:    
32832: 1644:    public Object get() {
32833: 1645:        return obj;
32834: 1646:    }
32835: 1647:    
32836: 1648:    public static void main(String[] args) {
32837: 1649:        SimpleHolder holder = new SimpleHolder();
32838: 1650:        holder.set("Item");
32839: 1651:        String s = (String) holder.get();
32840: 1652:    }
32841: 1653:}
32842: 1654:```
32843: 1655:
32844: 1656:如果用 **javap -c SimpleHolder** 反编译这个类，会得到如下内容（经过编辑）：
32845: 1657:
32846: 1658:```java
32847: 1659:public void set(java.lang.Object);
32848: 1660:   0: aload_0
32849: 1661:   1: aload_1
32850: 1662:   2: putfield #2; // Field obj:Object;
32851: 1663:   5: return
32852: 1664:    
32853: 1665:public java.lang.Object get();
32854: 1666:   0: aload_0
32855: 1667:   1: getfield #2; // Field obj:Object;
32856: 1668:   4: areturn
32857: 1669:    
32858: 1670:public static void main(java.lang.String[]);
32859: 1671:   0: new #3; // class SimpleHolder
32860: 1672:   3: dup
32861: 1673:   4: invokespecial #4; // Method "<init>":()V
32862: 1674:   7: astore_1
32863: 1675:   8: aload_1
32864: 1676:   9: ldc #5; // String Item
32865: 1677:   11: invokevirtual #6; // Method set:(Object;)V
32866: 1678:   14: aload_1
32867: 1679:   15: invokevirtual #7; // Method get:()Object;
32868: 1680:   18: checkcast #8; // class java/lang/String
32869: 1681:   21: astore_2
32870: 1682:   22: return
32871: 1683:```
32872: 1684:
32873: 1685:`set()` 和 `get()` 方法存储和产生值，转型在调用 `get()` 时接受检查。
32874: 1686:
32875: 1687:现在将泛型融入上例代码中：
32876: 1688:
32877: 1689:```java
32878: 1690:// generics/GenericHolder2.java
32879: 1691:
32880: 1692:public class GenericHolder2<T> {
32881: 1693:    private T obj;
32882: 1694:
32883: 1695:    public void set(T obj) {
32884: 1696:        this.obj = obj;
32885: 1697:    }
32886: 1698:
32887: 1699:    public T get() {
32888: 1700:        return obj;
32889: 1701:    }
32890: 1702:
32891: 1703:    public static void main(String[] args) {
32892: 1704:        GenericHolder2<String> holder =  new GenericHolder2<>();
32893: 1705:        holder.set("Item");
32894: 1706:        String s = holder.get();
32895: 1707:    }
32896: 1708:}
32897: 1709:```
32898: 1710:
32899: 1711:从 `get()` 返回后的转型消失了，但是我们还知道传递给 `set()` 的值在编译期会被检查。下面是相关的字节码：
32900: 1712:
32901: 1713:```java
32902: 1714:public void set(java.lang.Object);
32903: 1715:   0: aload_0
32904: 1716:   1: aload_1
32905: 1717:   2: putfield #2; // Field obj:Object;
32906: 1718:   5: return
32907: 1719:       
32908: 1720:public java.lang.Object get();
32909: 1721:   0: aload_0
32910: 1722:   1: getfield #2; // Field obj:Object;
32911: 1723:   4: areturn
32912: 1724:       
32913: 1725:public static void main(java.lang.String[]);
32914: 1726:   0: new #3; // class GenericHolder2
32915: 1727:   3: dup
32916: 1728:   4: invokespecial #4; // Method "<init>":()V
32917: 1729:   7: astore_1
32918: 1730:   8: aload_1
32919: 1731:   9: ldc #5; // String Item
32920: 1732:   11: invokevirtual #6; // Method set:(Object;)V
32921: 1733:   14: aload_1
32922: 1734:   15: invokevirtual #7; // Method get:()Object;
32923: 1735:   18: checkcast #8; // class java/lang/String
32924: 1736:   21: astore_2
32925: 1737:   22: return
32926: 1738:```
32927: 1739:
32928: 1740:所产生的字节码是相同的。对进入 `set()` 的类型进行检查是不需要的，因为这将由编译器执行。而对 `get()` 返回的值进行转型仍然是需要的，只不过不需要你来操作，它由编译器自动插入，这样你就不用编写（阅读）杂乱的代码。
32929: 1741:
32930: 1742:`get()` 和 `set()` 产生了相同的字节码，这就告诉我们泛型的所有动作都发生在边界处——对入参的编译器检查和对返回值的转型。这有助于澄清对擦除的困惑，记住：“边界就是动作发生的地方”。
32931: 1743:
32932: 1744:<!-- Compensating for Erasure -->
32933: 1745:
32934: 1746:## 补偿擦除
32935: 1747:
32936: 1748:因为擦除，我们将失去执行泛型代码中某些操作的能力。无法在运行时知道确切类型：
32937: 1749:
32938: 1750:```java
32939: 1751:// generics/Erased.java
32940: 1752:// {WillNotCompile}
32941: 1753:
32942: 1754:public class Erased<T> {
32943: 1755:    private final int SIZE = 100;
32944: 1756:
32945: 1757:    public void f(Object arg) {
32946: 1758:        // error: illegal generic type for instanceof
32947: 1759:        if (arg instanceof T) {
32948: 1760:        }
32949: 1761:        // error: unexpected type
32950: 1762:        T var = new T();
32951: 1763:        // error: generic array creation
32952: 1764:        T[] array = new T[SIZE];
32953: 1765:        // warning: [unchecked] unchecked cast
32954: 1766:        T[] array = (T[]) new Object[SIZE];
32955: 1767:
32956: 1768:    }
32957: 1769:}
32958: 1770:```
32959: 1771:
32960: 1772:有时，我们可以对这些问题进行编程，但是有时必须通过引入类型标签来补偿擦除。这意味着为所需的类型显式传递一个 **Class** 对象，以在类型表达式中使用它。
32961: 1773:
32962: 1774:例如，由于擦除了类型信息，因此在上一个程序中尝试使用 **instanceof** 将会失败。类型标签可以使用动态 `isInstance()` ：
32963: 1775:
32964: 1776:```java
32965: 1777:// generics/ClassTypeCapture.java
32966: 1778:
32967: 1779:class Building {
32968: 1780:}
32969: 1781:
32970: 1782:class House extends Building {
32971: 1783:}
32972: 1784:
32973: 1785:public class ClassTypeCapture<T> {
32974: 1786:    Class<T> kind;
32975: 1787:
32976: 1788:    public ClassTypeCapture(Class<T> kind) {
32977: 1789:        this.kind = kind;
32978: 1790:    }
32979: 1791:
32980: 1792:    public boolean f(Object arg) {
32981: 1793:        return kind.isInstance(arg);
32982: 1794:    }
32983: 1795:
32984: 1796:    public static void main(String[] args) {
32985: 1797:        ClassTypeCapture<Building> ctt1 =
32986: 1798:                new ClassTypeCapture<>(Building.class);
32987: 1799:        System.out.println(ctt1.f(new Building()));
32988: 1800:        System.out.println(ctt1.f(new House()));
32989: 1801:        ClassTypeCapture<House> ctt2 =
32990: 1802:                new ClassTypeCapture<>(House.class);
32991: 1803:        System.out.println(ctt2.f(new Building()));
32992: 1804:        System.out.println(ctt2.f(new House()));
32993: 1805:    }
32994: 1806:}
32995: 1807:/* Output:
32996: 1808:true
32997: 1809:true
32998: 1810:false
32999: 1811:true
33000: 1812:*/
33001: 1813:```
33002: 1814:
33003: 1815:编译器来保证类型标签与泛型参数相匹配。
33004: 1816:
33005: 1817:<!-- Creating Instances of Types -->
33006: 1818:
33007: 1819:### 创建类型的实例
33008: 1820:
33009: 1821:试图在 **Erased.java** 中 `new T()` 是行不通的，部分原因是由于擦除，部分原因是编译器无法验证 **T** 是否具有默认（无参）构造函数。但是在 C++ 中，此操作自然，直接且安全（在编译时检查）：
33010: 1822:
33011: 1823:```C++
33012: 1824:// generics/InstantiateGenericType.cpp
33013: 1825:// C++, not Java!
33014: 1826:
33015: 1827:template<class T> class Foo {
33016: 1828:  T x; // Create a field of type T
33017: 1829:  T* y; // Pointer to T
33018: 1830:public:
33019: 1831:  // Initialize the pointer:
33020: 1832:  Foo() { y = new T(); }
33021: 1833:};
33022: 1834:
33023: 1835:class Bar {};
33024: 1836:
33025: 1837:int main() {
33026: 1838:  Foo<Bar> fb;
33027: 1839:  Foo<int> fi; // ... and it works with primitives
33028: 1840:}
33029: 1841:```
33030: 1842:
33031: 1843:Java 中的解决方案是传入一个工厂对象，并使用该对象创建新实例。方便的工厂对象只是 **Class** 对象，因此，如果使用类型标记，则可以使用 `newInstance()` 创建该类型的新对象：
33032: 1844:
33033: 1845:```java
33034: 1846:// generics/InstantiateGenericType.java
33035: 1847:
33036: 1848:import java.util.function.Supplier;
33037: 1849:
33038: 1850:class ClassAsFactory<T> implements Supplier<T> {
33039: 1851:    Class<T> kind;
33040: 1852:
33041: 1853:    ClassAsFactory(Class<T> kind) {
33042: 1854:        this.kind = kind;
33043: 1855:    }
33044: 1856:
33045: 1857:    @Override
33046: 1858:    public T get() {
33047: 1859:        try {
33048: 1860:            return kind.newInstance();
33049: 1861:        } catch (InstantiationException |
33050: 1862:                IllegalAccessException e) {
33051: 1863:            throw new RuntimeException(e);
33052: 1864:        }
33053: 1865:    }
33054: 1866:}
33055: 1867:
33056: 1868:class Employee {
33057: 1869:    @Override
33058: 1870:    public String toString() {
33059: 1871:        return "Employee";
33060: 1872:    }
33061: 1873:}
33062: 1874:
33063: 1875:public class InstantiateGenericType {
33064: 1876:    public static void main(String[] args) {
33065: 1877:        ClassAsFactory<Employee> fe =
33066: 1878:                new ClassAsFactory<>(Employee.class);
33067: 1879:        System.out.println(fe.get());
33068: 1880:        ClassAsFactory<Integer> fi =
33069: 1881:                new ClassAsFactory<>(Integer.class);
33070: 1882:        try {
33071: 1883:            System.out.println(fi.get());
33072: 1884:        } catch (Exception e) {
33073: 1885:            System.out.println(e.getMessage());
33074: 1886:        }
33075: 1887:    }
33076: 1888:}
33077: 1889:/* Output:
33078: 1890:Employee
33079: 1891:java.lang.InstantiationException: java.lang.Integer
33080: 1892:*/
33081: 1893:```
33082: 1894:
33083: 1895:这样可以编译，但对于 `ClassAsFactory<Integer>` 会失败，这是因为 **Integer** 没有无参构造函数。由于错误不是在编译时捕获的，因此语言创建者不赞成这种方法。他们建议使用显式工厂（**Supplier**）并约束类型，以便只有实现该工厂的类可以这样创建对象。这是创建工厂的两种不同方法：
33084: 1896:
33085: 1897:```java
33086: 1898:// generics/FactoryConstraint.java
33087: 1899:
33088: 1900:import onjava.Suppliers;
33089: 1901:
33090: 1902:import java.util.ArrayList;
33091: 1903:import java.util.List;
33092: 1904:import java.util.function.Supplier;
33093: 1905:
33094: 1906:class IntegerFactory implements Supplier<Integer> {
33095: 1907:    private int i = 0;
33096: 1908:
33097: 1909:    @Override
33098: 1910:    public Integer get() {
33099: 1911:        return ++i;
33100: 1912:    }
33101: 1913:}
33102: 1914:
33103: 1915:class Widget {
33104: 1916:    private int id;
33105: 1917:
33106: 1918:    Widget(int n) {
33107: 1919:        id = n;
33108: 1920:    }
33109: 1921:
33110: 1922:    @Override
33111: 1923:    public String toString() {
33112: 1924:        return "Widget " + id;
33113: 1925:    }
33114: 1926:
33115: 1927:    public static
33116: 1928:    class Factory implements Supplier<Widget> {
33117: 1929:        private int i = 0;
33118: 1930:
33119: 1931:        @Override
33120: 1932:        public Widget get() {
33121: 1933:            return new Widget(++i);
33122: 1934:        }
33123: 1935:    }
33124: 1936:}
33125: 1937:
33126: 1938:class Fudge {
33127: 1939:    private static int count = 1;
33128: 1940:    private int n = count++;
33129: 1941:
33130: 1942:    @Override
33131: 1943:    public String toString() {
33132: 1944:        return "Fudge " + n;
33133: 1945:    }
33134: 1946:}
33135: 1947:
33136: 1948:class Foo2<T> {
33137: 1949:    private List<T> x = new ArrayList<>();
33138: 1950:
33139: 1951:    Foo2(Supplier<T> factory) {
33140: 1952:        Suppliers.fill(x, factory, 5);
33141: 1953:    }
33142: 1954:
33143: 1955:    @Override
33144: 1956:    public String toString() {
33145: 1957:        return x.toString();
33146: 1958:    }
33147: 1959:}
33148: 1960:
33149: 1961:public class FactoryConstraint {
33150: 1962:    public static void main(String[] args) {
33151: 1963:        System.out.println(
33152: 1964:                new Foo2<>(new IntegerFactory()));
33153: 1965:        System.out.println(
33154: 1966:                new Foo2<>(new Widget.Factory()));
33155: 1967:        System.out.println(
33156: 1968:                new Foo2<>(Fudge::new));
33157: 1969:    }
33158: 1970:}
33159: 1971:/* Output:
33160: 1972:[1, 2, 3, 4, 5]
33161: 1973:[Widget 1, Widget 2, Widget 3, Widget 4, Widget 5]
33162: 1974:[Fudge 1, Fudge 2, Fudge 3, Fudge 4, Fudge 5]
33163: 1975:*/
33164: 1976:```
33165: 1977:
33166: 1978:**IntegerFactory** 本身就是通过实现 `Supplier<Integer>` 的工厂。 **Widget** 包含一个内部类，它是一个工厂。还要注意，**Fudge** 并没有做任何类似于工厂的操作，并且传递 `Fudge::new` 仍然会产生工厂行为，因为编译器将对函数方法 `::new` 的调用转换为对 `get()` 的调用。
33167: 1979:
33168: 1980:另一种方法是模板方法设计模式。在以下示例中，`create()` 是模板方法，在子类中被重写以生成该类型的对象：
33169: 1981:
33170: 1982:```java
33171: 1983:// generics/CreatorGeneric.java
33172: 1984:
33173: 1985:abstract class GenericWithCreate<T> {
33174: 1986:    final T element;
33175: 1987:
33176: 1988:    GenericWithCreate() {
33177: 1989:        element = create();
33178: 1990:    }
33179: 1991:
33180: 1992:    abstract T create();
33181: 1993:}
33182: 1994:
33183: 1995:class X {
33184: 1996:}
33185: 1997:
33186: 1998:class XCreator extends GenericWithCreate<X> {
33187: 1999:    @Override
33188: 2000:    X create() {
33189: 2001:        return new X();
33190: 2002:    }
33191: 2003:
33192: 2004:    void f() {
33193: 2005:        System.out.println(
33194: 2006:                element.getClass().getSimpleName());
33195: 2007:    }
33196: 2008:}
33197: 2009:
33198: 2010:public class CreatorGeneric {
33199: 2011:    public static void main(String[] args) {
33200: 2012:        XCreator xc = new XCreator();
33201: 2013:        xc.f();
33202: 2014:    }
33203: 2015:}
33204: 2016:/* Output:
33205: 2017:X
33206: 2018:*/
33207: 2019:```
33208: 2020:
33209: 2021:**GenericWithCreate** 包含 `element` 字段，并通过无参构造函数强制其初始化，该构造函数又调用抽象的 `create()` 方法。这种创建方式可以在子类中定义，同时建立 **T** 的类型。
33210: 2022:
33211: 2023:<!-- Arrays of Generics -->
33212: 2024:
33213: 2025:### 泛型数组
33214: 2026:
33215: 2027:正如在 **Erased.java** 中所看到的，我们无法创建泛型数组。通用解决方案是在试图创建泛型数组的时候使用 **ArrayList** ：
33216: 2028:
33217: 2029:```java
33218: 2030:// generics/ListOfGenerics.java
33219: 2031:
33220: 2032:import java.util.ArrayList;
33221: 2033:import java.util.List;
33222: 2034:
33223: 2035:public class ListOfGenerics<T> {
33224: 2036:    private List<T> array = new ArrayList<>();
33225: 2037:
33226: 2038:    public void add(T item) {
33227: 2039:        array.add(item);
33228: 2040:    }
33229: 2041:
33230: 2042:    public T get(int index) {
33231: 2043:        return array.get(index);
33232: 2044:    }
33233: 2045:}
33234: 2046:```
33235: 2047:
33236: 2048:这样做可以获得数组的行为，并且还具有泛型提供的编译时类型安全性。
33237: 2049:
33238: 2050:有时，仍然会创建泛型类型的数组（例如， **ArrayList** 在内部使用数组）。可以通过使编译器满意的方式定义对数组的通用引用：
33239: 2051:
33240: 2052:```java
33241: 2053:// generics/ArrayOfGenericReference.java
33242: 2054:
33243: 2055:class Generic<T> {
33244: 2056:}
33245: 2057:
33246: 2058:public class ArrayOfGenericReference {
33247: 2059:    static Generic<Integer>[] gia;
33248: 2060:}
33249: 2061:```
33250: 2062:
33251: 2063:编译器接受此操作而不产生警告。但是我们永远无法创建具有该确切类型（包括类型参数）的数组，因此有点令人困惑。由于所有数组，无论它们持有什么类型，都具有相同的结构（每个数组插槽的大小和数组布局），因此似乎可以创建一个 **Object** 数组并将其转换为所需的数组类型。实际上，这确实可以编译，但是会产生 **ClassCastException** ：
33252: 2064:
33253: 2065:```java
33254: 2066:// generics/ArrayOfGeneric.java
33255: 2067:
33256: 2068:public class ArrayOfGeneric {
33257: 2069:    static final int SIZE = 100;
33258: 2070:    static Generic<Integer>[] gia;
33259: 2071:
33260: 2072:    @SuppressWarnings("unchecked")
33261: 2073:    public static void main(String[] args) {
33262: 2074:        try {
33263: 2075:            gia = (Generic<Integer>[]) new Object[SIZE];
33264: 2076:        } catch (ClassCastException e) {
33265: 2077:            System.out.println(e.getMessage());
33266: 2078:        }
33267: 2079:        // Runtime type is the raw (erased) type:
33268: 2080:        gia = (Generic<Integer>[]) new Generic[SIZE];
33269: 2081:        System.out.println(gia.getClass().getSimpleName());
33270: 2082:        gia[0] = new Generic<>();
33271: 2083:        //- gia[1] = new Object(); // Compile-time error
33272: 2084:        // Discovers type mismatch at compile time:
33273: 2085:        //- gia[2] = new Generic<Double>();
33274: 2086:    }
33275: 2087:}
33276: 2088:/* Output:
33277: 2089:[Ljava.lang.Object; cannot be cast to [LGeneric;
33278: 2090:Generic[]
33279: 2091:*/
33280: 2092:```
33281: 2093:
33282: 2094:问题在于数组会跟踪其实际类型，而该类型是在创建数组时建立的。因此，即使 `gia` 被强制转换为 `Generic<Integer>[]` ，该信息也仅在编译时存在（并且没有 **@SuppressWarnings** 注解，将会收到有关该强制转换的警告）。在运行时，它仍然是一个 **Object** 数组，这会引起问题。成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换。
33283: 2095:
33284: 2096:让我们看一个更复杂的示例。考虑一个包装数组的简单泛型包装器：
33285: 2097:
33286: 2098:```java
33287: 2099:// generics/GenericArray.java
33288: 2100:
33289: 2101:public class GenericArray<T> {
33290: 2102:    private T[] array;
33291: 2103:
33292: 2104:    @SuppressWarnings("unchecked")
33293: 2105:    public GenericArray(int sz) {
33294: 2106:        array = (T[]) new Object[sz];
33295: 2107:    }
33296: 2108:
33297: 2109:    public void put(int index, T item) {
33298: 2110:        array[index] = item;
33299: 2111:    }
33300: 2112:
33301: 2113:    public T get(int index) {
33302: 2114:        return array[index];
33303: 2115:    }
33304: 2116:
33305: 2117:    // Method that exposes the underlying representation:
33306: 2118:    public T[] rep() {
33307: 2119:        return array;
33308: 2120:    }
33309: 2121:
33310: 2122:    public static void main(String[] args) {
33311: 2123:        GenericArray<Integer> gai = new GenericArray<>(10);
33312: 2124:        try {
33313: 2125:            Integer[] ia = gai.rep();
33314: 2126:        } catch (ClassCastException e) {
33315: 2127:            System.out.println(e.getMessage());
33316: 2128:        }
33317: 2129:        // This is OK:
33318: 2130:        Object[] oa = gai.rep();
33319: 2131:    }
33320: 2132:}
33321: 2133:/* Output:
33322: 2134:[Ljava.lang.Object; cannot be cast to
33323: 2135:[Ljava.lang.Integer;
33324: 2136:*/
33325: 2137:```
33326: 2138:
33327: 2139:和以前一样，我们不能说 `T[] array = new T[sz]` ，所以我们创建了一个 **Object** 数组并将其强制转换。
33328: 2140:
33329: 2141:`rep()` 方法返回一个 `T[]` ，在主方法中它应该是 `gai` 的 `Integer[]`，但是如果调用它并尝试将结果转换为 `Integer[]` 引用，则会得到 **ClassCastException** ，这再次是因为实际的运行时类型为 `Object[]` 。
33330: 2142:
33331: 2143:如果再注释掉 **@SuppressWarnings** 注解后编译 **GenericArray.java** ，则编译器会产生警告：
33332: 2144:
33333: 2145:```java
33334: 2146:GenericArray.java uses unchecked or unsafe operations.
33335: 2147:Recompile with -Xlint:unchecked for details.
33336: 2148:```
33337: 2149:
33338: 2150:在这里，我们收到了一个警告，我们认为这是有关强制转换的。
33339: 2151:
33340: 2152:但是要真正确定，请使用 `-Xlint：unchecked` 进行编译：
33341: 2153:
33342: 2154:```java
33343: 2155:GenericArray.java:7: warning: [unchecked] unchecked cast    array = (T[])new Object[sz];                 ^  required: T[]  found:    Object[]  where T is a type-variable:    T extends Object declared in class GenericArray 1 warning
33344: 2156:```
33345: 2157:
33346: 2158:确实是在抱怨那个强制转换。由于警告会变成噪音，因此，一旦我们确认预期会出现特定警告，我们可以做的最好的办法就是使用 **@SuppressWarnings** 将其关闭。这样，当警告确实出现时，我们将进行实际调查。
33347: 2159:
33348: 2160:由于擦除，数组的运行时类型只能是 `Object[]` 。 如果我们立即将其转换为 `T[]` ，则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。因此，最好在集合中使用 `Object[]` ，并在使用数组元素时向 **T** 添加强制类型转换。让我们来看看在 **GenericArray.java** 示例中会是怎么样的：
33349: 2161:
33350: 2162:```java
33351: 2163:// generics/GenericArray2.java
33352: 2164:
33353: 2165:public class GenericArray2<T> {
33354: 2166:    private Object[] array;
33355: 2167:
33356: 2168:    public GenericArray2(int sz) {
33357: 2169:        array = new Object[sz];
33358: 2170:    }
33359: 2171:
33360: 2172:    public void put(int index, T item) {
33361: 2173:        array[index] = item;
33362: 2174:    }
33363: 2175:
33364: 2176:    @SuppressWarnings("unchecked")
33365: 2177:    public T get(int index) {
33366: 2178:        return (T) array[index];
33367: 2179:    }
33368: 2180:
33369: 2181:    @SuppressWarnings("unchecked")
33370: 2182:    public T[] rep() {
33371: 2183:        return (T[]) array; // Unchecked cast
33372: 2184:    }
33373: 2185:
33374: 2186:    public static void main(String[] args) {
33375: 2187:        GenericArray2<Integer> gai =
33376: 2188:                new GenericArray2<>(10);
33377: 2189:        for (int i = 0; i < 10; i++)
33378: 2190:            gai.put(i, i);
33379: 2191:        for (int i = 0; i < 10; i++)
33380: 2192:            System.out.print(gai.get(i) + " ");
33381: 2193:        System.out.println();
33382: 2194:        try {
33383: 2195:            Integer[] ia = gai.rep();
33384: 2196:        } catch (Exception e) {
33385: 2197:            System.out.println(e);
33386: 2198:        }
33387: 2199:    }
33388: 2200:}
33389: 2201:/* Output:
33390: 2202:0 1 2 3 4 5 6 7 8 9
33391: 2203:java.lang.ClassCastException: [Ljava.lang.Object;
33392: 2204:cannot be cast to [Ljava.lang.Integer;
33393: 2205:*/
33394: 2206:```
33395: 2207:
33396: 2208:最初，看起来并没有太大不同，只是转换的位置移动了。没有 **@SuppressWarnings** 注解，仍然会收到“unchecked”警告。但是，内部表示现在是 `Object[]` 而不是 `T[]` 。 调用 `get()` 时，它将对象强制转换为 **T** ，实际上这是正确的类型，因此很安全。但是，如果调用 `rep()` ，它将再次尝试将 `Object[]` 强制转换为 `T[]` ，但仍然不正确，并在编译时生成警告，并在运行时生成异常。因此，无法破坏基础数组的类型，该基础数组只能是 `Object[]` 。在内部将数组视为 `Object[]` 而不是 `T[]` 的优点是，我们不太可能会忘记数组的运行时类型并意外地引入了bug，尽管大多数（也许是全部）此类错误会在运行时被迅速检测到。
33397: 2209:
33398: 2210:对于新代码，请传入类型标记。在这种情况下，**GenericArray** 如下所示：
33399: 2211:
33400: 2212:```java
33401: 2213:// generics/GenericArrayWithTypeToken.java
33402: 2214:
33403: 2215:import java.lang.reflect.Array;
33404: 2216:
33405: 2217:public class GenericArrayWithTypeToken<T> {
33406: 2218:    private T[] array;
33407: 2219:
33408: 2220:    @SuppressWarnings("unchecked")
33409: 2221:    public GenericArrayWithTypeToken(Class<T> type, int sz) {
33410: 2222:        array = (T[]) Array.newInstance(type, sz);
33411: 2223:    }
33412: 2224:
33413: 2225:    public void put(int index, T item) {
33414: 2226:        array[index] = item;
33415: 2227:    }
33416: 2228:
33417: 2229:    public T get(int index) {
33418: 2230:        return array[index];
33419: 2231:    }
33420: 2232:
33421: 2233:    // Expose the underlying representation:
33422: 2234:    public T[] rep() {
33423: 2235:        return array;
33424: 2236:    }
33425: 2237:
33426: 2238:    public static void main(String[] args) {
33427: 2239:        GenericArrayWithTypeToken<Integer> gai =
33428: 2240:                new GenericArrayWithTypeToken<>(
33429: 2241:                        Integer.class, 10);
33430: 2242:        // This now works:
33431: 2243:        Integer[] ia = gai.rep();
33432: 2244:    }
33433: 2245:}
33434: 2246:```
33435: 2247:
33436: 2248:类型标记 **Class\<T\>** 被传递到构造函数中以从擦除中恢复，因此尽管必须使用 **@SuppressWarnings** 关闭来自强制类型转换的警告，但我们仍可以创建所需的实际数组类型。一旦获得了实际的类型，就可以返回它并产生所需的结果，如在主方法中看到的那样。数组的运行时类型是确切的类型 `T[]` 。
33437: 2249:
33438: 2250:不幸的是，如果查看 Java 标准库中的源代码，你会发现到处都有从 **Object** 数组到参数化类型的转换。例如，这是**ArrayList** 中，复制一个 **Collection** 的构造函数，这里为了简化，去除了源码中对此不重要的代码：
33439: 2251:
33440: 2252:```java
33441: 2253:public ArrayList(Collection c) {
33442: 2254:  size = c.size();
33443: 2255:  elementData = (E[])new Object[size];
33444: 2256:  c.toArray(elementData);
33445: 2257:}
33446: 2258:```
33447: 2259:
33448: 2260:如果你浏览 **ArrayList.java** 的代码，将会发现很多此类强制转换。当我们编译它时会发生什么？
33449: 2261:
33450: 2262:```java
33451: 2263:Note: ArrayList.java uses unchecked or unsafe operations
33452: 2264:Note: Recompile with -Xlint:unchecked for details.
33453: 2265:```
33454: 2266:
33455: 2267:果然，标准库会产生很多警告。如果你使用过 C 语言，尤其是使用 ANSI C 之前的语言，你会记住警告的特殊效果：发现警告后，可以忽略它们。因此，除非程序员必须对其进行处理，否则最好不要从编译器发出任何类型的消息。
33456: 2268:
33457: 2269:Neal Gafter（Java 5 的主要开发人员之一）在他的博客中[^2]指出，他在重写 Java 库时是很随意、马虎的，我们不应该像他那样做。Neal 还指出，他在不破坏现有接口的情况下无法修复某些 Java 库代码。因此，即使在 Java 库源代码中出现了一些习惯用法，它们也不一定是正确的做法。当查看库代码时，我们不能认为这就是要在自己代码中必须遵循的示例。
33458: 2270:
33459: 2271:请注意，在 Java 文献中推荐使用类型标记技术，例如 Gilad Bracha 的论文《Generics in the Java Programming Language》[^3]，他指出：“例如，这种用法已广泛用于新的 API 中以处理注解。” 我发现此技术在人们对于舒适度的看法方面存在一些不一致之处；有些人强烈喜欢本章前面介绍的工厂方法。
33460: 2272:
33461: 2273:<!-- Bounds -->
33462: 2274:
33463: 2275:## 边界
33464: 2276:
33465: 2277:*边界*（bounds）在本章的前面进行了简要介绍。边界允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法。
33466: 2278:
33467: 2279:由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 **Object** 可用的方法。但是，如果将该参数限制为某类型的子集，则可以调用该子集中的方法。为了应用约束，Java 泛型使用了 `extends` 关键字。
33468: 2280:
33469: 2281:重要的是要理解，当用于限定泛型类型时，`extends` 的含义与通常的意义截然不同。此示例展示边界的基础应用：
33470: 2282:
33471: 2283:```java
33472: 2284:// generics/BasicBounds.java
33473: 2285:
33474: 2286:interface HasColor {
33475: 2287:    java.awt.Color getColor();
33476: 2288:}
33477: 2289:
33478: 2290:class WithColor<T extends HasColor> {
33479: 2291:    T item;
33480: 2292:
33481: 2293:    WithColor(T item) {
33482: 2294:        this.item = item;
33483: 2295:    }
33484: 2296:
33485: 2297:    T getItem() {
33486: 2298:        return item;
33487: 2299:    }
33488: 2300:
33489: 2301:    // The bound allows you to call a method:
33490: 2302:    java.awt.Color color() {
33491: 2303:        return item.getColor();
33492: 2304:    }
33493: 2305:}
33494: 2306:
33495: 2307:class Coord {
33496: 2308:    public int x, y, z;
33497: 2309:}
33498: 2310:
33499: 2311:// This fails. Class must be first, then interfaces:
33500: 2312:// class WithColorCoord<T extends HasColor & Coord> {
33501: 2313:
33502: 2314:// Multiple bounds:
33503: 2315:class WithColorCoord<T extends Coord & HasColor> {
33504: 2316:    T item;
33505: 2317:
33506: 2318:    WithColorCoord(T item) {
33507: 2319:        this.item = item;
33508: 2320:    }
33509: 2321:
33510: 2322:    T getItem() {
33511: 2323:        return item;
33512: 2324:    }
33513: 2325:
33514: 2326:    java.awt.Color color() {
33515: 2327:        return item.getColor();
33516: 2328:    }
33517: 2329:
33518: 2330:    int getX() {
33519: 2331:        return item.x;
33520: 2332:    }
33521: 2333:
33522: 2334:    int getY() {
33523: 2335:        return item.y;
33524: 2336:    }
33525: 2337:
33526: 2338:    int getZ() {
33527: 2339:        return item.z;
33528: 2340:    }
33529: 2341:}
33530: 2342:
33531: 2343:interface Weight {
33532: 2344:    int weight();
33533: 2345:}
33534: 2346:
33535: 2347:// As with inheritance, you can have only one
33536: 2348:// concrete class but multiple interfaces:
33537: 2349:class Solid<T extends Coord & HasColor & Weight> {
33538: 2350:    T item;
33539: 2351:
33540: 2352:    Solid(T item) {
33541: 2353:        this.item = item;
33542: 2354:    }
33543: 2355:
33544: 2356:    T getItem() {
33545: 2357:        return item;
33546: 2358:    }
33547: 2359:
33548: 2360:    java.awt.Color color() {
33549: 2361:        return item.getColor();
33550: 2362:    }
33551: 2363:
33552: 2364:    int getX() {
33553: 2365:        return item.x;
33554: 2366:    }
33555: 2367:
33556: 2368:    int getY() {
33557: 2369:        return item.y;
33558: 2370:    }
33559: 2371:
33560: 2372:    int getZ() {
33561: 2373:        return item.z;
33562: 2374:    }
33563: 2375:
33564: 2376:    int weight() {
33565: 2377:        return item.weight();
33566: 2378:    }
33567: 2379:}
33568: 2380:
33569: 2381:class Bounded
33570: 2382:        extends Coord implements HasColor, Weight {
33571: 2383:    @Override
33572: 2384:    public java.awt.Color getColor() {
33573: 2385:        return null;
33574: 2386:    }
33575: 2387:
33576: 2388:    @Override
33577: 2389:    public int weight() {
33578: 2390:        return 0;
33579: 2391:    }
33580: 2392:}
33581: 2393:
33582: 2394:public class BasicBounds {
33583: 2395:    public static void main(String[] args) {
33584: 2396:        Solid<Bounded> solid =
33585: 2397:                new Solid<>(new Bounded());
33586: 2398:        solid.color();
33587: 2399:        solid.getY();
33588: 2400:        solid.weight();
33589: 2401:    }
33590: 2402:}
33591: 2403:```
33592: 2404:
33593: 2405:你可能会观察到 **BasicBounds.java** 中似乎包含一些冗余，它们可以通过继承来消除。在这里，每个继承级别还添加了边界约束：
33594: 2406:
33595: 2407:```java
33596: 2408:// generics/InheritBounds.java
33597: 2409:
33598: 2410:class HoldItem<T> {
33599: 2411:    T item;
33600: 2412:
33601: 2413:    HoldItem(T item) {
33602: 2414:        this.item = item;
33603: 2415:    }
33604: 2416:
33605: 2417:    T getItem() {
33606: 2418:        return item;
33607: 2419:    }
33608: 2420:}
33609: 2421:
33610: 2422:class WithColor2<T extends HasColor>
33611: 2423:        extends HoldItem<T> {
33612: 2424:    WithColor2(T item) {
33613: 2425:        super(item);
33614: 2426:    }
33615: 2427:
33616: 2428:    java.awt.Color color() {
33617: 2429:        return item.getColor();
33618: 2430:    }
33619: 2431:}
33620: 2432:
33621: 2433:class WithColorCoord2<T extends Coord & HasColor>
33622: 2434:        extends WithColor2<T> {
33623: 2435:    WithColorCoord2(T item) {
33624: 2436:        super(item);
33625: 2437:    }
33626: 2438:
33627: 2439:    int getX() {
33628: 2440:        return item.x;
33629: 2441:    }
33630: 2442:
33631: 2443:    int getY() {
33632: 2444:        return item.y;
33633: 2445:    }
33634: 2446:
33635: 2447:    int getZ() {
33636: 2448:        return item.z;
33637: 2449:    }
33638: 2450:}
33639: 2451:
33640: 2452:class Solid2<T extends Coord & HasColor & Weight>
33641: 2453:        extends WithColorCoord2<T> {
33642: 2454:    Solid2(T item) {
33643: 2455:        super(item);
33644: 2456:    }
33645: 2457:
33646: 2458:    int weight() {
33647: 2459:        return item.weight();
33648: 2460:    }
33649: 2461:}
33650: 2462:
33651: 2463:public class InheritBounds {
33652: 2464:    public static void main(String[] args) {
33653: 2465:        Solid2<Bounded> solid2 =
33654: 2466:                new Solid2<>(new Bounded());
33655: 2467:        solid2.color();
33656: 2468:        solid2.getY();
33657: 2469:        solid2.weight();
33658: 2470:    }
33659: 2471:}
33660: 2472:```
33661: 2473:
33662: 2474:**HoldItem** 拥有一个对象，因此此行为将继承到 **WithColor2** 中，这也需要其参数符合 **HasColor**。 **WithColorCoord2** 和 **Solid2** 进一步扩展了层次结构，并在每个级别添加了边界。现在，这些方法已被继承，并且在每个类中不再重复。
33663: 2475:
33664: 2476:这是一个具有更多层次的示例：
33665: 2477:
33666: 2478:```java
33667: 2479:// generics/EpicBattle.java
33668: 2480:// Bounds in Java generics
33669: 2481:
33670: 2482:import java.util.List;
33671: 2483:
33672: 2484:interface SuperPower {
33673: 2485:}
33674: 2486:
33675: 2487:interface XRayVision extends SuperPower {
33676: 2488:    void seeThroughWalls();
33677: 2489:}
33678: 2490:
33679: 2491:interface SuperHearing extends SuperPower {
33680: 2492:    void hearSubtleNoises();
33681: 2493:}
33682: 2494:
33683: 2495:interface SuperSmell extends SuperPower {
33684: 2496:    void trackBySmell();
33685: 2497:}
33686: 2498:
33687: 2499:class SuperHero<POWER extends SuperPower> {
33688: 2500:    POWER power;
33689: 2501:
33690: 2502:    SuperHero(POWER power) {
33691: 2503:        this.power = power;
33692: 2504:    }
33693: 2505:
33694: 2506:    POWER getPower() {
33695: 2507:        return power;
33696: 2508:    }
33697: 2509:}
33698: 2510:
33699: 2511:class SuperSleuth<POWER extends XRayVision>
33700: 2512:        extends SuperHero<POWER> {
33701: 2513:    SuperSleuth(POWER power) {
33702: 2514:        super(power);
33703: 2515:    }
33704: 2516:
33705: 2517:    void see() {
33706: 2518:        power.seeThroughWalls();
33707: 2519:    }
33708: 2520:}
33709: 2521:
33710: 2522:class
33711: 2523:CanineHero<POWER extends SuperHearing & SuperSmell>
33712: 2524:        extends SuperHero<POWER> {
33713: 2525:    CanineHero(POWER power) {
33714: 2526:        super(power);
33715: 2527:    }
33716: 2528:
33717: 2529:    void hear() {
33718: 2530:        power.hearSubtleNoises();
33719: 2531:    }
33720: 2532:
33721: 2533:    void smell() {
33722: 2534:        power.trackBySmell();
33723: 2535:    }
33724: 2536:}
33725: 2537:
33726: 2538:class SuperHearSmell
33727: 2539:        implements SuperHearing, SuperSmell {
33728: 2540:    @Override
33729: 2541:    public void hearSubtleNoises() {
33730: 2542:    }
33731: 2543:
33732: 2544:    @Override
33733: 2545:    public void trackBySmell() {
33734: 2546:    }
33735: 2547:}
33736: 2548:
33737: 2549:class DogPerson extends CanineHero<SuperHearSmell> {
33738: 2550:    DogPerson() {
33739: 2551:        super(new SuperHearSmell());
33740: 2552:    }
33741: 2553:}
33742: 2554:
33743: 2555:public class EpicBattle {
33744: 2556:    // Bounds in generic methods:
33745: 2557:    static <POWER extends SuperHearing>
33746: 2558:    void useSuperHearing(SuperHero<POWER> hero) {
33747: 2559:        hero.getPower().hearSubtleNoises();
33748: 2560:    }
33749: 2561:
33750: 2562:    static <POWER extends SuperHearing & SuperSmell>
33751: 2563:    void superFind(SuperHero<POWER> hero) {
33752: 2564:        hero.getPower().hearSubtleNoises();
33753: 2565:        hero.getPower().trackBySmell();
33754: 2566:    }
33755: 2567:
33756: 2568:    public static void main(String[] args) {
33757: 2569:        DogPerson dogPerson = new DogPerson();
33758: 2570:        useSuperHearing(dogPerson);
33759: 2571:        superFind(dogPerson);
33760: 2572:        // You can do this:
33761: 2573:        List<? extends SuperHearing> audioPeople;
33762: 2574:        // But you can't do this:
33763: 2575:        // List<? extends SuperHearing & SuperSmell> dogPs;
33764: 2576:    }
33765: 2577:}
33766: 2578:```
33767: 2579:
33768: 2580:接下来将要研究的通配符将会把范围限制在单个类型。
33769: 2581:
33770: 2582:<!-- Wildcards -->
33771: 2583:
33772: 2584:## 通配符
33773: 2585:
33774: 2586:你已经在 [集合](book/12-Collections.md) 章节中看到了一些简单示例使用了通配符——在泛型参数表达式中的问号，在 [类型信息](book/19-Type-Information.md) 一章中这种示例更多。本节将更深入地探讨这个特性。
33775: 2587:
33776: 2588:我们的起始示例要展示数组的一种特殊行为：你可以将派生类的数组赋值给基类的引用：
33777: 2589:
33778: 2590:```java
33779: 2591:// generics/CovariantArrays.java
33780: 2592:
33781: 2593:class Fruit {}
33782: 2594:
33783: 2595:class Apple extends Fruit {}
33784: 2596:
33785: 2597:class Jonathan extends Apple {}
33786: 2598:
33787: 2599:class Orange extends Fruit {}
33788: 2600:
33789: 2601:public class CovariantArrays {
33790: 2602:    
33791: 2603:    public static void main(String[] args) {
33792: 2604:        Fruit[] fruit = new Apple[10];
33793: 2605:        fruit[0] = new Apple(); // OK
33794: 2606:        fruit[1] = new Jonathan(); // OK
33795: 2607:        // Runtime type is Apple[], not Fruit[] or Orange[]:
33796: 2608:        try {
33797: 2609:            // Compiler allows you to add Fruit:
33798: 2610:            fruit[0] = new Fruit(); // ArrayStoreException
33799: 2611:        } catch (Exception e) {
33800: 2612:            System.out.println(e);
33801: 2613:        }
33802: 2614:        try {
33803: 2615:            // Compiler allows you to add Oranges:
33804: 2616:            fruit[0] = new Orange(); // ArrayStoreException
33805: 2617:        } catch (Exception e) {
33806: 2618:            System.out.println(e);
33807: 2619:        }
33808: 2620:    }
33809: 2621:}
33810: 2622:/* Output:
33811: 2623:java.lang.ArrayStoreException: Fruit
33812: 2624:java.lang.ArrayStoreException: Orange
33813: 2625:```
33814: 2626:
33815: 2627:`main()` 中的第一行创建了 **Apple** 数组，并赋值给一个 **Fruit** 数组引用。这是有意义的，因为 **Apple** 也是一种 **Fruit**，因此 **Apple** 数组应该也是一个 **Fruit** 数组。
33816: 2628:
33817: 2629:但是，如果实际的数组类型是 **Apple[]**，你可以在其中放置 **Apple** 或 **Apple** 的子类型，这在编译期和运行时都可以工作。但是你也可以在数组中放置 **Fruit** 对象。这对编译器来说是有意义的，因为它有一个 **Fruit[]** 引用——它有什么理由不允许将 **Fruit** 对象或任何从 **Fruit** 继承出来的对象（比如 **Orange**），放置到这个数组中呢？因此在编译期，这是允许的。然而，运行时的数组机制知道它处理的是 **Apple[]**，因此会在向数组中放置异构类型时抛出异常。
33818: 2630:
33819: 2631:向上转型用在这里不合适。你真正在做的是将一个数组赋值给另一个数组。数组的行为是持有其他对象，这里只是因为我们能够向上转型而已，所以很明显，数组对象可以保留有关它们包含的对象类型的规则。看起来就像数组对它们持有的对象是有意识的，因此在编译期检查和运行时检查之间，你不能滥用它们。
33820: 2632:
33821: 2633:数组的这种赋值并不是那么可怕，因为在运行时你可以发现插入了错误的类型。但是泛型的主要目标之一是将这种错误检测移到编译期。所以当我们试图使用泛型集合代替数组时，会发生什么呢？
33822: 2634:
33823: 2635:```java
33824: 2636:// generics/NonCovariantGenerics.java
33825: 2637:// {WillNotCompile}
33826: 2638:
33827: 2639:import java.util.*;
33828: 2640:
33829: 2641:public class NonCovariantGenerics {
33830: 2642:    // Compile Error: incompatible types:
33831: 2643:    List<Fruit> flist = new ArrayList<Apple>();
33832: 2644:}
33833: 2645:```
33834: 2646:
33835: 2647:尽管你在首次阅读这段代码时会认为“不能将一个 **Apple** 集合赋值给一个 **Fruit** 集合”。记住，泛型不仅仅是关于集合，它真正要表达的是“不能把一个涉及 **Apple** 的泛型赋值给一个涉及 **Fruit** 的泛型”。如果像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及到的集合，那么它可能会留下一些余地。但是它不知道任何有关这方面的信息，因此它拒绝向上转型。然而实际上这也不是向上转型—— **Apple** 的 **List** 不是 **Fruit** 的 **List**。**Apple** 的 **List** 将持有 **Apple** 和 **Apple** 的子类型，**Fruit** 的 **List** 将持有任何类型的 **Fruit**。是的，这包括 **Apple**，但是它不是一个 **Apple** 的 **List**，它仍然是 **Fruit** 的 **List**。**Apple** 的 **List** 在类型上不等价于 **Fruit** 的 **List**，即使 **Apple** 是一种 **Fruit** 类型。
33836: 2648:
33837: 2649:真正的问题是我们在讨论的集合类型，而不是集合持有对象的类型。与数组不同，泛型没有内建的协变类型。这是因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查，但是在使用泛型时，编译器和运行时系统不知道你想用类型做什么，以及应该采用什么规则。
33838: 2650:
33839: 2651:但是，有时你想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。
33840: 2652:
33841: 2653:```java
33842: 2654:// generics/GenericsAndCovariance.java
33843: 2655:
33844: 2656:import java.util.*;
33845: 2657:
33846: 2658:public class GenericsAndCovariance {
33847: 2659:    
33848: 2660:    public static void main(String[] args) {
33849: 2661:        // Wildcards allow covariance:
33850: 2662:        List<? extends Fruit> flist = new ArrayList<>();
33851: 2663:        // Compile Error: can't add any type of object:
33852: 2664:        // flist.add(new Apple());
33853: 2665:        // flist.add(new Fruit());
33854: 2666:        // flist.add(new Object());
33855: 2667:        flist.add(null); // Legal but uninteresting
33856: 2668:        // We know it returns at least Fruit:
33857: 2669:        Fruit f = flist.get(0);
33858: 2670:    }
33859: 2671:    
33860: 2672:}
33861: 2673:```
33862: 2674:
33863: 2675:**flist** 的类型现在是 `List<? extends Fruit>`，你可以读作“一个具有任何从 **Fruit** 继承的类型的列表”。然而，这实际上并不意味着这个 **List** 将持有任何类型的 **Fruit**。通配符引用的是明确的类型，因此它意味着“某种 **flist** 引用没有指定的具体类型”。因此这个被赋值的 **List** 必须持有诸如 **Fruit** 或 **Apple** 这样的指定类型，但是为了向上转型为 **Fruit**，这个类型是什么没人在意。
33864: 2676:
33865: 2677:**List** 必须持有一种具体的 **Fruit** 或 **Fruit** 的子类型，但是如果你不关心具体的类型是什么，那么你能对这样的 **List** 做什么呢？如果不知道 **List** 中持有的对象是什么类型，你怎能保证安全地向其中添加对象呢？就像在 **CovariantArrays.java** 中向上转型一样，你不能，除非编译器而不是运行时系统可以阻止这种操作的发生。你很快就会发现这个问题。
33866: 2678:
33867: 2679:你可能认为事情开始变得有点走极端了，因为现在你甚至不能向刚刚声明过将持有 **Apple** 对象的 **List** 中放入一个 **Apple** 对象。是的，但编译器并不知道这一点。`List<? extends Fruit>` 可能合法地指向一个 `List<Orange>`。一旦执行这种类型的向上转型，你就丢失了向其中传递任何对象的能力，甚至传递 **Object** 也不行。
33868: 2680:
33869: 2681:另一方面，如果你调用了一个返回 **Fruit** 的方法，则是安全的，因为你知道这个 **List** 中的任何对象至少具有 **Fruit** 类型，因此编译器允许这么做。
33870: 2682:
33871: 2683:### 编译器有多聪明
33872: 2684:
33873: 2685:现在你可能会猜想自己不能去调用任何接受参数的方法，但是考虑下面的代码：
33874: 2686:
33875: 2687:```java
33876: 2688:// generics/CompilerIntelligence.java
33877: 2689:
33878: 2690:import java.util.*;
33879: 2691:
33880: 2692:public class CompilerIntelligence {
33881: 2693:    
33882: 2694:    public static void main(String[] args) {
33883: 2695:        List<? extends Fruit> flist = Arrays.asList(new Apple());
33884: 2696:        Apple a = (Apple) flist.get(0); // No warning
33885: 2697:        flist.contains(new Apple()); // Argument is 'Object'
33886: 2698:        flist.indexOf(new Apple()); // Argument is 'Object'
33887: 2699:    }
33888: 2700:    
33889: 2701:}
33890: 2702:```
33891: 2703:
33892: 2704:这里对 `contains()` 和 `indexOf()` 的调用接受 **Apple** 对象作为参数，执行没问题。这是否意味着编译器实际上会检查代码，以查看是否有某个特定的方法修改了它的对象？
33893: 2705:
33894: 2706:通过查看 **ArrayList** 的文档，我们发现编译器没有那么聪明。尽管 `add()` 接受一个泛型参数类型的参数，但 `contains()` 和 `indexOf()` 接受的参数类型是 **Object**。因此当你指定一个 `ArrayList<? extends Fruit>` 时，`add()` 的参数就变成了"**? extends Fruit**"。从这个描述中，编译器无法得知这里需要 **Fruit** 的哪个具体子类型，因此它不会接受任何类型的 **Fruit**。如果你先把 **Apple** 向上转型为 **Fruit**，也没有关系——编译器仅仅会拒绝调用像 `add()` 这样参数列表中涉及通配符的方法。
33895: 2707:
33896: 2708:`contains()` 和 `indexOf()` 的参数类型是 **Object**，不涉及通配符，所以编译器允许调用它们。这意味着将由泛型类的设计者来决定哪些调用是“安全的”，并使用 **Object** 类作为它们的参数类型。为了禁止对类型中使用了通配符的方法调用，需要在参数列表中使用类型参数。
33897: 2709:
33898: 2710:下面展示一个简单的 **Holder** 类：
33899: 2711:
33900: 2712:```java
33901: 2713:// generics/Holder.java
33902: 2714:
33903: 2715:public class Holder<T> {
33904: 2716:
33905: 2717:    private T value;
33906: 2718:
33907: 2719:    public Holder() {}
33908: 2720:
33909: 2721:    public Holder(T val) {
33910: 2722:        value = val;
33911: 2723:    }
33912: 2724:
33913: 2725:    public void set(T val) {
33914: 2726:        value = val;
33915: 2727:    }
33916: 2728:
33917: 2729:    public T get() {
33918: 2730:        return value;
33919: 2731:    }
33920: 2732:
33921: 2733:    @Override
33922: 2734:    public boolean equals(Object o) {
33923: 2735:        return o instanceof Holder && Objects.equals(value, ((Holder) o).value);
33924: 2736:    }
33925: 2737:
33926: 2738:    @Override
33927: 2739:    public int hashCode() {
33928: 2740:        return Objects.hashCode(value);
33929: 2741:    }
33930: 2742:
33931: 2743:    public static void main(String[] args) {
33932: 2744:        Holder<Apple> apple = new Holder<>(new Apple());
33933: 2745:        Apple d = apple.get();
33934: 2746:        apple.set(d);
33935: 2747:        // Holder<Fruit> fruit = apple; // Cannot upcast
33936: 2748:        Holder<? extends Fruit> fruit = apple; // OK
33937: 2749:        Fruit p = fruit.get();
33938: 2750:        d = (Apple) fruit.get();
33939: 2751:        try {
33940: 2752:            Orange c = (Orange) fruit.get(); // No warning
33941: 2753:        } catch (Exception e) {
33942: 2754:            System.out.println(e);
33943: 2755:        }
33944: 2756:        // fruit.set(new Apple()); // Cannot call set()
33945: 2757:        // fruit.set(new Fruit()); // Cannot call set()
33946: 2758:        System.out.println(fruit.equals(d)); // OK
33947: 2759:    }
33948: 2760:}
33949: 2761:/* Output
33950: 2762:java.lang.ClassCastException: Apple cannot be cast to Orange
33951: 2763:false
33952: 2764:*/
33953: 2765:```
33954: 2766:
33955: 2767:**Holder** 有一个接受 **T** 类型对象的 `set()` 方法，一个返回 T 对象的 `get()` 方法和一个接受 Object 对象的 `equals()` 方法。正如你所见，如果创建了一个 `Holder<Apple>`，就不能将其向上转型为 `Holder<Fruit>`，但是可以向上转型为 `Holder<? extends Fruit>`。如果调用 `get()`，只能返回一个 **Fruit**——这就是在给定“任何扩展自 **Fruit** 的对象”这一边界后，它所能知道的一切了。如果你知道更多的信息，就可以将其转型到某种具体的 **Fruit** 而不会导致任何警告，但是存在得到 **ClassCastException** 的风险。`set()` 方法不能工作在 **Apple** 和 **Fruit** 上，因为 `set()` 的参数也是"**? extends Fruit**"，意味着它可以是任何事物，编译器无法验证“任何事物”的类型安全性。
33956: 2768:
33957: 2769:但是，`equals()` 方法可以正常工作，因为它接受的参数是 **Object** 而不是 **T** 类型。因此，编译器只关注传递进来和要返回的对象类型。它不会分析代码，以查看是否执行了任何实际的写入和读取操作。
33958: 2770:
33959: 2771:Java 7 引入了 **java.util.Objects** 库，使创建 `equals()` 和 `hashCode()` 方法变得更加容易，当然还有很多其他功能。`equals()` 方法的标准形式参考 [附录：理解 equals 和 hashCode 方法](book/Appendix-Understanding-equals-and-hashCode) 一章。
33960: 2772:
33961: 2773:### 逆变
33962: 2774:
33963: 2775:还可以走另外一条路，即使用超类型通配符。这里，可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 `<？super MyClass>` ，或者甚至使用类型参数： `<？super T>`（尽管你不能对泛型参数给出一个超类型边界；即不能声明 `<T super MyClass>` ）。这使得你可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，就可以向 **Collection** 写入了：
33964: 2776:
33965: 2777:```java
33966: 2778:// generics/SuperTypeWildcards.java
33967: 2779:import java.util.*;
33968: 2780:public class SuperTypeWildcards {
33969: 2781:    static void writeTo(List<? super Apple> apples) {
33970: 2782:        apples.add(new Apple());
33971: 2783:        apples.add(new Jonathan());
33972: 2784:        // apples.add(new Fruit()); // Error
33973: 2785:    }
33974: 2786:}
33975: 2787:```
33976: 2788:
33977: 2789:参数 **apples** 是 **Apple** 的某种基类型的 **List**，这样你就知道向其中添加 **Apple** 或 **Apple** 的子类型是安全的。但是因为 **Apple** 是下界，所以你知道向这样的 **List** 中添加 **Fruit** 是不安全的，因为这将使这个 **List** 敞开口子，从而可以向其中添加非 **Apple** 类型的对象，而这是违反静态类型安全的。
33978: 2790:下面的示例复习了一下逆变和通配符的的使用：
33979: 2791:
33980: 2792:```java
33981: 2793:// generics/GenericReading.java
33982: 2794:import java.util.*;
33983: 2795:
33984: 2796:public class GenericReading {
33985: 2797:    static List<Apple> apples = Arrays.asList(new Apple());
33986: 2798:    static List<Fruit> fruit = Arrays.asList(new Fruit());
33987: 2799:    
33988: 2800:    static <T> T readExact(List<T> list) {
33989: 2801:        return list.get(0);
33990: 2802:    }
33991: 2803:    
33992: 2804:    // A static method adapts to each call:
33993: 2805:    static void f1() {
33994: 2806:        Apple a = readExact(apples);
33995: 2807:        Fruit f = readExact(fruit);
33996: 2808:        f = readExact(apples);
33997: 2809:    }
33998: 2810:    
33999: 2811:    // A class type is established
34000: 2812:    // when the class is instantiated:
34001: 2813:    static class Reader<T> {
34002: 2814:        T readExact(List<T> list) { 
34003: 2815:            return list.get(0); 
34004: 2816:        }
34005: 2817:    }
34006: 2818:    
34007: 2819:    static void f2() {
34008: 2820:        Reader<Fruit> fruitReader = new Reader<>();
34009: 2821:        Fruit f = fruitReader.readExact(fruit);
34010: 2822:        //- Fruit a = fruitReader.readExact(apples);
34011: 2823:        // error: incompatible types: List<Apple>
34012: 2824:        // cannot be converted to List<Fruit>
34013: 2825:    }
34014: 2826:    
34015: 2827:    static class CovariantReader<T> {
34016: 2828:        T readCovariant(List<? extends T> list) {
34017: 2829:            return list.get(0);
34018: 2830:        }
34019: 2831:    }
34020: 2832:    
34021: 2833:    static void f3() {
34022: 2834:        CovariantReader<Fruit> fruitReader = new CovariantReader<>();
34023: 2835:        Fruit f = fruitReader.readCovariant(fruit);
34024: 2836:        Fruit a = fruitReader.readCovariant(apples);
34025: 2837:    }
34026: 2838:    
34027: 2839:    public static void main(String[] args) {
34028: 2840:        f1(); 
34029: 2841:        f2(); 
34030: 2842:        f3();
34031: 2843:    }
34032: 2844:}
34033: 2845:```
34034: 2846:
34035: 2847:`readExact()` 方法使用了精确的类型。如果使用这个没有任何通配符的精确类型，就可以向 **List** 中写入和读取这个精确类型。另外，对于返回值，静态的泛型方法 `readExact()` 可以有效地“适应”每个方法调用，并能够从 `List<Apple>` 中返回一个 **Apple** ，从 `List<Fruit>` 中返回一个 **Fruit** ，就像在 `f1()` 中看到的那样。因此，如果可以摆脱静态泛型方法，那么在读取时就不需要协变类型了。
34036: 2848:然而对于泛型类来说，当你创建这个类的实例时，就要为这个类确定参数。就像在 `f2()` 中看到的，**fruitReader** 实例可以从 `List<Fruit>` 中读取一个 **Fruit** ，因为这就是它的确切类型。但是 `List<Apple>` 也应该产生 **Fruit** 对象，而 **fruitReader** 不允许这么做。
34037: 2849:为了修正这个问题，`CovariantReader.readCovariant()` 方法将接受 `List<？extends T>` ，因此，从这个列表中读取一个 **T** 是安全的（你知道在这个列表中的所有对象至少是一个 **T** ，并且可能是从 T 导出的某种对象）。在 `f3()` 中，你可以看到现在可以从 `List<Apple>` 中读取 **Fruit** 了。
34038: 2850:
34039: 2851:### 无界通配符
34040: 2852:
34041: 2853:无界通配符 `<?>` 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器初看起来是支持这种判断的：
34042: 2854:
34043: 2855:```java
34044: 2856:// generics/UnboundedWildcards1.java
34045: 2857:import java.util.*;
34046: 2858:
34047: 2859:public class UnboundedWildcards1 {
34048: 2860:    static List list1;
34049: 2861:    static List<?> list2;
34050: 2862:    static List<? extends Object> list3;
34051: 2863:  
34052: 2864:    static void assign1(List list) {
34053: 2865:        list1 = list;
34054: 2866:        list2 = list;
34055: 2867:        //- list3 = list;
34056: 2868:        // warning: [unchecked] unchecked conversion
34057: 2869:        // list3 = list;
34058: 2870:        //         ^
34059: 2871:        // required: List<? extends Object>
34060: 2872:        // found:    List
34061: 2873:    }
34062: 2874:    
34063: 2875:    static void assign2(List<?> list) {
34064: 2876:        list1 = list;
34065: 2877:        list2 = list;
34066: 2878:        list3 = list;
34067: 2879:    }
34068: 2880:    
34069: 2881:    static void assign3(List<? extends Object> list) {
34070: 2882:        list1 = list;
34071: 2883:        list2 = list;
34072: 2884:        list3 = list;
34073: 2885:    }
34074: 2886:    
34075: 2887:    public static void main(String[] args) {
34076: 2888:        assign1(new ArrayList());
34077: 2889:        assign2(new ArrayList());
34078: 2890:        //- assign3(new ArrayList());
34079: 2891:        // warning: [unchecked] unchecked method invocation:
34080: 2892:        // method assign3 in class UnboundedWildcards1
34081: 2893:        // is applied to given types
34082: 2894:        // assign3(new ArrayList());
34083: 2895:        //        ^
34084: 2896:        // required: List<? extends Object>
34085: 2897:        // found: ArrayList
34086: 2898:        // warning: [unchecked] unchecked conversion
34087: 2899:        // assign3(new ArrayList());
34088: 2900:        //         ^
34089: 2901:        // required: List<? extends Object>
34090: 2902:        // found:    ArrayList
34091: 2903:        // 2 warnings
34092: 2904:        assign1(new ArrayList<>());
34093: 2905:        assign2(new ArrayList<>());
34094: 2906:        assign3(new ArrayList<>());
34095: 2907:        // Both forms are acceptable as List<?>:
34096: 2908:        List<?> wildList = new ArrayList();
34097: 2909:        wildList = new ArrayList<>();
34098: 2910:        assign1(wildList);
34099: 2911:        assign2(wildList);
34100: 2912:        assign3(wildList);
34101: 2913:    }
34102: 2914:}
34103: 2915:```
34104: 2916:
34105: 2917:有很多情况都和你在这里看到的情况类似，即编译器很少关心使用的是原生类型还是 `<?>` 。在这些情况中，`<?>` 可以被认为是一种装饰，但是它仍旧是很有价值的，因为，实际上它是在声明：“我是想用 Java 的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型。”
34106: 2918:第二个示例展示了无界通配符的一个重要应用。当你在处理多个泛型参数时，有时允许一个参数可以是任何类型，同时为其他参数确定某种特定类型的这种能力会显得很重要：
34107: 2919:
34108: 2920:```java
34109: 2921:// generics/UnboundedWildcards2.java
34110: 2922:import java.util.*;
34111: 2923:
34112: 2924:public class UnboundedWildcards2 {
34113: 2925:    static Map map1;
34114: 2926:    static Map<?,?> map2;
34115: 2927:    static Map<String,?> map3;
34116: 2928:  
34117: 2929:    static void assign1(Map map) { 
34118: 2930:        map1 = map; 
34119: 2931:    }
34120: 2932:    
34121: 2933:    static void assign2(Map<?,?> map) { 
34122: 2934:        map2 = map; 
34123: 2935:    }
34124: 2936:    
34125: 2937:    static void assign3(Map<String,?> map) { 
34126: 2938:        map3 = map; 
34127: 2939:    }
34128: 2940:    
34129: 2941:    public static void main(String[] args) {
34130: 2942:        assign1(new HashMap());
34131: 2943:        assign2(new HashMap());
34132: 2944:        //- assign3(new HashMap());
34133: 2945:        // warning: [unchecked] unchecked method invocation:
34134: 2946:        // method assign3 in class UnboundedWildcards2
34135: 2947:        // is applied to given types
34136: 2948:        //     assign3(new HashMap());
34137: 2949:        //            ^
34138: 2950:        //   required: Map<String,?>
34139: 2951:        //   found: HashMap
34140: 2952:        // warning: [unchecked] unchecked conversion
34141: 2953:        //     assign3(new HashMap());
34142: 2954:        //             ^
34143: 2955:        //   required: Map<String,?>
34144: 2956:        //   found:    HashMap
34145: 2957:        // 2 warnings
34146: 2958:        assign1(new HashMap<>());
34147: 2959:        assign2(new HashMap<>());
34148: 2960:        assign3(new HashMap<>());
34149: 2961:    }
34150: 2962:}
34151: 2963:```
34152: 2964:
34153: 2965:但是，当你拥有的全都是无界通配符时，就像在 `Map<?,?>` 中看到的那样，编译器看起来就无法将其与原生 **Map** 区分开了。另外， **UnboundedWildcards1.java** 展示了编译器处理  `List<?>` 和 `List<? extends Object>` 是不同的。
34154: 2966:令人困惑的是，编译器并非总是关注像 `List` 和 `List<?>` 之间的这种差异，因此它们看起来就像是相同的事物。事实上，因为泛型参数擦除到它的第一个边界，因此 `List<?>` 看起来等价于 `List<Object>` ，而 **List** 实际上也是 `List<Object>` ——除非这些语句都不为真。**List** 实际上表示“持有任何 **Object** 类型的原生 **List** ”，而 `List<?>` 表示“具有某种特定类型的非原生 **List** ，只是我们不知道类型是什么。”
34155: 2967:编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？下面的示例使用了前面定义的 `Holder<T>` 类，它包含接受 **Holder** 作为参数的各种方法，但是它们具有不同的形式：作为原生类型，具有具体的类型参数以及具有无界通配符参数：
34156: 2968:
34157: 2969:```java
34158: 2970:// generics/Wildcards.java
34159: 2971:// Exploring the meaning of wildcards
34160: 2972:
34161: 2973:public class Wildcards {
34162: 2974:    // Raw argument:
34163: 2975:    static void rawArgs(Holder holder, Object arg) {
34164: 2976:        //- holder.set(arg);
34165: 2977:        // warning: [unchecked] unchecked call to set(T)
34166: 2978:        // as a member of the raw type Holder
34167: 2979:        //     holder.set(arg);
34168: 2980:        //               ^
34169: 2981:        //   where T is a type-variable:
34170: 2982:        //     T extends Object declared in class Holder
34171: 2983:        // 1 warning
34172: 2984:
34173: 2985:        // Can't do this; don't have any 'T':
34174: 2986:        // T t = holder.get();
34175: 2987:
34176: 2988:        // OK, but type information is lost:
34177: 2989:        Object obj = holder.get();
34178: 2990:    }
34179: 2991:    
34180: 2992:    // Like rawArgs(), but errors instead of warnings:
34181: 2993:    static void unboundedArg(Holder<?> holder, Object arg) {
34182: 2994:        //- holder.set(arg);
34183: 2995:        // error: method set in class Holder<T>
34184: 2996:        // cannot be applied to given types;
34185: 2997:        //     holder.set(arg);
34186: 2998:        //           ^
34187: 2999:        //   required: CAP#1
34188: 3000:        //   found: Object
34189: 3001:        //   reason: argument mismatch;
34190: 3002:        //     Object cannot be converted to CAP#1
34191: 3003:        //   where T is a type-variable:
34192: 3004:        //     T extends Object declared in class Holder
34193: 3005:        //   where CAP#1 is a fresh type-variable:
34194: 3006:        //     CAP#1 extends Object from capture of ?
34195: 3007:        // 1 error
34196: 3008:
34197: 3009:        // Can't do this; don't have any 'T':
34198: 3010:        // T t = holder.get();
34199: 3011:
34200: 3012:        // OK, but type information is lost:
34201: 3013:        Object obj = holder.get();
34202: 3014:    }
34203: 3015:    
34204: 3016:    static <T> T exact1(Holder<T> holder) {
34205: 3017:        return holder.get();
34206: 3018:    }
34207: 3019:    
34208: 3020:    static <T> T exact2(Holder<T> holder, T arg) {
34209: 3021:        holder.set(arg);
34210: 3022:        return holder.get();
34211: 3023:    }
34212: 3024:    
34213: 3025:    static <T> T wildSubtype(Holder<? extends T> holder, T arg) {
34214: 3026:        //- holder.set(arg);
34215: 3027:        // error: method set in class Holder<T#2>
34216: 3028:        // cannot be applied to given types;
34217: 3029:        //     holder.set(arg);
34218: 3030:        //           ^
34219: 3031:        //   required: CAP#1
34220: 3032:        //   found: T#1
34221: 3033:        //   reason: argument mismatch;
34222: 3034:        //     T#1 cannot be converted to CAP#1
34223: 3035:        //   where T#1,T#2 are type-variables:
34224: 3036:        //     T#1 extends Object declared in method
34225: 3037:        //     <T#1>wildSubtype(Holder<? extends T#1>,T#1)
34226: 3038:        //     T#2 extends Object declared in class Holder
34227: 3039:        //   where CAP#1 is a fresh type-variable:
34228: 3040:        //     CAP#1 extends T#1 from
34229: 3041:        //       capture of ? extends T#1
34230: 3042:        // 1 error
34231: 3043:        return holder.get();
34232: 3044:    }
34233: 3045:    
34234: 3046:    static <T> void wildSupertype(Holder<? super T> holder, T arg) {
34235: 3047:        holder.set(arg);
34236: 3048:        //- T t = holder.get();
34237: 3049:        // error: incompatible types:
34238: 3050:        // CAP#1 cannot be converted to T
34239: 3051:        //     T t = holder.get();
34240: 3052:        //                     ^
34241: 3053:        //   where T is a type-variable:
34242: 3054:        //     T extends Object declared in method
34243: 3055:        //       <T>wildSupertype(Holder<? super T>,T)
34244: 3056:        //   where CAP#1 is a fresh type-variable:
34245: 3057:        //     CAP#1 extends Object super:
34246: 3058:        //       T from capture of ? super T
34247: 3059:        // 1 error
34248: 3060:
34249: 3061:        // OK, but type information is lost:
34250: 3062:        Object obj = holder.get();
34251: 3063:    }
34252: 3064:    
34253: 3065:    public static void main(String[] args) {
34254: 3066:        Holder raw = new Holder<>();
34255: 3067:        // Or:
34256: 3068:        raw = new Holder();
34257: 3069:        Holder<Long> qualified = new Holder<>();
34258: 3070:        Holder<?> unbounded = new Holder<>();
34259: 3071:        Holder<? extends Long> bounded = new Holder<>();
34260: 3072:        Long lng = 1L;
34261: 3073:
34262: 3074:        rawArgs(raw, lng);
34263: 3075:        rawArgs(qualified, lng);
34264: 3076:        rawArgs(unbounded, lng);
34265: 3077:        rawArgs(bounded, lng);
34266: 3078:
34267: 3079:        unboundedArg(raw, lng);
34268: 3080:        unboundedArg(qualified, lng);
34269: 3081:        unboundedArg(unbounded, lng);
34270: 3082:        unboundedArg(bounded, lng);
34271: 3083:
34272: 3084:        //- Object r1 = exact1(raw);
34273: 3085:        // warning: [unchecked] unchecked method invocation:
34274: 3086:        // method exact1 in class Wildcards is applied
34275: 3087:        // to given types
34276: 3088:        //      Object r1 = exact1(raw);
34277: 3089:        //                        ^
34278: 3090:        //   required: Holder<T>
34279: 3091:        //   found: Holder
34280: 3092:        //   where T is a type-variable:
34281: 3093:        //     T extends Object declared in
34282: 3094:        //     method <T>exact1(Holder<T>)
34283: 3095:        // warning: [unchecked] unchecked conversion
34284: 3096:        //      Object r1 = exact1(raw);
34285: 3097:        //                         ^
34286: 3098:        //   required: Holder<T>
34287: 3099:        //   found:    Holder
34288: 3100:        //   where T is a type-variable:
34289: 3101:        //     T extends Object declared in
34290: 3102:        //     method <T>exact1(Holder<T>)
34291: 3103:        // 2 warnings
34292: 3104:
34293: 3105:        Long r2 = exact1(qualified);
34294: 3106:        Object r3 = exact1(unbounded); // Must return Object
34295: 3107:        Long r4 = exact1(bounded);
34296: 3108:
34297: 3109:        //- Long r5 = exact2(raw, lng);
34298: 3110:        // warning: [unchecked] unchecked method invocation:
34299: 3111:        // method exact2 in class Wildcards is
34300: 3112:        // applied to given types
34301: 3113:        //     Long r5 = exact2(raw, lng);
34302: 3114:        //                     ^
34303: 3115:        //   required: Holder<T>,T
34304: 3116:        //   found: Holder,Long
34305: 3117:        //   where T is a type-variable:
34306: 3118:        //     T extends Object declared in
34307: 3119:        //       method <T>exact2(Holder<T>,T)
34308: 3120:        // warning: [unchecked] unchecked conversion
34309: 3121:        //     Long r5 = exact2(raw, lng);
34310: 3122:        //                      ^
34311: 3123:        //   required: Holder<T>
34312: 3124:        //   found:    Holder
34313: 3125:        //   where T is a type-variable:
34314: 3126:        //     T extends Object declared in
34315: 3127:        //       method <T>exact2(Holder<T>,T)
34316: 3128:        // 2 warnings
34317: 3129:
34318: 3130:        Long r6 = exact2(qualified, lng);
34319: 3131:
34320: 3132:        //- Long r7 = exact2(unbounded, lng);
34321: 3133:        // error: method exact2 in class Wildcards
34322: 3134:        // cannot be applied to given types;
34323: 3135:        //     Long r7 = exact2(unbounded, lng);
34324: 3136:        //               ^
34325: 3137:        //   required: Holder<T>,T
34326: 3138:        //   found: Holder<CAP#1>,Long
34327: 3139:        //   reason: inference variable T has
34328: 3140:        //     incompatible bounds
34329: 3141:        //     equality constraints: CAP#1
34330: 3142:        //     lower bounds: Long
34331: 3143:        //   where T is a type-variable:
34332: 3144:        //     T extends Object declared in
34333: 3145:        //       method <T>exact2(Holder<T>,T)
34334: 3146:        //   where CAP#1 is a fresh type-variable:
34335: 3147:        //     CAP#1 extends Object from capture of ?
34336: 3148:        // 1 error
34337: 3149:
34338: 3150:        //- Long r8 = exact2(bounded, lng);
34339: 3151:        // error: method exact2 in class Wildcards
34340: 3152:        // cannot be applied to given types;
34341: 3153:        //      Long r8 = exact2(bounded, lng);
34342: 3154:        //                ^
34343: 3155:        //   required: Holder<T>,T
34344: 3156:        //   found: Holder<CAP#1>,Long
34345: 3157:        //   reason: inference variable T
34346: 3158:        //     has incompatible bounds
34347: 3159:        //     equality constraints: CAP#1
34348: 3160:        //     lower bounds: Long
34349: 3161:        //   where T is a type-variable:
34350: 3162:        //     T extends Object declared in
34351: 3163:        //       method <T>exact2(Holder<T>,T)
34352: 3164:        //   where CAP#1 is a fresh type-variable:
34353: 3165:        //     CAP#1 extends Long from
34354: 3166:        //       capture of ? extends Long
34355: 3167:        // 1 error
34356: 3168:
34357: 3169:        //- Long r9 = wildSubtype(raw, lng);
34358: 3170:        // warning: [unchecked] unchecked method invocation:
34359: 3171:        // method wildSubtype in class Wildcards
34360: 3172:        // is applied to given types
34361: 3173:        //     Long r9 = wildSubtype(raw, lng);
34362: 3174:        //                          ^
34363: 3175:        //   required: Holder<? extends T>,T
34364: 3176:        //   found: Holder,Long
34365: 3177:        //   where T is a type-variable:
34366: 3178:        //     T extends Object declared in
34367: 3179:        //     method <T>wildSubtype(Holder<? extends T>,T)
34368: 3180:        // warning: [unchecked] unchecked conversion
34369: 3181:        //     Long r9 = wildSubtype(raw, lng);
34370: 3182:        //                           ^
34371: 3183:        //   required: Holder<? extends T>
34372: 3184:        //   found:    Holder
34373: 3185:        //   where T is a type-variable:
34374: 3186:        //     T extends Object declared in
34375: 3187:        //     method <T>wildSubtype(Holder<? extends T>,T)
34376: 3188:        // 2 warnings
34377: 3189:
34378: 3190:        Long r10 = wildSubtype(qualified, lng);
34379: 3191:        // OK, but can only return Object:
34380: 3192:        Object r11 = wildSubtype(unbounded, lng);
34381: 3193:        Long r12 = wildSubtype(bounded, lng);
34382: 3194:
34383: 3195:        //- wildSupertype(raw, lng);
34384: 3196:        // warning: [unchecked] unchecked method invocation:
34385: 3197:        //   method wildSupertype in class Wildcards
34386: 3198:        //   is applied to given types
34387: 3199:        //     wildSupertype(raw, lng);
34388: 3200:        //                  ^
34389: 3201:        //   required: Holder<? super T>,T
34390: 3202:        //   found: Holder,Long
34391: 3203:        //   where T is a type-variable:
34392: 3204:        //     T extends Object declared in
34393: 3205:        //     method <T>wildSupertype(Holder<? super T>,T)
34394: 3206:        // warning: [unchecked] unchecked conversion
34395: 3207:        //     wildSupertype(raw, lng);
34396: 3208:        //                   ^
34397: 3209:        //   required: Holder<? super T>
34398: 3210:        //   found:    Holder
34399: 3211:        //   where T is a type-variable:
34400: 3212:        //     T extends Object declared in
34401: 3213:        //     method <T>wildSupertype(Holder<? super T>,T)
34402: 3214:        // 2 warnings
34403: 3215:
34404: 3216:        wildSupertype(qualified, lng);
34405: 3217:
34406: 3218:        //- wildSupertype(unbounded, lng);
34407: 3219:        // error: method wildSupertype in class Wildcards
34408: 3220:        // cannot be applied to given types;
34409: 3221:        //     wildSupertype(unbounded, lng);
34410: 3222:        //     ^
34411: 3223:        //   required: Holder<? super T>,T
34412: 3224:        //   found: Holder<CAP#1>,Long
34413: 3225:        //   reason: cannot infer type-variable(s) T
34414: 3226:        //     (argument mismatch; Holder<CAP#1>
34415: 3227:        //     cannot be converted to Holder<? super T>)
34416: 3228:        //   where T is a type-variable:
34417: 3229:        //     T extends Object declared in
34418: 3230:        //     method <T>wildSupertype(Holder<? super T>,T)
34419: 3231:        //   where CAP#1 is a fresh type-variable:
34420: 3232:        //     CAP#1 extends Object from capture of ?
34421: 3233:        // 1 error
34422: 3234:
34423: 3235:        //- wildSupertype(bounded, lng);
34424: 3236:        // error: method wildSupertype in class Wildcards
34425: 3237:        // cannot be applied to given types;
34426: 3238:        //     wildSupertype(bounded, lng);
34427: 3239:        //     ^
34428: 3240:        //   required: Holder<? super T>,T
34429: 3241:        //   found: Holder<CAP#1>,Long
34430: 3242:        //   reason: cannot infer type-variable(s) T
34431: 3243:        //     (argument mismatch; Holder<CAP#1>
34432: 3244:        //     cannot be converted to Holder<? super T>)
34433: 3245:        //   where T is a type-variable:
34434: 3246:        //     T extends Object declared in
34435: 3247:        //     method <T>wildSupertype(Holder<? super T>,T)
34436: 3248:        //   where CAP#1 is a fresh type-variable:
34437: 3249:        //     CAP#1 extends Long from capture of
34438: 3250:        //     ? extends Long
34439: 3251:        // 1 error
34440: 3252:    }
34441: 3253:}
34442: 3254:```
34443: 3255:
34444: 3256:在 `rawArgs()` 中，编译器知道 `Holder` 是一个泛型类型，因此即使它在这里被表示成一个原生类型，编译器仍旧知道向 `set()` 传递一个 **Object** 是不安全的。由于它是原生类型，你可以将任何类型的对象传递给 `set()` ，而这个对象将被向上转型为 **Object** 。因此无论何时，只要使用了原生类型，都会放弃编译期检查。对 `get()` 的调用说明了相同的问题：没有任何 **T** 类型的对象，因此结果只能是一个 **Object**。
34445: 3257:人们很自然地会开始考虑原生 `Holder` 与 `Holder<?>` 是大致相同的事物。但是 `unboundedArg()` 强调它们是不同的——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，因为原生 **Holder** 将持有任何类型的组合，而 `Holder<?>` 将持有具有某种具体类型的同构集合，因此不能只是向其中传递 **Object** 。
34446: 3258:在 `exact1()` 和 `exact2()` 中，你可以看到使用了确切的泛型参数——没有任何通配符。你将看到，`exact2()`与 `exact1()` 具有不同的限制，因为它有额外的参数。
34447: 3259:在 `wildSubtype()` 中，在 **Holder** 类型上的限制被放松为包括持有任何扩展自 **T** 的对象的 **Holder** 。这还是意味着如果 T 是 **Fruit** ，那么 `holder` 可以是 `Holder<Apple>` ，这是合法的。为了防止将 **Orange** 放置到 `Holder<Apple>` 中，对 `set()` 的调用（或者对任何接受这个类型参数为参数的方法的调用）都是不允许的。但是，你仍旧知道任何来自 `Holder<？extends Fruit>` 的对象至少是 **Fruit** ，因此 `get()` （或者任何将产生具有这个类型参数的返回值的方法）都是允许的。
34448: 3260:`wildSupertype()` 展示了超类型通配符，这个方法展示了与 `wildSubtype()` 相反的行为：`holder` 可以是持有任何 T 的基类型的容器。因此， `set()` 可以接受 **T** ，因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是 **T** ）。但是，尝试着调用 `get()` 是没有用的，因为由 `holder` 持有的类型可以是任何超类型，因此唯一安全的类型就是 **Object** 。
34449: 3261:这个示例还展示了对于在 `unbounded()` 中使用无界通配符能够做什么不能做什么所做出的限制：因为你没有 **T**，所以你不能将 `set()` 或 `get()` 作用于 **T** 上。
34450: 3262:
34451: 3263:在 `main()` 方法中你看到了某些方法在接受某些类型的参数时没有报错和警告。为了迁移兼容性，`rawArgs()`  将接受所有 **Holder** 的不同变体，而不会产生警告。`unboundedArg()` 方法也可以接受相同的所有类型，尽管如前所述，它在方法体内部处理这些类型的方式并不相同。
34452: 3264:
34453: 3265:如果向接受“确切”泛型类型（没有通配符）的方法传递一个原生 **Holder** 引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息。如果向 `exact1()` 传递一个无界引用，就不会有任何可以确定返回类型的类型信息。
34454: 3266:可以看到，`exact2()` 具有最多的限制，因为它希望精确地得到一个 `Holder<T>` ，以及一个具有类型 **T** 的参数，正由于此，它将产生错误或警告，除非提供确切的参数。有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决于是否想要从泛型参数中返回类型确定的返回值（就像在 `wildSubtype()` 中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在 `wildSupertype()` 中看到的那样）。
34455: 3267:因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合你的需求的方法。
34456: 3268:
34457: 3269:### 捕获转换
34458: 3270:
34459: 3271:有一种特殊情况需要使用 `<?>` 而不是原生类型。如果向一个使用 `<?>` 的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。下面的示例演示了这种技术，它被称为捕获转换，因为未指定的通配符类型被捕获，并被转换为确切类型。这里，有关警告的注释只有在 `@SuppressWarnings` 注解被移除之后才能起作用：
34460: 3272:
34461: 3273:```java
34462: 3274:// generics/CaptureConversion.java
34463: 3275:
34464: 3276:public class CaptureConversion {
34465: 3277:    static <T> void f1(Holder<T> holder) {
34466: 3278:        T t = holder.get();
34467: 3279:        System.out.println(t.getClass().getSimpleName());
34468: 3280:    }
34469: 3281:  
34470: 3282:    static void f2(Holder<?> holder) {
34471: 3283:        f1(holder); // Call with captured type
34472: 3284:    }
34473: 3285:    
34474: 3286:    @SuppressWarnings("unchecked")
34475: 3287:    public static void main(String[] args) {
34476: 3288:        Holder raw = new Holder<>(1);
34477: 3289:        f1(raw);
34478: 3290:        // warning: [unchecked] unchecked method invocation:
34479: 3291:        // method f1 in class CaptureConversion
34480: 3292:        // is applied to given types
34481: 3293:        //     f1(raw);
34482: 3294:        //       ^
34483: 3295:        //   required: Holder<T>
34484: 3296:        //   found: Holder
34485: 3297:        //   where T is a type-variable:
34486: 3298:        //     T extends Object declared in
34487: 3299:        //     method <T>f1(Holder<T>)
34488: 3300:        // warning: [unchecked] unchecked conversion
34489: 3301:        //     f1(raw);
34490: 3302:        //        ^
34491: 3303:        //   required: Holder<T>
34492: 3304:        //   found:    Holder
34493: 3305:        //   where T is a type-variable:
34494: 3306:        //     T extends Object declared in
34495: 3307:        //     method <T>f1(Holder<T>)
34496: 3308:        // 2 warnings
34497: 3309:        f2(raw); // No warnings
34498: 3310:        
34499: 3311:        Holder rawBasic = new Holder();
34500: 3312:        rawBasic.set(new Object());
34501: 3313:        // warning: [unchecked] unchecked call to set(T)
34502: 3314:        // as a member of the raw type Holder
34503: 3315:        //     rawBasic.set(new Object());
34504: 3316:        //                 ^
34505: 3317:        //   where T is a type-variable:
34506: 3318:        //     T extends Object declared in class Holder
34507: 3319:        // 1 warning
34508: 3320:        f2(rawBasic); // No warnings
34509: 3321:        
34510: 3322:        // Upcast to Holder<?>, still figures it out:
34511: 3323:        Holder<?> wildcarded = new Holder<>(1.0);
34512: 3324:        f2(wildcarded);
34513: 3325:    }
34514: 3326:}
34515: 3327:/* Output:
34516: 3328:Integer
34517: 3329:Integer
34518: 3330:Object
34519: 3331:Double
34520: 3332:*/
34521: 3333:```
34522: 3334:
34523: 3335:`f1()` 中的类型参数都是确切的，没有通配符或边界。在 `f2()` 中，**Holder** 参数是一个无界通配符，因此它看起来是未知的。但是，在 `f2()` 中调用了 `f1()`，而 `f1()` 需要一个已知参数。这里所发生的是：在调用 `f2()` 的过程中捕获了参数类型，并在调用 `f1()` 时使用了这种类型。
34524: 3336:你可能想知道这项技术是否可以用于写入，但是这要求在传递 `Holder<?>` 时同时传递一个具体类型。捕获转换只有在这样的情况下可以工作：即在方法内部，你需要使用确切的类型。注意，不能从 `f2()` 中返回 **T**，因为 **T** 对于 `f2()` 来说是未知的。捕获转换十分有趣，但是非常受限。
34525: 3337:
34526: 3338:<!-- Issues -->
34527: 3339:
34528: 3340:## 问题
34529: 3341:
34530: 3342:本节将阐述在使用 Java 泛型时会出现的各类问题。
34531: 3343:
34532: 3344:### 任何基本类型都不能作为类型参数
34533: 3345:
34534: 3346:正如本章早先提到的，Java 泛型的限制之一是不能将基本类型用作类型参数。因此，不能创建  `ArrayList<int>` 之类的东西。
34535: 3347:解决方法是使用基本类型的包装器类以及自动装箱机制。如果创建一个 `ArrayList<Integer>`，并将基本类型 **int** 应用于这个集合，那么你将发现自动装箱机制将自动地实现 **int** 到 **Integer** 的双向转换——因此，这几乎就像是有一个 `ArrayList<int>` 一样：
34536: 3348:
34537: 3349:```java
34538: 3350:// generics/ListOfInt.java
34539: 3351:// Autoboxing compensates for the inability
34540: 3352:// to use primitives in generics
34541: 3353:import java.util.*;
34542: 3354:import java.util.stream.*;
34543: 3355:
34544: 3356:public class ListOfInt {
34545: 3357:    public static void main(String[] args) {
34546: 3358:        List<Integer> li = IntStream.range(38, 48)
34547: 3359:            .boxed() // Converts ints to Integers
34548: 3360:            .collect(Collectors.toList());
34549: 3361:        System.out.println(li);
34550: 3362:    }
34551: 3363:}
34552: 3364:/* Output:
34553: 3365:[38, 39, 40, 41, 42, 43, 44, 45, 46, 47]
34554: 3366:*/
34555: 3367:```
34556: 3368:
34557: 3369:通常，这种解决方案工作得很好——能够成功地存储和读取 **int**，自动装箱隐藏了转换的过程。但是如果性能成为问题的话，就需要使用专门为基本类型适配的特殊版本的集合；一个开源版本的实现是 **org.apache.commons.collections.primitives**。
34558: 3370:下面是另外一种方式，它可以创建持有 **Byte** 的 **Set**：
34559: 3371:
34560: 3372:```java
34561: 3373:// generics/ByteSet.java
34562: 3374:import java.util.*;
34563: 3375:
34564: 3376:public class ByteSet {
34565: 3377:    Byte[] possibles = { 1,2,3,4,5,6,7,8,9 };
34566: 3378:    Set<Byte> mySet = new HashSet<>(Arrays.asList(possibles));
34567: 3379:    // But you can't do this:
34568: 3380:    // Set<Byte> mySet2 = new HashSet<>(
34569: 3381:    // Arrays.<Byte>asList(1,2,3,4,5,6,7,8,9));
34570: 3382:}
34571: 3383:```
34572: 3384:
34573: 3385:自动装箱机制解决了一些问题，但并没有解决所有问题。
34574: 3386:
34575: 3387:在下面的示例中，**FillArray** 接口包含一些通用方法，这些方法使用 **Supplier** 来用对象填充数组（这使得类泛型在本例中无法工作，因为这个方法是静态的）。**Supplier** 实现来自 [数组](book/21-Arrays.md) 一章,并且在 `main()` 中，可以看到 `FillArray.fill()` 使用对象填充了数组：
34576: 3388:
34577: 3389:```java
34578: 3390:// generics/PrimitiveGenericTest.java
34579: 3391:import onjava.*;
34580: 3392:import java.util.*;
34581: 3393:import java.util.function.*;
34582: 3394:
34583: 3395:// Fill an array using a generator:
34584: 3396:interface FillArray {
34585: 3397:    static <T> T[] fill(T[] a, Supplier<T> gen) {
34586: 3398:        Arrays.setAll(a, n -> gen.get());
34587: 3399:        return a;
34588: 3400:    }
34589: 3401:    
34590: 3402:    static int[] fill(int[] a, IntSupplier gen) {
34591: 3403:        Arrays.setAll(a, n -> gen.getAsInt());
34592: 3404:        return a;
34593: 3405:    }
34594: 3406:    
34595: 3407:    static long[] fill(long[] a, LongSupplier gen) {
34596: 3408:        Arrays.setAll(a, n -> gen.getAsLong());
34597: 3409:        return a;
34598: 3410:    }
34599: 3411:    
34600: 3412:    static double[] fill(double[] a, DoubleSupplier gen) {
34601: 3413:        Arrays.setAll(a, n -> gen.getAsDouble());
34602: 3414:        return a;
34603: 3415:    }
34604: 3416:}
34605: 3417:
34606: 3418:public class PrimitiveGenericTest {
34607: 3419:    public static void main(String[] args) {
34608: 3420:        String[] strings = FillArray.fill(
34609: 3421:            new String[5], new Rand.String(9));
34610: 3422:        System.out.println(Arrays.toString(strings));
34611: 3423:        int[] integers = FillArray.fill(
34612: 3424:            new int[9], new Rand.Pint());
34613: 3425:        System.out.println(Arrays.toString(integers));
34614: 3426:    }
34615: 3427:}
34616: 3428:/* Output:
34617: 3429:[btpenpccu, xszgvgmei, nneeloztd, vewcippcy, gpoalkljl]
34618: 3430:[635, 8737, 3941, 4720, 6177, 8479, 6656, 3768, 4948]
34619: 3431:*/
34620: 3432:```
34621: 3433:
34622: 3434:自动装箱不适用于数组，因此我们必须创建 `FillArray.fill()` 的重载版本，或创建产生 **Wrapped** 输出的生成器。 **FillArray** 仅比 `java.util.Arrays.setAll()` 有用一点，因为它返回填充的数组。
34623: 3435:
34624: 3436:### 实现参数化接口
34625: 3437:
34626: 3438:一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。下面是产生这种冲突的情况：
34627: 3439:
34628: 3440:```java
34629: 3441:// generics/MultipleInterfaceVariants.java
34630: 3442:// {WillNotCompile}
34631: 3443:package generics;
34632: 3444:
34633: 3445:interface Payable<T> {}
34634: 3446:
34635: 3447:class Employee implements Payable<Employee> {}
34636: 3448:
34637: 3449:class Hourly extends Employee implements Payable<Hourly> {}
34638: 3450:```
34639: 3451:
34640: 3452:**Hourly** 不能编译，因为擦除会将  `Payable<Employe>` 和 `Payable<Hourly>` 简化为相同的类 **Payable**，这样，上面的代码就意味着在重复两次地实现相同的接口。十分有趣的是，如果从 **Payable** 的两种用法中都移除掉泛型参数（就像编译器在擦除阶段所做的那样）这段代码就可以编译。
34641: 3453:
34642: 3454:在使用某些更基本的 Java 接口，例如 `Comparable<T>` 时，这个问题可能会变得十分令人恼火，就像你在本节稍后看到的那样。
34643: 3455:
34644: 3456:### 转型和警告
34645: 3457:
34646: 3458:使用带有泛型类型参数的转型或 **instanceof** 不会有任何效果。下面的集合在内部将各个值存储为 **Object**，并在获取这些值时，再将它们转型回 **T**：
34647: 3459:
34648: 3460:```java
34649: 3461:// generics/GenericCast.java
34650: 3462:import java.util.*;
34651: 3463:import java.util.stream.*;
34652: 3464:
34653: 3465:class FixedSizeStack<T> {
34654: 3466:    private final int size;
34655: 3467:    private Object[] storage;
34656: 3468:    private int index = 0;
34657: 3469:    
34658: 3470:    FixedSizeStack(int size) {
34659: 3471:        this.size = size;
34660: 3472:        storage = new Object[size];
34661: 3473:    }
34662: 3474:    
34663: 3475:    public void push(T item) {
34664: 3476:        if(index < size)
34665: 3477:            storage[index++] = item;
34666: 3478:    }
34667: 3479:    
34668: 3480:    @SuppressWarnings("unchecked")
34669: 3481:    public T pop() {
34670: 3482:        return index == 0 ? null : (T)storage[--index];
34671: 3483:    }
34672: 3484:    
34673: 3485:    @SuppressWarnings("unchecked")
34674: 3486:    Stream<T> stream() {
34675: 3487:        return (Stream<T>)Arrays.stream(storage);
34676: 3488:    }
34677: 3489:}
34678: 3490:
34679: 3491:public class GenericCast {
34680: 3492:    static String[] letters = "ABCDEFGHIJKLMNOPQRS".split("");
34681: 3493:  
34682: 3494:    public static void main(String[] args) {
34683: 3495:        FixedSizeStack<String> strings =
34684: 3496:            new FixedSizeStack<>(letters.length);
34685: 3497:        Arrays.stream("ABCDEFGHIJKLMNOPQRS".split(""))
34686: 3498:            .forEach(strings::push);
34687: 3499:        System.out.println(strings.pop());
34688: 3500:        strings.stream()
34689: 3501:            .map(s -> s + " ")
34690: 3502:            .forEach(System.out::print);
34691: 3503:    }
34692: 3504:}
34693: 3505:/* Output:
34694: 3506:S
34695: 3507:A B C D E F G H I J K L M N O P Q R S
34696: 3508:*/
34697: 3509:```
34698: 3510:
34699: 3511:如果没有 **@SuppressWarnings** 注解，编译器将对 `pop()` 产生 “unchecked cast” 警告。由于擦除的原因，编译器无法知道这个转型是否是安全的，并且 `pop()` 方法实际上并没有执行任何转型。
34700: 3512:这是因为，**T** 被擦除到它的第一个边界，默认情况下是 **Object** ，因此 `pop()` 实际上只是将 **Object** 转型为 **Object**。
34701: 3513:有时，泛型没有消除对转型的需要，这就会由编译器产生警告，而这个警告是不恰当的。例如：
34702: 3514:
34703: 3515:```java
34704: 3516:// generics/NeedCasting.java
34705: 3517:import java.io.*;
34706: 3518:import java.util.*;
34707: 3519:
34708: 3520:public class NeedCasting {
34709: 3521:    @SuppressWarnings("unchecked")
34710: 3522:    public void f(String[] args) throws Exception {
34711: 3523:        ObjectInputStream in = new ObjectInputStream(
34712: 3524:            new FileInputStream(args[0]));
34713: 3525:        List<Widget> shapes = (List<Widget>)in.readObject();
34714: 3526:    }
34715: 3527:}
34716: 3528:```
34717: 3529:
34718: 3530:正如你将在 [附录：对象序列化](book/Appendix-Object-Serialization.md) 中学到的那样，`readObject()` 无法知道它正在读取的是什么，因此它返回的是必须转型的对象。但是当注释掉 **@SuppressWarnings** 注解并编译这个程序时，就会得到下面的警告。
34719: 3531:
34720: 3532:```
34721: 3533:NeedCasting.java uses unchecked or unsafe operations.
34722: 3534:Recompile with -Xlint:unchecked for details.
34723: 3535:
34724: 3536:And if you follow the instructions and recompile with  -
34725: 3537:Xlint:unchecked :(如果遵循这条指示，使用-Xlint:unchecked来重新编译：)
34726: 3538:
34727: 3539:NeedCasting.java:10: warning: [unchecked] unchecked cast
34728: 3540:    List<Widget> shapes = (List<Widget>)in.readObject();
34729: 3541:    required: List<Widget>
34730: 3542:    found: Object
34731: 3543:1 warning
34732: 3544:```
34733: 3545:
34734: 3546:你会被强制要求转型，但是又被告知不应该转型。为了解决这个问题，必须使用 Java 5 引入的新的转型形式，即通过泛型类来转型：
34735: 3547:
34736: 3548:```java
34737: 3549:// generics/ClassCasting.java
34738: 3550:import java.io.*;
34739: 3551:import java.util.*;
34740: 3552:
34741: 3553:public class ClassCasting {
34742: 3554:    @SuppressWarnings("unchecked")
34743: 3555:    public void f(String[] args) throws Exception {
34744: 3556:        ObjectInputStream in = new ObjectInputStream(
34745: 3557:            new FileInputStream(args[0]));
34746: 3558:        // Won't Compile:
34747: 3559:        //    List<Widget> lw1 =
34748: 3560:        //    List<>.class.cast(in.readObject());
34749: 3561:        List<Widget> lw2 = List.class.cast(in.readObject());
34750: 3562:    }
34751: 3563:}
34752: 3564:```
34753: 3565:
34754: 3566:但是，不能转型到实际类型（ `List<Widget>` ）。也就是说，不能声明：
34755: 3567:
34756: 3568:```
34757: 3569:List<Widget>.class.cast(in.readobject())
34758: 3570:```
34759: 3571:
34760: 3572:甚至当你添加一个像下面这样的另一个转型时：
34761: 3573:
34762: 3574:```
34763: 3575:(List<Widget>)List.class.cast(in.readobject())
34764: 3576:```
34765: 3577:
34766: 3578:仍旧会得到一个警告。
34767: 3579:
34768: 3580:### 重载
34769: 3581:
34770: 3582:下面的程序是不能编译的，即使它看起来是合理的：
34771: 3583:
34772: 3584:```java
34773: 3585:// generics/UseList.java
34774: 3586:// {WillNotCompile}
34775: 3587:import java.util.*;
34776: 3588:
34777: 3589:public class UseList<W, T> {
34778: 3590:    void f(List<T> v) {}
34779: 3591:    void f(List<W> v) {}
34780: 3592:}
34781: 3593:```
34782: 3594:
34783: 3595:因为擦除，所以重载方法产生了相同的类型签名。
34784: 3596:
34785: 3597:因而，当擦除后的参数不能产生唯一的参数列表时，你必须提供不同的方法名：
34786: 3598:
34787: 3599:```java
34788: 3600:// generics/UseList2.java
34789: 3601:
34790: 3602:import java.util.*;
34791: 3603:
34792: 3604:public class UseList2<W, T> {
34793: 3605:    void f1(List<T> v) {}
34794: 3606:    void f2(List<W> v) {}
34795: 3607:}
34796: 3608:```
34797: 3609:
34798: 3610:幸运的是，编译器可以检测到这类问题。
34799: 3611:
34800: 3612:### 基类劫持接口
34801: 3613:
34802: 3614:假设你有一个实现了 **Comparable** 接口的 **Pet** 类：
34803: 3615:
34804: 3616:```java
34805: 3617:// generics/ComparablePet.java
34806: 3618:
34807: 3619:public class ComparablePet implements Comparable<ComparablePet> {
34808: 3620:    @Override
34809: 3621:    public int compareTo(ComparablePet o) {
34810: 3622:        return 0;
34811: 3623:    }
34812: 3624:}
34813: 3625:```
34814: 3626:
34815: 3627:尝试缩小 **ComparablePet** 子类的比较类型是有意义的。例如，**Cat** 类可以与其他的 **Cat** 比较：
34816: 3628:
34817: 3629:```java
34818: 3630:// generics/HijackedInterface.java
34819: 3631:// {WillNotCompile}
34820: 3632:
34821: 3633:class Cat extends ComparablePet implements Comparable<Cat> {
34822: 3634:    // error: Comparable cannot be inherited with
34823: 3635:    // different arguments: <Cat> and <ComparablePet>
34824: 3636:    // class Cat
34825: 3637:    // ^
34826: 3638:    // 1 error
34827: 3639:    public int compareTo(Cat arg) {
34828: 3640:        return 0;
34829: 3641:    }
34830: 3642:}
34831: 3643:```
34832: 3644:
34833: 3645:不幸的是，这不能工作。一旦 **Comparable** 的类型参数设置为 **ComparablePet**，其他的实现类只能比较 **ComparablePet**：
34834: 3646:
34835: 3647:```java
34836: 3648:// generics/RestrictedComparablePets.java
34837: 3649:
34838: 3650:public class Hamster extends ComparablePet implements Comparable<ComparablePet> {
34839: 3651:
34840: 3652:    @Override
34841: 3653:    public int compareTo(ComparablePet arg) {
34842: 3654:        return 0;
34843: 3655:    }
34844: 3656:}
34845: 3657:// Or just:
34846: 3658:class Gecko extends ComparablePet {
34847: 3659:    public int compareTo(ComparablePet arg) {
34848: 3660:        return 0;
34849: 3661:    }
34850: 3662:}
34851: 3663:```
34852: 3664:
34853: 3665:**Hamster** 显示了重新实现 **ComparablePet** 中相同的接口是可能的，只要接口完全相同，包括参数类型。然而正如 **Gecko** 中所示，这与直接覆写基类的方法完全相同。
34854: 3666:
34855: 3667:<!-- Self-Bounded Types -->
34856: 3668:
34857: 3669:## 自限定的类型
34858: 3670:
34859: 3671:在 Java 泛型中，有一个似乎经常性出现的惯用法，它相当令人费解：
34860: 3672:
34861: 3673:```java
34862: 3674:class SelfBounded<T extends SelfBounded<T>> { // ...
34863: 3675:```
34864: 3676:
34865: 3677:这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。**SelfBounded** 类接受泛型参数 **T**，而 **T** 由一个边界类限定，这个边界就是拥有 **T** 作为其参数的 **SelfBounded**。
34866: 3678:
34867: 3679:当你首次看到它时，很难去解析它，它强调的是当 **extends** 关键字用于边界与用来创建子类明显是不同的。
34868: 3680:
34869: 3681:### 古怪的循环泛型
34870: 3682:
34871: 3683:为了理解自限定类型的含义，我们从这个惯用法的一个简单版本入手，它没有自限定的边界。
34872: 3684:
34873: 3685:不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类。也就是说，可以声明：
34874: 3686:
34875: 3687:```java
34876: 3688:// generics/CuriouslyRecurringGeneric.java
34877: 3689:
34878: 3690:class GenericType<T> {}
34879: 3691:
34880: 3692:public class CuriouslyRecurringGeneric
34881: 3693:  extends GenericType<CuriouslyRecurringGeneric> {}
34882: 3694:```
34883: 3695:
34884: 3696:这可以按照 Jim Coplien 在 C++ 中的*古怪的循环模版模式*的命名方式，称为古怪的循环泛型（CRG）。“古怪的循环”是指类相当古怪地出现在它自己的基类中这一事实。
34885: 3697:为了理解其含义，努力大声说：“我在创建一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为其参数。”当给出导出类的名字时，这个泛型基类能够实现什么呢？好吧，Java 中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为其参数和返回类型的基类。它还能将导出类型用作其域类型，尽管这些将被擦除为 **Object** 的类型。下面是表示了这种情况的一个泛型类：
34886: 3698:
34887: 3699:```java
34888: 3700:// generics/BasicHolder.java
34889: 3701:
34890: 3702:public class BasicHolder<T> {
34891: 3703:    T element;
34892: 3704:    void set(T arg) { element = arg; }
34893: 3705:    T get() { return element; }
34894: 3706:    void f() {
34895: 3707:        System.out.println(element.getClass().getSimpleName());
34896: 3708:    }
34897: 3709:}
34898: 3710:```
34899: 3711:
34900: 3712:这是一个普通的泛型类型，它的一些方法将接受和产生具有其参数类型的对象，还有一个方法在其存储的域上执行操作（尽管只是在这个域上执行 **Object** 操作）。
34901: 3713:我们可以在一个古怪的循环泛型中使用 **BasicHolder**：
34902: 3714:
34903: 3715:```java
34904: 3716:// generics/CRGWithBasicHolder.java
34905: 3717:
34906: 3718:class Subtype extends BasicHolder<Subtype> {}
34907: 3719:
34908: 3720:public class CRGWithBasicHolder {
34909: 3721:    public static void main(String[] args) {
34910: 3722:        Subtype st1 = new Subtype(), st2 = new Subtype();
34911: 3723:        st1.set(st2);
34912: 3724:        Subtype st3 = st1.get();
34913: 3725:        st1.f();
34914: 3726:    }
34915: 3727:}
34916: 3728:/* Output:
34917: 3729:Subtype
34918: 3730:*/
34919: 3731:```
34920: 3732:
34921: 3733:注意，这里有些东西很重要：新类 **Subtype** 接受的参数和返回的值具有 **Subtype** 类型而不仅仅是基类 **BasicHolder** 类型。这就是 CRG 的本质：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型。也就是说，在所产生的类中将使用确切类型而不是基类型。因此，在**Subtype** 中，传递给 `set()` 的参数和从 `get()` 返回的类型都是确切的 **Subtype**。
34922: 3734:
34923: 3735:### 自限定
34924: 3736:
34925: 3737:**BasicHolder** 可以使用任何类型作为其泛型参数，就像下面看到的那样：
34926: 3738:
34927: 3739:```java
34928: 3740:// generics/Unconstrained.java
34929: 3741:// (c)2017 MindView LLC: see Copyright.txt
34930: 3742:// We make no guarantees that this code is fit for any purpose.
34931: 3743:// Visit http://OnJava8.com for more book information.
34932: 3744:
34933: 3745:class Other {}
34934: 3746:class BasicOther extends BasicHolder<Other> {}
34935: 3747:
34936: 3748:public class Unconstrained {
34937: 3749:    public static void main(String[] args) {
34938: 3750:        BasicOther b = new BasicOther();
34939: 3751:        BasicOther b2 = new BasicOther();
34940: 3752:        b.set(new Other());
34941: 3753:        Other other = b.get();
34942: 3754:        b.f();
34943: 3755:    }
34944: 3756:}
34945: 3757:/* Output:
34946: 3758:Other
34947: 3759:*/
34948: 3760:```
34949: 3761:
34950: 3762:限定将采取额外的步骤，强制泛型当作其自身的边界参数来使用。观察所产生的类可以如何使用以及不可以如何使用：
34951: 3763:
34952: 3764:```java
34953: 3765:// generics/SelfBounding.java
34954: 3766:
34955: 3767:class SelfBounded<T extends SelfBounded<T>> {
34956: 3768:    T element;
34957: 3769:    SelfBounded<T> set(T arg) {
34958: 3770:        element = arg;
34959: 3771:        return this;
34960: 3772:    }
34961: 3773:    T get() { return element; }
34962: 3774:}
34963: 3775:
34964: 3776:class A extends SelfBounded<A> {}
34965: 3777:class B extends SelfBounded<A> {} // Also OK
34966: 3778:
34967: 3779:class C extends SelfBounded<C> {
34968: 3780:    C setAndGet(C arg) { 
34969: 3781:        set(arg); 
34970: 3782:        return get();
34971: 3783:    }
34972: 3784:}
34973: 3785:
34974: 3786:class D {}
34975: 3787:// Can't do this:
34976: 3788:// class E extends SelfBounded<D> {}
34977: 3789:// Compile error:
34978: 3790://   Type parameter D is not within its bound
34979: 3791:
34980: 3792:// Alas, you can do this, so you cannot force the idiom:
34981: 3793:class F extends SelfBounded {}
34982: 3794:
34983: 3795:public class SelfBounding {
34984: 3796:    public static void main(String[] args) {
34985: 3797:        A a = new A();
34986: 3798:        a.set(new A());
34987: 3799:        a = a.set(new A()).get();
34988: 3800:        a = a.get();
34989: 3801:        C c = new C();
34990: 3802:        c = c.setAndGet(new C());
34991: 3803:    }
34992: 3804:}
34993: 3805:```
34994: 3806:
34995: 3807:自限定所做的，就是要求在继承关系中，像下面这样使用这个类：
34996: 3808:
34997: 3809:```java
34998: 3810:class A extends SelfBounded<A>{}
34999: 3811:```
35000: 3812:
35001: 3813:这会强制要求将正在定义的类当作参数传递给基类。
35002: 3814:
35003: 3815:自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。正如你在 B 类的定义中所看到的，还可以从使用了另一个 **SelfBounded** 参数的 **SelfBounded** 中导出，尽管在 **A** 类看到的用法看起来是主要的用法。对定义 **E** 的尝试说明不能使用不是 **SelfBounded** 的类型参数。
35004: 3816:遗憾的是， **F** 可以编译，不会有任何警告，因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型。
35005: 3817:注意，可以移除自限定这个限制，这样所有的类仍旧是可以编译的，但是 **E** 也会因此而变得可编译：
35006: 3818:
35007: 3819:```java
35008: 3820:// generics/NotSelfBounded.java
35009: 3821:
35010: 3822:public class NotSelfBounded<T> {
35011: 3823:    T element;
35012: 3824:    NotSelfBounded<T> set(T arg) {
35013: 3825:        element = arg;
35014: 3826:        return this;
35015: 3827:    }
35016: 3828:    T get() { return element; }
35017: 3829:} 
35018: 3830:
35019: 3831:class A2 extends NotSelfBounded<A2> {}
35020: 3832:class B2 extends NotSelfBounded<A2> {}
35021: 3833:
35022: 3834:class C2 extends NotSelfBounded<C2> {
35023: 3835:    C2 setAndGet(C2 arg) { 
35024: 3836:        set(arg); 
35025: 3837:        return get(); 
35026: 3838:    }
35027: 3839:}
35028: 3840:
35029: 3841:class D2 {}
35030: 3842:// Now this is OK:
35031: 3843:class E2 extends NotSelfBounded<D2> {}
35032: 3844:```
35033: 3845:
35034: 3846:因此很明显，自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。这会强制要求使用这个类的每个人都要遵循这种形式。
35035: 3847:还可以将自限定用于泛型方法：
35036: 3848:
35037: 3849:```java
35038: 3850:// generics/SelfBoundingMethods.java
35039: 3851:// (c)2017 MindView LLC: see Copyright.txt
35040: 3852:// We make no guarantees that this code is fit for any purpose.
35041: 3853:// Visit http://OnJava8.com for more book information.
35042: 3854:
35043: 3855:public class SelfBoundingMethods {
35044: 3856:    static <T extends SelfBounded<T>> T f(T arg) {
35045: 3857:        return arg.set(arg).get();
35046: 3858:    }
35047: 3859:    
35048: 3860:    public static void main(String[] args) {
35049: 3861:        A a = f(new A());
35050: 3862:    }
35051: 3863:}
35052: 3864:```
35053: 3865:
35054: 3866:这可以防止这个方法被应用于除上述形式的自限定参数之外的任何事物上。
35055: 3867:
35056: 3868:### 参数协变
35057: 3869:
35058: 3870:自限定类型的价值在于它们可以产生*协变参数类型*——方法参数类型会随子类而变化。
35059: 3871:
35060: 3872:尽管自限定类型还可以产生与子类类型相同的返回类型，但是这并不十分重要，因为*协变返回类型*是在 Java 5 引入：
35061: 3873:
35062: 3874:```java
35063: 3875:// generics/CovariantReturnTypes.java
35064: 3876:
35065: 3877:class Base {}
35066: 3878:class Derived extends Base {}
35067: 3879:
35068: 3880:interface OrdinaryGetter {
35069: 3881:    Base get();
35070: 3882:}
35071: 3883:
35072: 3884:interface DerivedGetter extends OrdinaryGetter {
35073: 3885:    // Overridden method return type can vary:
35074: 3886:    @Override
35075: 3887:    Derived get();
35076: 3888:}
35077: 3889:
35078: 3890:public class CovariantReturnTypes {
35079: 3891:    void test(DerivedGetter d) {
35080: 3892:        Derived d2 = d.get();
35081: 3893:    }
35082: 3894:}
35083: 3895:```
35084: 3896:
35085: 3897:**DerivedGetter** 中的 `get()` 方法覆盖了 **OrdinaryGetter** 中的 `get()` ，并返回了一个从 `OrdinaryGetter.get()` 的返回类型中导出的类型。尽管这是完全合乎逻辑的事情（导出类方法应该能够返回比它覆盖的基类方法更具体的类型）但是这在早先的 Java 版本中是不合法的。
35086: 3898:
35087: 3899:自限定泛型事实上将产生确切的导出类型作为其返回值，就像在 `get()` 中所看到的一样：
35088: 3900:
35089: 3901:```java
35090: 3902:// generics/GenericsAndReturnTypes.java
35091: 3903:
35092: 3904:interface GenericGetter<T extends GenericGetter<T>> {
35093: 3905:    T get();
35094: 3906:}
35095: 3907:
35096: 3908:interface Getter extends GenericGetter<Getter> {}
35097: 3909:
35098: 3910:public class GenericsAndReturnTypes {
35099: 3911:    void test(Getter g) {
35100: 3912:        Getter result = g.get();
35101: 3913:        GenericGetter gg = g.get(); // Also the base type
35102: 3914:    }
35103: 3915:}
35104: 3916:```
35105: 3917:
35106: 3918:注意，这段代码不能编译，除非是使用囊括了协变返回类型的 Java 5。
35107: 3919:
35108: 3920:然而，在非泛型代码中，参数类型不能随子类型发生变化：
35109: 3921:
35110: 3922:```java
35111: 3923:// generics/OrdinaryArguments.java
35112: 3924:
35113: 3925:class OrdinarySetter {
35114: 3926:    void set(Base base) {
35115: 3927:        System.out.println("OrdinarySetter.set(Base)");
35116: 3928:    }
35117: 3929:}
35118: 3930:
35119: 3931:class DerivedSetter extends OrdinarySetter {
35120: 3932:    void set(Derived derived) {
35121: 3933:        System.out.println("DerivedSetter.set(Derived)");
35122: 3934:    }
35123: 3935:}
35124: 3936:
35125: 3937:public class OrdinaryArguments {
35126: 3938:    public static void main(String[] args) {
35127: 3939:        Base base = new Base();
35128: 3940:        Derived derived = new Derived();
35129: 3941:        DerivedSetter ds = new DerivedSetter();
35130: 3942:        ds.set(derived);
35131: 3943:        // Compiles--overloaded, not overridden!:
35132: 3944:        ds.set(base);
35133: 3945:    }
35134: 3946:}
35135: 3947:/* Output:
35136: 3948:DerivedSetter.set(Derived)
35137: 3949:OrdinarySetter.set(Base)
35138: 3950:*/
35139: 3951:```
35140: 3952:
35141: 3953:`set(derived)` 和 `set(base)` 都是合法的，因此 `DerivedSetter.set()` 没有覆盖 `OrdinarySetter.set()` ，而是重载了这个方法。从输出中可以看到，在 **DerivedSetter** 中有两个方法，因此基类版本仍旧是可用的，因此可以证明它被重载过。
35142: 3954:但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类型而不是基类型为参数：
35143: 3955:
35144: 3956:```java
35145: 3957:// generics/SelfBoundingAndCovariantArguments.java
35146: 3958:
35147: 3959:interface SelfBoundSetter<T extends SelfBoundSetter<T>> {
35148: 3960:    void set(T arg);
35149: 3961:}
35150: 3962:
35151: 3963:interface Setter extends SelfBoundSetter<Setter> {}
35152: 3964:
35153: 3965:public class SelfBoundingAndCovariantArguments {
35154: 3966:    void
35155: 3967:    testA(Setter s1, Setter s2, SelfBoundSetter sbs) {
35156: 3968:        s1.set(s2);
35157: 3969:        //- s1.set(sbs);
35158: 3970:        // error: method set in interface SelfBoundSetter<T>
35159: 3971:        // cannot be applied to given types;
35160: 3972:        //     s1.set(sbs);
35161: 3973:        //       ^
35162: 3974:        //   required: Setter
35163: 3975:        //   found: SelfBoundSetter
35164: 3976:        //   reason: argument mismatch;
35165: 3977:        // SelfBoundSetter cannot be converted to Setter
35166: 3978:        //   where T is a type-variable:
35167: 3979:        //     T extends SelfBoundSetter<T> declared in
35168: 3980:        //     interface SelfBoundSetter
35169: 3981:        // 1 error
35170: 3982:    }
35171: 3983:}
35172: 3984:```
35173: 3985:
35174: 3986:编译器不能识别将基类型当作参数传递给 `set()` 的尝试，因为没有任何方法具有这样的签名。实际上，这个参数已经被覆盖。
35175: 3987:如果不使用自限定类型，普通的继承机制就会介入，而你将能够重载，就像在非泛型的情况下一样：
35176: 3988:
35177: 3989:```java
35178: 3990:// generics/PlainGenericInheritance.java
35179: 3991:
35180: 3992:class GenericSetter<T> { // Not self-bounded
35181: 3993:    void set(T arg) {
35182: 3994:        System.out.println("GenericSetter.set(Base)");
35183: 3995:    }
35184: 3996:}
35185: 3997:
35186: 3998:class DerivedGS extends GenericSetter<Base> {
35187: 3999:    void set(Derived derived) {
35188: 4000:        System.out.println("DerivedGS.set(Derived)");
35189: 4001:    }
35190: 4002:}
35191: 4003:
35192: 4004:public class PlainGenericInheritance {
35193: 4005:    public static void main(String[] args) {
35194: 4006:        Base base = new Base();
35195: 4007:        Derived derived = new Derived();
35196: 4008:        DerivedGS dgs = new DerivedGS();
35197: 4009:        dgs.set(derived);
35198: 4010:        dgs.set(base); // Overloaded, not overridden!
35199: 4011:    }
35200: 4012:}
35201: 4013:/* Output:
35202: 4014:DerivedGS.set(Derived)
35203: 4015:GenericSetter.set(Base)
35204: 4016:*/
35205: 4017:```
35206: 4018:
35207: 4019:这段代码在模仿 **OrdinaryArguments.java**；在那个示例中，**DerivedSetter** 继承自包含一个 `set(Base)` 的**OrdinarySetter** 。而这里，**DerivedGS** 继承自泛型创建的也包含有一个 `set(Base)`的 `GenericSetter<Base>`。就像 **OrdinaryArguments.java** 一样，你可以从输出中看到， **DerivedGS** 包含两个  `set()` 的重载版本。如果不使用自限定，将重载参数类型。如果使用了自限定，只能获得方法的一个版本，它将接受确切的参数类型。
35208: 4020:
35209: 4021:<!-- Dynamic Type Safety -->
35210: 4022:
35211: 4023:## 动态类型安全
35212: 4024:
35213: 4025:因为可以向 Java 5 之前的代码传递泛型集合，所以旧式代码仍旧有可能会破坏你的集合。Java 5 的 **java.util.Collections** 中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：静态方法 `checkedCollection()` 、`checkedList()`、 `checkedMap()` 、 `checkedSet()` 、`checkedSortedMap()`和 `checkedSortedSet()`。这些方法每一个都会将你希望动态检查的集合当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。
35214: 4026:
35215: 4027:受检查的集合在你试图插入类型不正确的对象时抛出 **ClassCastException** ，这与泛型之前的（原生）集合形成了对比，对于后者来说，当你将对象从集合中取出时，才会通知你出现了问题。在后一种情况中，你知道存在问题，但是不知道罪魁祸首在哪里，如果使用受检查的集合，就可以发现谁在试图插入不良对象。
35216: 4028:让我们用受检查的集合来看看“将猫插入到狗列表中”这个问题。这里，`oldStyleMethod()` 表示遗留代码，因为它接受的是原生的 **List** ，而 **@SuppressWarnings（“unchecked”）** 注解对于压制所产生的警告是必需的：
35217: 4029:
35218: 4030:```java
35219: 4031:// generics/CheckedList.java
35220: 4032:// Using Collection.checkedList()
35221: 4033:import typeinfo.pets.*;
35222: 4034:import java.util.*;
35223: 4035:
35224: 4036:public class CheckedList {
35225: 4037:    @SuppressWarnings("unchecked")
35226: 4038:    static void oldStyleMethod(List probablyDogs) {
35227: 4039:        probablyDogs.add(new Cat());
35228: 4040:    }
35229: 4041:    
35230: 4042:    public static void main(String[] args) {
35231: 4043:        List<Dog> dogs1 = new ArrayList<>();
35232: 4044:        oldStyleMethod(dogs1); // Quietly accepts a Cat
35233: 4045:        List<Dog> dogs2 = Collections.checkedList(
35234: 4046:            new ArrayList<>(), Dog.class);
35235: 4047:        try {
35236: 4048:            oldStyleMethod(dogs2); // Throws an exception
35237: 4049:        } catch(Exception e) {
35238: 4050:            System.out.println("Expected: " + e);
35239: 4051:        }
35240: 4052:        // Derived types work fine:
35241: 4053:        List<Pet> pets = Collections.checkedList(
35242: 4054:            new ArrayList<>(), Pet.class);
35243: 4055:        pets.add(new Dog());
35244: 4056:        pets.add(new Cat());
35245: 4057:    }
35246: 4058:}
35247: 4059:/* Output:
35248: 4060:Expected: java.lang.ClassCastException: Attempt to
35249: 4061:insert class typeinfo.pets.Cat element into collection
35250: 4062:with element type class typeinfo.pets.Dog
35251: 4063:*/
35252: 4064:```
35253: 4065:
35254: 4066:运行这个程序时，你会发现插入一个 **Cat** 对于 **dogs1** 来说没有任何问题，而 **dogs2** 立即会在这个错误类型的插入操作上抛出一个异常。还可以看到，将导出类型的对象放置到将要检查基类型的受检查容器中是没有问题的。
35255: 4067:
35256: 4068:<!-- Exceptions -->
35257: 4069:
35258: 4070:## 泛型异常
35259: 4071:
35260: 4072:由于擦除的原因，**catch** 语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承自 **Throwable**（这将进一步阻止你去定义不能捕获的泛型异常）。
35261: 4073:但是，类型参数可能会在一个方法的 **throws** 子句中用到。这使得你可以编写随检查型异常类型变化的泛型代码：
35262: 4074:
35263: 4075:```java
35264: 4076:// generics/ThrowGenericException.java
35265: 4077:
35266: 4078:import java.util.*;
35267: 4079:
35268: 4080:interface Processor<T, E extends Exception> {
35269: 4081:    void process(List<T> resultCollector) throws E;
35270: 4082:}
35271: 4083:
35272: 4084:class ProcessRunner<T, E extends Exception>
35273: 4085:extends ArrayList<Processor<T, E>> {
35274: 4086:    List<T> processAll() throws E {
35275: 4087:        List<T> resultCollector = new ArrayList<>();
35276: 4088:        for(Processor<T, E> processor : this)
35277: 4089:            processor.process(resultCollector);
35278: 4090:        return resultCollector;
35279: 4091:    }
35280: 4092:}
35281: 4093:
35282: 4094:class Failure1 extends Exception {}
35283: 4095:
35284: 4096:class Processor1
35285: 4097:implements Processor<String, Failure1> {
35286: 4098:    static int count = 3;
35287: 4099:    @Override
35288: 4100:    public void process(List<String> resultCollector)
35289: 4101:    throws Failure1 {
35290: 4102:        if(count-- > 1)
35291: 4103:            resultCollector.add("Hep!");
35292: 4104:        else
35293: 4105:            resultCollector.add("Ho!");
35294: 4106:        if(count < 0)
35295: 4107:            throw new Failure1();
35296: 4108:    }
35297: 4109:}
35298: 4110:
35299: 4111:class Failure2 extends Exception {}
35300: 4112:
35301: 4113:class Processor2
35302: 4114:implements Processor<Integer, Failure2> {
35303: 4115:    static int count = 2;
35304: 4116:    @Override
35305: 4117:    public void process(List<Integer> resultCollector)
35306: 4118:    throws Failure2 {
35307: 4119:        if(count-- == 0)
35308: 4120:            resultCollector.add(47);
35309: 4121:        else {
35310: 4122:            resultCollector.add(11);
35311: 4123:        }
35312: 4124:        if(count < 0)
35313: 4125:            throw new Failure2();
35314: 4126:    }
35315: 4127:}
35316: 4128:
35317: 4129:public class ThrowGenericException {
35318: 4130:    public static void main(String[] args) {
35319: 4131:        ProcessRunner<String, Failure1> runner =
35320: 4132:            new ProcessRunner<>();
35321: 4133:        for(int i = 0; i < 3; i++)
35322: 4134:            runner.add(new Processor1());
35323: 4135:        try {
35324: 4136:            System.out.println(runner.processAll());
35325: 4137:        } catch(Failure1 e) {
35326: 4138:            System.out.println(e);
35327: 4139:        }
35328: 4140:
35329: 4141:        ProcessRunner<Integer, Failure2> runner2 =
35330: 4142:            new ProcessRunner<>();
35331: 4143:        for(int i = 0; i < 3; i++)
35332: 4144:            runner2.add(new Processor2());
35333: 4145:        try {
35334: 4146:            System.out.println(runner2.processAll());
35335: 4147:        } catch(Failure2 e) {
35336: 4148:            System.out.println(e);
35337: 4149:        }
35338: 4150:    }
35339: 4151:}
35340: 4152:/* Output:
35341: 4153:[Hep!, Hep!, Ho!]
35342: 4154:Failure2
35343: 4155:*/
35344: 4156:```
35345: 4157:
35346: 4158:**Processor** 执行 `process()` 方法，并且可能会抛出具有类型 **E** 的异常。`process()` 的结果存储在 `List<T>resultCollector` 中（这被称为*收集参数*）。**ProcessRunner** 有一个 `processAll()` 方法，它会在所持有的每个 **Process** 对象执行，并返回 **resultCollector** 。
35347: 4159:如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出这种泛化的代码。
35348: 4160:
35349: 4161:<!-- Mixins -->
35350: 4162:
35351: 4163:## 混型
35352: 4164:
35353: 4165:术语*混型*随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是你最后的手段，它将使组装多个类变得简单易行。
35354: 4166:混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点*面向切面编程* （AOP） 的味道，而切面经常被建议用来解决混型问题。
35355: 4167:
35356: 4168:### C++ 中的混型
35357: 4169:
35358: 4170:在 C++ 中，使用多重继承的最大理由，就是为了使用混型。但是，对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为混型就是继承自其类型参数的类。在 C++ 中，可以很容易地创建混型，因为 C++ 能够记住其模版参数的类型。
35359: 4171:下面是一个 C++ 示例，它有两个混型类型：一个使得你可以在每个对象中混入拥有一个时间戳这样的属性，而另一个可以混入一个序列号。
35360: 4172:
35361: 4173:```c++
35362: 4174:// generics/Mixins.cpp
35363: 4175:
35364: 4176:#include <string>
35365: 4177:#include <ctime>
35366: 4178:#include <iostream>
35367: 4179:using namespace std;
35368: 4180:
35369: 4181:template<class T> class TimeStamped : public T {
35370: 4182:    long timeStamp;
35371: 4183:public:
35372: 4184:    TimeStamped() { timeStamp = time(0); }
35373: 4185:    long getStamp() { return timeStamp; }
35374: 4186:};
35375: 4187:
35376: 4188:template<class T> class SerialNumbered : public T {
35377: 4189:    long serialNumber;
35378: 4190:    static long counter;
35379: 4191:public:
35380: 4192:    SerialNumbered() { serialNumber = counter++; }
35381: 4193:    long getSerialNumber() { return serialNumber; }
35382: 4194:};
35383: 4195:
35384: 4196:// Define and initialize the static storage:
35385: 4197:template<class T> long SerialNumbered<T>::counter = 1;
35386: 4198:
35387: 4199:class Basic {
35388: 4200:    string value;
35389: 4201:public:
35390: 4202:    void set(string val) { value = val; }
35391: 4203:    string get() { return value; }
35392: 4204:};
35393: 4205:
35394: 4206:int main() {
35395: 4207:    TimeStamped<SerialNumbered<Basic>> mixin1, mixin2;
35396: 4208:    mixin1.set("test string 1");
35397: 4209:    mixin2.set("test string 2");
35398: 4210:    cout << mixin1.get() << " " << mixin1.getStamp() <<
35399: 4211:      " " << mixin1.getSerialNumber() << endl;
35400: 4212:    cout << mixin2.get() << " " << mixin2.getStamp() <<
35401: 4213:      " " << mixin2.getSerialNumber() << endl;
35402: 4214:}
35403: 4215:/* Output:
35404: 4216:test string 1 1452987605 1
35405: 4217:test string 2 1452987605 2
35406: 4218:*/
35407: 4219:```
35408: 4220:
35409: 4221:在 `main()` 中， **mixin1** 和 **mixin2** 所产生的类型拥有所混入类型的所有方法。可以将混型看作是一种功能，它可以将现有类映射到新的子类上。注意，使用这种技术来创建一个混型是多么的轻而易举。基本上，只需要声明“这就是我想要的”，紧跟着它就发生了：
35410: 4222:
35411: 4223:```c++
35412: 4224:TimeStamped<SerialNumbered<Basic>> mixin1，mixin2；
35413: 4225:```
35414: 4226:
35415: 4227:遗憾的是，Java 泛型不允许这样。擦除会忘记基类类型，因此
35416: 4228:
35417: 4229:>  泛型类不能直接继承自一个泛型参数
35418: 4230:
35419: 4231:这突显了许多我在 Java 语言设计决策（以及与这些功能一起发布）中遇到的一大问题：处理一件事很有希望，但是当您实际尝试做一些有趣的事情时，您会发现自己做不到。
35420: 4232:
35421: 4233:### 与接口混合
35422: 4234:
35423: 4235:一种更常见的推荐解决方案是使用接口来产生混型效果，就像下面这样：
35424: 4236:
35425: 4237:```java
35426: 4238:// generics/Mixins.java
35427: 4239:
35428: 4240:import java.util.*;
35429: 4241:
35430: 4242:interface TimeStamped { long getStamp(); }
35431: 4243:
35432: 4244:class TimeStampedImp implements TimeStamped {
35433: 4245:    private final long timeStamp;
35434: 4246:    TimeStampedImp() {
35435: 4247:        timeStamp = new Date().getTime();
35436: 4248:    }
35437: 4249:    @Override
35438: 4250:    public long getStamp() { return timeStamp; }
35439: 4251:}
35440: 4252:
35441: 4253:interface SerialNumbered { long getSerialNumber(); }
35442: 4254:
35443: 4255:class SerialNumberedImp implements SerialNumbered {
35444: 4256:    private static long counter = 1;
35445: 4257:    private final long serialNumber = counter++;
35446: 4258:    @Override
35447: 4259:    public long getSerialNumber() { return serialNumber; }
35448: 4260:}
35449: 4261:
35450: 4262:interface Basic {
35451: 4263:    void set(String val);
35452: 4264:    String get();
35453: 4265:}
35454: 4266:
35455: 4267:class BasicImp implements Basic {
35456: 4268:    private String value;
35457: 4269:    @Override
35458: 4270:    public void set(String val) { value = val; }
35459: 4271:    @Override
35460: 4272:    public String get() { return value; }
35461: 4273:}
35462: 4274:
35463: 4275:class Mixin extends BasicImp
35464: 4276:implements TimeStamped, SerialNumbered {
35465: 4277:    private TimeStamped timeStamp = new TimeStampedImp();
35466: 4278:    private SerialNumbered serialNumber =
35467: 4279:        new SerialNumberedImp();
35468: 4280:    @Override
35469: 4281:    public long getStamp() {
35470: 4282:        return timeStamp.getStamp();
35471: 4283:    }
35472: 4284:    @Override
35473: 4285:    public long getSerialNumber() {
35474: 4286:        return serialNumber.getSerialNumber();
35475: 4287:    }
35476: 4288:}
35477: 4289:
35478: 4290:public class Mixins {
35479: 4291:    public static void main(String[] args) {
35480: 4292:        Mixin mixin1 = new Mixin(), mixin2 = new Mixin();
35481: 4293:        mixin1.set("test string 1");
35482: 4294:        mixin2.set("test string 2");
35483: 4295:        System.out.println(mixin1.get() + " " +
35484: 4296:            mixin1.getStamp() +  " " + mixin1.getSerialNumber());
35485: 4297:        System.out.println(mixin2.get() + " " +
35486: 4298:            mixin2.getStamp() +  " " + mixin2.getSerialNumber());
35487: 4299:    }
35488: 4300:}
35489: 4301:/* Output:
35490: 4302:test string 1 1494331663026 1
35491: 4303:test string 2 1494331663027 2
35492: 4304:*/
35493: 4305:```
35494: 4306:
35495: 4307:**Mixin** 类基本上是在使用*委托*，因此每个混入类型都要求在 **Mixin** 中有一个相应的域，而你必须在 **Mixin** 中编写所有必需的方法，将方法调用转发给恰当的对象。这个示例使用了非常简单的类，但是当使用更复杂的混型时，代码数量会急速增加。[^4]
35496: 4308:
35497: 4309:### 使用装饰器模式
35498: 4310:
35499: 4311:当你观察混型的使用方式时，就会发现混型概念好像与*装饰器*设计模式关系很近。装饰器经常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的。
35500: 4312:装饰器模式使用分层对象来动态透明地向单个对象中添加责任。装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。某些事物是可装饰的，可以通过将其他类包装在这个可装饰对象的四周，来将功能分层。这使得对装饰器的使用是透明的——无论对象是否被装饰，你都拥有一个可以向对象发送的公共消息集。装饰类也可以添加新方法，但是正如你所见，这将是受限的。
35501: 4313:装饰器是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。
35502: 4314:前面的示例可以被改写为使用装饰器：
35503: 4315:
35504: 4316:```java
35505: 4317:// generics/decorator/Decoration.java
35506: 4318:
35507: 4319:// {java generics.decorator.Decoration}
35508: 4320:package generics.decorator;
35509: 4321:import java.util.*;
35510: 4322:
35511: 4323:class Basic {
35512: 4324:    private String value;
35513: 4325:    public void set(String val) { value = val; }
35514: 4326:    public String get() { return value; }
35515: 4327:}
35516: 4328:
35517: 4329:class Decorator extends Basic {
35518: 4330:    protected Basic basic;
35519: 4331:    Decorator(Basic basic) { this.basic = basic; }
35520: 4332:    @Override
35521: 4333:    public void set(String val) { basic.set(val); }
35522: 4334:    @Override
35523: 4335:    public String get() { return basic.get(); }
35524: 4336:}
35525: 4337:
35526: 4338:class TimeStamped extends Decorator {
35527: 4339:    private final long timeStamp;
35528: 4340:    TimeStamped(Basic basic) {
35529: 4341:        super(basic);
35530: 4342:        timeStamp = new Date().getTime();
35531: 4343:    }
35532: 4344:    public long getStamp() { return timeStamp; }
35533: 4345:}
35534: 4346:
35535: 4347:class SerialNumbered extends Decorator {
35536: 4348:    private static long counter = 1;
35537: 4349:    private final long serialNumber = counter++;
35538: 4350:    SerialNumbered(Basic basic) { super(basic); }
35539: 4351:    public long getSerialNumber() { return serialNumber; }
35540: 4352:}
35541: 4353:
35542: 4354:public class Decoration {
35543: 4355:    public static void main(String[] args) {
35544: 4356:        TimeStamped t = new TimeStamped(new Basic());
35545: 4357:        TimeStamped t2 = new TimeStamped(
35546: 4358:            new SerialNumbered(new Basic()));
35547: 4359:        //- t2.getSerialNumber(); // Not available
35548: 4360:        SerialNumbered s = new SerialNumbered(new Basic());
35549: 4361:        SerialNumbered s2 = new SerialNumbered(
35550: 4362:            new TimeStamped(new Basic()));
35551: 4363:        //- s2.getStamp(); // Not available
35552: 4364:  }
35553: 4365:}
35554: 4366:```
35555: 4367:
35556: 4368:产生自泛型的类包含所有感兴趣的方法，但是由使用装饰器所产生的对象类型是最后被装饰的类型。也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。因此，装饰器只是对由混型提出的问题的一种局限的解决方案。
35557: 4369:
35558: 4370:### 与动态代理混合
35559: 4371:
35560: 4372:可以使用动态代理来创建一种比装饰器更贴近混型模型的机制（查看 [类型信息](book/19-Type-Information.md) 一章中关于 Java 的动态代理如何工作的解释）。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。
35561: 4373:由于动态代理的限制，每个被混入的类都必须是某个接口的实现：
35562: 4374:
35563: 4375:```java
35564: 4376:// generics/DynamicProxyMixin.java
35565: 4377:
35566: 4378:import java.lang.reflect.*;
35567: 4379:import java.util.*;
35568: 4380:import onjava.*;
35569: 4381:import static onjava.Tuple.*;
35570: 4382:
35571: 4383:class MixinProxy implements InvocationHandler {
35572: 4384:    Map<String, Object> delegatesByMethod;
35573: 4385:    @SuppressWarnings("unchecked")
35574: 4386:    MixinProxy(Tuple2<Object, Class<?>>... pairs) {
35575: 4387:        delegatesByMethod = new HashMap<>();
35576: 4388:        for(Tuple2<Object, Class<?>> pair : pairs) {
35577: 4389:            for(Method method : pair.a2.getMethods()) {
35578: 4390:                String methodName = method.getName();
35579: 4391:                // The first interface in the map
35580: 4392:                // implements the method.
35581: 4393:                if(!delegatesByMethod.containsKey(methodName))
35582: 4394:                    delegatesByMethod.put(methodName, pair.a1);
35583: 4395:            }
35584: 4396:        }
35585: 4397:    }
35586: 4398:    @Override
35587: 4399:    public Object invoke(Object proxy, Method method,
35588: 4400:      Object[] args) throws Throwable {
35589: 4401:        String methodName = method.getName();
35590: 4402:        Object delegate = delegatesByMethod.get(methodName);
35591: 4403:        return method.invoke(delegate, args);
35592: 4404:    }
35593: 4405:    
35594: 4406:    @SuppressWarnings("unchecked")
35595: 4407:    public static Object newInstance(Tuple2... pairs) {
35596: 4408:        Class[] interfaces = new Class[pairs.length];
35597: 4409:        for(int i = 0; i < pairs.length; i++) {
35598: 4410:            interfaces[i] = (Class)pairs[i].a2;
35599: 4411:        }
35600: 4412:        ClassLoader cl = pairs[0].a1.getClass().getClassLoader();
35601: 4413:        return Proxy.newProxyInstance(cl, interfaces, new MixinProxy(pairs));
35602: 4414:    }
35603: 4415:}
35604: 4416:
35605: 4417:public class DynamicProxyMixin {
35606: 4418:    public static void main(String[] args) {
35607: 4419:        Object mixin = MixinProxy.newInstance(
35608: 4420:          tuple(new BasicImp(), Basic.class),
35609: 4421:          tuple(new TimeStampedImp(), TimeStamped.class),
35610: 4422:          tuple(new SerialNumberedImp(), SerialNumbered.class));
35611: 4423:        Basic b = (Basic)mixin;
35612: 4424:        TimeStamped t = (TimeStamped)mixin;
35613: 4425:        SerialNumbered s = (SerialNumbered)mixin;
35614: 4426:        b.set("Hello");
35615: 4427:        System.out.println(b.get());
35616: 4428:        System.out.println(t.getStamp());
35617: 4429:        System.out.println(s.getSerialNumber());
35618: 4430:    }
35619: 4431:}
35620: 4432:/* Output:
35621: 4433:Hello
35622: 4434:1494331653339
35623: 4435:1
35624: 4436:*/
35625: 4437:```
35626: 4438:
35627: 4439:因为只有动态类型而不是静态类型才包含所有的混入类型，因此这仍旧不如 C++ 的方式好，因为可以在具有这些类型的对象上调用方法之前，你被强制要求必须先将这些对象向下转型到恰当的类型。但是，它明显地更接近于真正的混型。
35628: 4440:为了让 Java 支持混型，人们已经做了大量的工作朝着这个目标努力，包括创建了至少一种附加语言（ Jam 语言），它是专门用来支持混型的。
35629: 4441:
35630: 4442:<!-- Latent Typing -->
35631: 4443:
35632: 4444:## 潜在类型机制
35633: 4445:
35634: 4446:在本章的开头介绍过这样的思想，即要编写能够尽可能广泛地应用的代码。为了实现这一点，我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处。然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码。
35635: 4447:
35636: 4448:Java 泛型看起来是向这一方向迈进了一步。当你在编写或使用只是持有对象的泛型时，这些代码将可以工作于任何类型（除了基本类型，尽管正如你所见到的，自动装箱机制可以克服这一点）。或者，换个角度讲，“持有器”泛型能够声明：“我不关心你是什么类型”。如果代码不关心它将要作用的类型，那么这种代码就可以真正地应用于任何地方，并因此而相当泛化。
35637: 4449:
35638: 4450:还是正如你所见到的，当要在泛型类型上执行操作（即调用 **Object** 方法之外的方法）时，就会产生问题。擦除强制要求指定可能会用到的泛型类型的边界，以安全地调用代码中的泛型对象上的具体方法。这是对“泛化”概念的一种明显的限制，因为必须限制你的泛型类型，使它们继承自特定的类，或者实现特定的接口。在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类或接口没有任何区别。
35639: 4451:
35640: 4452:某些编程语言提供的一种解决方案称为*潜在类型机制*或*结构化类型机制*，而更古怪的术语称为*鸭子类型机制*，即“如果它走起来像鸭子，并且叫起来也像鸭子，那么你就可以将它当作鸭子对待。”鸭子类型机制变成了一种相当流行的术语，可能是因为它不像其他的术语那样承载着历史的包袱。
35641: 4453:
35642: 4454:泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得你可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以 `speak()` 和 `sit()` 即可。”由于不要求具体类型，因此代码就可以更加泛化。
35643: 4455:
35644: 4456:潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方。
35645: 4457:
35646: 4458:支持潜在类型机制的语言包括 Python（可以从 www.Python.org 免费下载）、C++、Ruby、SmallTalk 和 Go。Python 是动态类型语言（几乎所有的类型检查都发生在运行时），而 C++ 和 Go 是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查。
35647: 4459:
35648: 4460:### pyhton 中的潜在类型
35649: 4461:
35650: 4462:如果我们将上面的描述用 Python 来表示，如下所示：
35651: 4463:
35652: 4464:```python
35653: 4465:# generics/DogsAndRobots.py
35654: 4466:
35655: 4467:class Dog:
35656: 4468:    def speak(self):
35657: 4469:        print("Arf!")
35658: 4470:    def sit(self):
35659: 4471:        print("Sitting")
35660: 4472:    def reproduce(self):
35661: 4473:        pass
35662: 4474:
35663: 4475:class Robot:
35664: 4476:    def speak(self):
35665: 4477:        print("Click!")
35666: 4478:    def sit(self):
35667: 4479:        print("Clank!")
35668: 4480:    def oilChange(self):
35669: 4481:        pass
35670: 4482:
35671: 4483:def perform(anything):
35672: 4484:    anything.speak()
35673: 4485:    anything.sit()
35674: 4486:
35675: 4487:a = Dog()
35676: 4488:b = Robot()
35677: 4489:perform(a)
35678: 4490:perform(b)
35679: 4491:
35680: 4492:output = """
35681: 4493:Arf!
35682: 4494:Sitting
35683: 4495:Click!
35684: 4496:Clank!
35685: 4497:"""
35686: 4498:```
35687: 4499:
35688: 4500:Python 使用缩进来确定作用域（因此不需要任何花括号），而冒号将表示新的作用域的开始。“**#**” 表示注释到行尾，就像Java中的 “ **//** ”。类的方法需要显式地指定 **this** 引用的等价物作为第一个参数，按惯例成为 **self** 。构造器调用不要求任何类型的“ **new** ”关键字，并且 Python 允许普通（非成员）函数，就像 `perform()` 所表明的那样。注意，在 `perform(anything)` 中，没有任何针对 **anything** 的类型，**anything** 只是一个标识符，它必须能够执行 `perform()` 期望它执行的操作，因此这里隐含着一个接口。但是你从来都不必显式地写出这个接口——它是潜在的。`perform()` 不关心其参数的类型，因此我可以向它传递任何对象，只要该对象支持  `speak()` 和 `sit()` 方法。如果传递给 `perform()` 的对象不支持这些操作，那么将会得到运行时异常。
35689: 4501:
35690: 4502:输出规定使用三重引号创建带有内嵌换行符的字符串。
35691: 4503:
35692: 4504:### C++ 中的潜在类型
35693: 4505:
35694: 4506:我们可以用 C++ 产生相同的效果：
35695: 4507:
35696: 4508:```c++
35697: 4509:// generics/DogsAndRobots.cpp
35698: 4510:
35699: 4511:#include <iostream>
35700: 4512:using namespace std;
35701: 4513:
35702: 4514:class Dog {
35703: 4515:public:
35704: 4516:    void speak() { cout << "Arf!" << endl; }
35705: 4517:    void sit() { cout << "Sitting" << endl; }
35706: 4518:    void reproduce() {}
35707: 4519:};
35708: 4520:
35709: 4521:class Robot {
35710: 4522:public:
35711: 4523:    void speak() { cout << "Click!" << endl; }
35712: 4524:    void sit() { cout << "Clank!" << endl; }
35713: 4525:    void oilChange() {}
35714: 4526:};
35715: 4527:
35716: 4528:template<class T> void perform(T anything) {
35717: 4529:    anything.speak();
35718: 4530:    anything.sit();
35719: 4531:}
35720: 4532:
35721: 4533:int main() {
35722: 4534:    Dog d;
35723: 4535:    Robot r;
35724: 4536:    perform(d);
35725: 4537:    perform(r);
35726: 4538:}
35727: 4539:/* Output:
35728: 4540:Arf!
35729: 4541:Sitting
35730: 4542:Click!
35731: 4543:Clank!
35732: 4544:*/
35733: 4545:```
35734: 4546:
35735: 4547:在 Python 和 C++ 中，**Dog** 和 **Robot** 没有任何共同的东西，只是碰巧有两个方法具有相同的签名。从类型的观点看，它们是完全不同的类型。但是，`perform()` 不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。
35736: 4548:C++ 确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给你一个错误消息（这些错误消息从历史上看是相当可怕和冗长的，是 C++ 的模版名声欠佳的主要原因）。尽管它们是在不同时期实现这一点的，C++ 在编译期，而 Python 在运行时，但是这两种语言都可以确保类型不会被误用，因此被认为是强类型的。[^5]潜在类型机制没有损害强类型机制。
35737: 4549:
35738: 4550:### Go 中的潜在类型
35739: 4551:
35740: 4552:这里用 Go 语言编写相同的程序：
35741: 4553:
35742: 4554:```go
35743: 4555:// generics/dogsandrobots.go
35744: 4556:
35745: 4557:package main
35746: 4558:import "fmt"
35747: 4559:
35748: 4560:type Dog struct {}
35749: 4561:func (this Dog) speak() { fmt.Printf("Arf!\n")}
35750: 4562:func (this Dog) sit() { fmt.Printf("Sitting\n")}
35751: 4563:func (this Dog) reproduce() {}
35752: 4564:
35753: 4565:type Robot struct {}
35754: 4566:func (this Robot) speak() { fmt.Printf("Click!\n") }
35755: 4567:func (this Robot) sit() { fmt.Printf("Clank!\n") }
35756: 4568:func (this Robot) oilChange() {}
35757: 4569:
35758: 4570:func perform(speaker interface { speak(); sit() }) {
35759: 4571:  speaker.speak();
35760: 4572:  speaker.sit();
35761: 4573:}
35762: 4574:
35763: 4575:func main() {
35764: 4576:  perform(Dog{})
35765: 4577:  perform(Robot{})
35766: 4578:}
35767: 4579:/* Output:
35768: 4580:Arf!
35769: 4581:Sitting
35770: 4582:Click!
35771: 4583:Clank!
35772: 4584:*/
35773: 4585:```
35774: 4586:
35775: 4587:Go 没有 **class** 关键字，但是可以使用上述形式创建等效的基本类：它通常不定义为类，而是定义为 **struct** ，在其中定义数据字段（此处不存在）。 对于每种方法，都以 **func** 关键字开头，然后（为了将该方法附加到您的类上）放在括号中，该括号包含对象引用，该对象引用可以是任何标识符，但是我在这里使用 **this** 来提醒您，就像在 C ++ 或 Java 中的 **this** 一样。 然后，在Go中像这样定义其余的函数。
35776: 4588:
35777: 4589:Go也没有继承关系，因此这种“面向对象的目标”形式是相对原始的，并且可能是我无法花更多的时间来学习该语言的主要原因。 但是，Go 的组成很简单。
35778: 4590:
35779: 4591:`perform()` 函数使用潜在类型：参数的确切类型并不重要，只要它包含了 `speak()` 和  `sit()` 方法即可。 该接口在此处匿名定义，内联，如 `perform()` 的参数列表所示。
35780: 4592:
35781: 4593:`main()` 证明 `perform()` 确实对其参数的确切类型不在乎，只要可以在该参数上调用 `talk()` 和 `sit()` 即可。 但是，就像 C ++ 模板函数一样，在编译时检查类型。
35782: 4594:
35783: 4595:语法 **Dog {}** 和 **Robot {}** 创建匿名的 **Dog** 和 **Robot** 结构。
35784: 4596:
35785: 4597:### java中的直接潜在类型
35786: 4598:
35787: 4599:因为泛型是在这场竞赛的后期才添加到 Java 中，因此没有任何机会可以去实现任何类型的潜在类型机制，因此 Java 没有对这种特性的支持。所以，初看起来，Java 的泛型机制比支持潜在类型机制的语言更“缺乏泛化性”。（使用擦除来实现 Java 泛型的实现有时称为第二类泛型类型）例如，在 Java 8  之前如果我们试图用 Java 实现上面 dogs-and-robots 的示例，那么就会被强制要求使用一个类或接口，并在边界表达式中指定它：
35788: 4600:
35789: 4601:```java
35790: 4602:// generics/Performs.java
35791: 4603:
35792: 4604:public interface Performs {
35793: 4605:    void speak();
35794: 4606:    void sit();
35795: 4607:}
35796: 4608:```
35797: 4609:
35798: 4610:```java
35799: 4611:// generics/DogsAndRobots.java
35800: 4612:// No (direct) latent typing in Java
35801: 4613:import typeinfo.pets.*;
35802: 4614:
35803: 4615:class PerformingDog extends Dog implements Performs {
35804: 4616:    @Override
35805: 4617:    public void speak() { System.out.println("Woof!"); }
35806: 4618:    @Override
35807: 4619:    public void sit() { System.out.println("Sitting"); }
35808: 4620:    public void reproduce() {}
35809: 4621:}
35810: 4622:
35811: 4623:class Robot implements Performs {
35812: 4624:    public void speak() { System.out.println("Click!"); }
35813: 4625:    public void sit() { System.out.println("Clank!"); }
35814: 4626:    public void oilChange() {}
35815: 4627:}
35816: 4628:
35817: 4629:class Communicate {
35818: 4630:    public static <T extends Performs>
35819: 4631:      void perform(T performer) {
35820: 4632:        performer.speak();
35821: 4633:        performer.sit();
35822: 4634:    }
35823: 4635:}
35824: 4636:
35825: 4637:public class DogsAndRobots {
35826: 4638:    public static void main(String[] args) {
35827: 4639:        Communicate.perform(new PerformingDog());
35828: 4640:        Communicate.perform(new Robot());
35829: 4641:    }
35830: 4642:}
35831: 4643:/* Output:
35832: 4644:Woof!
35833: 4645:Sitting
35834: 4646:Click!
35835: 4647:Clank!
35836: 4648:*/
35837: 4649:```
35838: 4650:
35839: 4651:但是要注意，`perform()` 不需要使用泛型来工作，它可以被简单地指定为接受一个 **Performs** 对象：
35840: 4652:
35841: 4653:```java
35842: 4654:// generics/SimpleDogsAndRobots.java
35843: 4655:// Removing the generic; code still works
35844: 4656:
35845: 4657:class CommunicateSimply {
35846: 4658:    static void perform(Performs performer) {
35847: 4659:        performer.speak();
35848: 4660:        performer.sit();
35849: 4661:    }
35850: 4662:}
35851: 4663:
35852: 4664:public class SimpleDogsAndRobots {
35853: 4665:    public static void main(String[] args) {
35854: 4666:        CommunicateSimply.perform(new PerformingDog());
35855: 4667:        CommunicateSimply.perform(new Robot());
35856: 4668:    }
35857: 4669:}
35858: 4670:/* Output:
35859: 4671:Woof!
35860: 4672:Sitting
35861: 4673:Click!
35862: 4674:Clank!
35863: 4675:*/
35864: 4676:```
35865: 4677:
35866: 4678:在本例中，泛型不是必需的，因为这些类已经被强制要求实现 **Performs** 接口。
35867: 4679:
35868: 4680:<!-- Compensating for the Lack of (Direct) Latent -->
35869: 4681:
35870: 4682:## 对缺乏潜在类型机制的补偿
35871: 4683:
35872: 4684:尽管 Java 不直接支持潜在类型机制，但是这并不意味着泛型代码不能在不同的类型层次结构之间应用。也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。
35873: 4685:
35874: 4686:### 反射
35875: 4687:
35876: 4688:可以使用的一种方式是反射，下面的 `perform()` 方法就是用了潜在类型机制：
35877: 4689:
35878: 4690:```java
35879: 4691:// generics/LatentReflection.java
35880: 4692:// Using reflection for latent typing
35881: 4693:import java.lang.reflect.*;
35882: 4694:
35883: 4695:// Does not implement Performs:
35884: 4696:class Mime {
35885: 4697:    public void walkAgainstTheWind() {}
35886: 4698:    public void sit() {
35887: 4699:        System.out.println("Pretending to sit");
35888: 4700:    }
35889: 4701:    public void pushInvisibleWalls() {}
35890: 4702:    @Override
35891: 4703:    public String toString() { return "Mime"; }
35892: 4704:}
35893: 4705:
35894: 4706:// Does not implement Performs:
35895: 4707:class SmartDog {
35896: 4708:    public void speak() { System.out.println("Woof!"); }
35897: 4709:    public void sit() { System.out.println("Sitting"); }
35898: 4710:    public void reproduce() {}
35899: 4711:}
35900: 4712:
35901: 4713:class CommunicateReflectively {
35902: 4714:    public static void perform(Object speaker) {
35903: 4715:        Class<?> spkr = speaker.getClass();
35904: 4716:        try {
35905: 4717:            try {
35906: 4718:                Method speak = spkr.getMethod("speak");
35907: 4719:                speak.invoke(speaker);
35908: 4720:            } catch(NoSuchMethodException e) {
35909: 4721:                System.out.println(speaker + " cannot speak");
35910: 4722:            }
35911: 4723:            try {
35912: 4724:                Method sit = spkr.getMethod("sit");
35913: 4725:                sit.invoke(speaker);
35914: 4726:            } catch(NoSuchMethodException e) {
35915: 4727:                System.out.println(speaker + " cannot sit");
35916: 4728:            }
35917: 4729:        } catch(SecurityException |
35918: 4730:            IllegalAccessException |
35919: 4731:            IllegalArgumentException |
35920: 4732:            InvocationTargetException e) {
35921: 4733:            throw new RuntimeException(speaker.toString(), e);
35922: 4734:        }
35923: 4735:    }
35924: 4736:}
35925: 4737:
35926: 4738:public class LatentReflection {
35927: 4739:    public static void main(String[] args) {
35928: 4740:        CommunicateReflectively.perform(new SmartDog());
35929: 4741:        CommunicateReflectively.perform(new Robot());
35930: 4742:        CommunicateReflectively.perform(new Mime());
35931: 4743:    }
35932: 4744:}
35933: 4745:/* Output:
35934: 4746:Woof!
35935: 4747:Sitting
35936: 4748:Click!
35937: 4749:Clank!
35938: 4750:Mime cannot speak
35939: 4751:Pretending to sit
35940: 4752:*/
35941: 4753:```
35942: 4754:
35943: 4755:上例中，这些类完全是彼此分离的，没有任何公共基类（除了 **Object** ）或接口。通过反射, `CommunicateReflectively.perform()` 能够动态地确定所需要的方法是否可用并调用它们。它甚至能够处理 **Mime** 只具有一个必需的方法这一事实，并能够部分实现其目标。
35944: 4756:
35945: 4757:### 将一个方法应用于序列
35946: 4758:
35947: 4759:反射提供了一些有用的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。但是有可能实现编译期类型检查和潜在类型机制吗？
35948: 4760:
35949: 4761:让我们看一个说明这个问题的示例。假设想要创建一个 `apply()` 方法，它能够将任何方法应用于某个序列中的所有对象。这种情况下使用接口不适合，因为你想要将任何方法应用于一个对象集合，而接口不可能描述任何方法。如何用 Java 来实现这个需求呢？
35950: 4762:
35951: 4763:最初，我们可以用反射来解决这个问题，由于有了 Java 的可变参数，这种方式被证明是相当优雅的：
35952: 4764:
35953: 4765:```java
35954: 4766:// generics/Apply.java
35955: 4767:
35956: 4768:import java.lang.reflect.*;
35957: 4769:import java.util.*;
35958: 4770:
35959: 4771:public class Apply {
35960: 4772:    public static <T, S extends Iterable<T>>
35961: 4773:      void apply(S seq, Method f, Object... args) {
35962: 4774:        try {
35963: 4775:            for(T t: seq)
35964: 4776:                f.invoke(t, args);
35965: 4777:        } catch(IllegalAccessException |
35966: 4778:            IllegalArgumentException |
35967: 4779:            InvocationTargetException e) {
35968: 4780:            // Failures are programmer errors
35969: 4781:            throw new RuntimeException(e);
35970: 4782:        }
35971: 4783:    }
35972: 4784:}
35973: 4785:```
35974: 4786:
35975: 4787:在 **Apply.java** 中，异常被转换为 **RuntimeException** ，因为没有多少办法可以从这种异常中恢复——在这种情况下，它们实际上代表着程序员的错误。
35976: 4788:
35977: 4789:为什么我们不只使用 Java 8 方法参考（稍后显示）而不是反射方法 **f** ？ 注意，`invoke()` 和 `apply()` 的优点是它们可以接受任意数量的参数。 在某些情况下，灵活性可能至关重要。
35978: 4790:
35979: 4791:为了测试 **Apply** ，我们首先创建一个 **Shape** 类：
35980: 4792:
35981: 4793:```java
35982: 4794:// generics/Shape.java
35983: 4795:
35984: 4796:public class Shape {
35985: 4797:    private static long counter = 0;
35986: 4798:    private final long id = counter++;
35987: 4799:    @Override
35988: 4800:    public String toString() {
35989: 4801:        return getClass().getSimpleName() + " " + id;
35990: 4802:    }
35991: 4803:    public void rotate() {
35992: 4804:        System.out.println(this + " rotate");
35993: 4805:    }
35994: 4806:    public void resize(int newSize) {
35995: 4807:        System.out.println(this + " resize " + newSize);
35996: 4808:    }
35997: 4809:}
35998: 4810:```
35999: 4811:
36000: 4812:被一个子类 **Square** 继承：
36001: 4813:
36002: 4814:```java
36003: 4815:// generics/Square.java
36004: 4816:
36005: 4817:public class Square extends Shape {}
36006: 4818:```
36007: 4819:
36008: 4820:通过这些，我们可以测试 **Apply**：
36009: 4821:
36010: 4822:```java
36011: 4823:// generics/ApplyTest.java
36012: 4824:
36013: 4825:import java.util.*;
36014: 4826:import java.util.function.*;
36015: 4827:import onjava.*;
36016: 4828:
36017: 4829:public class ApplyTest {
36018: 4830:    public static
36019: 4831:    void main(String[] args) throws Exception {
36020: 4832:        List<Shape> shapes =
36021: 4833:          Suppliers.create(ArrayList::new, Shape::new, 3);
36022: 4834:        Apply.apply(shapes, Shape.class.getMethod("rotate"));
36023: 4835:        Apply.apply(shapes, Shape.class.getMethod("resize", int.class), 7);
36024: 4836:
36025: 4837:        List<Square> squares =
36026: 4838:          Suppliers.create(ArrayList::new, Square::new, 3);
36027: 4839:        Apply.apply(squares, Shape.class.getMethod("rotate"));
36028: 4840:        Apply.apply(squares, Shape.class.getMethod("resize", int.class), 7);
36029: 4841:
36030: 4842:        Apply.apply(new FilledList<>(Shape::new, 3),
36031: 4843:          Shape.class.getMethod("rotate"));
36032: 4844:        Apply.apply(new FilledList<>(Square::new, 3),
36033: 4845:          Shape.class.getMethod("rotate"));
36034: 4846:
36035: 4847:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
36036: 4848:          new SimpleQueue<>(), SimpleQueue::add,
36037: 4849:          Shape::new, 3);
36038: 4850:        Suppliers.fill(shapeQ, SimpleQueue::add,
36039: 4851:          Square::new, 3);
36040: 4852:        Apply.apply(shapeQ, Shape.class.getMethod("rotate"));
36041: 4853:    }
36042: 4854:}
36043: 4855:/* Output:
36044: 4856:Shape 0 rotate
36045: 4857:Shape 1 rotate
36046: 4858:Shape 2 rotate
36047: 4859:Shape 0 resize 7
36048: 4860:Shape 1 resize 7
36049: 4861:Shape 2 resize 7
36050: 4862:Square 3 rotate
36051: 4863:Square 4 rotate
36052: 4864:Square 5 rotate
36053: 4865:Square 3 resize 7
36054: 4866:Square 4 resize 7
36055: 4867:Square 5 resize 7
36056: 4868:Shape 6 rotate
36057: 4869:Shape 7 rotate
36058: 4870:Shape 8 rotate
36059: 4871:Square 9 rotate
36060: 4872:Square 10 rotate
36061: 4873:Square 11 rotate
36062: 4874:Shape 12 rotate
36063: 4875:Shape 13 rotate
36064: 4876:Shape 14 rotate
36065: 4877:Square 15 rotate
36066: 4878:Square 16 rotate
36067: 4879:Square 17 rotate
36068: 4880:*/
36069: 4881:```
36070: 4882:
36071: 4883:在 **Apply** 中，我们运气很好，因为碰巧在 Java 中内建了一个由 Java 集合类库使用的 **Iterable** 接口。正由于此， `apply()` 方法可以接受任何实现了 **Iterable** 接口的事物，包括诸如 **List** 这样的所有 **Collection** 类。但是它还可以接受其他任何事物，只要能够使这些事物是 **Iterable** 的——例如，在 `main()` 中使用下面定义的 **SimpleQueue** 类：
36072: 4884:
36073: 4885:```java
36074: 4886:// generics/SimpleQueue.java
36075: 4887:
36076: 4888:// A different kind of Iterable collection
36077: 4889:import java.util.*;
36078: 4890:
36079: 4891:public class SimpleQueue<T> implements Iterable<T> {
36080: 4892:    private LinkedList<T> storage = new LinkedList<>();
36081: 4893:    public void add(T t) { storage.offer(t); }
36082: 4894:    public T get() { return storage.poll(); }
36083: 4895:    @Override
36084: 4896:    public Iterator<T> iterator() {
36085: 4897:        return storage.iterator();
36086: 4898:    }
36087: 4899:}
36088: 4900:```
36089: 4901:
36090: 4902:正如反射解决方案看起来那样优雅，我们必须观察到反射（尽管在 Java 的最新版本中得到了显着改进）通常比非反射实现要慢，因为在运行时发生了很多事情。 但它不应阻止您尝试这种解决方案，这依然是值得考虑的一点。
36091: 4903:
36092: 4904:几乎可以肯定，你会首先使用 Java 8 的函数式方法，并且只有在解决了特殊需求时才诉诸反射。 这里对 **ApplyTest.java** 进行了重写，以利用 Java 8 的流和函数工具：
36093: 4905:
36094: 4906:```java
36095: 4907:// generics/ApplyFunctional.java
36096: 4908:
36097: 4909:import java.util.*;
36098: 4910:import java.util.stream.*;
36099: 4911:import java.util.function.*;
36100: 4912:import onjava.*;
36101: 4913:
36102: 4914:public class ApplyFunctional {
36103: 4915:    public static void main(String[] args) {
36104: 4916:        Stream.of(
36105: 4917:          Stream.generate(Shape::new).limit(2),
36106: 4918:          Stream.generate(Square::new).limit(2))
36107: 4919:        .flatMap(c -> c) // flatten into one stream
36108: 4920:        .peek(Shape::rotate)
36109: 4921:        .forEach(s -> s.resize(7));
36110: 4922:
36111: 4923:        new FilledList<>(Shape::new, 2)
36112: 4924:          .forEach(Shape::rotate);
36113: 4925:        new FilledList<>(Square::new, 2)
36114: 4926:          .forEach(Shape::rotate);
36115: 4927:
36116: 4928:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
36117: 4929:          new SimpleQueue<>(), SimpleQueue::add,
36118: 4930:          Shape::new, 2);
36119: 4931:        Suppliers.fill(shapeQ, SimpleQueue::add,
36120: 4932:          Square::new, 2);
36121: 4933:        shapeQ.forEach(Shape::rotate);
36122: 4934:    }
36123: 4935:}
36124: 4936:/* Output:
36125: 4937:Shape 0 rotate
36126: 4938:Shape 0 resize 7
36127: 4939:Shape 1 rotate
36128: 4940:Shape 1 resize 7
36129: 4941:Square 2 rotate
36130: 4942:Square 2 resize 7
36131: 4943:Square 3 rotate
36132: 4944:Square 3 resize 7
36133: 4945:Shape 4 rotate
36134: 4946:Shape 5 rotate
36135: 4947:Square 6 rotate
36136: 4948:Square 7 rotate
36137: 4949:Shape 8 rotate
36138: 4950:Shape 9 rotate
36139: 4951:Square 10 rotate
36140: 4952:Square 11 rotate
36141: 4953:*/
36142: 4954:```
36143: 4955:
36144: 4956:由于使用 Java 8，因此不需要 `Apply.apply()` 。
36145: 4957:
36146: 4958:我们首先生成两个 **Stream** ： 一个是 **Shape** ，一个是 **Square** ，并将它们展平为单个流。 尽管 Java 缺少功能语言中经常出现的 `flatten()` ，但是我们可以使用 `flatMap(c-> c)` 产生相同的结果，后者使用身份映射将操作简化为“  **flatten** ”。
36147: 4959:
36148: 4960:我们使用 `peek()` 当做对 `rotate()` 的调用，因为 `peek()` 执行一个操作（此处是出于副作用），并在未更改的情况下传递对象。
36149: 4961:
36150: 4962:注意，使用 **FilledList** 和 **shapeQ** 调用 `forEach()` 比 `Apply.apply()` 代码整洁得多。 在代码简单性和可读性方面，结果比以前的方法好得多。 并且，现在也不可能从  `main()` 引发异常。
36151: 4963:
36152: 4964:<!-- Assisted Latent Typing in Java 8 -->
36153: 4965:
36154: 4966:## Java8 中的辅助潜在类型
36155: 4967:
36156: 4968:先前声明关于 Java 缺乏对潜在类型的支持在 Java 8 之前是完全正确的。但是，Java 8 中的非绑定方法引用使我们能够产生一种潜在类型的形式，以满足创建一段可工作在不相干类型上的代码。因为 Java 最初并不是如此设计，所以结果可想而知，比其他语言中要尴尬一些。但是，至少现在成为了可能，只是缺乏令人惊艳之处。
36157: 4969:
36158: 4970:我在其他地方从没遇过这种技术，因此我将其称为辅助潜在类型。
36159: 4971:
36160: 4972:我们将重写 **DogsAndRobots.java** 来演示该技术。 为使外观看起来与原始示例尽可能相似，我仅向每个原始类名添加了 **A**：
36161: 4973:
36162: 4974:```java
36163: 4975:// generics/DogsAndRobotMethodReferences.java
36164: 4976:
36165: 4977:// "Assisted Latent Typing"
36166: 4978:import typeinfo.pets.*;
36167: 4979:import java.util.function.*;
36168: 4980:
36169: 4981:class PerformingDogA extends Dog {
36170: 4982:    public void speak() { System.out.println("Woof!"); }
36171: 4983:    public void sit() { System.out.println("Sitting"); }
36172: 4984:    public void reproduce() {}
36173: 4985:}
36174: 4986:
36175: 4987:class RobotA {
36176: 4988:    public void speak() { System.out.println("Click!"); }
36177: 4989:    public void sit() { System.out.println("Clank!"); }
36178: 4990:    public void oilChange() {}
36179: 4991:}
36180: 4992:
36181: 4993:class CommunicateA {
36182: 4994:    public static <P> void perform(P performer,
36183: 4995:      Consumer<P> action1, Consumer<P> action2) {
36184: 4996:        action1.accept(performer);
36185: 4997:        action2.accept(performer);
36186: 4998:    }
36187: 4999:}
36188: 5000:
36189: 5001:public class DogsAndRobotMethodReferences {
36190: 5002:    public static void main(String[] args) {
36191: 5003:        CommunicateA.perform(new PerformingDogA(),
36192: 5004:          PerformingDogA::speak, PerformingDogA::sit);
36193: 5005:        CommunicateA.perform(new RobotA(),
36194: 5006:          RobotA::speak, RobotA::sit);
36195: 5007:        CommunicateA.perform(new Mime(),
36196: 5008:          Mime::walkAgainstTheWind,
36197: 5009:          Mime::pushInvisibleWalls);
36198: 5010:    }
36199: 5011:}
36200: 5012:/* Output:
36201: 5013:Woof!
36202: 5014:Sitting
36203: 5015:Click!
36204: 5016:Clank!
36205: 5017:*/
36206: 5018:```
36207: 5019:
36208: 5020:**PerformingDogA** 和 **RobotA** 与 **DogsAndRobots.java** 中的相同，不同之处在于它们不继承通用接口 **Performs** ，因此它们没有通用性。
36209: 5021:
36210: 5022:`CommunicateA.perform()` 在没有约束的 **P** 上生成。 只要可以使用 `Consumer <P>`，它在这里就可以是任何东西，这些 `Consumer<P>` 代表不带参数的 **P** 方法的未绑定方法引用。当您调用 **Consumer**  的 `accept()` 方法时，它将方法引用绑定到执行者对象并调用该方法。 由于 [函数式编程](book/13-Functional-Programming.md) 一章中描述的“魔术”，我们可以将任何符合签名的未绑定方法引用传递给 `CommunicateA.perform()` 。
36211: 5023:
36212: 5024:之所以称其为“辅助”，是因为您必须显式地为 `perform()` 提供要使用的方法引用。 它不能只按名称调用方法。
36213: 5025:
36214: 5026:尽管传递未绑定的方法引用似乎要花很多力气，但潜在类型的最终目标还是可以实现的。 我们创建了一个代码片段 `CommunicateA.perform()` ，该代码可用于任何具有符合签名的方法引用的类型。 请注意，这与我们看到的其他语言中的潜在类型有所不同，因为这些语言不仅需要签名以符合规范，还需要方法名称。 因此，该技术可以说产生了更多的通用代码。
36215: 5027:
36216: 5028:为了证明这一点，我还从 **LatentReflection.java** 中引入了 **Mime**。
36217: 5029:
36218: 5030:### 使用**Suppliers**类的通用方法
36219: 5031:
36220: 5032:通过辅助潜在类型，我们可以定义本章其他部分中使用的 **Suppliers** 类。 此类包含使用生成器填充 **Collection** 的工具方法。 泛化这些操作很有意义：
36221: 5033:
36222: 5034:```java
36223: 5035:// onjava/Suppliers.java
36224: 5036:
36225: 5037:// A utility to use with Suppliers
36226: 5038:package onjava;
36227: 5039:import java.util.*;
36228: 5040:import java.util.function.*;
36229: 5041:import java.util.stream.*;
36230: 5042:
36231: 5043:public class Suppliers {
36232: 5044:    // Create a collection and fill it:
36233: 5045:    public static <T, C extends Collection<T>> C
36234: 5046:      create(Supplier<C> factory, Supplier<T> gen, int n) {
36235: 5047:        return Stream.generate(gen)
36236: 5048:            .limit(n)
36237: 5049:            .collect(factory, C::add, C::addAll);
36238: 5050:    }
36239: 5051:    
36240: 5052:    // Fill an existing collection:
36241: 5053:    public static <T, C extends Collection<T>>
36242: 5054:      C fill(C coll, Supplier<T> gen, int n) {
36243: 5055:        Stream.generate(gen)
36244: 5056:            .limit(n)
36245: 5057:            .forEach(coll::add);
36246: 5058:        return coll;
36247: 5059:    }
36248: 5060:    
36249: 5061:    // Use an unbound method reference to
36250: 5062:    // produce a more general method:
36251: 5063:    public static <H, A> H fill(H holder,
36252: 5064:      BiConsumer<H, A> adder, Supplier<A> gen, int n) {
36253: 5065:        Stream.generate(gen)
36254: 5066:            .limit(n)
36255: 5067:            .forEach(a -> adder.accept(holder, a));
36256: 5068:        return holder;
36257: 5069:    }
36258: 5070:}
36259: 5071:```
36260: 5072:
36261: 5073:`create()` 为你创建一个新的 **Collection** 子类型，而 `fill()` 的第一个版本将元素放入 **Collection** 的现有子类型中。 请注意，还会返回传入的容器的确切类型，因此不会丢失类型信息。[^6]
36262: 5074:
36263: 5075:前两种方法一般都受约束，只能与 **Collection** 子类型一起使用。`fill()` 的第二个版本适用于任何类型的 **holder** 。 它需要一个附加参数：未绑定方法引用 `adder. fill()` ，使用辅助潜在类型来使其与任何具有添加元素方法的 **holder** 类型一起使用。因为此未绑定方法 **adder** 必须带有一个参数（要添加到 **holder** 的元素），所以 **adder** 必须是 `BiConsumer <H，A>` ，其中 **H** 是要绑定到的 **holder** 对象的类型，而 **A** 是要被添加的绑定元素类型。 对 `accept()` 的调用将使用参数 a 调用对象 **holder** 上的未绑定方法 **holder**。
36264: 5076:
36265: 5077:在一个稍作模拟的测试中对 **Suppliers** 工具程序进行了测试，该仿真还使用了本章前面定义的 **RandomList** ：
36266: 5078:
36267: 5079:```java
36268: 5080:// generics/BankTeller.java
36269: 5081:
36270: 5082:// A very simple bank teller simulation
36271: 5083:import java.util.*;
36272: 5084:import onjava.*;
36273: 5085:
36274: 5086:class Customer {
36275: 5087:    private static long counter = 1;
36276: 5088:    private final long id = counter++;
36277: 5089:    @Override
36278: 5090:    public String toString() {
36279: 5091:        return "Customer " + id;
36280: 5092:    }
36281: 5093:}
36282: 5094:
36283: 5095:class Teller {
36284: 5096:    private static long counter = 1;
36285: 5097:    private final long id = counter++;
36286: 5098:    @Override
36287: 5099:    public String toString() {
36288: 5100:        return "Teller " + id;
36289: 5101:    }
36290: 5102:}
36291: 5103:
36292: 5104:class Bank {
36293: 5105:    private List<BankTeller> tellers =
36294: 5106:        new ArrayList<>();
36295: 5107:    public void put(BankTeller bt) {
36296: 5108:        tellers.add(bt);
36297: 5109:    }
36298: 5110:}
36299: 5111:
36300: 5112:public class BankTeller {
36301: 5113:    public static void serve(Teller t, Customer c) {
36302: 5114:        System.out.println(t + " serves " + c);
36303: 5115:    }
36304: 5116:    public static void main(String[] args) {
36305: 5117:        // Demonstrate create():
36306: 5118:        RandomList<Teller> tellers =
36307: 5119:            Suppliers.create(
36308: 5120:            RandomList::new, Teller::new, 4);
36309: 5121:        // Demonstrate fill():
36310: 5122:        List<Customer> customers = Suppliers.fill(
36311: 5123:            new ArrayList<>(), Customer::new, 12);
36312: 5124:        customers.forEach(c ->
36313: 5125:            serve(tellers.select(), c));
36314: 5126:        // Demonstrate assisted latent typing:
36315: 5127:        Bank bank = Suppliers.fill(
36316: 5128:            new Bank(), Bank::put, BankTeller::new, 3);
36317: 5129:        // Can also use second version of fill():
36318: 5130:        List<Customer> customers2 = Suppliers.fill(
36319: 5131:            new ArrayList<>(),
36320: 5132:            List::add, Customer::new, 12);
36321: 5133:    }
36322: 5134:}
36323: 5135:/* Output:
36324: 5136:Teller 3 serves Customer 1
36325: 5137:Teller 2 serves Customer 2
36326: 5138:Teller 3 serves Customer 3
36327: 5139:Teller 1 serves Customer 4
36328: 5140:Teller 1 serves Customer 5
36329: 5141:Teller 3 serves Customer 6
36330: 5142:Teller 1 serves Customer 7
36331: 5143:Teller 2 serves Customer 8
36332: 5144:Teller 3 serves Customer 9
36333: 5145:Teller 3 serves Customer 10
36334: 5146:Teller 2 serves Customer 11
36335: 5147:Teller 4 serves Customer 12
36336: 5148:*/
36337: 5149:```
36338: 5150:
36339: 5151:可以看到 `create()` 生成一个新的 **Collection** 对象，而 `fill()` 添加到现有 **Collection** 中。第二个版本`fill()` 显示，它不仅与无关的新类型 **Bank** 一起使用，还能与 **List** 一起使用。因此，从技术上讲，`fill()` 的第一个版本在技术上不是必需的，但在使用 **Collection** 时提供了较短的语法。
36340: 5152:
36341: 5153:<!-- Summary: Is Casting Really So Bad? -->
36342: 5154:
36343: 5155:## 总结：类型转换真的如此之糟吗？
36344: 5156:
36345: 5157:自从 C++ 模版出现以来，我就一直在致力于解释它，我可能比大多数人都更早地提出了下面的论点。直到最近，我才停下来，去思考这个论点到底在多少时间内是有效的——我将要描述的问题到底有多少次可以穿越障碍得以解决。
36346: 5158:
36347: 5159:这个论点就是：使用泛型类型机制的最吸引人的地方，就是在使用集合类的地方，这些类包括诸如各种 **List** 、各种 **Set** 、各种 **Map** 等你在 [集合](book/12-Collections.md) 和 [附录：集合主题](book/Appendix-Collection-Topics.md) 这两章所见。在 Java 5 之前，当你将一个对象放置到集合中时，这个对象就会被向上转型为 **Object** ，因此你会丢失类型信息。当你想要将这个对象从集合中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。我用的示例是持有 **Cat** 的 **List** （这个示例的一种使用苹果和桔子的变体在 [集合](book/12-Collections.md) 章节的开头展示过）。如果没有 Java 5 泛型版本的集合，你放到容集里和从集合中取回的都是 **Object** 。因此，我们很可能会将一个 **Dog** 放置到 **Cat** 的 **List** 中。
36348: 5160:
36349: 5161:但是，泛型出现之前的 Java 并不会让你误用放入到集合中的对象。如果将一个 **Dog** 扔到 **Cat** 的集合中，并且试图将这个集合中的所有东西都当作 **Cat** 处理，那么当你从这个 **Cat** 集合中取回那个 **Dog** 引用，并试图将其转型为 **Cat** 时，就会得到一个 **RuntimeException** 。你仍旧可以发现问题，但是是在运行时而非编译期发现它的。
36350: 5162:
36351: 5163:在本书以前的版本中，我曾经说过：
36352: 5164:
36353: 5165:> 这不止令人恼火，它还可能会产生难以发现的缺陷。如果这个程序的某个部分（或数个部分）向集合中插入了对象，并且通过异常，你在程序的另一个独立的部分中发现有不良对象被放置到了集合中，那么必须发现这个不良插入到底是在何处发生的。
36354: 5166:
36355: 5167:但是，随着对这个论点的进一步检查，我开始怀疑它了。首先，这会多么频繁地发生呢？我记得这类事情从未发生在我身上，并且当我在会议上询问其他人时，我也从来没有听说过有人碰上过。另一本书使用了一个称为 **files** 的 list 示例，它包含 **String** 对象。在这个示例中，向 **files** 中添加一个 **File** 对象看起来相当自然，因此这个对象的名字可能叫 **fileNames** 更好。无论 Java 提供了多少类型检查，仍旧可能会写出晦涩的程序，而编写差劲儿的程序即便可以编译，它仍旧是编写差劲儿的程序。可能大多数人都会使用命名良好的集合，例如 **cats** ，因为它们可以向试图添加非 **Cat** 对象的程序员提供可视的警告。并且即便这类事情发生了，它真正又能潜伏多久呢？只要你开始用真实数据来运行测试，就会非常快地看到异常。
36356: 5168:
36357: 5169:有一位作者甚至断言，这样的缺陷将“*潜伏数年*”。但是我不记得有任何大量的相关报告，来说明人们在查找“狗在猫列表中”这类缺陷时困难重重，或者是说明人们会非常频繁地产生这种错误。然而，你将在 [多线程编程](book/24-Concurrent-Programming.md) 章节中看到，在使用线程时，出现那些可能看起来极罕见的缺陷，是很寻常并容易发生的事，而且，对于到底出了什么错，这些缺陷只能给你一个很模糊的概念。因此，对于泛型是添加到 Java 中的非常显著和相当复杂的特性这一点，“狗在猫列表中”这个论据真的能够成为它的理由吗？
36358: 5170:我相信被称为*泛型*的通用语言特性（并非必须是其在 Java 中的特定实现）的目的在于可表达性，而不仅仅是为了创建类型安全的集合。类型安全的集合是能够创建更通用代码这一能力所带来的副作用。
36359: 5171:因此，即便“狗在猫列表中”这个论据经常被用来证明泛型是必要的，但是它仍旧是有问题的。就像我在本章开头声称的，我不相信这就是泛型这个概念真正的含义。相反，泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。正如你在本章中看到的，编写真正泛化的“持有器”类（ Java 的容器就是这种类）相当简单，但是编写出能够操作其泛型类型的泛化代码就需要额外的努力了，这些努力需要类创建者和类消费者共同付出，他们必须理解这些代码的概念和实现。这些额外的努力会增加使用这种特性的难度，并可能会因此而使其在某些场合缺乏可应用性，而在这些场合中，它可能会带来附加的价值。
36360: 5172:
36361: 5173:还要注意到，因为泛型是后来添加到 Java 中，而不是从一开始就设计到这种语言中的，所以某些容器无法达到它们应该具备的健壮性。例如，观察一下 **Map** ，在特定的方法 `containsKey(Object key) `和 `get(Object key)` 中就包含这类情况。如果这些类是使用在它们之前就存在的泛型设计的，那么这些方法将会使用参数化类型而不是 **Object** ，因此也就可以提供这些泛型假设会提供的编译期检查。例如，在 C++ 的 **map** 中，键的类型总是在编译期检查的。
36362: 5174:
36363: 5175:有一件事很明显：在一种语言已经被广泛应用之后，在其较新的版本中引入任何种类的泛型机制，都会是一项非常非常棘手的任务，并且是一项不付出艰辛就无法完成的任务。在 C++ 中，模版是在其最初的 ISO 版本中就引入的（即便如此，也引发了阵痛，因为在第一个标准 C++ 出现之前，有很多非模版版本在使用），因此实际上模版一直都是这种语言的一部分。在 Java 中，泛型是在这种语言首次发布大约 10 年之后才引入的，因此向泛型迁移的问题特别多，并且对泛型的设计产生了明显的影响。其结果就是，程序员将承受这些痛苦，而这一切都是由于 Java 设计者在设计 1.0 版本时所表现出来的短视造成的。当 Java 最初被创建时，它的设计者们当然了解 C++ 的模版，他们甚至考虑将其囊括到 Java 语言中，但是出于这样或那样的原因，他们决定将模版排除在外（其迹象就是他们过于匆忙）。因此， Java 语言和使用它的程序员都将承受这些痛苦。只有时间将会说明 Java 的泛型方式对这种语言所造成的最终影响。
36364: 5176:某些语言，已经融入了更简洁、影响更小的方式，来实现参数化类型。我们不可能不去想象这样的语言将会成为 Java 的继任者，因为它们采用的方式，与 C++ 通过 C 来实现的方式相同：按原样使用它，然后对其进行改进。
36365: 5177:
36366: 5178:## 进阶阅读
36367: 5179:
36368: 5180:泛型的入门文档是 《Generics in the Java Programming Language》，作者是 Gilad Bracha，可以从 http://java.oracle.com 获取。
36369: 5181:
36370: 5182:Angelika Langer 的《Java Generics FAQs》是一份非常有帮助的资料，可以从 http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html 获取。
36371: 5183:
36372: 5184:你可以从 《Adding Wildcards to the Java Programming Language》中学到更多关于通配符的知识，作者是 Torgerson、Ernst、Hansen、von der Ahe、Bracha 和 Gafter，地址是 http://www.jot.fm/issues/issue_2004_12/article5。
36373: 5185:
36374: 5186:Neal After 对于 Java 问题（尤其是擦除）的看法可以从这里找到：http://www.infoq.com/articles/neal-gafter-on-java。
36375: 5187:
36376: 5188:[^1]: 在编写本章期间，Angelika Langer的 Java 泛型常见问题解答以及她的其他著作（与Klaus Kreft一起）是非常宝贵的。
36377: 5189:[^2]: [http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html](http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html)
36378: 5190:[^3]: 参见本章章末引文。
36379: 5191:[^4]: 注意，一些编程环境，如 Eclipse 和 IntelliJ IDEA，将会自动生成委托代码。
36380: 5192:[^5]: 因为可以使用转型，有效地禁止了类型系统，一些人就认为 C++ 是弱类型，但这太极端了。一种可能更好的说法是 C++ 是有一道暗门的强类型语言。
36381: 5193:[^6]: 我再次从 Brian Goetz 那获得帮助。
36382: 5194:
36383: 5195:<!-- 分页 -->
36384: 5196:
36385: 5197:<div style="page-break-after: always;"></div>
36386: 
36387: 1:[TOC]
36388: 2:
36389: 3:<!-- Generics -->
36390: 4:
36391: 5:# 第二十章 泛型
36392: 6:
36393: 7:> 普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。
36394: 8:
36395: 9:多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。除了 `final` 类（或只提供私有构造函数的类）任何类型都可被扩展，所以大部分时候这种灵活性是自带的。
36396: 10:
36397: 11:拘泥于单一的继承体系太过局限，因为只有继承体系中的对象才能适用基类作为参数的方法中。如果方法以接口而不是类作为参数，限制就宽松多了，只要实现了接口就可以。这给予调用方一种选项，通过调整现有的类来实现接口，满足方法参数要求。接口可以突破继承体系的限制。
36398: 12:
36399: 13:即便是接口也还是有诸多限制。一旦指定了接口，它就要求你的代码必须使用特定的接口。而我们希望编写更通用的代码，能够适用“非特定的类型”，而不是一个具体的接口或类。
36400: 14:
36401: 15:这就是泛型的概念，是 Java 5 的重大变化之一。泛型实现了*参数化类型*，这样你编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。随后你会发现 Java 中泛型的实现并没有那么“泛”，你可能会质疑“泛型”这个词是否合适用来描述这一功能。
36402: 16:
36403: 17:如果你从未接触过参数化类型机制，你会发现泛型对 Java 语言确实是个很有益的补充。在你实例化一个类型参数时，编译器会负责转型并确保类型的正确性。这是一大进步。
36404: 18:
36405: 19:然而，如果你了解其他语言（例如 C++ ）的参数化机制，你会发现，Java 泛型并不能满足所有的预期。使用别人创建好的泛型相对容易，但是创建自己的泛型时，就会遇到很多意料之外的麻烦。
36406: 20:
36407: 21:这并不是说 Java 泛型毫无用处。在很多情况下，它可以使代码更直接更优雅。不过，如果你见识过那种实现了更纯粹的泛型的编程语言，那么，Java 可能会令你失望。本章会介绍 Java 泛型的优点与局限。我会解释 Java 的泛型是如何发展成现在这样的，希望能够帮助你更有效地使用这个特性。[^1]
36408: 22:
36409: 23:### 与 C++ 的比较
36410: 24:
36411: 25:Java 的设计者曾说过，这门语言的灵感主要来自 C++ 。尽管如此，学习 Java 时基本不用参考 C++ 。
36412: 26:
36413: 27:但是，Java 中的泛型需要与 C++ 进行对比，理由有两个：首先，理解 C++ *模板*（泛型的主要灵感来源，包括基本语法）的某些特性，有助于理解泛型的基础理念。同时，非常重要的一点是，你可以了解 Java 泛型的局限是什么，以及为什么会有这些局限。最终的目标是明确 Java 泛型的边界，让你成为一个程序高手。只有知道了某个技术不能做什么，你才能更好地做到所能做的（部分原因是，不必浪费时间在死胡同里）。
36414: 28:
36415: 29:第二个原因是，在 Java 社区中，大家普遍对 C++ 模板有一种误解，而这种误解可能会令你在理解泛型的意图时产生偏差。
36416: 30:
36417: 31:因此，本章中会介绍少量 C++ 模板的例子，仅当它们确实可以加深理解时才会引入。
36418: 32:
36419: 33:<!-- Simple Generics -->
36420: 34:
36421: 35:## 简单泛型
36422: 36:
36423: 37:促成泛型出现的最主要的动机之一是为了创建*集合类*，参见 [集合](book/12-Collections.md) 章节。集合用于存放要使用到的对象。数组也是如此，不过集合比数组更加灵活，功能更丰富。几乎所有程序在运行过程中都会涉及到一组对象，因此集合是可复用性最高的类库之一。
36424: 38:
36425: 39:我们先看一个只能持有单个对象的类。这个类可以明确指定其持有的对象的类型：
36426: 40:
36427: 41:```java
36428: 42:// generics/Holder1.java
36429: 43:
36430: 44:class Automobile {}
36431: 45:
36432: 46:public class Holder1 {
36433: 47:    private Automobile a;
36434: 48:    public Holder1(Automobile a) { this.a = a; }
36435: 49:    Automobile get() { return a; }
36436: 50:}
36437: 51:```
36438: 52:
36439: 53:这个类的可复用性不高，它无法持有其他类型的对象。我们可不希望为碰到的每个类型都编写一个新的类。
36440: 54:
36441: 55:在 Java 5 之前，我们可以让这个类直接持有 `Object` 类型的对象：
36442: 56:
36443: 57:```java
36444: 58:// generics/ObjectHolder.java
36445: 59:
36446: 60:public class ObjectHolder {
36447: 61:    private Object a;
36448: 62:    public ObjectHolder(Object a) { this.a = a; }
36449: 63:    public void set(Object a) { this.a = a; }
36450: 64:    public Object get() { return a; }
36451: 65:    
36452: 66:    public static void main(String[] args) {
36453: 67:        ObjectHolder h2 = new ObjectHolder(new Automobile());
36454: 68:        Automobile a = (Automobile)h2.get();
36455: 69:        h2.set("Not an Automobile");
36456: 70:        String s = (String)h2.get();
36457: 71:        h2.set(1); // 自动装箱为 Integer
36458: 72:        Integer x = (Integer)h2.get();
36459: 73:    }
36460: 74:}
36461: 75:```
36462: 76:
36463: 77:现在，`ObjectHolder` 可以持有任何类型的对象，在上面的示例中，一个 `ObjectHolder` 先后持有了三种不同类型的对象。
36464: 78:
36465: 79:一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。
36466: 80:
36467: 81:因此，与其使用 `Object` ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用*类型参数*，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，`T` 就是类型参数：
36468: 82:
36469: 83:```java
36470: 84:// generics/GenericHolder.java
36471: 85:
36472: 86:public class GenericHolder<T> {
36473: 87:    private T a;
36474: 88:    public GenericHolder() {}
36475: 89:    public void set(T a) { this.a = a; }
36476: 90:    public T get() { return a; }
36477: 91:    
36478: 92:    public static void main(String[] args) {
36479: 93:        GenericHolder<Automobile> h3 = new GenericHolder<Automobile>();
36480: 94:        h3.set(new Automobile()); // 此处有类型校验
36481: 95:        Automobile a = h3.get();  // 无需类型转换
36482: 96:        //- h3.set("Not an Automobile"); // 报错
36483: 97:        //- h3.set(1);  // 报错
36484: 98:    }
36485: 99:}
36486: 100:```
36487: 101:
36488: 102:创建 `GenericHolder` 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 `main()` 中那样使用。然后，你就只能在 `GenericHolder` 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当你调用 `get()` 取值时，直接就是正确的类型。
36489: 103:
36490: 104:这就是 Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。
36491: 105:
36492: 106:你可能注意到 `h3` 的定义非常繁复。在 `=` 左边有 `GenericHolder<Automobile>`, 右边又重复了一次。在 Java 5 中，这种写法被解释成“必要的”，但在 Java 7 中设计者修正了这个问题（新的简写语法随后成为备受欢迎的特性）。以下是简写的例子：
36493: 107:
36494: 108:```java
36495: 109:// generics/Diamond.java
36496: 110:
36497: 111:class Bob {}
36498: 112:
36499: 113:public class Diamond<T> {
36500: 114:    public static void main(String[] args) {
36501: 115:        GenericHolder<Bob> h3 = new GenericHolder<>();
36502: 116:        h3.set(new Bob());
36503: 117:    }
36504: 118:}
36505: 119:```
36506: 120:
36507: 121:注意，在 `h3` 的定义处，`=` 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。在本书剩余部分都会使用这种语法。
36508: 122:
36509: 123:一般来说，你可以认为泛型和其他类型差不多，只不过它们碰巧有类型参数罢了。在使用泛型时，你只需要指定它们的名称和类型参数列表即可。
36510: 124:
36511: 125:### 一个元组类库
36512: 126:
36513: 127:有时一个方法需要能返回多个对象。而 **return** 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得了编译时的类型安全。
36514: 128:
36515: 129:这个概念称为*元组*，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 *数据传输对象* 或 *信使* ）。
36516: 130:
36517: 131:通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组：
36518: 132:
36519: 133:```java
36520: 134:// onjava/Tuple2.java
36521: 135:package onjava;
36522: 136:
36523: 137:public class Tuple2<A, B> {
36524: 138:    public final A a1;
36525: 139:    public final B a2;
36526: 140:    public Tuple2(A a, B b) { a1 = a; a2 = b; }
36527: 141:    public String rep() { return a1 + ", " + a2; }
36528: 142:  
36529: 143:    @Override
36530: 144:    public String toString() {
36531: 145:        return "(" + rep() + ")";
36532: 146:    }
36533: 147:}
36534: 148:```
36535: 149:
36536: 150:构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。
36537: 151:
36538: 152:初次阅读上面的代码时，你可能认为这违反了 Java 编程的封装原则。`a1` 和 `a2` 应该声明为 **private**，然后提供 `getFirst()` 和 `getSecond()` 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取 `a1` 和 `a2` 然后对它们执行任何操作，但无法对 `a1` 和 `a2` 重新赋值。例子中的 `final` 可以实现同样的效果，并且更为简洁明了。
36539: 153:
36540: 154:另一种设计思路是允许元组的用户给 `a1` 和 `a2` 重新赋值。然而，采用上例中的形式无疑更加安全，如果用户想存储不同的元素，就会强制他们创建新的 `Tuple2` 对象。
36541: 155:
36542: 156:我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了：
36543: 157:
36544: 158:```java
36545: 159:// onjava/Tuple3.java
36546: 160:package onjava;
36547: 161:
36548: 162:public class Tuple3<A, B, C> extends Tuple2<A, B> {
36549: 163:    public final C a3;
36550: 164:    public Tuple3(A a, B b, C c) {
36551: 165:        super(a, b);
36552: 166:        a3 = c;
36553: 167:    }
36554: 168:    
36555: 169:    @Override
36556: 170:    public String rep() {
36557: 171:        return super.rep() + ", " + a3;
36558: 172:    }
36559: 173:}
36560: 174:
36561: 175:// onjava/Tuple4.java
36562: 176:package onjava;
36563: 177:
36564: 178:public class Tuple4<A, B, C, D>
36565: 179:  extends Tuple3<A, B, C> {
36566: 180:    public final D a4;
36567: 181:    public Tuple4(A a, B b, C c, D d) {
36568: 182:        super(a, b, c);
36569: 183:        a4 = d;
36570: 184:    }
36571: 185:    
36572: 186:    @Override
36573: 187:    public String rep() {
36574: 188:        return super.rep() + ", " + a4;
36575: 189:    }
36576: 190:}
36577: 191:
36578: 192:// onjava/Tuple5.java
36579: 193:package onjava;
36580: 194:
36581: 195:public class Tuple5<A, B, C, D, E>
36582: 196:  extends Tuple4<A, B, C, D> {
36583: 197:    public final E a5;
36584: 198:    public Tuple5(A a, B b, C c, D d, E e) {
36585: 199:        super(a, b, c, d);
36586: 200:        a5 = e;
36587: 201:    }
36588: 202:    
36589: 203:    @Override
36590: 204:    public String rep() {
36591: 205:        return super.rep() + ", " + a5;
36592: 206:    }
36593: 207:}
36594: 208:```
36595: 209:
36596: 210:演示需要，再定义两个类：
36597: 211:
36598: 212:```java
36599: 213:// generics/Amphibian.java
36600: 214:public class Amphibian {}
36601: 215:
36602: 216:// generics/Vehicle.java
36603: 217:public class Vehicle {}
36604: 218:```
36605: 219:
36606: 220:使用元组时，你只需要定义一个长度适合的元组，将其作为返回值即可。注意下面例子中方法的返回类型：
36607: 221:
36608: 222:```java
36609: 223:// generics/TupleTest.java
36610: 224:import onjava.*;
36611: 225:
36612: 226:public class TupleTest {
36613: 227:    static Tuple2<String, Integer> f() {
36614: 228:        // 47 自动装箱为 Integer
36615: 229:        return new Tuple2<>("hi", 47);
36616: 230:    }
36617: 231:  
36618: 232:    static Tuple3<Amphibian, String, Integer> g() {
36619: 233:        return new Tuple3<>(new Amphibian(), "hi", 47);
36620: 234:    }
36621: 235:  
36622: 236:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
36623: 237:        return new Tuple4<>(new Vehicle(), new Amphibian(), "hi", 47);
36624: 238:    }
36625: 239:  
36626: 240:    static Tuple5<Vehicle, Amphibian, String, Integer, Double> k() {
36627: 241:        return new Tuple5<>(new Vehicle(), new Amphibian(), "hi", 47, 11.1);
36628: 242:    }
36629: 243:  
36630: 244:    public static void main(String[] args) {
36631: 245:        Tuple2<String, Integer> ttsi = f();
36632: 246:        System.out.println(ttsi);
36633: 247:        // ttsi.a1 = "there"; // 编译错误，因为 final 不能重新赋值
36634: 248:        System.out.println(g());
36635: 249:        System.out.println(h());
36636: 250:        System.out.println(k());
36637: 251:    }
36638: 252:}
36639: 253:
36640: 254:/* 输出：
36641: 255: (hi, 47)
36642: 256: (Amphibian@1540e19d, hi, 47)
36643: 257: (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47)
36644: 258: (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1)
36645: 259: */
36646: 260:```
36647: 261:
36648: 262:有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。
36649: 263:
36650: 264:通过 `ttsi.a1 = "there"` 语句的报错，我们可以看出，**final** 声明确实可以确保 **public** 字段在对象被构造出来之后就不能重新赋值了。
36651: 265:
36652: 266:在上面的程序中，`new` 表达式有些啰嗦。本章稍后会介绍，如何利用 *泛型方法* 简化它们。
36653: 267:
36654: 268:### 一个堆栈类
36655: 269:
36656: 270:接下来我们看一个稍微复杂一点的例子：堆栈。在 [集合](book/12-Collections.md) 一章中，我们用 `LinkedList` 实现了 `onjava.Stack` 类。在那个例子中，`LinkedList` 本身已经具备了创建堆栈所需的方法。`Stack` 是通过两个泛型类 `Stack<T>` 和 `LinkedList<T>` 的组合来创建。我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。
36657: 271:
36658: 272:这次我们不用 `LinkedList` 来实现自己的内部链式存储机制。
36659: 273:
36660: 274:```java
36661: 275:// generics/LinkedStack.java
36662: 276:// 用链式结构实现的堆栈
36663: 277:
36664: 278:public class LinkedStack<T> {
36665: 279:    private static class Node<U> {
36666: 280:        U item;
36667: 281:        Node<U> next;
36668: 282:    
36669: 283:        Node() { item = null; next = null; }
36670: 284:        
36671: 285:        Node(U item, Node<U> next) {
36672: 286:            this.item = item;
36673: 287:            this.next = next;
36674: 288:        }
36675: 289:    
36676: 290:        boolean end() {
36677: 291:            return item == null && next == null;
36678: 292:        }
36679: 293:    }
36680: 294:  
36681: 295:    private Node<T> top = new Node<>();  // 栈顶
36682: 296:  
36683: 297:    public void push(T item) {
36684: 298:        top = new Node<>(item, top);
36685: 299:    }
36686: 300:  
36687: 301:    public T pop() {
36688: 302:        T result = top.item;
36689: 303:        if (!top.end()) {
36690: 304:            top = top.next;
36691: 305:        }
36692: 306:        return result;
36693: 307:    }
36694: 308:  
36695: 309:    public static void main(String[] args) {
36696: 310:        LinkedStack<String> lss = new LinkedStack<>();
36697: 311:        for (String s : "Phasers on stun!".split(" ")) {
36698: 312:            lss.push(s);
36699: 313:        }
36700: 314:        String s;
36701: 315:        while ((s = lss.pop()) != null) {
36702: 316:            System.out.println(s);
36703: 317:        }
36704: 318:    }
36705: 319:}
36706: 320:```
36707: 321:
36708: 322:输出结果：
36709: 323:
36710: 324:```java
36711: 325:stun!
36712: 326:on
36713: 327:Phasers
36714: 328:```
36715: 329:
36716: 330:内部类 `Node` 也是一个泛型，它拥有自己的类型参数。
36717: 331:
36718: 332:这个例子使用了一个 *末端标识* (end sentinel) 来判断栈何时为空。这个末端标识是在构造 `LinkedStack` 时创建的。然后，每次调用 `push()` 就会创建一个 `Node<T>` 对象，并将其链接到前一个 `Node<T>` 对象。当你调用 `pop()` 方法时，总是返回 `top.item`，然后丢弃当前 `top` 所指向的 `Node<T>`，并将 `top` 指向下一个 `Node<T>`，除非到达末端标识，这时就不能再移动 `top` 了。如果已经到达末端，程序还继续调用 `pop()` 方法，它只能得到 `null`，说明栈已经空了。
36719: 333:
36720: 334:### RandomList
36721: 335:
36722: 336:作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 `select()` 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型：
36723: 337:
36724: 338:```java
36725: 339:// generics/RandomList.java
36726: 340:import java.util.*;
36727: 341:import java.util.stream.*;
36728: 342:
36729: 343:public class RandomList<T> extends ArrayList<T> {
36730: 344:    private Random rand = new Random(47);
36731: 345:  
36732: 346:    public T select() {
36733: 347:        return get(rand.nextInt(size()));
36734: 348:    }
36735: 349:  
36736: 350:    public static void main(String[] args) {
36737: 351:        RandomList<String> rs = new RandomList<>();
36738: 352:        Arrays.stream("The quick brown fox jumped over the lazy brown dog".split(" ")).forEach(rs::add);
36739: 353:        IntStream.range(0, 11).forEach(i -> 
36740: 354:            System.out.print(rs.select() + " "));
36741: 355:    }
36742: 356:}
36743: 357:```
36744: 358:
36745: 359:输出结果：
36746: 360:
36747: 361:```java
36748: 362:brown over fox quick quick dog brown The brown lazy brown
36749: 363:```
36750: 364:
36751: 365:`RandomList` 继承了 `ArrayList` 的所有方法。本例中只添加了 `select()` 这个方法。
36752: 366:
36753: 367:<!-- Generic Interfaces -->
36754: 368:
36755: 369:## 泛型接口
36756: 370:
36757: 371:泛型也可以应用于接口。例如 *生成器*，这是一种专门负责创建对象的类。实际上，这是 *工厂方法* 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。
36758: 372:
36759: 373:一般而言，一个生成器只定义一个方法，用于创建对象。例如 `java.util.function` 类库中的 `Supplier` 就是一个生成器，调用其 `get()` 获取对象。`get()` 是泛型方法，返回值为类型参数 `T`。
36760: 374:
36761: 375:为了演示 `Supplier`，我们需要定义几个类。下面是个咖啡相关的继承体系：
36762: 376:
36763: 377:```java
36764: 378:// generics/coffee/Coffee.java
36765: 379:package generics.coffee;
36766: 380:
36767: 381:public class Coffee {
36768: 382:    private static long counter = 0;
36769: 383:    private final long id = counter++;
36770: 384:  
36771: 385:    @Override
36772: 386:    public String toString() {
36773: 387:        return getClass().getSimpleName() + " " + id;
36774: 388:    }
36775: 389:}
36776: 390:
36777: 391:
36778: 392:// generics/coffee/Latte.java
36779: 393:package generics.coffee;
36780: 394:public class Latte extends Coffee {}
36781: 395:
36782: 396:
36783: 397:// generics/coffee/Mocha.java
36784: 398:package generics.coffee;
36785: 399:public class Mocha extends Coffee {}
36786: 400:
36787: 401:
36788: 402:// generics/coffee/Cappuccino.java
36789: 403:package generics.coffee;
36790: 404:public class Cappuccino extends Coffee {}
36791: 405:
36792: 406:
36793: 407:// generics/coffee/Americano.java
36794: 408:package generics.coffee;
36795: 409:public class Americano extends Coffee {}
36796: 410:
36797: 411:
36798: 412:// generics/coffee/Breve.java
36799: 413:package generics.coffee;
36800: 414:public class Breve extends Coffee {}
36801: 415:```
36802: 416:
36803: 417:现在，我们可以编写一个类，实现 `Supplier<Coffee>` 接口，它能够随机生成不同类型的 `Coffee` 对象：
36804: 418:
36805: 419:```java
36806: 420:// generics/coffee/CoffeeSupplier.java
36807: 421:// {java generics.coffee.CoffeeSupplier}
36808: 422:package generics.coffee;
36809: 423:import java.util.*;
36810: 424:import java.util.function.*;
36811: 425:import java.util.stream.*;
36812: 426:
36813: 427:public class CoffeeSupplier
36814: 428:implements Supplier<Coffee>, Iterable<Coffee> {
36815: 429:    private Class<?>[] types = { Latte.class, Mocha.class, 
36816: 430:        Cappuccino.class, Americano.class, Breve.class };
36817: 431:    private static Random rand = new Random(47);
36818: 432:  
36819: 433:    public CoffeeSupplier() {}
36820: 434:    // For iteration:
36821: 435:    private int size = 0;
36822: 436:    public CoffeeSupplier(int sz) { size = sz; }
36823: 437:  
36824: 438:    @Override
36825: 439:    public Coffee get() {
36826: 440:        try {
36827: 441:            return (Coffee) types[rand.nextInt(types.length)].newInstance();
36828: 442:        } catch (InstantiationException | IllegalAccessException e) {
36829: 443:            throw new RuntimeException(e);
36830: 444:        }
36831: 445:    }
36832: 446:  
36833: 447:    class CoffeeIterator implements Iterator<Coffee> {
36834: 448:        int count = size;
36835: 449:        @Override
36836: 450:        public boolean hasNext() { return count > 0; }
36837: 451:        @Override
36838: 452:        public Coffee next() {
36839: 453:            count--;
36840: 454:            return CoffeeSupplier.this.get();
36841: 455:        }
36842: 456:        @Override
36843: 457:        public void remove() {
36844: 458:            throw new UnsupportedOperationException();
36845: 459:        }
36846: 460:    }
36847: 461:  
36848: 462:    @Override
36849: 463:    public Iterator<Coffee> iterator() {
36850: 464:        return new CoffeeIterator();
36851: 465:    }
36852: 466:  
36853: 467:    public static void main(String[] args) {
36854: 468:        Stream.generate(new CoffeeSupplier())
36855: 469:              .limit(5)
36856: 470:              .forEach(System.out::println);
36857: 471:        for (Coffee c : new CoffeeSupplier(5)) {
36858: 472:            System.out.println(c);
36859: 473:        }
36860: 474:    }
36861: 475:}
36862: 476:```
36863: 477:
36864: 478:输出结果：
36865: 479:
36866: 480:```java
36867: 481:Americano 0
36868: 482:Latte 1
36869: 483:Americano 2
36870: 484:Mocha 3
36871: 485:Mocha 4
36872: 486:Breve 5
36873: 487:Americano 6
36874: 488:Latte 7
36875: 489:Cappuccino 8
36876: 490:Cappuccino 9
36877: 491:```
36878: 492:
36879: 493:参数化的 `Supplier` 接口确保 `get()` 返回值是参数的类型。`CoffeeSupplier` 同时还实现了 `Iterable` 接口，所以能用于 *for-in* 语句。不过，它还需要知道何时终止循环，这正是第二个构造函数的作用。
36880: 494:
36881: 495:下面是另一个实现 `Supplier<T>` 接口的例子，它负责生成 Fibonacci 数列：
36882: 496:
36883: 497:```java
36884: 498:// generics/Fibonacci.java
36885: 499:// Generate a Fibonacci sequence
36886: 500:import java.util.function.*;
36887: 501:import java.util.stream.*;
36888: 502:
36889: 503:public class Fibonacci implements Supplier<Integer> {
36890: 504:    private int count = 0;
36891: 505:    @Override
36892: 506:    public Integer get() { return fib(count++); }
36893: 507:  
36894: 508:    private int fib(int n) {
36895: 509:        if(n < 2) return 1;
36896: 510:        return fib(n-2) + fib(n-1);
36897: 511:    }
36898: 512:  
36899: 513:    public static void main(String[] args) {
36900: 514:        Stream.generate(new Fibonacci())
36901: 515:              .limit(18)
36902: 516:              .map(n -> n + " ")
36903: 517:              .forEach(System.out::print);
36904: 518:    }
36905: 519:}
36906: 520:```
36907: 521:
36908: 522:输出结果：
36909: 523:
36910: 524:```java
36911: 525:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
36912: 526:```
36913: 527:
36914: 528:虽然我们在 `Fibonacci` 类的里里外外使用的都是 `int` 类型，但是其参数类型却是 `Integer`。这个例子引出了 Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备自动装箱和拆箱的功能，可以很方便地在基本类型和相应的包装类之间进行转换。通过这个例子中 `Fibonacci` 类对 `int` 的使用，我们已经看到了这种效果。
36915: 529:
36916: 530:如果还想更进一步，编写一个实现了 `Iterable` 的 `Fibnoacci` 生成器。我们的一个选择是重写这个类，令其实现 `Iterable` 接口。不过，你并不是总能拥有源代码的控制权，并且，除非必须这么做，否则，我们也不愿意重写一个类。而且我们还有另一种选择，就是创建一个 *适配器* (Adapter) 来实现所需的接口，我们在前面介绍过这个设计模式。
36917: 531:
36918: 532:有多种方法可以实现适配器。例如，可以通过继承来创建适配器类：
36919: 533:
36920: 534:```java
36921: 535:// generics/IterableFibonacci.java
36922: 536:// Adapt the Fibonacci class to make it Iterable
36923: 537:import java.util.*;
36924: 538:
36925: 539:public class IterableFibonacci
36926: 540:extends Fibonacci implements Iterable<Integer> {
36927: 541:    private int n;
36928: 542:    public IterableFibonacci(int count) { n = count; }
36929: 543:  
36930: 544:    @Override
36931: 545:    public Iterator<Integer> iterator() {
36932: 546:        return new Iterator<Integer>() {
36933: 547:            @Override
36934: 548:            public boolean hasNext() { return n > 0; }
36935: 549:            @Override
36936: 550:            public Integer next() {
36937: 551:                n--;
36938: 552:                return IterableFibonacci.this.get();
36939: 553:            }
36940: 554:            @Override
36941: 555:            public void remove() { // Not implemented
36942: 556:                throw new UnsupportedOperationException();
36943: 557:            }
36944: 558:        };
36945: 559:    }
36946: 560:  
36947: 561:    public static void main(String[] args) {
36948: 562:        for(int i : new IterableFibonacci(18))
36949: 563:            System.out.print(i + " ");
36950: 564:    }
36951: 565:}
36952: 566:```
36953: 567:
36954: 568:输出结果：
36955: 569:
36956: 570:```java
36957: 571:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
36958: 572:```
36959: 573:
36960: 574:在 *for-in* 语句中使用 `IterableFibonacci`，必须在构造函数中提供一个边界值，这样 `hasNext()` 才知道何时返回 **false**，结束循环。
36961: 575:
36962: 576:<!-- Generic Methods -->
36963: 577:
36964: 578:## 泛型方法
36965: 579:
36966: 580:到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。
36967: 581:
36968: 582:泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。
36969: 583:
36970: 584:如果方法是 **static** 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型类型参数，则它必须是泛型方法。
36971: 585:
36972: 586:要定义泛型方法，请将泛型参数列表放置在返回值之前，如下所示：
36973: 587:
36974: 588:```java
36975: 589:// generics/GenericMethods.java
36976: 590:
36977: 591:public class GenericMethods {
36978: 592:    public <T> void f(T x) {
36979: 593:        System.out.println(x.getClass().getName());
36980: 594:    }
36981: 595:
36982: 596:    public static void main(String[] args) {
36983: 597:        GenericMethods gm = new GenericMethods();
36984: 598:        gm.f("");
36985: 599:        gm.f(1);
36986: 600:        gm.f(1.0);
36987: 601:        gm.f(1.0F);
36988: 602:        gm.f('c');
36989: 603:        gm.f(gm);
36990: 604:    }
36991: 605:}
36992: 606:/* Output:
36993: 607:java.lang.String
36994: 608:java.lang.Integer
36995: 609:java.lang.Double
36996: 610:java.lang.Float
36997: 611:java.lang.Character
36998: 612:GenericMethods
36999: 613:*/
37000: 614:```
37001: 615:
37002: 616:尽管可以同时对类及其方法进行参数化，但这里未将 **GenericMethods** 类参数化。只有方法 `f()` 具有类型参数，该参数由方法返回类型之前的参数列表指示。
37003: 617:
37004: 618:对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 *类型参数推断*。因此，对 `f()` 的调用看起来像普通的方法调用，并且 `f()` 看起来像被重载了无数次一样。它甚至会接受 **GenericMethods** 类型的参数。
37005: 619:
37006: 620:如果使用基本类型调用 `f()` ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。
37007: 621:
37008: 622:<!-- Varargs and Generic Methods -->
37009: 623:
37010: 624:### 变长参数和泛型方法
37011: 625:
37012: 626:泛型方法和变长参数列表可以很好地共存：
37013: 627:
37014: 628:```java
37015: 629:// generics/GenericVarargs.java
37016: 630:
37017: 631:import java.util.ArrayList;
37018: 632:import java.util.List;
37019: 633:
37020: 634:public class GenericVarargs {
37021: 635:    @SafeVarargs
37022: 636:    public static <T> List<T> makeList(T... args) {
37023: 637:        List<T> result = new ArrayList<>();
37024: 638:        for (T item : args)
37025: 639:            result.add(item);
37026: 640:        return result;
37027: 641:    }
37028: 642:
37029: 643:    public static void main(String[] args) {
37030: 644:        List<String> ls = makeList("A");
37031: 645:        System.out.println(ls);
37032: 646:        ls = makeList("A", "B", "C");
37033: 647:        System.out.println(ls);
37034: 648:        ls = makeList(
37035: 649:                "ABCDEFFHIJKLMNOPQRSTUVWXYZ".split(""));
37036: 650:        System.out.println(ls);
37037: 651:    }
37038: 652:}
37039: 653:/* Output:
37040: 654:[A]
37041: 655:[A, B, C]
37042: 656:[A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R,
37043: 657:S, T, U, V, W, X, Y, Z]
37044: 658:*/
37045: 659:```
37046: 660:
37047: 661:此处显示的 `makeList()` 方法产生的功能与标准库的 `java.util.Arrays.asList()` 方法相同。
37048: 662:
37049: 663:`@SafeVarargs` 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。
37050: 664:
37051: 665:<!-- A General-Purpose Supplier -->
37052: 666:
37053: 667:### 一个泛型的 Supplier
37054: 668:
37055: 669:这是一个为任意具有无参构造方法的类生成 **Supplier** 的类。为了减少键入，它还包括一个用于生成 **BasicSupplier** 的泛型方法：
37056: 670:
37057: 671:```java
37058: 672:// onjava/BasicSupplier.java
37059: 673:// Supplier from a class with a no-arg constructor
37060: 674:package onjava;
37061: 675:
37062: 676:import java.util.function.Supplier;
37063: 677:
37064: 678:public class BasicSupplier<T> implements Supplier<T> {
37065: 679:    private Class<T> type;
37066: 680:
37067: 681:    public BasicSupplier(Class<T> type) {
37068: 682:        this.type = type;
37069: 683:    }
37070: 684:
37071: 685:    @Override
37072: 686:    public T get() {
37073: 687:        try {
37074: 688:            // Assumes type is a public class:
37075: 689:            return type.newInstance();
37076: 690:        } catch (InstantiationException |
37077: 691:                IllegalAccessException e) {
37078: 692:            throw new RuntimeException(e);
37079: 693:        }
37080: 694:    }
37081: 695:
37082: 696:    // Produce a default Supplier from a type token:
37083: 697:    public static <T> Supplier<T> create(Class<T> type) {
37084: 698:        return new BasicSupplier<>(type);
37085: 699:    }
37086: 700:}
37087: 701:```
37088: 702:
37089: 703:此类提供了产生以下对象的基本实现：
37090: 704:
37091: 705:1. 是 **public** 的。 因为 **BasicSupplier** 在单独的包中，所以相关的类必须具有 **public** 权限，而不仅仅是包级访问权限。
37092: 706:
37093: 707:2. 具有无参构造方法。要创建一个这样的 **BasicSupplier** 对象，请调用 `create()` 方法，并将要生成类型的类型令牌传递给它。通用的 `create()` 方法提供了 `BasicSupplier.create(MyType.class)` 这种较简洁的语法来代替较笨拙的 `new BasicSupplier <MyType>(MyType.class)`。
37094: 708:
37095: 709:例如，这是一个具有无参构造方法的简单类：
37096: 710:
37097: 711:```java
37098: 712:// generics/CountedObject.java
37099: 713:
37100: 714:public class CountedObject {
37101: 715:    private static long counter = 0;
37102: 716:    private final long id = counter++;
37103: 717:
37104: 718:    public long id() {
37105: 719:        return id;
37106: 720:    }
37107: 721:
37108: 722:    @Override
37109: 723:    public String toString() {
37110: 724:        return "CountedObject " + id;
37111: 725:    }
37112: 726:}
37113: 727:```
37114: 728:
37115: 729:**CountedObject** 类可以跟踪自身创建了多少个实例，并通过 `toString()` 报告这些实例的数量。 **BasicSupplier** 可以轻松地为 **CountedObject** 创建 **Supplier**：
37116: 730:
37117: 731:```java
37118: 732:  // generics/BasicSupplierDemo.java
37119: 733:
37120: 734:import onjava.BasicSupplier;
37121: 735:
37122: 736:import java.util.stream.Stream;
37123: 737:
37124: 738:public class BasicSupplierDemo {
37125: 739:    public static void main(String[] args) {
37126: 740:        Stream.generate(
37127: 741:                BasicSupplier.create(CountedObject.class))
37128: 742:                .limit(5)
37129: 743:                .forEach(System.out::println);
37130: 744:    }
37131: 745:}
37132: 746:/* Output:
37133: 747:CountedObject 0
37134: 748:CountedObject 1
37135: 749:CountedObject 2
37136: 750:CountedObject 3
37137: 751:CountedObject 4
37138: 752:*/
37139: 753:```
37140: 754:
37141: 755:泛型方法减少了产生 **Supplier** 对象所需的代码量。 Java 泛型强制传递 **Class** 对象，以便在 `create()` 方法中将其用于类型推断。
37142: 756:
37143: 757:<!-- Simplifying Tuple Use -->
37144: 758:
37145: 759:### 简化元组的使用
37146: 760:
37147: 761:使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库。在这里，我们使用重载的静态方法创建元组：
37148: 762:
37149: 763:```java
37150: 764:// onjava/Tuple.java
37151: 765:// Tuple library using type argument inference
37152: 766:package onjava;
37153: 767:
37154: 768:public class Tuple {
37155: 769:    public static <A, B> Tuple2<A, B> tuple(A a, B b) {
37156: 770:        return new Tuple2<>(a, b);
37157: 771:    }
37158: 772:
37159: 773:    public static <A, B, C> Tuple3<A, B, C>
37160: 774:    tuple(A a, B b, C c) {
37161: 775:        return new Tuple3<>(a, b, c);
37162: 776:    }
37163: 777:
37164: 778:    public static <A, B, C, D> Tuple4<A, B, C, D>
37165: 779:    tuple(A a, B b, C c, D d) {
37166: 780:        return new Tuple4<>(a, b, c, d);
37167: 781:    }
37168: 782:
37169: 783:    public static <A, B, C, D, E>
37170: 784:    Tuple5<A, B, C, D, E> tuple(A a, B b, C c, D d, E e) {
37171: 785:        return new Tuple5<>(a, b, c, d, e);
37172: 786:    }
37173: 787:}
37174: 788:```
37175: 789:
37176: 790:我们修改 **TupleTest.java** 来测试 **Tuple.java** :
37177: 791:
37178: 792:```java
37179: 793:// generics/TupleTest2.java
37180: 794:
37181: 795:import onjava.Tuple2;
37182: 796:import onjava.Tuple3;
37183: 797:import onjava.Tuple4;
37184: 798:import onjava.Tuple5;
37185: 799:
37186: 800:import static onjava.Tuple.tuple;
37187: 801:
37188: 802:public class TupleTest2 {
37189: 803:    static Tuple2<String, Integer> f() {
37190: 804:        return tuple("hi", 47);
37191: 805:    }
37192: 806:
37193: 807:    static Tuple2 f2() {
37194: 808:        return tuple("hi", 47);
37195: 809:    }
37196: 810:
37197: 811:    static Tuple3<Amphibian, String, Integer> g() {
37198: 812:        return tuple(new Amphibian(), "hi", 47);
37199: 813:    }
37200: 814:
37201: 815:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
37202: 816:        return tuple(
37203: 817:                new Vehicle(), new Amphibian(), "hi", 47);
37204: 818:    }
37205: 819:
37206: 820:    static Tuple5<Vehicle, Amphibian,
37207: 821:            String, Integer, Double> k() {
37208: 822:        return tuple(new Vehicle(), new Amphibian(),
37209: 823:                "hi", 47, 11.1);
37210: 824:    }
37211: 825:
37212: 826:    public static void main(String[] args) {
37213: 827:        Tuple2<String, Integer> ttsi = f();
37214: 828:        System.out.println(ttsi);
37215: 829:        System.out.println(f2());
37216: 830:        System.out.println(g());
37217: 831:        System.out.println(h());
37218: 832:        System.out.println(k());
37219: 833:    }
37220: 834:}
37221: 835:/* Output:
37222: 836:(hi, 47)
37223: 837:(hi, 47)
37224: 838:(Amphibian@14ae5a5, hi, 47)
37225: 839:(Vehicle@135fbaa4, Amphibian@45ee12a7, hi, 47)
37226: 840:(Vehicle@4b67cf4d, Amphibian@7ea987ac, hi, 47, 11.1)
37227: 841:*/
37228: 842:```
37229: 843:
37230: 844:请注意，`f()` 返回一个参数化的 **Tuple2** 对象，而 `f2()` 返回一个未参数化的 **Tuple2** 对象。编译器不会在这里警告 `f2()` ，因为返回值未以参数化方式使用。从某种意义上说，它被“向上转型”为一个未参数化的 **Tuple2** 。 但是，如果尝试将 `f2()` 的结果放入到参数化的 **Tuple2** 中，则编译器将发出警告。
37231: 845:
37232: 846:<!-- A Set Utility -->
37233: 847:
37234: 848:### 一个 Set 工具
37235: 849:
37236: 850:对于泛型方法的另一个示例，请考虑由 **Set** 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法：
37237: 851:
37238: 852:```java
37239: 853:// onjava/Sets.java
37240: 854:
37241: 855:package onjava;
37242: 856:
37243: 857:import java.util.HashSet;
37244: 858:import java.util.Set;
37245: 859:
37246: 860:public class Sets {
37247: 861:    public static <T> Set<T> union(Set<T> a, Set<T> b) {
37248: 862:        Set<T> result = new HashSet<>(a);
37249: 863:        result.addAll(b);
37250: 864:        return result;
37251: 865:    }
37252: 866:
37253: 867:    public static <T>
37254: 868:    Set<T> intersection(Set<T> a, Set<T> b) {
37255: 869:        Set<T> result = new HashSet<>(a);
37256: 870:        result.retainAll(b);
37257: 871:        return result;
37258: 872:    }
37259: 873:
37260: 874:    // Subtract subset from superset:
37261: 875:    public static <T> Set<T>
37262: 876:    difference(Set<T> superset, Set<T> subset) {
37263: 877:        Set<T> result = new HashSet<>(superset);
37264: 878:        result.removeAll(subset);
37265: 879:        return result;
37266: 880:    }
37267: 881:
37268: 882:    // Reflexive--everything not in the intersection:
37269: 883:    public static <T> Set<T> complement(Set<T> a, Set<T> b) {
37270: 884:        return difference(union(a, b), intersection(a, b));
37271: 885:    }
37272: 886:}
37273: 887:```
37274: 888:
37275: 889:前三个方法通过将第一个参数的引用复制到新的 **HashSet** 对象中来复制第一个参数，因此不会直接修改参数集合。因此，返回值是一个新的 **Set** 对象。
37276: 890:
37277: 891:这四种方法代表数学集合操作： `union()` 返回一个包含两个参数并集的 **Set** ， `intersection()` 返回一个包含两个参数集合交集的 **Set** ， `difference()` 从 **superset** 中减去 **subset** 的元素 ，而 `complement()` 返回所有不在交集中的元素的 **Set**。作为显示这些方法效果的简单示例的一部分，下面是一个包含不同水彩名称的 **enum** ：
37278: 892:
37279: 893:```java
37280: 894:// generics/watercolors/Watercolors.java
37281: 895:
37282: 896:package watercolors;
37283: 897:
37284: 898:public enum Watercolors {
37285: 899:    ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW,
37286: 900:    ORANGE, BRILLIANT_RED, CRIMSON, MAGENTA,
37287: 901:    ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE,
37288: 902:    PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE,
37289: 903:    PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN,
37290: 904:    YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
37291: 905:    BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK
37292: 906:}
37293: 907:```
37294: 908:
37295: 909:为了方便起见（不必全限定所有名称），将其静态导入到以下示例中。本示例使用 **EnumSet** 轻松从 **enum** 中创建 **Set** 。（可以在[第二十二章 枚举](book/22-Enumerations.md)一章中了解有关 **EnumSet** 的更多信息。）在这里，静态方法 `EnumSet.range()` 要求提供所要在结果 **Set** 中创建的元素范围的第一个和最后一个元素：
37296: 910:
37297: 911:```java
37298: 912:// generics/WatercolorSets.java
37299: 913:
37300: 914:import watercolors.*;
37301: 915:
37302: 916:import java.util.EnumSet;
37303: 917:import java.util.Set;
37304: 918:
37305: 919:import static watercolors.Watercolors.*;
37306: 920:import static onjava.Sets.*;
37307: 921:
37308: 922:public class WatercolorSets {
37309: 923:    public static void main(String[] args) {
37310: 924:        Set<Watercolors> set1 =
37311: 925:                EnumSet.range(BRILLIANT_RED, VIRIDIAN_HUE);
37312: 926:        Set<Watercolors> set2 =
37313: 927:                EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER);
37314: 928:        System.out.println("set1: " + set1);
37315: 929:        System.out.println("set2: " + set2);
37316: 930:        System.out.println(
37317: 931:                "union(set1, set2): " + union(set1, set2));
37318: 932:        Set<Watercolors> subset = intersection(set1, set2);
37319: 933:        System.out.println(
37320: 934:                "intersection(set1, set2): " + subset);
37321: 935:        System.out.println("difference(set1, subset): " +
37322: 936:                difference(set1, subset));
37323: 937:        System.out.println("difference(set2, subset): " +
37324: 938:                difference(set2, subset));
37325: 939:        System.out.println("complement(set1, set2): " +
37326: 940:                complement(set1, set2));
37327: 941:    }
37328: 942:}
37329: 943:/* Output:
37330: 944:set1: [BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER,
37331: 945:VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
37332: 946:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE]
37333: 947:set2: [CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
37334: 948:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE,
37335: 949:SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
37336: 950:BURNT_UMBER]
37337: 951:union(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
37338: 952:YELLOW_OCHRE, MAGENTA, SAP_GREEN, CERULEAN_BLUE_HUE,
37339: 953:ULTRAMARINE, VIRIDIAN_HUE, VIOLET, RAW_UMBER,
37340: 954:ROSE_MADDER, PERMANENT_GREEN, BURNT_UMBER,
37341: 955:PHTHALO_BLUE, CRIMSON, COBALT_BLUE_HUE]
37342: 956:intersection(set1, set2): [PERMANENT_GREEN,
37343: 957:CERULEAN_BLUE_HUE, ULTRAMARINE, VIRIDIAN_HUE,
37344: 958:PHTHALO_BLUE, COBALT_BLUE_HUE]
37345: 959:difference(set1, subset): [BRILLIANT_RED, MAGENTA,
37346: 960:VIOLET, CRIMSON, ROSE_MADDER]
37347: 961:difference(set2, subset): [BURNT_SIENNA, YELLOW_OCHRE,
37348: 962:BURNT_UMBER, SAP_GREEN, RAW_UMBER]
37349: 963:complement(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
37350: 964:YELLOW_OCHRE, MAGENTA, SAP_GREEN, VIOLET, RAW_UMBER,
37351: 965:ROSE_MADDER, BURNT_UMBER, CRIMSON]
37352: 966:*/
37353: 967:```
37354: 968:
37355: 969:接下来的例子使用 `Sets.difference()` 方法来展示 **java.util** 包中各种 **Collection** 和 **Map** 类之间的方法差异：
37356: 970:
37357: 971:```java
37358: 972:// onjava/CollectionMethodDifferences.java
37359: 973:// {java onjava.CollectionMethodDifferences}
37360: 974:
37361: 975:package onjava;
37362: 976:
37363: 977:import java.lang.reflect.Method;
37364: 978:import java.util.*;
37365: 979:import java.util.stream.Collectors;
37366: 980:
37367: 981:public class CollectionMethodDifferences {
37368: 982:    static Set<String> methodSet(Class<?> type) {
37369: 983:        return Arrays.stream(type.getMethods())
37370: 984:                .map(Method::getName)
37371: 985:                .collect(Collectors.toCollection(TreeSet::new));
37372: 986:    }
37373: 987:
37374: 988:    static void interfaces(Class<?> type) {
37375: 989:        System.out.print("Interfaces in " +
37376: 990:                type.getSimpleName() + ": ");
37377: 991:        System.out.println(
37378: 992:                Arrays.stream(type.getInterfaces())
37379: 993:                        .map(Class::getSimpleName)
37380: 994:                        .collect(Collectors.toList()));
37381: 995:    }
37382: 996:
37383: 997:    static Set<String> object = methodSet(Object.class);
37384: 998:
37385: 999:    static {
37386: 1000:        object.add("clone");
37387: 1001:    }
37388: 1002:
37389: 1003:    static void
37390: 1004:    difference(Class<?> superset, Class<?> subset) {
37391: 1005:        System.out.print(superset.getSimpleName() +
37392: 1006:                " extends " + subset.getSimpleName() +
37393: 1007:                ", adds: ");
37394: 1008:        Set<String> comp = Sets.difference(
37395: 1009:                methodSet(superset), methodSet(subset));
37396: 1010:        comp.removeAll(object); // Ignore 'Object' methods
37397: 1011:        System.out.println(comp);
37398: 1012:        interfaces(superset);
37399: 1013:    }
37400: 1014:
37401: 1015:    public static void main(String[] args) {
37402: 1016:        System.out.println("Collection: " +
37403: 1017:                methodSet(Collection.class));
37404: 1018:        interfaces(Collection.class);
37405: 1019:        difference(Set.class, Collection.class);
37406: 1020:        difference(HashSet.class, Set.class);
37407: 1021:        difference(LinkedHashSet.class, HashSet.class);
37408: 1022:        difference(TreeSet.class, Set.class);
37409: 1023:        difference(List.class, Collection.class);
37410: 1024:        difference(ArrayList.class, List.class);
37411: 1025:        difference(LinkedList.class, List.class);
37412: 1026:        difference(Queue.class, Collection.class);
37413: 1027:        difference(PriorityQueue.class, Queue.class);
37414: 1028:        System.out.println("Map: " + methodSet(Map.class));
37415: 1029:        difference(HashMap.class, Map.class);
37416: 1030:        difference(LinkedHashMap.class, HashMap.class);
37417: 1031:        difference(SortedMap.class, Map.class);
37418: 1032:        difference(TreeMap.class, Map.class);
37419: 1033:    }
37420: 1034:}
37421: 1035:/* Output:
37422: 1036:Collection: [add, addAll, clear, contains, containsAll,
37423: 1037:equals, forEach, hashCode, isEmpty, iterator,
37424: 1038:parallelStream, remove, removeAll, removeIf, retainAll,
37425: 1039:size, spliterator, stream, toArray]
37426: 1040:Interfaces in Collection: [Iterable]
37427: 1041:Set extends Collection, adds: []
37428: 1042:Interfaces in Set: [Collection]
37429: 1043:HashSet extends Set, adds: []
37430: 1044:Interfaces in HashSet: [Set, Cloneable, Serializable]
37431: 1045:LinkedHashSet extends HashSet, adds: []
37432: 1046:Interfaces in LinkedHashSet: [Set, Cloneable,
37433: 1047:Serializable]
37434: 1048:TreeSet extends Set, adds: [headSet,
37435: 1049:descendingIterator, descendingSet, pollLast, subSet,
37436: 1050:floor, tailSet, ceiling, last, lower, comparator,
37437: 1051:pollFirst, first, higher]
37438: 1052:Interfaces in TreeSet: [NavigableSet, Cloneable,
37439: 1053:Serializable]
37440: 1054:List extends Collection, adds: [replaceAll, get,
37441: 1055:indexOf, subList, set, sort, lastIndexOf, listIterator]
37442: 1056:Interfaces in List: [Collection]
37443: 1057:ArrayList extends List, adds: [trimToSize,
37444: 1058:ensureCapacity]
37445: 1059:Interfaces in ArrayList: [List, RandomAccess,
37446: 1060:Cloneable, Serializable]
37447: 1061:LinkedList extends List, adds: [offerFirst, poll,
37448: 1062:getLast, offer, getFirst, removeFirst, element,
37449: 1063:removeLastOccurrence, peekFirst, peekLast, push,
37450: 1064:pollFirst, removeFirstOccurrence, descendingIterator,
37451: 1065:pollLast, removeLast, pop, addLast, peek, offerLast,
37452: 1066:addFirst]
37453: 1067:Interfaces in LinkedList: [List, Deque, Cloneable,
37454: 1068:Serializable]
37455: 1069:Queue extends Collection, adds: [poll, peek, offer,
37456: 1070:element]
37457: 1071:Interfaces in Queue: [Collection]
37458: 1072:PriorityQueue extends Queue, adds: [comparator]
37459: 1073:Interfaces in PriorityQueue: [Serializable]
37460: 1074:Map: [clear, compute, computeIfAbsent,
37461: 1075:computeIfPresent, containsKey, containsValue, entrySet,
37462: 1076:equals, forEach, get, getOrDefault, hashCode, isEmpty,
37463: 1077:keySet, merge, put, putAll, putIfAbsent, remove,
37464: 1078:replace, replaceAll, size, values]
37465: 1079:HashMap extends Map, adds: []
37466: 1080:Interfaces in HashMap: [Map, Cloneable, Serializable]
37467: 1081:LinkedHashMap extends HashMap, adds: []
37468: 1082:Interfaces in LinkedHashMap: [Map]
37469: 1083:SortedMap extends Map, adds: [lastKey, subMap,
37470: 1084:comparator, firstKey, headMap, tailMap]
37471: 1085:Interfaces in SortedMap: [Map]
37472: 1086:TreeMap extends Map, adds: [descendingKeySet,
37473: 1087:navigableKeySet, higherEntry, higherKey, floorKey,
37474: 1088:subMap, ceilingKey, pollLastEntry, firstKey, lowerKey,
37475: 1089:headMap, tailMap, lowerEntry, ceilingEntry,
37476: 1090:descendingMap, pollFirstEntry, lastKey, firstEntry,
37477: 1091:floorEntry, comparator, lastEntry]
37478: 1092:Interfaces in TreeMap: [NavigableMap, Cloneable,
37479: 1093:Serializable]
37480: 1094:*/
37481: 1095:```
37482: 1096:
37483: 1097:在第十二章 [集合的本章小结](book/12-Collections.md#本章小结) 部分将会用到这里的输出结果。
37484: 1098:
37485: 1099:<!-- Building Complex Models -->
37486: 1100:
37487: 1101:## 构建复杂模型
37488: 1102:
37489: 1103:泛型的一个重要好处是能够简单安全地创建复杂模型。例如，我们可以轻松地创建一个元组列表：
37490: 1104:
37491: 1105:```java
37492: 1106:// generics/TupleList.java
37493: 1107:// Combining generic types to make complex generic types
37494: 1108:
37495: 1109:import onjava.Tuple4;
37496: 1110:
37497: 1111:import java.util.ArrayList;
37498: 1112:
37499: 1113:public class TupleList<A, B, C, D>
37500: 1114:        extends ArrayList<Tuple4<A, B, C, D>> {
37501: 1115:    public static void main(String[] args) {
37502: 1116:        TupleList<Vehicle, Amphibian, String, Integer> tl =
37503: 1117:                new TupleList<>();
37504: 1118:        tl.add(TupleTest2.h());
37505: 1119:        tl.add(TupleTest2.h());
37506: 1120:        tl.forEach(System.out::println);
37507: 1121:    }
37508: 1122:}
37509: 1123:/* Output:
37510: 1124:(Vehicle@7cca494b, Amphibian@7ba4f24f, hi, 47)
37511: 1125:(Vehicle@3b9a45b3, Amphibian@7699a589, hi, 47)
37512: 1126:*/
37513: 1127:```
37514: 1128:
37515: 1129:这将产生一个功能强大的数据结构，而无需太多代码。
37516: 1130:
37517: 1131:下面是第二个例子。每个类都是组成块，总体包含很多个块。在这里，该模型是一个具有过道，货架和产品的零售商店：
37518: 1132:
37519: 1133:```java
37520: 1134:// generics/Store.java
37521: 1135:// Building a complex model using generic collections
37522: 1136:
37523: 1137:import onjava.Suppliers;
37524: 1138:
37525: 1139:import java.util.ArrayList;
37526: 1140:import java.util.Random;
37527: 1141:import java.util.function.Supplier;
37528: 1142:
37529: 1143:class Product {
37530: 1144:    private final int id;
37531: 1145:    private String description;
37532: 1146:    private double price;
37533: 1147:
37534: 1148:    Product(int idNumber, String descr, double price) {
37535: 1149:        id = idNumber;
37536: 1150:        description = descr;
37537: 1151:        this.price = price;
37538: 1152:        System.out.println(toString());
37539: 1153:    }
37540: 1154:
37541: 1155:    @Override
37542: 1156:    public String toString() {
37543: 1157:        return id + ": " + description +
37544: 1158:                ", price: $" + price;
37545: 1159:    }
37546: 1160:
37547: 1161:    public void priceChange(double change) {
37548: 1162:        price += change;
37549: 1163:    }
37550: 1164:
37551: 1165:    public static Supplier<Product> generator =
37552: 1166:            new Supplier<Product>() {
37553: 1167:                private Random rand = new Random(47);
37554: 1168:
37555: 1169:                @Override
37556: 1170:                public Product get() {
37557: 1171:                    return new Product(rand.nextInt(1000), "Test",
37558: 1172:                            Math.round(
37559: 1173:                                    rand.nextDouble() * 1000.0) + 0.99);
37560: 1174:                }
37561: 1175:            };
37562: 1176:}
37563: 1177:
37564: 1178:class Shelf extends ArrayList<Product> {
37565: 1179:    Shelf(int nProducts) {
37566: 1180:        Suppliers.fill(this, Product.generator, nProducts);
37567: 1181:    }
37568: 1182:}
37569: 1183:
37570: 1184:class Aisle extends ArrayList<Shelf> {
37571: 1185:    Aisle(int nShelves, int nProducts) {
37572: 1186:        for (int i = 0; i < nShelves; i++)
37573: 1187:            add(new Shelf(nProducts));
37574: 1188:    }
37575: 1189:}
37576: 1190:
37577: 1191:class CheckoutStand {
37578: 1192:}
37579: 1193:
37580: 1194:class Office {
37581: 1195:}
37582: 1196:
37583: 1197:public class Store extends ArrayList<Aisle> {
37584: 1198:    private ArrayList<CheckoutStand> checkouts =
37585: 1199:            new ArrayList<>();
37586: 1200:    private Office office = new Office();
37587: 1201:
37588: 1202:    public Store(
37589: 1203:            int nAisles, int nShelves, int nProducts) {
37590: 1204:        for (int i = 0; i < nAisles; i++)
37591: 1205:            add(new Aisle(nShelves, nProducts));
37592: 1206:    }
37593: 1207:
37594: 1208:    @Override
37595: 1209:    public String toString() {
37596: 1210:        StringBuilder result = new StringBuilder();
37597: 1211:        for (Aisle a : this)
37598: 1212:            for (Shelf s : a)
37599: 1213:                for (Product p : s) {
37600: 1214:                    result.append(p);
37601: 1215:                    result.append("\n");
37602: 1216:                }
37603: 1217:        return result.toString();
37604: 1218:    }
37605: 1219:
37606: 1220:    public static void main(String[] args) {
37607: 1221:        System.out.println(new Store(5, 4, 3));
37608: 1222:    }
37609: 1223:}
37610: 1224:/* Output: (First 8 Lines)
37611: 1225:258: Test, price: $400.99
37612: 1226:861: Test, price: $160.99
37613: 1227:868: Test, price: $417.99
37614: 1228:207: Test, price: $268.99
37615: 1229:551: Test, price: $114.99
37616: 1230:278: Test, price: $804.99
37617: 1231:520: Test, price: $554.99
37618: 1232:140: Test, price: $530.99
37619: 1233:                  ...
37620: 1234:*/
37621: 1235:```
37622: 1236:
37623: 1237:`Store.toString()` 显示了结果：尽管有复杂的层次结构，但多层的集合仍然是类型安全的和可管理的。令人印象深刻的是，组装这样的模型并不需要耗费过多精力。
37624: 1238:
37625: 1239:**Shelf** 使用 `Suppliers.fill()` 这个实用程序，该实用程序接受 **Collection** （第一个参数），并使用 **Supplier** （第二个参数），以元素的数量为 **n** （第三个参数）来填充它。 **Suppliers** 类将会在本章末尾定义，其中的方法都是在执行某种填充操作，并在本章的其他示例中使用。
37626: 1240:
37627: 1241:<!-- The Mystery of Erasure -->
37628: 1242:
37629: 1243:## 泛型擦除
37630: 1244:
37631: 1245:当你开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的。例如，尽管可以说  `ArrayList.class`，但不能说成 `ArrayList<Integer>.class`。考虑下面的情况：
37632: 1246:
37633: 1247:```java
37634: 1248:// generics/ErasedTypeEquivalence.java
37635: 1249:
37636: 1250:import java.util.*;
37637: 1251:
37638: 1252:public class ErasedTypeEquivalence {
37639: 1253:    
37640: 1254:    public static void main(String[] args) {
37641: 1255:        Class c1 = new ArrayList<String>().getClass();
37642: 1256:        Class c2 = new ArrayList<Integer>().getClass();
37643: 1257:        System.out.println(c1 == c2);
37644: 1258:    }
37645: 1259:    
37646: 1260:}
37647: 1261:/* Output:
37648: 1262:true
37649: 1263:*/
37650: 1264:```
37651: 1265:
37652: 1266:`ArrayList<String>` 和 `ArrayList<Integer>` 应该是不同的类型。不同的类型会有不同的行为。例如，如果尝试向 `ArrayList<String>` 中放入一个 `Integer`，所得到的行为（失败）和向 `ArrayList<Integer>` 中放入一个 `Integer` 所得到的行为（成功）完全不同。然而上面的程序认为它们是相同的类型。
37653: 1267:
37654: 1268:下面的例子是对该谜题的补充：
37655: 1269:
37656: 1270:```java
37657: 1271:// generics/LostInformation.java
37658: 1272:
37659: 1273:import java.util.*;
37660: 1274:
37661: 1275:class Frob {}
37662: 1276:class Fnorkle {}
37663: 1277:class Quark<Q> {}
37664: 1278:
37665: 1279:class Particle<POSITION, MOMENTUM> {}
37666: 1280:
37667: 1281:public class LostInformation {
37668: 1282:
37669: 1283:    public static void main(String[] args) {
37670: 1284:        List<Frob> list = new ArrayList<>();
37671: 1285:        Map<Frob, Fnorkle> map = new HashMap<>();
37672: 1286:        Quark<Fnorkle> quark = new Quark<>();
37673: 1287:        Particle<Long, Double> p = new Particle<>();
37674: 1288:        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));
37675: 1289:        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));
37676: 1290:        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));
37677: 1291:        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));
37678: 1292:    }
37679: 1293:
37680: 1294:}
37681: 1295:/* Output:
37682: 1296:[E]
37683: 1297:[K,V]
37684: 1298:[Q]
37685: 1299:[POSITION,MOMENTUM]
37686: 1300:*/
37687: 1301:```
37688: 1302:
37689: 1303:根据 JDK 文档，**Class.getTypeParameters()** “返回一个 **TypeVariable** 对象数组，表示泛型声明中声明的类型参数...” 这暗示你可以发现这些参数类型。但是正如上例中输出所示，你只能看到用作参数占位符的标识符，这并非有用的信息。
37690: 1304:
37691: 1305:残酷的现实是：
37692: 1306:
37693: 1307:在泛型代码内部，无法获取任何有关泛型参数类型的信息。
37694: 1308:
37695: 1309:因此，你可以知道如类型参数标识符和泛型边界这些信息，但无法得知实际的类型参数从而用来创建特定的实例。如果你曾是 C++ 程序员，那么这个事实会让你很沮丧，在使用 Java 泛型工作时，它是必须处理的最基本的问题。
37696: 1310:
37697: 1311:Java 泛型是使用擦除实现的。这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此，`List<String>` 和 `List<Integer>` 在运行时实际上是相同的类型。它们都被擦除成原生类型 `List`。
37698: 1312:
37699: 1313:理解擦除并知道如何处理它，是你在学习 Java 泛型时面临的最大障碍之一。这也是本节将要探讨的内容。
37700: 1314:
37701: 1315:### C++ 的方式
37702: 1316:
37703: 1317:下面是使用模版的 C++ 示例。你会看到类型参数的语法十分相似，因为 Java 是受 C++ 启发的：
37704: 1318:
37705: 1319:```c++
37706: 1320:// generics/Templates.cpp
37707: 1321:
37708: 1322:#include <iostream>
37709: 1323:using namespace std;
37710: 1324:
37711: 1325:template<class T> class Manipulator {
37712: 1326:    T obj;
37713: 1327:public:
37714: 1328:    Manipulator(T x) { obj = x; }
37715: 1329:    void manipulate() { obj.f(); }
37716: 1330:};
37717: 1331:
37718: 1332:class HasF {
37719: 1333:public:
37720: 1334:    void f() { cout << "HasF::f()" << endl; }
37721: 1335:};
37722: 1336:
37723: 1337:int main() {
37724: 1338:    HasF hf;
37725: 1339:    Manipulator<HasF> manipulator(hf);
37726: 1340:    manipulator.manipulate();
37727: 1341:}
37728: 1342:/* Output:
37729: 1343:HasF::f()
37730: 1344:*/
37731: 1345:```
37732: 1346:
37733: 1347:**Manipulator** 类存储了一个 **T** 类型的对象。`manipulate()` 方法会调用 **obj** 上的 `f()` 方法。它是如何知道类型参数 **T** 中存在 `f()` 方法的呢？C++ 编译器会在你实例化模版时进行检查，所以在 `Manipulator<HasF>` 实例化的那一刻，它看到 **HasF** 中含有一个方法 `f()`。如果情况并非如此，你就会得到一个编译期错误，保持类型安全。
37734: 1348:
37735: 1349:用 C++ 编写这种代码很简单，因为当模版被实例化时，模版代码就知道模版参数的类型。Java 泛型就不同了。下面是 **HasF** 的 Java 版本：
37736: 1350:
37737: 1351:```java
37738: 1352:// generics/HasF.java
37739: 1353:
37740: 1354:public class HasF {
37741: 1355:    public void f() {
37742: 1356:        System.out.println("HasF.f()");
37743: 1357:    }
37744: 1358:}
37745: 1359:```
37746: 1360:
37747: 1361:如果我们将示例的其余代码用 Java 实现，就不会通过编译：
37748: 1362:
37749: 1363:```java
37750: 1364:// generics/Manipulation.java
37751: 1365:// {WillNotCompile}
37752: 1366:
37753: 1367:class Manipulator<T> {
37754: 1368:    private T obj;
37755: 1369:    
37756: 1370:    Manipulator(T x) {
37757: 1371:        obj = x;
37758: 1372:    }
37759: 1373:    
37760: 1374:    // Error: cannot find symbol: method f():
37761: 1375:    public void manipulate() {
37762: 1376:        obj.f();
37763: 1377:    }
37764: 1378:}
37765: 1379:
37766: 1380:public class Manipulation {
37767: 1381:	public static void main(String[] args) {
37768: 1382:        HasF hf = new HasF();
37769: 1383:        Manipulator<HasF> manipulator = new Manipulator<>(hf);
37770: 1384:        manipulator.manipulate();
37771: 1385:    }
37772: 1386:}
37773: 1387:```
37774: 1388:
37775: 1389:因为擦除，Java 编译器无法将 `manipulate()` 方法必须能调用 **obj** 的 `f()` 方法这一需求映射到 HasF 具有 `f()` 方法这个事实上。为了调用 `f()`，我们必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。这里重用了 **extends** 关键字。由于有了边界，下面的代码就能通过编译：
37776: 1390:
37777: 1391:```java
37778: 1392:public class Manipulator2<T extends HasF> {
37779: 1393:    private T obj;
37780: 1394:
37781: 1395:    Manipulator2(T x) {
37782: 1396:        obj = x;
37783: 1397:    }
37784: 1398:
37785: 1399:    public void manipulate() {
37786: 1400:        obj.f();
37787: 1401:    }
37788: 1402:}
37789: 1403:```
37790: 1404:
37791: 1405:边界 `<T extends HasF>` 声明 T 必须是 HasF 类型或其子类。如果情况确实如此，就可以安全地在 **obj** 上调用 `f()` 方法。
37792: 1406:
37793: 1407:我们说泛型类型参数会擦除到它的第一个边界（可能有多个边界，稍后你将看到）。我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的示例，**T** 擦除到了 **HasF**，就像在类的声明中用 **HasF** 替换了 **T** 一样。
37794: 1408:
37795: 1409:你可能正确地观察到了泛型在 **Manipulator2.java** 中没有贡献任何事。你可以很轻松地自己去执行擦除，生成没有泛型的类：
37796: 1410:
37797: 1411:```java
37798: 1412:// generics/Manipulator3.java
37799: 1413:
37800: 1414:class Manipulator3 {
37801: 1415:    private HasF obj;
37802: 1416:    
37803: 1417:    Manipulator3(HasF x) {
37804: 1418:        obj = x;
37805: 1419:    }
37806: 1420:    
37807: 1421:    public void manipulate() {
37808: 1422:        obj.f();
37809: 1423:    }
37810: 1424:}
37811: 1425:```
37812: 1426:
37813: 1427:这提出了很重要的一点：泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用。因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换更加复杂。但是，不能因此认为使用 `<T extends HasF>` 形式就是有缺陷的。例如，如果某个类有一个返回 **T** 的方法，那么泛型就有所帮助，因为它们之后将返回确切的类型：
37814: 1428:
37815: 1429:```java
37816: 1430:// generics/ReturnGenericType.java
37817: 1431:
37818: 1432:public class ReturnGenericType<T extends HasF> {
37819: 1433:    private T obj;
37820: 1434:    
37821: 1435:    ReturnGenericType(T x) {
37822: 1436:        obj = x;
37823: 1437:    }
37824: 1438:    
37825: 1439:    public T get() {
37826: 1440:        return obj;
37827: 1441:    }
37828: 1442:}
37829: 1443:```
37830: 1444:
37831: 1445:你必须查看所有的代码，从而确定代码是否复杂到必须使用泛型的程度。
37832: 1446:
37833: 1447:我们将在本章稍后看到有关边界的更多细节。
37834: 1448:
37835: 1449:### 迁移兼容性
37836: 1450:
37837: 1451:为了减少潜在的关于擦除的困惑，你必须清楚地认识到这不是一个语言特性。它是 Java 实现泛型的一种妥协，因为泛型不是 Java 语言出现时就有的，所以就有了这种妥协。它会使你痛苦，因此你需要尽早习惯它并了解为什么它会这样。
37838: 1452:
37839: 1453:如果 Java 1.0 就含有泛型的话，那么这个特性就不会使用擦除来实现——它会使用具体化，保持参数类型为第一类实体，因此你就能在类型参数上执行基于类型的语言操作和反射操作。本章稍后你会看到，擦除减少了泛型的泛化性。泛型在 Java 中仍然是有用的，只是不如它们本来设想的那么有用，而原因就是擦除。
37840: 1454:
37841: 1455:在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文使用泛型类型。泛型类型只有在静态类型检测期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如， `List<T>` 这样的类型注解会被擦除为 **List**，普通的类型变量在未指定边界的情况下会被擦除为 **Object**。
37842: 1456:
37843: 1457:擦除的核心动机是你可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称为“迁移兼容性”。在理想情况下，所有事物将在指定的某天被泛化。在现实中，即使程序员只编写泛型代码，他们也必须处理 Java 5 之前编写的非泛型类库。这些类库的作者可能从没想过要泛化他们的代码，或许他们可能刚刚开始接触泛型。
37844: 1458:
37845: 1459:因此 Java 泛型不仅必须支持向后兼容性——现有的代码和类文件仍然合法，继续保持之前的含义——而且还必须支持迁移兼容性，使得类库能按照它们自己的步调变为泛型，当某个类库变为泛型时，不会破坏依赖于它的代码和应用。在确定了这个目标后，Java 设计者们和从事此问题相关工作的各个团队决策认为擦除是唯一可行的解决方案。擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。
37846: 1460:
37847: 1461:例如，假设一个应用使用了两个类库 **X** 和 **Y**，**Y** 使用了类库 **Z**。随着 Java 5 的出现，这个应用和这些类库的创建者最终可能希望迁移到泛型上。但是当进行迁移时，它们有着不同的动机和限制。为了实现迁移兼容性，每个类库与应用必须与其他所有的部分是否使用泛型无关。因此，它们不能探测其他类库是否使用了泛型。因此，某个特定的类库使用了泛型这样的证据必须被”擦除“。
37848: 1462:
37849: 1463:如果没有某种类型的迁移途径，所有已经构建了很长时间的类库就需要与希望迁移到 Java 泛型上的开发者们说再见了。类库毫无争议是编程语言的一部分，对生产效率有着极大的影响，所以这种代码无法接受。擦除是否是最佳的或唯一的迁移途径，还待时间来证明。
37850: 1464:
37851: 1465:### 擦除的问题
37852: 1466:
37853: 1467:因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。擦除允许你继续使用现有的非泛型客户端代码，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会骤然破坏所有现有的代码。
37854: 1468:
37855: 1469:擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作中，例如转型、**instanceof** 操作和 **new** 表达式。因为所有关于参数的类型信息都丢失了，当你在编写泛型代码时，必须时刻提醒自己，你只是看起来拥有有关参数的类型信息而已。
37856: 1470:
37857: 1471:考虑如下的代码段：
37858: 1472:
37859: 1473:```java
37860: 1474:class Foo<T> {
37861: 1475:    T var;
37862: 1476:}
37863: 1477:```
37864: 1478:
37865: 1479:看上去当你创建一个 **Foo** 实例时：
37866: 1480:
37867: 1481:```java
37868: 1482:Foo<Cat> f = new Foo<>();
37869: 1483:```
37870: 1484:
37871: 1485:**class** **Foo** 中的代码应该知道现在工作于 **Cat** 之上。泛型语法也在强烈暗示整个类中所有 T 出现的地方都被替换，就像在 C++ 中一样。但是事实并非如此，当你在编写这个类的代码时，必须提醒自己：“不，这只是一个 **Object**“。
37872: 1486:
37873: 1487:另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管你可能希望这样：
37874: 1488:
37875: 1489:```java
37876: 1490:// generics/ErasureAndInheritance.java
37877: 1491:
37878: 1492:class GenericBase<T> {
37879: 1493:    private T element;
37880: 1494:    
37881: 1495:    public void set(T arg) {
37882: 1496:        element = arg;
37883: 1497:    }
37884: 1498:    
37885: 1499:    public T get() {
37886: 1500:        return element;
37887: 1501:    }
37888: 1502:}
37889: 1503:
37890: 1504:class Derived1<T> extends GenericBase<T> {}
37891: 1505:
37892: 1506:class Derived2 extends GenericBase {} // No warning
37893: 1507:
37894: 1508:// class Derived3 extends GenericBase<?> {}
37895: 1509:// Strange error:
37896: 1510:// unexpected type
37897: 1511:// required: class or interface without bounds
37898: 1512:public class ErasureAndInteritance {
37899: 1513:    @SuppressWarnings("unchecked")
37900: 1514:    public static void main(String[] args) {
37901: 1515:        Derived2 d2 = new Derived2();
37902: 1516:        Object obj = d2.get();
37903: 1517:        d2.set(obj); // Warning here!
37904: 1518:    }
37905: 1519:}
37906: 1520:```
37907: 1521:
37908: 1522:**Derived2** 继承自 **GenericBase**，但是没有任何类型参数，编译器没有发出任何警告。直到调用 `set()` 方法时才出现警告。
37909: 1523:
37910: 1524:为了关闭警告，Java 提供了一个注解，我们可以在列表中看到它：
37911: 1525:
37912: 1526:```java
37913: 1527:@SuppressWarnings("unchecked")
37914: 1528:```
37915: 1529:
37916: 1530:这个注解放置在产生警告的方法上，而不是整个类上。当你要关闭警告时，最好尽可能地“聚焦”，这样就不会因为过于宽泛地关闭警告，而导致意外地遮蔽掉真正的问题。
37917: 1531:
37918: 1532:可以推断，**Derived3** 产生的错误意味着编译器期望得到一个原生基类。
37919: 1533:
37920: 1534:当你希望将类型参数不仅仅当作 Object 处理时，就需要付出额外努力来管理边界，并且与在 C++、Ada 和 Eiffel 这样的语言中获得参数化类型相比，你需要付出多得多的努力来获得少得多的回报。这并不是说，对于大多数的编程问题而言，这些语言通常都会比 Java 更得心应手，只是说它们的参数化类型机制相比 Java 更灵活、更强大。
37921: 1535:
37922: 1536:### 边界处的动作
37923: 1537:
37924: 1538:因为擦除，我发现了泛型最令人困惑的方面是可以表示没有任何意义的事物。例如：
37925: 1539:
37926: 1540:```java
37927: 1541:// generics/ArrayMaker.java
37928: 1542:
37929: 1543:import java.lang.reflect.*;
37930: 1544:import java.util.*;
37931: 1545:
37932: 1546:public class ArrayMaker<T> {
37933: 1547:    private Class<T> kind;
37934: 1548:
37935: 1549:    public ArrayMaker(Class<T> kind) {
37936: 1550:        this.kind = kind;
37937: 1551:    }
37938: 1552:
37939: 1553:    @SuppressWarnings("unchecked")
37940: 1554:    T[] create(int size) {
37941: 1555:        return (T[]) Array.newInstance(kind, size);
37942: 1556:    }
37943: 1557:
37944: 1558:    public static void main(String[] args) {
37945: 1559:        ArrayMaker<String> stringMaker = new ArrayMaker<>(String.class);
37946: 1560:        String[] stringArray = stringMaker.create(9);
37947: 1561:        System.out.println(Arrays.toString(stringArray));
37948: 1562:    }
37949: 1563:}
37950: 1564:/* Output
37951: 1565:[null,null,null,null,null,null,null,null,null]
37952: 1566:*/
37953: 1567:```
37954: 1568:
37955: 1569:即使 **kind** 被存储为 `Class<T>`，擦除也意味着它实际被存储为没有任何参数的 **Class**。因此，当你在使用它时，例如创建数组，`Array.newInstance()` 实际上并未拥有 **kind** 所蕴含的类型信息。所以它不会产生具体的结果，因而必须转型，这会产生一条令你无法满意的警告。
37956: 1570:
37957: 1571:注意，对于在泛型中创建数组，使用 `Array.newInstance()` 是推荐的方式。
37958: 1572:
37959: 1573:如果我们创建一个集合而不是数组，情况就不同了：
37960: 1574:
37961: 1575:```java
37962: 1576:// generics/ListMaker.java
37963: 1577:
37964: 1578:import java.util.*;
37965: 1579:
37966: 1580:public class ListMaker<T> {
37967: 1581:    List<T> create() {
37968: 1582:        return new ArrayList<>();
37969: 1583:    }
37970: 1584:    
37971: 1585:    public static void main(String[] args) {
37972: 1586:        ListMaker<String> stringMaker = new ListMaker<>();
37973: 1587:        List<String> stringList = stringMaker.create();
37974: 1588:    }
37975: 1589:}
37976: 1590:```
37977: 1591:
37978: 1592:编译器不会给出任何警告，尽管我们知道（从擦除中）在 `create()` 内部的 `new ArrayList<>()` 中的 `<T>` 被移除了——在运行时，类内部没有任何 `<T>`，因此这看起来毫无意义。但是如果你遵从这种思路，并将这个表达式改为 `new ArrayList()`，编译器就会发出警告。
37979: 1593:
37980: 1594:本例中这么做真的毫无意义吗？如果在创建 **List** 的同时向其中放入一些对象呢，像这样：
37981: 1595:
37982: 1596:```java
37983: 1597:// generics/FilledList.java
37984: 1598:
37985: 1599:import java.util.*;
37986: 1600:import java.util.function.*;
37987: 1601:import onjava.*;
37988: 1602:
37989: 1603:public class FilledList<T> extends ArrayList<T> {
37990: 1604:    FilledList(Supplier<T> gen, int size) {
37991: 1605:        Suppliers.fill(this, gen, size);
37992: 1606:    }
37993: 1607:    
37994: 1608:    public FilledList(T t, int size) {
37995: 1609:        for (int i = 0; i < size; i++) {
37996: 1610:            this.add(t);
37997: 1611:        }
37998: 1612:    }
37999: 1613:    
38000: 1614:    public static void main(String[] args) {
38001: 1615:        List<String> list = new FilledList<>("Hello", 4);
38002: 1616:        System.out.println(list);
38003: 1617:        // Supplier version:
38004: 1618:        List<Integer> ilist = new FilledList<>(() -> 47, 4);
38005: 1619:        System.out.println(ilist);
38006: 1620:    }
38007: 1621:}
38008: 1622:/* Output:
38009: 1623:[Hello,Hello,Hello,Hello]
38010: 1624:[47,47,47,47]
38011: 1625:*/
38012: 1626:```
38013: 1627:
38014: 1628:即使编译器无法得知 `add()` 中的 **T** 的任何信息，但它仍可以在编译期确保你放入 **FilledList** 中的对象是 **T** 类型。因此，即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。
38015: 1629:
38016: 1630:因为擦除移除了方法体中的类型信息，所以在运行时的问题就是*边界*：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。
38017: 1631:
38018: 1632:考虑如下这段非泛型示例：
38019: 1633:
38020: 1634:```java
38021: 1635:// generics/SimpleHolder.java
38022: 1636:
38023: 1637:public class SimpleHolder {
38024: 1638:    private Object obj;
38025: 1639:    
38026: 1640:    public void set(Object obj) {
38027: 1641:        this.obj = obj;
38028: 1642:    }
38029: 1643:    
38030: 1644:    public Object get() {
38031: 1645:        return obj;
38032: 1646:    }
38033: 1647:    
38034: 1648:    public static void main(String[] args) {
38035: 1649:        SimpleHolder holder = new SimpleHolder();
38036: 1650:        holder.set("Item");
38037: 1651:        String s = (String) holder.get();
38038: 1652:    }
38039: 1653:}
38040: 1654:```
38041: 1655:
38042: 1656:如果用 **javap -c SimpleHolder** 反编译这个类，会得到如下内容（经过编辑）：
38043: 1657:
38044: 1658:```java
38045: 1659:public void set(java.lang.Object);
38046: 1660:   0: aload_0
38047: 1661:   1: aload_1
38048: 1662:   2: putfield #2; // Field obj:Object;
38049: 1663:   5: return
38050: 1664:    
38051: 1665:public java.lang.Object get();
38052: 1666:   0: aload_0
38053: 1667:   1: getfield #2; // Field obj:Object;
38054: 1668:   4: areturn
38055: 1669:    
38056: 1670:public static void main(java.lang.String[]);
38057: 1671:   0: new #3; // class SimpleHolder
38058: 1672:   3: dup
38059: 1673:   4: invokespecial #4; // Method "<init>":()V
38060: 1674:   7: astore_1
38061: 1675:   8: aload_1
38062: 1676:   9: ldc #5; // String Item
38063: 1677:   11: invokevirtual #6; // Method set:(Object;)V
38064: 1678:   14: aload_1
38065: 1679:   15: invokevirtual #7; // Method get:()Object;
38066: 1680:   18: checkcast #8; // class java/lang/String
38067: 1681:   21: astore_2
38068: 1682:   22: return
38069: 1683:```
38070: 1684:
38071: 1685:`set()` 和 `get()` 方法存储和产生值，转型在调用 `get()` 时接受检查。
38072: 1686:
38073: 1687:现在将泛型融入上例代码中：
38074: 1688:
38075: 1689:```java
38076: 1690:// generics/GenericHolder2.java
38077: 1691:
38078: 1692:public class GenericHolder2<T> {
38079: 1693:    private T obj;
38080: 1694:
38081: 1695:    public void set(T obj) {
38082: 1696:        this.obj = obj;
38083: 1697:    }
38084: 1698:
38085: 1699:    public T get() {
38086: 1700:        return obj;
38087: 1701:    }
38088: 1702:
38089: 1703:    public static void main(String[] args) {
38090: 1704:        GenericHolder2<String> holder =  new GenericHolder2<>();
38091: 1705:        holder.set("Item");
38092: 1706:        String s = holder.get();
38093: 1707:    }
38094: 1708:}
38095: 1709:```
38096: 1710:
38097: 1711:从 `get()` 返回后的转型消失了，但是我们还知道传递给 `set()` 的值在编译期会被检查。下面是相关的字节码：
38098: 1712:
38099: 1713:```java
38100: 1714:public void set(java.lang.Object);
38101: 1715:   0: aload_0
38102: 1716:   1: aload_1
38103: 1717:   2: putfield #2; // Field obj:Object;
38104: 1718:   5: return
38105: 1719:       
38106: 1720:public java.lang.Object get();
38107: 1721:   0: aload_0
38108: 1722:   1: getfield #2; // Field obj:Object;
38109: 1723:   4: areturn
38110: 1724:       
38111: 1725:public static void main(java.lang.String[]);
38112: 1726:   0: new #3; // class GenericHolder2
38113: 1727:   3: dup
38114: 1728:   4: invokespecial #4; // Method "<init>":()V
38115: 1729:   7: astore_1
38116: 1730:   8: aload_1
38117: 1731:   9: ldc #5; // String Item
38118: 1732:   11: invokevirtual #6; // Method set:(Object;)V
38119: 1733:   14: aload_1
38120: 1734:   15: invokevirtual #7; // Method get:()Object;
38121: 1735:   18: checkcast #8; // class java/lang/String
38122: 1736:   21: astore_2
38123: 1737:   22: return
38124: 1738:```
38125: 1739:
38126: 1740:所产生的字节码是相同的。对进入 `set()` 的类型进行检查是不需要的，因为这将由编译器执行。而对 `get()` 返回的值进行转型仍然是需要的，只不过不需要你来操作，它由编译器自动插入，这样你就不用编写（阅读）杂乱的代码。
38127: 1741:
38128: 1742:`get()` 和 `set()` 产生了相同的字节码，这就告诉我们泛型的所有动作都发生在边界处——对入参的编译器检查和对返回值的转型。这有助于澄清对擦除的困惑，记住：“边界就是动作发生的地方”。
38129: 1743:
38130: 1744:<!-- Compensating for Erasure -->
38131: 1745:
38132: 1746:## 补偿擦除
38133: 1747:
38134: 1748:因为擦除，我们将失去执行泛型代码中某些操作的能力。无法在运行时知道确切类型：
38135: 1749:
38136: 1750:```java
38137: 1751:// generics/Erased.java
38138: 1752:// {WillNotCompile}
38139: 1753:
38140: 1754:public class Erased<T> {
38141: 1755:    private final int SIZE = 100;
38142: 1756:
38143: 1757:    public void f(Object arg) {
38144: 1758:        // error: illegal generic type for instanceof
38145: 1759:        if (arg instanceof T) {
38146: 1760:        }
38147: 1761:        // error: unexpected type
38148: 1762:        T var = new T();
38149: 1763:        // error: generic array creation
38150: 1764:        T[] array = new T[SIZE];
38151: 1765:        // warning: [unchecked] unchecked cast
38152: 1766:        T[] array = (T[]) new Object[SIZE];
38153: 1767:
38154: 1768:    }
38155: 1769:}
38156: 1770:```
38157: 1771:
38158: 1772:有时，我们可以对这些问题进行编程，但是有时必须通过引入类型标签来补偿擦除。这意味着为所需的类型显式传递一个 **Class** 对象，以在类型表达式中使用它。
38159: 1773:
38160: 1774:例如，由于擦除了类型信息，因此在上一个程序中尝试使用 **instanceof** 将会失败。类型标签可以使用动态 `isInstance()` ：
38161: 1775:
38162: 1776:```java
38163: 1777:// generics/ClassTypeCapture.java
38164: 1778:
38165: 1779:class Building {
38166: 1780:}
38167: 1781:
38168: 1782:class House extends Building {
38169: 1783:}
38170: 1784:
38171: 1785:public class ClassTypeCapture<T> {
38172: 1786:    Class<T> kind;
38173: 1787:
38174: 1788:    public ClassTypeCapture(Class<T> kind) {
38175: 1789:        this.kind = kind;
38176: 1790:    }
38177: 1791:
38178: 1792:    public boolean f(Object arg) {
38179: 1793:        return kind.isInstance(arg);
38180: 1794:    }
38181: 1795:
38182: 1796:    public static void main(String[] args) {
38183: 1797:        ClassTypeCapture<Building> ctt1 =
38184: 1798:                new ClassTypeCapture<>(Building.class);
38185: 1799:        System.out.println(ctt1.f(new Building()));
38186: 1800:        System.out.println(ctt1.f(new House()));
38187: 1801:        ClassTypeCapture<House> ctt2 =
38188: 1802:                new ClassTypeCapture<>(House.class);
38189: 1803:        System.out.println(ctt2.f(new Building()));
38190: 1804:        System.out.println(ctt2.f(new House()));
38191: 1805:    }
38192: 1806:}
38193: 1807:/* Output:
38194: 1808:true
38195: 1809:true
38196: 1810:false
38197: 1811:true
38198: 1812:*/
38199: 1813:```
38200: 1814:
38201: 1815:编译器来保证类型标签与泛型参数相匹配。
38202: 1816:
38203: 1817:<!-- Creating Instances of Types -->
38204: 1818:
38205: 1819:### 创建类型的实例
38206: 1820:
38207: 1821:试图在 **Erased.java** 中 `new T()` 是行不通的，部分原因是由于擦除，部分原因是编译器无法验证 **T** 是否具有默认（无参）构造函数。但是在 C++ 中，此操作自然，直接且安全（在编译时检查）：
38208: 1822:
38209: 1823:```C++
38210: 1824:// generics/InstantiateGenericType.cpp
38211: 1825:// C++, not Java!
38212: 1826:
38213: 1827:template<class T> class Foo {
38214: 1828:  T x; // Create a field of type T
38215: 1829:  T* y; // Pointer to T
38216: 1830:public:
38217: 1831:  // Initialize the pointer:
38218: 1832:  Foo() { y = new T(); }
38219: 1833:};
38220: 1834:
38221: 1835:class Bar {};
38222: 1836:
38223: 1837:int main() {
38224: 1838:  Foo<Bar> fb;
38225: 1839:  Foo<int> fi; // ... and it works with primitives
38226: 1840:}
38227: 1841:```
38228: 1842:
38229: 1843:Java 中的解决方案是传入一个工厂对象，并使用该对象创建新实例。方便的工厂对象只是 **Class** 对象，因此，如果使用类型标记，则可以使用 `newInstance()` 创建该类型的新对象：
38230: 1844:
38231: 1845:```java
38232: 1846:// generics/InstantiateGenericType.java
38233: 1847:
38234: 1848:import java.util.function.Supplier;
38235: 1849:
38236: 1850:class ClassAsFactory<T> implements Supplier<T> {
38237: 1851:    Class<T> kind;
38238: 1852:
38239: 1853:    ClassAsFactory(Class<T> kind) {
38240: 1854:        this.kind = kind;
38241: 1855:    }
38242: 1856:
38243: 1857:    @Override
38244: 1858:    public T get() {
38245: 1859:        try {
38246: 1860:            return kind.newInstance();
38247: 1861:        } catch (InstantiationException |
38248: 1862:                IllegalAccessException e) {
38249: 1863:            throw new RuntimeException(e);
38250: 1864:        }
38251: 1865:    }
38252: 1866:}
38253: 1867:
38254: 1868:class Employee {
38255: 1869:    @Override
38256: 1870:    public String toString() {
38257: 1871:        return "Employee";
38258: 1872:    }
38259: 1873:}
38260: 1874:
38261: 1875:public class InstantiateGenericType {
38262: 1876:    public static void main(String[] args) {
38263: 1877:        ClassAsFactory<Employee> fe =
38264: 1878:                new ClassAsFactory<>(Employee.class);
38265: 1879:        System.out.println(fe.get());
38266: 1880:        ClassAsFactory<Integer> fi =
38267: 1881:                new ClassAsFactory<>(Integer.class);
38268: 1882:        try {
38269: 1883:            System.out.println(fi.get());
38270: 1884:        } catch (Exception e) {
38271: 1885:            System.out.println(e.getMessage());
38272: 1886:        }
38273: 1887:    }
38274: 1888:}
38275: 1889:/* Output:
38276: 1890:Employee
38277: 1891:java.lang.InstantiationException: java.lang.Integer
38278: 1892:*/
38279: 1893:```
38280: 1894:
38281: 1895:这样可以编译，但对于 `ClassAsFactory<Integer>` 会失败，这是因为 **Integer** 没有无参构造函数。由于错误不是在编译时捕获的，因此语言创建者不赞成这种方法。他们建议使用显式工厂（**Supplier**）并约束类型，以便只有实现该工厂的类可以这样创建对象。这是创建工厂的两种不同方法：
38282: 1896:
38283: 1897:```java
38284: 1898:// generics/FactoryConstraint.java
38285: 1899:
38286: 1900:import onjava.Suppliers;
38287: 1901:
38288: 1902:import java.util.ArrayList;
38289: 1903:import java.util.List;
38290: 1904:import java.util.function.Supplier;
38291: 1905:
38292: 1906:class IntegerFactory implements Supplier<Integer> {
38293: 1907:    private int i = 0;
38294: 1908:
38295: 1909:    @Override
38296: 1910:    public Integer get() {
38297: 1911:        return ++i;
38298: 1912:    }
38299: 1913:}
38300: 1914:
38301: 1915:class Widget {
38302: 1916:    private int id;
38303: 1917:
38304: 1918:    Widget(int n) {
38305: 1919:        id = n;
38306: 1920:    }
38307: 1921:
38308: 1922:    @Override
38309: 1923:    public String toString() {
38310: 1924:        return "Widget " + id;
38311: 1925:    }
38312: 1926:
38313: 1927:    public static
38314: 1928:    class Factory implements Supplier<Widget> {
38315: 1929:        private int i = 0;
38316: 1930:
38317: 1931:        @Override
38318: 1932:        public Widget get() {
38319: 1933:            return new Widget(++i);
38320: 1934:        }
38321: 1935:    }
38322: 1936:}
38323: 1937:
38324: 1938:class Fudge {
38325: 1939:    private static int count = 1;
38326: 1940:    private int n = count++;
38327: 1941:
38328: 1942:    @Override
38329: 1943:    public String toString() {
38330: 1944:        return "Fudge " + n;
38331: 1945:    }
38332: 1946:}
38333: 1947:
38334: 1948:class Foo2<T> {
38335: 1949:    private List<T> x = new ArrayList<>();
38336: 1950:
38337: 1951:    Foo2(Supplier<T> factory) {
38338: 1952:        Suppliers.fill(x, factory, 5);
38339: 1953:    }
38340: 1954:
38341: 1955:    @Override
38342: 1956:    public String toString() {
38343: 1957:        return x.toString();
38344: 1958:    }
38345: 1959:}
38346: 1960:
38347: 1961:public class FactoryConstraint {
38348: 1962:    public static void main(String[] args) {
38349: 1963:        System.out.println(
38350: 1964:                new Foo2<>(new IntegerFactory()));
38351: 1965:        System.out.println(
38352: 1966:                new Foo2<>(new Widget.Factory()));
38353: 1967:        System.out.println(
38354: 1968:                new Foo2<>(Fudge::new));
38355: 1969:    }
38356: 1970:}
38357: 1971:/* Output:
38358: 1972:[1, 2, 3, 4, 5]
38359: 1973:[Widget 1, Widget 2, Widget 3, Widget 4, Widget 5]
38360: 1974:[Fudge 1, Fudge 2, Fudge 3, Fudge 4, Fudge 5]
38361: 1975:*/
38362: 1976:```
38363: 1977:
38364: 1978:**IntegerFactory** 本身就是通过实现 `Supplier<Integer>` 的工厂。 **Widget** 包含一个内部类，它是一个工厂。还要注意，**Fudge** 并没有做任何类似于工厂的操作，并且传递 `Fudge::new` 仍然会产生工厂行为，因为编译器将对函数方法 `::new` 的调用转换为对 `get()` 的调用。
38365: 1979:
38366: 1980:另一种方法是模板方法设计模式。在以下示例中，`create()` 是模板方法，在子类中被重写以生成该类型的对象：
38367: 1981:
38368: 1982:```java
38369: 1983:// generics/CreatorGeneric.java
38370: 1984:
38371: 1985:abstract class GenericWithCreate<T> {
38372: 1986:    final T element;
38373: 1987:
38374: 1988:    GenericWithCreate() {
38375: 1989:        element = create();
38376: 1990:    }
38377: 1991:
38378: 1992:    abstract T create();
38379: 1993:}
38380: 1994:
38381: 1995:class X {
38382: 1996:}
38383: 1997:
38384: 1998:class XCreator extends GenericWithCreate<X> {
38385: 1999:    @Override
38386: 2000:    X create() {
38387: 2001:        return new X();
38388: 2002:    }
38389: 2003:
38390: 2004:    void f() {
38391: 2005:        System.out.println(
38392: 2006:                element.getClass().getSimpleName());
38393: 2007:    }
38394: 2008:}
38395: 2009:
38396: 2010:public class CreatorGeneric {
38397: 2011:    public static void main(String[] args) {
38398: 2012:        XCreator xc = new XCreator();
38399: 2013:        xc.f();
38400: 2014:    }
38401: 2015:}
38402: 2016:/* Output:
38403: 2017:X
38404: 2018:*/
38405: 2019:```
38406: 2020:
38407: 2021:**GenericWithCreate** 包含 `element` 字段，并通过无参构造函数强制其初始化，该构造函数又调用抽象的 `create()` 方法。这种创建方式可以在子类中定义，同时建立 **T** 的类型。
38408: 2022:
38409: 2023:<!-- Arrays of Generics -->
38410: 2024:
38411: 2025:### 泛型数组
38412: 2026:
38413: 2027:正如在 **Erased.java** 中所看到的，我们无法创建泛型数组。通用解决方案是在试图创建泛型数组的时候使用 **ArrayList** ：
38414: 2028:
38415: 2029:```java
38416: 2030:// generics/ListOfGenerics.java
38417: 2031:
38418: 2032:import java.util.ArrayList;
38419: 2033:import java.util.List;
38420: 2034:
38421: 2035:public class ListOfGenerics<T> {
38422: 2036:    private List<T> array = new ArrayList<>();
38423: 2037:
38424: 2038:    public void add(T item) {
38425: 2039:        array.add(item);
38426: 2040:    }
38427: 2041:
38428: 2042:    public T get(int index) {
38429: 2043:        return array.get(index);
38430: 2044:    }
38431: 2045:}
38432: 2046:```
38433: 2047:
38434: 2048:这样做可以获得数组的行为，并且还具有泛型提供的编译时类型安全性。
38435: 2049:
38436: 2050:有时，仍然会创建泛型类型的数组（例如， **ArrayList** 在内部使用数组）。可以通过使编译器满意的方式定义对数组的通用引用：
38437: 2051:
38438: 2052:```java
38439: 2053:// generics/ArrayOfGenericReference.java
38440: 2054:
38441: 2055:class Generic<T> {
38442: 2056:}
38443: 2057:
38444: 2058:public class ArrayOfGenericReference {
38445: 2059:    static Generic<Integer>[] gia;
38446: 2060:}
38447: 2061:```
38448: 2062:
38449: 2063:编译器接受此操作而不产生警告。但是我们永远无法创建具有该确切类型（包括类型参数）的数组，因此有点令人困惑。由于所有数组，无论它们持有什么类型，都具有相同的结构（每个数组插槽的大小和数组布局），因此似乎可以创建一个 **Object** 数组并将其转换为所需的数组类型。实际上，这确实可以编译，但是会产生 **ClassCastException** ：
38450: 2064:
38451: 2065:```java
38452: 2066:// generics/ArrayOfGeneric.java
38453: 2067:
38454: 2068:public class ArrayOfGeneric {
38455: 2069:    static final int SIZE = 100;
38456: 2070:    static Generic<Integer>[] gia;
38457: 2071:
38458: 2072:    @SuppressWarnings("unchecked")
38459: 2073:    public static void main(String[] args) {
38460: 2074:        try {
38461: 2075:            gia = (Generic<Integer>[]) new Object[SIZE];
38462: 2076:        } catch (ClassCastException e) {
38463: 2077:            System.out.println(e.getMessage());
38464: 2078:        }
38465: 2079:        // Runtime type is the raw (erased) type:
38466: 2080:        gia = (Generic<Integer>[]) new Generic[SIZE];
38467: 2081:        System.out.println(gia.getClass().getSimpleName());
38468: 2082:        gia[0] = new Generic<>();
38469: 2083:        //- gia[1] = new Object(); // Compile-time error
38470: 2084:        // Discovers type mismatch at compile time:
38471: 2085:        //- gia[2] = new Generic<Double>();
38472: 2086:    }
38473: 2087:}
38474: 2088:/* Output:
38475: 2089:[Ljava.lang.Object; cannot be cast to [LGeneric;
38476: 2090:Generic[]
38477: 2091:*/
38478: 2092:```
38479: 2093:
38480: 2094:问题在于数组会跟踪其实际类型，而该类型是在创建数组时建立的。因此，即使 `gia` 被强制转换为 `Generic<Integer>[]` ，该信息也仅在编译时存在（并且没有 **@SuppressWarnings** 注解，将会收到有关该强制转换的警告）。在运行时，它仍然是一个 **Object** 数组，这会引起问题。成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换。
38481: 2095:
38482: 2096:让我们看一个更复杂的示例。考虑一个包装数组的简单泛型包装器：
38483: 2097:
38484: 2098:```java
38485: 2099:// generics/GenericArray.java
38486: 2100:
38487: 2101:public class GenericArray<T> {
38488: 2102:    private T[] array;
38489: 2103:
38490: 2104:    @SuppressWarnings("unchecked")
38491: 2105:    public GenericArray(int sz) {
38492: 2106:        array = (T[]) new Object[sz];
38493: 2107:    }
38494: 2108:
38495: 2109:    public void put(int index, T item) {
38496: 2110:        array[index] = item;
38497: 2111:    }
38498: 2112:
38499: 2113:    public T get(int index) {
38500: 2114:        return array[index];
38501: 2115:    }
38502: 2116:
38503: 2117:    // Method that exposes the underlying representation:
38504: 2118:    public T[] rep() {
38505: 2119:        return array;
38506: 2120:    }
38507: 2121:
38508: 2122:    public static void main(String[] args) {
38509: 2123:        GenericArray<Integer> gai = new GenericArray<>(10);
38510: 2124:        try {
38511: 2125:            Integer[] ia = gai.rep();
38512: 2126:        } catch (ClassCastException e) {
38513: 2127:            System.out.println(e.getMessage());
38514: 2128:        }
38515: 2129:        // This is OK:
38516: 2130:        Object[] oa = gai.rep();
38517: 2131:    }
38518: 2132:}
38519: 2133:/* Output:
38520: 2134:[Ljava.lang.Object; cannot be cast to
38521: 2135:[Ljava.lang.Integer;
38522: 2136:*/
38523: 2137:```
38524: 2138:
38525: 2139:和以前一样，我们不能说 `T[] array = new T[sz]` ，所以我们创建了一个 **Object** 数组并将其强制转换。
38526: 2140:
38527: 2141:`rep()` 方法返回一个 `T[]` ，在主方法中它应该是 `gai` 的 `Integer[]`，但是如果调用它并尝试将结果转换为 `Integer[]` 引用，则会得到 **ClassCastException** ，这再次是因为实际的运行时类型为 `Object[]` 。
38528: 2142:
38529: 2143:如果再注释掉 **@SuppressWarnings** 注解后编译 **GenericArray.java** ，则编译器会产生警告：
38530: 2144:
38531: 2145:```java
38532: 2146:GenericArray.java uses unchecked or unsafe operations.
38533: 2147:Recompile with -Xlint:unchecked for details.
38534: 2148:```
38535: 2149:
38536: 2150:在这里，我们收到了一个警告，我们认为这是有关强制转换的。
38537: 2151:
38538: 2152:但是要真正确定，请使用 `-Xlint：unchecked` 进行编译：
38539: 2153:
38540: 2154:```java
38541: 2155:GenericArray.java:7: warning: [unchecked] unchecked cast    array = (T[])new Object[sz];                 ^  required: T[]  found:    Object[]  where T is a type-variable:    T extends Object declared in class GenericArray 1 warning
38542: 2156:```
38543: 2157:
38544: 2158:确实是在抱怨那个强制转换。由于警告会变成噪音，因此，一旦我们确认预期会出现特定警告，我们可以做的最好的办法就是使用 **@SuppressWarnings** 将其关闭。这样，当警告确实出现时，我们将进行实际调查。
38545: 2159:
38546: 2160:由于擦除，数组的运行时类型只能是 `Object[]` 。 如果我们立即将其转换为 `T[]` ，则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。因此，最好在集合中使用 `Object[]` ，并在使用数组元素时向 **T** 添加强制类型转换。让我们来看看在 **GenericArray.java** 示例中会是怎么样的：
38547: 2161:
38548: 2162:```java
38549: 2163:// generics/GenericArray2.java
38550: 2164:
38551: 2165:public class GenericArray2<T> {
38552: 2166:    private Object[] array;
38553: 2167:
38554: 2168:    public GenericArray2(int sz) {
38555: 2169:        array = new Object[sz];
38556: 2170:    }
38557: 2171:
38558: 2172:    public void put(int index, T item) {
38559: 2173:        array[index] = item;
38560: 2174:    }
38561: 2175:
38562: 2176:    @SuppressWarnings("unchecked")
38563: 2177:    public T get(int index) {
38564: 2178:        return (T) array[index];
38565: 2179:    }
38566: 2180:
38567: 2181:    @SuppressWarnings("unchecked")
38568: 2182:    public T[] rep() {
38569: 2183:        return (T[]) array; // Unchecked cast
38570: 2184:    }
38571: 2185:
38572: 2186:    public static void main(String[] args) {
38573: 2187:        GenericArray2<Integer> gai =
38574: 2188:                new GenericArray2<>(10);
38575: 2189:        for (int i = 0; i < 10; i++)
38576: 2190:            gai.put(i, i);
38577: 2191:        for (int i = 0; i < 10; i++)
38578: 2192:            System.out.print(gai.get(i) + " ");
38579: 2193:        System.out.println();
38580: 2194:        try {
38581: 2195:            Integer[] ia = gai.rep();
38582: 2196:        } catch (Exception e) {
38583: 2197:            System.out.println(e);
38584: 2198:        }
38585: 2199:    }
38586: 2200:}
38587: 2201:/* Output:
38588: 2202:0 1 2 3 4 5 6 7 8 9
38589: 2203:java.lang.ClassCastException: [Ljava.lang.Object;
38590: 2204:cannot be cast to [Ljava.lang.Integer;
38591: 2205:*/
38592: 2206:```
38593: 2207:
38594: 2208:最初，看起来并没有太大不同，只是转换的位置移动了。没有 **@SuppressWarnings** 注解，仍然会收到“unchecked”警告。但是，内部表示现在是 `Object[]` 而不是 `T[]` 。 调用 `get()` 时，它将对象强制转换为 **T** ，实际上这是正确的类型，因此很安全。但是，如果调用 `rep()` ，它将再次尝试将 `Object[]` 强制转换为 `T[]` ，但仍然不正确，并在编译时生成警告，并在运行时生成异常。因此，无法破坏基础数组的类型，该基础数组只能是 `Object[]` 。在内部将数组视为 `Object[]` 而不是 `T[]` 的优点是，我们不太可能会忘记数组的运行时类型并意外地引入了bug，尽管大多数（也许是全部）此类错误会在运行时被迅速检测到。
38595: 2209:
38596: 2210:对于新代码，请传入类型标记。在这种情况下，**GenericArray** 如下所示：
38597: 2211:
38598: 2212:```java
38599: 2213:// generics/GenericArrayWithTypeToken.java
38600: 2214:
38601: 2215:import java.lang.reflect.Array;
38602: 2216:
38603: 2217:public class GenericArrayWithTypeToken<T> {
38604: 2218:    private T[] array;
38605: 2219:
38606: 2220:    @SuppressWarnings("unchecked")
38607: 2221:    public GenericArrayWithTypeToken(Class<T> type, int sz) {
38608: 2222:        array = (T[]) Array.newInstance(type, sz);
38609: 2223:    }
38610: 2224:
38611: 2225:    public void put(int index, T item) {
38612: 2226:        array[index] = item;
38613: 2227:    }
38614: 2228:
38615: 2229:    public T get(int index) {
38616: 2230:        return array[index];
38617: 2231:    }
38618: 2232:
38619: 2233:    // Expose the underlying representation:
38620: 2234:    public T[] rep() {
38621: 2235:        return array;
38622: 2236:    }
38623: 2237:
38624: 2238:    public static void main(String[] args) {
38625: 2239:        GenericArrayWithTypeToken<Integer> gai =
38626: 2240:                new GenericArrayWithTypeToken<>(
38627: 2241:                        Integer.class, 10);
38628: 2242:        // This now works:
38629: 2243:        Integer[] ia = gai.rep();
38630: 2244:    }
38631: 2245:}
38632: 2246:```
38633: 2247:
38634: 2248:类型标记 **Class\<T\>** 被传递到构造函数中以从擦除中恢复，因此尽管必须使用 **@SuppressWarnings** 关闭来自强制类型转换的警告，但我们仍可以创建所需的实际数组类型。一旦获得了实际的类型，就可以返回它并产生所需的结果，如在主方法中看到的那样。数组的运行时类型是确切的类型 `T[]` 。
38635: 2249:
38636: 2250:不幸的是，如果查看 Java 标准库中的源代码，你会发现到处都有从 **Object** 数组到参数化类型的转换。例如，这是**ArrayList** 中，复制一个 **Collection** 的构造函数，这里为了简化，去除了源码中对此不重要的代码：
38637: 2251:
38638: 2252:```java
38639: 2253:public ArrayList(Collection c) {
38640: 2254:  size = c.size();
38641: 2255:  elementData = (E[])new Object[size];
38642: 2256:  c.toArray(elementData);
38643: 2257:}
38644: 2258:```
38645: 2259:
38646: 2260:如果你浏览 **ArrayList.java** 的代码，将会发现很多此类强制转换。当我们编译它时会发生什么？
38647: 2261:
38648: 2262:```java
38649: 2263:Note: ArrayList.java uses unchecked or unsafe operations
38650: 2264:Note: Recompile with -Xlint:unchecked for details.
38651: 2265:```
38652: 2266:
38653: 2267:果然，标准库会产生很多警告。如果你使用过 C 语言，尤其是使用 ANSI C 之前的语言，你会记住警告的特殊效果：发现警告后，可以忽略它们。因此，除非程序员必须对其进行处理，否则最好不要从编译器发出任何类型的消息。
38654: 2268:
38655: 2269:Neal Gafter（Java 5 的主要开发人员之一）在他的博客中[^2]指出，他在重写 Java 库时是很随意、马虎的，我们不应该像他那样做。Neal 还指出，他在不破坏现有接口的情况下无法修复某些 Java 库代码。因此，即使在 Java 库源代码中出现了一些习惯用法，它们也不一定是正确的做法。当查看库代码时，我们不能认为这就是要在自己代码中必须遵循的示例。
38656: 2270:
38657: 2271:请注意，在 Java 文献中推荐使用类型标记技术，例如 Gilad Bracha 的论文《Generics in the Java Programming Language》[^3]，他指出：“例如，这种用法已广泛用于新的 API 中以处理注解。” 我发现此技术在人们对于舒适度的看法方面存在一些不一致之处；有些人强烈喜欢本章前面介绍的工厂方法。
38658: 2272:
38659: 2273:<!-- Bounds -->
38660: 2274:
38661: 2275:## 边界
38662: 2276:
38663: 2277:*边界*（bounds）在本章的前面进行了简要介绍。边界允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法。
38664: 2278:
38665: 2279:由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 **Object** 可用的方法。但是，如果将该参数限制为某类型的子集，则可以调用该子集中的方法。为了应用约束，Java 泛型使用了 `extends` 关键字。
38666: 2280:
38667: 2281:重要的是要理解，当用于限定泛型类型时，`extends` 的含义与通常的意义截然不同。此示例展示边界的基础应用：
38668: 2282:
38669: 2283:```java
38670: 2284:// generics/BasicBounds.java
38671: 2285:
38672: 2286:interface HasColor {
38673: 2287:    java.awt.Color getColor();
38674: 2288:}
38675: 2289:
38676: 2290:class WithColor<T extends HasColor> {
38677: 2291:    T item;
38678: 2292:
38679: 2293:    WithColor(T item) {
38680: 2294:        this.item = item;
38681: 2295:    }
38682: 2296:
38683: 2297:    T getItem() {
38684: 2298:        return item;
38685: 2299:    }
38686: 2300:
38687: 2301:    // The bound allows you to call a method:
38688: 2302:    java.awt.Color color() {
38689: 2303:        return item.getColor();
38690: 2304:    }
38691: 2305:}
38692: 2306:
38693: 2307:class Coord {
38694: 2308:    public int x, y, z;
38695: 2309:}
38696: 2310:
38697: 2311:// This fails. Class must be first, then interfaces:
38698: 2312:// class WithColorCoord<T extends HasColor & Coord> {
38699: 2313:
38700: 2314:// Multiple bounds:
38701: 2315:class WithColorCoord<T extends Coord & HasColor> {
38702: 2316:    T item;
38703: 2317:
38704: 2318:    WithColorCoord(T item) {
38705: 2319:        this.item = item;
38706: 2320:    }
38707: 2321:
38708: 2322:    T getItem() {
38709: 2323:        return item;
38710: 2324:    }
38711: 2325:
38712: 2326:    java.awt.Color color() {
38713: 2327:        return item.getColor();
38714: 2328:    }
38715: 2329:
38716: 2330:    int getX() {
38717: 2331:        return item.x;
38718: 2332:    }
38719: 2333:
38720: 2334:    int getY() {
38721: 2335:        return item.y;
38722: 2336:    }
38723: 2337:
38724: 2338:    int getZ() {
38725: 2339:        return item.z;
38726: 2340:    }
38727: 2341:}
38728: 2342:
38729: 2343:interface Weight {
38730: 2344:    int weight();
38731: 2345:}
38732: 2346:
38733: 2347:// As with inheritance, you can have only one
38734: 2348:// concrete class but multiple interfaces:
38735: 2349:class Solid<T extends Coord & HasColor & Weight> {
38736: 2350:    T item;
38737: 2351:
38738: 2352:    Solid(T item) {
38739: 2353:        this.item = item;
38740: 2354:    }
38741: 2355:
38742: 2356:    T getItem() {
38743: 2357:        return item;
38744: 2358:    }
38745: 2359:
38746: 2360:    java.awt.Color color() {
38747: 2361:        return item.getColor();
38748: 2362:    }
38749: 2363:
38750: 2364:    int getX() {
38751: 2365:        return item.x;
38752: 2366:    }
38753: 2367:
38754: 2368:    int getY() {
38755: 2369:        return item.y;
38756: 2370:    }
38757: 2371:
38758: 2372:    int getZ() {
38759: 2373:        return item.z;
38760: 2374:    }
38761: 2375:
38762: 2376:    int weight() {
38763: 2377:        return item.weight();
38764: 2378:    }
38765: 2379:}
38766: 2380:
38767: 2381:class Bounded
38768: 2382:        extends Coord implements HasColor, Weight {
38769: 2383:    @Override
38770: 2384:    public java.awt.Color getColor() {
38771: 2385:        return null;
38772: 2386:    }
38773: 2387:
38774: 2388:    @Override
38775: 2389:    public int weight() {
38776: 2390:        return 0;
38777: 2391:    }
38778: 2392:}
38779: 2393:
38780: 2394:public class BasicBounds {
38781: 2395:    public static void main(String[] args) {
38782: 2396:        Solid<Bounded> solid =
38783: 2397:                new Solid<>(new Bounded());
38784: 2398:        solid.color();
38785: 2399:        solid.getY();
38786: 2400:        solid.weight();
38787: 2401:    }
38788: 2402:}
38789: 2403:```
38790: 2404:
38791: 2405:你可能会观察到 **BasicBounds.java** 中似乎包含一些冗余，它们可以通过继承来消除。在这里，每个继承级别还添加了边界约束：
38792: 2406:
38793: 2407:```java
38794: 2408:// generics/InheritBounds.java
38795: 2409:
38796: 2410:class HoldItem<T> {
38797: 2411:    T item;
38798: 2412:
38799: 2413:    HoldItem(T item) {
38800: 2414:        this.item = item;
38801: 2415:    }
38802: 2416:
38803: 2417:    T getItem() {
38804: 2418:        return item;
38805: 2419:    }
38806: 2420:}
38807: 2421:
38808: 2422:class WithColor2<T extends HasColor>
38809: 2423:        extends HoldItem<T> {
38810: 2424:    WithColor2(T item) {
38811: 2425:        super(item);
38812: 2426:    }
38813: 2427:
38814: 2428:    java.awt.Color color() {
38815: 2429:        return item.getColor();
38816: 2430:    }
38817: 2431:}
38818: 2432:
38819: 2433:class WithColorCoord2<T extends Coord & HasColor>
38820: 2434:        extends WithColor2<T> {
38821: 2435:    WithColorCoord2(T item) {
38822: 2436:        super(item);
38823: 2437:    }
38824: 2438:
38825: 2439:    int getX() {
38826: 2440:        return item.x;
38827: 2441:    }
38828: 2442:
38829: 2443:    int getY() {
38830: 2444:        return item.y;
38831: 2445:    }
38832: 2446:
38833: 2447:    int getZ() {
38834: 2448:        return item.z;
38835: 2449:    }
38836: 2450:}
38837: 2451:
38838: 2452:class Solid2<T extends Coord & HasColor & Weight>
38839: 2453:        extends WithColorCoord2<T> {
38840: 2454:    Solid2(T item) {
38841: 2455:        super(item);
38842: 2456:    }
38843: 2457:
38844: 2458:    int weight() {
38845: 2459:        return item.weight();
38846: 2460:    }
38847: 2461:}
38848: 2462:
38849: 2463:public class InheritBounds {
38850: 2464:    public static void main(String[] args) {
38851: 2465:        Solid2<Bounded> solid2 =
38852: 2466:                new Solid2<>(new Bounded());
38853: 2467:        solid2.color();
38854: 2468:        solid2.getY();
38855: 2469:        solid2.weight();
38856: 2470:    }
38857: 2471:}
38858: 2472:```
38859: 2473:
38860: 2474:**HoldItem** 拥有一个对象，因此此行为将继承到 **WithColor2** 中，这也需要其参数符合 **HasColor**。 **WithColorCoord2** 和 **Solid2** 进一步扩展了层次结构，并在每个级别添加了边界。现在，这些方法已被继承，并且在每个类中不再重复。
38861: 2475:
38862: 2476:这是一个具有更多层次的示例：
38863: 2477:
38864: 2478:```java
38865: 2479:// generics/EpicBattle.java
38866: 2480:// Bounds in Java generics
38867: 2481:
38868: 2482:import java.util.List;
38869: 2483:
38870: 2484:interface SuperPower {
38871: 2485:}
38872: 2486:
38873: 2487:interface XRayVision extends SuperPower {
38874: 2488:    void seeThroughWalls();
38875: 2489:}
38876: 2490:
38877: 2491:interface SuperHearing extends SuperPower {
38878: 2492:    void hearSubtleNoises();
38879: 2493:}
38880: 2494:
38881: 2495:interface SuperSmell extends SuperPower {
38882: 2496:    void trackBySmell();
38883: 2497:}
38884: 2498:
38885: 2499:class SuperHero<POWER extends SuperPower> {
38886: 2500:    POWER power;
38887: 2501:
38888: 2502:    SuperHero(POWER power) {
38889: 2503:        this.power = power;
38890: 2504:    }
38891: 2505:
38892: 2506:    POWER getPower() {
38893: 2507:        return power;
38894: 2508:    }
38895: 2509:}
38896: 2510:
38897: 2511:class SuperSleuth<POWER extends XRayVision>
38898: 2512:        extends SuperHero<POWER> {
38899: 2513:    SuperSleuth(POWER power) {
38900: 2514:        super(power);
38901: 2515:    }
38902: 2516:
38903: 2517:    void see() {
38904: 2518:        power.seeThroughWalls();
38905: 2519:    }
38906: 2520:}
38907: 2521:
38908: 2522:class
38909: 2523:CanineHero<POWER extends SuperHearing & SuperSmell>
38910: 2524:        extends SuperHero<POWER> {
38911: 2525:    CanineHero(POWER power) {
38912: 2526:        super(power);
38913: 2527:    }
38914: 2528:
38915: 2529:    void hear() {
38916: 2530:        power.hearSubtleNoises();
38917: 2531:    }
38918: 2532:
38919: 2533:    void smell() {
38920: 2534:        power.trackBySmell();
38921: 2535:    }
38922: 2536:}
38923: 2537:
38924: 2538:class SuperHearSmell
38925: 2539:        implements SuperHearing, SuperSmell {
38926: 2540:    @Override
38927: 2541:    public void hearSubtleNoises() {
38928: 2542:    }
38929: 2543:
38930: 2544:    @Override
38931: 2545:    public void trackBySmell() {
38932: 2546:    }
38933: 2547:}
38934: 2548:
38935: 2549:class DogPerson extends CanineHero<SuperHearSmell> {
38936: 2550:    DogPerson() {
38937: 2551:        super(new SuperHearSmell());
38938: 2552:    }
38939: 2553:}
38940: 2554:
38941: 2555:public class EpicBattle {
38942: 2556:    // Bounds in generic methods:
38943: 2557:    static <POWER extends SuperHearing>
38944: 2558:    void useSuperHearing(SuperHero<POWER> hero) {
38945: 2559:        hero.getPower().hearSubtleNoises();
38946: 2560:    }
38947: 2561:
38948: 2562:    static <POWER extends SuperHearing & SuperSmell>
38949: 2563:    void superFind(SuperHero<POWER> hero) {
38950: 2564:        hero.getPower().hearSubtleNoises();
38951: 2565:        hero.getPower().trackBySmell();
38952: 2566:    }
38953: 2567:
38954: 2568:    public static void main(String[] args) {
38955: 2569:        DogPerson dogPerson = new DogPerson();
38956: 2570:        useSuperHearing(dogPerson);
38957: 2571:        superFind(dogPerson);
38958: 2572:        // You can do this:
38959: 2573:        List<? extends SuperHearing> audioPeople;
38960: 2574:        // But you can't do this:
38961: 2575:        // List<? extends SuperHearing & SuperSmell> dogPs;
38962: 2576:    }
38963: 2577:}
38964: 2578:```
38965: 2579:
38966: 2580:接下来将要研究的通配符将会把范围限制在单个类型。
38967: 2581:
38968: 2582:<!-- Wildcards -->
38969: 2583:
38970: 2584:## 通配符
38971: 2585:
38972: 2586:你已经在 [集合](book/12-Collections.md) 章节中看到了一些简单示例使用了通配符——在泛型参数表达式中的问号，在 [类型信息](book/19-Type-Information.md) 一章中这种示例更多。本节将更深入地探讨这个特性。
38973: 2587:
38974: 2588:我们的起始示例要展示数组的一种特殊行为：你可以将派生类的数组赋值给基类的引用：
38975: 2589:
38976: 2590:```java
38977: 2591:// generics/CovariantArrays.java
38978: 2592:
38979: 2593:class Fruit {}
38980: 2594:
38981: 2595:class Apple extends Fruit {}
38982: 2596:
38983: 2597:class Jonathan extends Apple {}
38984: 2598:
38985: 2599:class Orange extends Fruit {}
38986: 2600:
38987: 2601:public class CovariantArrays {
38988: 2602:    
38989: 2603:    public static void main(String[] args) {
38990: 2604:        Fruit[] fruit = new Apple[10];
38991: 2605:        fruit[0] = new Apple(); // OK
38992: 2606:        fruit[1] = new Jonathan(); // OK
38993: 2607:        // Runtime type is Apple[], not Fruit[] or Orange[]:
38994: 2608:        try {
38995: 2609:            // Compiler allows you to add Fruit:
38996: 2610:            fruit[0] = new Fruit(); // ArrayStoreException
38997: 2611:        } catch (Exception e) {
38998: 2612:            System.out.println(e);
38999: 2613:        }
39000: 2614:        try {
39001: 2615:            // Compiler allows you to add Oranges:
39002: 2616:            fruit[0] = new Orange(); // ArrayStoreException
39003: 2617:        } catch (Exception e) {
39004: 2618:            System.out.println(e);
39005: 2619:        }
39006: 2620:    }
39007: 2621:}
39008: 2622:/* Output:
39009: 2623:java.lang.ArrayStoreException: Fruit
39010: 2624:java.lang.ArrayStoreException: Orange
39011: 2625:```
39012: 2626:
39013: 2627:`main()` 中的第一行创建了 **Apple** 数组，并赋值给一个 **Fruit** 数组引用。这是有意义的，因为 **Apple** 也是一种 **Fruit**，因此 **Apple** 数组应该也是一个 **Fruit** 数组。
39014: 2628:
39015: 2629:但是，如果实际的数组类型是 **Apple[]**，你可以在其中放置 **Apple** 或 **Apple** 的子类型，这在编译期和运行时都可以工作。但是你也可以在数组中放置 **Fruit** 对象。这对编译器来说是有意义的，因为它有一个 **Fruit[]** 引用——它有什么理由不允许将 **Fruit** 对象或任何从 **Fruit** 继承出来的对象（比如 **Orange**），放置到这个数组中呢？因此在编译期，这是允许的。然而，运行时的数组机制知道它处理的是 **Apple[]**，因此会在向数组中放置异构类型时抛出异常。
39016: 2630:
39017: 2631:向上转型用在这里不合适。你真正在做的是将一个数组赋值给另一个数组。数组的行为是持有其他对象，这里只是因为我们能够向上转型而已，所以很明显，数组对象可以保留有关它们包含的对象类型的规则。看起来就像数组对它们持有的对象是有意识的，因此在编译期检查和运行时检查之间，你不能滥用它们。
39018: 2632:
39019: 2633:数组的这种赋值并不是那么可怕，因为在运行时你可以发现插入了错误的类型。但是泛型的主要目标之一是将这种错误检测移到编译期。所以当我们试图使用泛型集合代替数组时，会发生什么呢？
39020: 2634:
39021: 2635:```java
39022: 2636:// generics/NonCovariantGenerics.java
39023: 2637:// {WillNotCompile}
39024: 2638:
39025: 2639:import java.util.*;
39026: 2640:
39027: 2641:public class NonCovariantGenerics {
39028: 2642:    // Compile Error: incompatible types:
39029: 2643:    List<Fruit> flist = new ArrayList<Apple>();
39030: 2644:}
39031: 2645:```
39032: 2646:
39033: 2647:尽管你在首次阅读这段代码时会认为“不能将一个 **Apple** 集合赋值给一个 **Fruit** 集合”。记住，泛型不仅仅是关于集合，它真正要表达的是“不能把一个涉及 **Apple** 的泛型赋值给一个涉及 **Fruit** 的泛型”。如果像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及到的集合，那么它可能会留下一些余地。但是它不知道任何有关这方面的信息，因此它拒绝向上转型。然而实际上这也不是向上转型—— **Apple** 的 **List** 不是 **Fruit** 的 **List**。**Apple** 的 **List** 将持有 **Apple** 和 **Apple** 的子类型，**Fruit** 的 **List** 将持有任何类型的 **Fruit**。是的，这包括 **Apple**，但是它不是一个 **Apple** 的 **List**，它仍然是 **Fruit** 的 **List**。**Apple** 的 **List** 在类型上不等价于 **Fruit** 的 **List**，即使 **Apple** 是一种 **Fruit** 类型。
39034: 2648:
39035: 2649:真正的问题是我们在讨论的集合类型，而不是集合持有对象的类型。与数组不同，泛型没有内建的协变类型。这是因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查，但是在使用泛型时，编译器和运行时系统不知道你想用类型做什么，以及应该采用什么规则。
39036: 2650:
39037: 2651:但是，有时你想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。
39038: 2652:
39039: 2653:```java
39040: 2654:// generics/GenericsAndCovariance.java
39041: 2655:
39042: 2656:import java.util.*;
39043: 2657:
39044: 2658:public class GenericsAndCovariance {
39045: 2659:    
39046: 2660:    public static void main(String[] args) {
39047: 2661:        // Wildcards allow covariance:
39048: 2662:        List<? extends Fruit> flist = new ArrayList<>();
39049: 2663:        // Compile Error: can't add any type of object:
39050: 2664:        // flist.add(new Apple());
39051: 2665:        // flist.add(new Fruit());
39052: 2666:        // flist.add(new Object());
39053: 2667:        flist.add(null); // Legal but uninteresting
39054: 2668:        // We know it returns at least Fruit:
39055: 2669:        Fruit f = flist.get(0);
39056: 2670:    }
39057: 2671:    
39058: 2672:}
39059: 2673:```
39060: 2674:
39061: 2675:**flist** 的类型现在是 `List<? extends Fruit>`，你可以读作“一个具有任何从 **Fruit** 继承的类型的列表”。然而，这实际上并不意味着这个 **List** 将持有任何类型的 **Fruit**。通配符引用的是明确的类型，因此它意味着“某种 **flist** 引用没有指定的具体类型”。因此这个被赋值的 **List** 必须持有诸如 **Fruit** 或 **Apple** 这样的指定类型，但是为了向上转型为 **Fruit**，这个类型是什么没人在意。
39062: 2676:
39063: 2677:**List** 必须持有一种具体的 **Fruit** 或 **Fruit** 的子类型，但是如果你不关心具体的类型是什么，那么你能对这样的 **List** 做什么呢？如果不知道 **List** 中持有的对象是什么类型，你怎能保证安全地向其中添加对象呢？就像在 **CovariantArrays.java** 中向上转型一样，你不能，除非编译器而不是运行时系统可以阻止这种操作的发生。你很快就会发现这个问题。
39064: 2678:
39065: 2679:你可能认为事情开始变得有点走极端了，因为现在你甚至不能向刚刚声明过将持有 **Apple** 对象的 **List** 中放入一个 **Apple** 对象。是的，但编译器并不知道这一点。`List<? extends Fruit>` 可能合法地指向一个 `List<Orange>`。一旦执行这种类型的向上转型，你就丢失了向其中传递任何对象的能力，甚至传递 **Object** 也不行。
39066: 2680:
39067: 2681:另一方面，如果你调用了一个返回 **Fruit** 的方法，则是安全的，因为你知道这个 **List** 中的任何对象至少具有 **Fruit** 类型，因此编译器允许这么做。
39068: 2682:
39069: 2683:### 编译器有多聪明
39070: 2684:
39071: 2685:现在你可能会猜想自己不能去调用任何接受参数的方法，但是考虑下面的代码：
39072: 2686:
39073: 2687:```java
39074: 2688:// generics/CompilerIntelligence.java
39075: 2689:
39076: 2690:import java.util.*;
39077: 2691:
39078: 2692:public class CompilerIntelligence {
39079: 2693:    
39080: 2694:    public static void main(String[] args) {
39081: 2695:        List<? extends Fruit> flist = Arrays.asList(new Apple());
39082: 2696:        Apple a = (Apple) flist.get(0); // No warning
39083: 2697:        flist.contains(new Apple()); // Argument is 'Object'
39084: 2698:        flist.indexOf(new Apple()); // Argument is 'Object'
39085: 2699:    }
39086: 2700:    
39087: 2701:}
39088: 2702:```
39089: 2703:
39090: 2704:这里对 `contains()` 和 `indexOf()` 的调用接受 **Apple** 对象作为参数，执行没问题。这是否意味着编译器实际上会检查代码，以查看是否有某个特定的方法修改了它的对象？
39091: 2705:
39092: 2706:通过查看 **ArrayList** 的文档，我们发现编译器没有那么聪明。尽管 `add()` 接受一个泛型参数类型的参数，但 `contains()` 和 `indexOf()` 接受的参数类型是 **Object**。因此当你指定一个 `ArrayList<? extends Fruit>` 时，`add()` 的参数就变成了"**? extends Fruit**"。从这个描述中，编译器无法得知这里需要 **Fruit** 的哪个具体子类型，因此它不会接受任何类型的 **Fruit**。如果你先把 **Apple** 向上转型为 **Fruit**，也没有关系——编译器仅仅会拒绝调用像 `add()` 这样参数列表中涉及通配符的方法。
39093: 2707:
39094: 2708:`contains()` 和 `indexOf()` 的参数类型是 **Object**，不涉及通配符，所以编译器允许调用它们。这意味着将由泛型类的设计者来决定哪些调用是“安全的”，并使用 **Object** 类作为它们的参数类型。为了禁止对类型中使用了通配符的方法调用，需要在参数列表中使用类型参数。
39095: 2709:
39096: 2710:下面展示一个简单的 **Holder** 类：
39097: 2711:
39098: 2712:```java
39099: 2713:// generics/Holder.java
39100: 2714:
39101: 2715:public class Holder<T> {
39102: 2716:
39103: 2717:    private T value;
39104: 2718:
39105: 2719:    public Holder() {}
39106: 2720:
39107: 2721:    public Holder(T val) {
39108: 2722:        value = val;
39109: 2723:    }
39110: 2724:
39111: 2725:    public void set(T val) {
39112: 2726:        value = val;
39113: 2727:    }
39114: 2728:
39115: 2729:    public T get() {
39116: 2730:        return value;
39117: 2731:    }
39118: 2732:
39119: 2733:    @Override
39120: 2734:    public boolean equals(Object o) {
39121: 2735:        return o instanceof Holder && Objects.equals(value, ((Holder) o).value);
39122: 2736:    }
39123: 2737:
39124: 2738:    @Override
39125: 2739:    public int hashCode() {
39126: 2740:        return Objects.hashCode(value);
39127: 2741:    }
39128: 2742:
39129: 2743:    public static void main(String[] args) {
39130: 2744:        Holder<Apple> apple = new Holder<>(new Apple());
39131: 2745:        Apple d = apple.get();
39132: 2746:        apple.set(d);
39133: 2747:        // Holder<Fruit> fruit = apple; // Cannot upcast
39134: 2748:        Holder<? extends Fruit> fruit = apple; // OK
39135: 2749:        Fruit p = fruit.get();
39136: 2750:        d = (Apple) fruit.get();
39137: 2751:        try {
39138: 2752:            Orange c = (Orange) fruit.get(); // No warning
39139: 2753:        } catch (Exception e) {
39140: 2754:            System.out.println(e);
39141: 2755:        }
39142: 2756:        // fruit.set(new Apple()); // Cannot call set()
39143: 2757:        // fruit.set(new Fruit()); // Cannot call set()
39144: 2758:        System.out.println(fruit.equals(d)); // OK
39145: 2759:    }
39146: 2760:}
39147: 2761:/* Output
39148: 2762:java.lang.ClassCastException: Apple cannot be cast to Orange
39149: 2763:false
39150: 2764:*/
39151: 2765:```
39152: 2766:
39153: 2767:**Holder** 有一个接受 **T** 类型对象的 `set()` 方法，一个返回 T 对象的 `get()` 方法和一个接受 Object 对象的 `equals()` 方法。正如你所见，如果创建了一个 `Holder<Apple>`，就不能将其向上转型为 `Holder<Fruit>`，但是可以向上转型为 `Holder<? extends Fruit>`。如果调用 `get()`，只能返回一个 **Fruit**——这就是在给定“任何扩展自 **Fruit** 的对象”这一边界后，它所能知道的一切了。如果你知道更多的信息，就可以将其转型到某种具体的 **Fruit** 而不会导致任何警告，但是存在得到 **ClassCastException** 的风险。`set()` 方法不能工作在 **Apple** 和 **Fruit** 上，因为 `set()` 的参数也是"**? extends Fruit**"，意味着它可以是任何事物，编译器无法验证“任何事物”的类型安全性。
39154: 2768:
39155: 2769:但是，`equals()` 方法可以正常工作，因为它接受的参数是 **Object** 而不是 **T** 类型。因此，编译器只关注传递进来和要返回的对象类型。它不会分析代码，以查看是否执行了任何实际的写入和读取操作。
39156: 2770:
39157: 2771:Java 7 引入了 **java.util.Objects** 库，使创建 `equals()` 和 `hashCode()` 方法变得更加容易，当然还有很多其他功能。`equals()` 方法的标准形式参考 [附录：理解 equals 和 hashCode 方法](book/Appendix-Understanding-equals-and-hashCode) 一章。
39158: 2772:
39159: 2773:### 逆变
39160: 2774:
39161: 2775:还可以走另外一条路，即使用超类型通配符。这里，可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 `<？super MyClass>` ，或者甚至使用类型参数： `<？super T>`（尽管你不能对泛型参数给出一个超类型边界；即不能声明 `<T super MyClass>` ）。这使得你可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，就可以向 **Collection** 写入了：
39162: 2776:
39163: 2777:```java
39164: 2778:// generics/SuperTypeWildcards.java
39165: 2779:import java.util.*;
39166: 2780:public class SuperTypeWildcards {
39167: 2781:    static void writeTo(List<? super Apple> apples) {
39168: 2782:        apples.add(new Apple());
39169: 2783:        apples.add(new Jonathan());
39170: 2784:        // apples.add(new Fruit()); // Error
39171: 2785:    }
39172: 2786:}
39173: 2787:```
39174: 2788:
39175: 2789:参数 **apples** 是 **Apple** 的某种基类型的 **List**，这样你就知道向其中添加 **Apple** 或 **Apple** 的子类型是安全的。但是因为 **Apple** 是下界，所以你知道向这样的 **List** 中添加 **Fruit** 是不安全的，因为这将使这个 **List** 敞开口子，从而可以向其中添加非 **Apple** 类型的对象，而这是违反静态类型安全的。
39176: 2790:下面的示例复习了一下逆变和通配符的的使用：
39177: 2791:
39178: 2792:```java
39179: 2793:// generics/GenericReading.java
39180: 2794:import java.util.*;
39181: 2795:
39182: 2796:public class GenericReading {
39183: 2797:    static List<Apple> apples = Arrays.asList(new Apple());
39184: 2798:    static List<Fruit> fruit = Arrays.asList(new Fruit());
39185: 2799:    
39186: 2800:    static <T> T readExact(List<T> list) {
39187: 2801:        return list.get(0);
39188: 2802:    }
39189: 2803:    
39190: 2804:    // A static method adapts to each call:
39191: 2805:    static void f1() {
39192: 2806:        Apple a = readExact(apples);
39193: 2807:        Fruit f = readExact(fruit);
39194: 2808:        f = readExact(apples);
39195: 2809:    }
39196: 2810:    
39197: 2811:    // A class type is established
39198: 2812:    // when the class is instantiated:
39199: 2813:    static class Reader<T> {
39200: 2814:        T readExact(List<T> list) { 
39201: 2815:            return list.get(0); 
39202: 2816:        }
39203: 2817:    }
39204: 2818:    
39205: 2819:    static void f2() {
39206: 2820:        Reader<Fruit> fruitReader = new Reader<>();
39207: 2821:        Fruit f = fruitReader.readExact(fruit);
39208: 2822:        //- Fruit a = fruitReader.readExact(apples);
39209: 2823:        // error: incompatible types: List<Apple>
39210: 2824:        // cannot be converted to List<Fruit>
39211: 2825:    }
39212: 2826:    
39213: 2827:    static class CovariantReader<T> {
39214: 2828:        T readCovariant(List<? extends T> list) {
39215: 2829:            return list.get(0);
39216: 2830:        }
39217: 2831:    }
39218: 2832:    
39219: 2833:    static void f3() {
39220: 2834:        CovariantReader<Fruit> fruitReader = new CovariantReader<>();
39221: 2835:        Fruit f = fruitReader.readCovariant(fruit);
39222: 2836:        Fruit a = fruitReader.readCovariant(apples);
39223: 2837:    }
39224: 2838:    
39225: 2839:    public static void main(String[] args) {
39226: 2840:        f1(); 
39227: 2841:        f2(); 
39228: 2842:        f3();
39229: 2843:    }
39230: 2844:}
39231: 2845:```
39232: 2846:
39233: 2847:`readExact()` 方法使用了精确的类型。如果使用这个没有任何通配符的精确类型，就可以向 **List** 中写入和读取这个精确类型。另外，对于返回值，静态的泛型方法 `readExact()` 可以有效地“适应”每个方法调用，并能够从 `List<Apple>` 中返回一个 **Apple** ，从 `List<Fruit>` 中返回一个 **Fruit** ，就像在 `f1()` 中看到的那样。因此，如果可以摆脱静态泛型方法，那么在读取时就不需要协变类型了。
39234: 2848:然而对于泛型类来说，当你创建这个类的实例时，就要为这个类确定参数。就像在 `f2()` 中看到的，**fruitReader** 实例可以从 `List<Fruit>` 中读取一个 **Fruit** ，因为这就是它的确切类型。但是 `List<Apple>` 也应该产生 **Fruit** 对象，而 **fruitReader** 不允许这么做。
39235: 2849:为了修正这个问题，`CovariantReader.readCovariant()` 方法将接受 `List<？extends T>` ，因此，从这个列表中读取一个 **T** 是安全的（你知道在这个列表中的所有对象至少是一个 **T** ，并且可能是从 T 导出的某种对象）。在 `f3()` 中，你可以看到现在可以从 `List<Apple>` 中读取 **Fruit** 了。
39236: 2850:
39237: 2851:### 无界通配符
39238: 2852:
39239: 2853:无界通配符 `<?>` 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器初看起来是支持这种判断的：
39240: 2854:
39241: 2855:```java
39242: 2856:// generics/UnboundedWildcards1.java
39243: 2857:import java.util.*;
39244: 2858:
39245: 2859:public class UnboundedWildcards1 {
39246: 2860:    static List list1;
39247: 2861:    static List<?> list2;
39248: 2862:    static List<? extends Object> list3;
39249: 2863:  
39250: 2864:    static void assign1(List list) {
39251: 2865:        list1 = list;
39252: 2866:        list2 = list;
39253: 2867:        //- list3 = list;
39254: 2868:        // warning: [unchecked] unchecked conversion
39255: 2869:        // list3 = list;
39256: 2870:        //         ^
39257: 2871:        // required: List<? extends Object>
39258: 2872:        // found:    List
39259: 2873:    }
39260: 2874:    
39261: 2875:    static void assign2(List<?> list) {
39262: 2876:        list1 = list;
39263: 2877:        list2 = list;
39264: 2878:        list3 = list;
39265: 2879:    }
39266: 2880:    
39267: 2881:    static void assign3(List<? extends Object> list) {
39268: 2882:        list1 = list;
39269: 2883:        list2 = list;
39270: 2884:        list3 = list;
39271: 2885:    }
39272: 2886:    
39273: 2887:    public static void main(String[] args) {
39274: 2888:        assign1(new ArrayList());
39275: 2889:        assign2(new ArrayList());
39276: 2890:        //- assign3(new ArrayList());
39277: 2891:        // warning: [unchecked] unchecked method invocation:
39278: 2892:        // method assign3 in class UnboundedWildcards1
39279: 2893:        // is applied to given types
39280: 2894:        // assign3(new ArrayList());
39281: 2895:        //        ^
39282: 2896:        // required: List<? extends Object>
39283: 2897:        // found: ArrayList
39284: 2898:        // warning: [unchecked] unchecked conversion
39285: 2899:        // assign3(new ArrayList());
39286: 2900:        //         ^
39287: 2901:        // required: List<? extends Object>
39288: 2902:        // found:    ArrayList
39289: 2903:        // 2 warnings
39290: 2904:        assign1(new ArrayList<>());
39291: 2905:        assign2(new ArrayList<>());
39292: 2906:        assign3(new ArrayList<>());
39293: 2907:        // Both forms are acceptable as List<?>:
39294: 2908:        List<?> wildList = new ArrayList();
39295: 2909:        wildList = new ArrayList<>();
39296: 2910:        assign1(wildList);
39297: 2911:        assign2(wildList);
39298: 2912:        assign3(wildList);
39299: 2913:    }
39300: 2914:}
39301: 2915:```
39302: 2916:
39303: 2917:有很多情况都和你在这里看到的情况类似，即编译器很少关心使用的是原生类型还是 `<?>` 。在这些情况中，`<?>` 可以被认为是一种装饰，但是它仍旧是很有价值的，因为，实际上它是在声明：“我是想用 Java 的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型。”
39304: 2918:第二个示例展示了无界通配符的一个重要应用。当你在处理多个泛型参数时，有时允许一个参数可以是任何类型，同时为其他参数确定某种特定类型的这种能力会显得很重要：
39305: 2919:
39306: 2920:```java
39307: 2921:// generics/UnboundedWildcards2.java
39308: 2922:import java.util.*;
39309: 2923:
39310: 2924:public class UnboundedWildcards2 {
39311: 2925:    static Map map1;
39312: 2926:    static Map<?,?> map2;
39313: 2927:    static Map<String,?> map3;
39314: 2928:  
39315: 2929:    static void assign1(Map map) { 
39316: 2930:        map1 = map; 
39317: 2931:    }
39318: 2932:    
39319: 2933:    static void assign2(Map<?,?> map) { 
39320: 2934:        map2 = map; 
39321: 2935:    }
39322: 2936:    
39323: 2937:    static void assign3(Map<String,?> map) { 
39324: 2938:        map3 = map; 
39325: 2939:    }
39326: 2940:    
39327: 2941:    public static void main(String[] args) {
39328: 2942:        assign1(new HashMap());
39329: 2943:        assign2(new HashMap());
39330: 2944:        //- assign3(new HashMap());
39331: 2945:        // warning: [unchecked] unchecked method invocation:
39332: 2946:        // method assign3 in class UnboundedWildcards2
39333: 2947:        // is applied to given types
39334: 2948:        //     assign3(new HashMap());
39335: 2949:        //            ^
39336: 2950:        //   required: Map<String,?>
39337: 2951:        //   found: HashMap
39338: 2952:        // warning: [unchecked] unchecked conversion
39339: 2953:        //     assign3(new HashMap());
39340: 2954:        //             ^
39341: 2955:        //   required: Map<String,?>
39342: 2956:        //   found:    HashMap
39343: 2957:        // 2 warnings
39344: 2958:        assign1(new HashMap<>());
39345: 2959:        assign2(new HashMap<>());
39346: 2960:        assign3(new HashMap<>());
39347: 2961:    }
39348: 2962:}
39349: 2963:```
39350: 2964:
39351: 2965:但是，当你拥有的全都是无界通配符时，就像在 `Map<?,?>` 中看到的那样，编译器看起来就无法将其与原生 **Map** 区分开了。另外， **UnboundedWildcards1.java** 展示了编译器处理  `List<?>` 和 `List<? extends Object>` 是不同的。
39352: 2966:令人困惑的是，编译器并非总是关注像 `List` 和 `List<?>` 之间的这种差异，因此它们看起来就像是相同的事物。事实上，因为泛型参数擦除到它的第一个边界，因此 `List<?>` 看起来等价于 `List<Object>` ，而 **List** 实际上也是 `List<Object>` ——除非这些语句都不为真。**List** 实际上表示“持有任何 **Object** 类型的原生 **List** ”，而 `List<?>` 表示“具有某种特定类型的非原生 **List** ，只是我们不知道类型是什么。”
39353: 2967:编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？下面的示例使用了前面定义的 `Holder<T>` 类，它包含接受 **Holder** 作为参数的各种方法，但是它们具有不同的形式：作为原生类型，具有具体的类型参数以及具有无界通配符参数：
39354: 2968:
39355: 2969:```java
39356: 2970:// generics/Wildcards.java
39357: 2971:// Exploring the meaning of wildcards
39358: 2972:
39359: 2973:public class Wildcards {
39360: 2974:    // Raw argument:
39361: 2975:    static void rawArgs(Holder holder, Object arg) {
39362: 2976:        //- holder.set(arg);
39363: 2977:        // warning: [unchecked] unchecked call to set(T)
39364: 2978:        // as a member of the raw type Holder
39365: 2979:        //     holder.set(arg);
39366: 2980:        //               ^
39367: 2981:        //   where T is a type-variable:
39368: 2982:        //     T extends Object declared in class Holder
39369: 2983:        // 1 warning
39370: 2984:
39371: 2985:        // Can't do this; don't have any 'T':
39372: 2986:        // T t = holder.get();
39373: 2987:
39374: 2988:        // OK, but type information is lost:
39375: 2989:        Object obj = holder.get();
39376: 2990:    }
39377: 2991:    
39378: 2992:    // Like rawArgs(), but errors instead of warnings:
39379: 2993:    static void unboundedArg(Holder<?> holder, Object arg) {
39380: 2994:        //- holder.set(arg);
39381: 2995:        // error: method set in class Holder<T>
39382: 2996:        // cannot be applied to given types;
39383: 2997:        //     holder.set(arg);
39384: 2998:        //           ^
39385: 2999:        //   required: CAP#1
39386: 3000:        //   found: Object
39387: 3001:        //   reason: argument mismatch;
39388: 3002:        //     Object cannot be converted to CAP#1
39389: 3003:        //   where T is a type-variable:
39390: 3004:        //     T extends Object declared in class Holder
39391: 3005:        //   where CAP#1 is a fresh type-variable:
39392: 3006:        //     CAP#1 extends Object from capture of ?
39393: 3007:        // 1 error
39394: 3008:
39395: 3009:        // Can't do this; don't have any 'T':
39396: 3010:        // T t = holder.get();
39397: 3011:
39398: 3012:        // OK, but type information is lost:
39399: 3013:        Object obj = holder.get();
39400: 3014:    }
39401: 3015:    
39402: 3016:    static <T> T exact1(Holder<T> holder) {
39403: 3017:        return holder.get();
39404: 3018:    }
39405: 3019:    
39406: 3020:    static <T> T exact2(Holder<T> holder, T arg) {
39407: 3021:        holder.set(arg);
39408: 3022:        return holder.get();
39409: 3023:    }
39410: 3024:    
39411: 3025:    static <T> T wildSubtype(Holder<? extends T> holder, T arg) {
39412: 3026:        //- holder.set(arg);
39413: 3027:        // error: method set in class Holder<T#2>
39414: 3028:        // cannot be applied to given types;
39415: 3029:        //     holder.set(arg);
39416: 3030:        //           ^
39417: 3031:        //   required: CAP#1
39418: 3032:        //   found: T#1
39419: 3033:        //   reason: argument mismatch;
39420: 3034:        //     T#1 cannot be converted to CAP#1
39421: 3035:        //   where T#1,T#2 are type-variables:
39422: 3036:        //     T#1 extends Object declared in method
39423: 3037:        //     <T#1>wildSubtype(Holder<? extends T#1>,T#1)
39424: 3038:        //     T#2 extends Object declared in class Holder
39425: 3039:        //   where CAP#1 is a fresh type-variable:
39426: 3040:        //     CAP#1 extends T#1 from
39427: 3041:        //       capture of ? extends T#1
39428: 3042:        // 1 error
39429: 3043:        return holder.get();
39430: 3044:    }
39431: 3045:    
39432: 3046:    static <T> void wildSupertype(Holder<? super T> holder, T arg) {
39433: 3047:        holder.set(arg);
39434: 3048:        //- T t = holder.get();
39435: 3049:        // error: incompatible types:
39436: 3050:        // CAP#1 cannot be converted to T
39437: 3051:        //     T t = holder.get();
39438: 3052:        //                     ^
39439: 3053:        //   where T is a type-variable:
39440: 3054:        //     T extends Object declared in method
39441: 3055:        //       <T>wildSupertype(Holder<? super T>,T)
39442: 3056:        //   where CAP#1 is a fresh type-variable:
39443: 3057:        //     CAP#1 extends Object super:
39444: 3058:        //       T from capture of ? super T
39445: 3059:        // 1 error
39446: 3060:
39447: 3061:        // OK, but type information is lost:
39448: 3062:        Object obj = holder.get();
39449: 3063:    }
39450: 3064:    
39451: 3065:    public static void main(String[] args) {
39452: 3066:        Holder raw = new Holder<>();
39453: 3067:        // Or:
39454: 3068:        raw = new Holder();
39455: 3069:        Holder<Long> qualified = new Holder<>();
39456: 3070:        Holder<?> unbounded = new Holder<>();
39457: 3071:        Holder<? extends Long> bounded = new Holder<>();
39458: 3072:        Long lng = 1L;
39459: 3073:
39460: 3074:        rawArgs(raw, lng);
39461: 3075:        rawArgs(qualified, lng);
39462: 3076:        rawArgs(unbounded, lng);
39463: 3077:        rawArgs(bounded, lng);
39464: 3078:
39465: 3079:        unboundedArg(raw, lng);
39466: 3080:        unboundedArg(qualified, lng);
39467: 3081:        unboundedArg(unbounded, lng);
39468: 3082:        unboundedArg(bounded, lng);
39469: 3083:
39470: 3084:        //- Object r1 = exact1(raw);
39471: 3085:        // warning: [unchecked] unchecked method invocation:
39472: 3086:        // method exact1 in class Wildcards is applied
39473: 3087:        // to given types
39474: 3088:        //      Object r1 = exact1(raw);
39475: 3089:        //                        ^
39476: 3090:        //   required: Holder<T>
39477: 3091:        //   found: Holder
39478: 3092:        //   where T is a type-variable:
39479: 3093:        //     T extends Object declared in
39480: 3094:        //     method <T>exact1(Holder<T>)
39481: 3095:        // warning: [unchecked] unchecked conversion
39482: 3096:        //      Object r1 = exact1(raw);
39483: 3097:        //                         ^
39484: 3098:        //   required: Holder<T>
39485: 3099:        //   found:    Holder
39486: 3100:        //   where T is a type-variable:
39487: 3101:        //     T extends Object declared in
39488: 3102:        //     method <T>exact1(Holder<T>)
39489: 3103:        // 2 warnings
39490: 3104:
39491: 3105:        Long r2 = exact1(qualified);
39492: 3106:        Object r3 = exact1(unbounded); // Must return Object
39493: 3107:        Long r4 = exact1(bounded);
39494: 3108:
39495: 3109:        //- Long r5 = exact2(raw, lng);
39496: 3110:        // warning: [unchecked] unchecked method invocation:
39497: 3111:        // method exact2 in class Wildcards is
39498: 3112:        // applied to given types
39499: 3113:        //     Long r5 = exact2(raw, lng);
39500: 3114:        //                     ^
39501: 3115:        //   required: Holder<T>,T
39502: 3116:        //   found: Holder,Long
39503: 3117:        //   where T is a type-variable:
39504: 3118:        //     T extends Object declared in
39505: 3119:        //       method <T>exact2(Holder<T>,T)
39506: 3120:        // warning: [unchecked] unchecked conversion
39507: 3121:        //     Long r5 = exact2(raw, lng);
39508: 3122:        //                      ^
39509: 3123:        //   required: Holder<T>
39510: 3124:        //   found:    Holder
39511: 3125:        //   where T is a type-variable:
39512: 3126:        //     T extends Object declared in
39513: 3127:        //       method <T>exact2(Holder<T>,T)
39514: 3128:        // 2 warnings
39515: 3129:
39516: 3130:        Long r6 = exact2(qualified, lng);
39517: 3131:
39518: 3132:        //- Long r7 = exact2(unbounded, lng);
39519: 3133:        // error: method exact2 in class Wildcards
39520: 3134:        // cannot be applied to given types;
39521: 3135:        //     Long r7 = exact2(unbounded, lng);
39522: 3136:        //               ^
39523: 3137:        //   required: Holder<T>,T
39524: 3138:        //   found: Holder<CAP#1>,Long
39525: 3139:        //   reason: inference variable T has
39526: 3140:        //     incompatible bounds
39527: 3141:        //     equality constraints: CAP#1
39528: 3142:        //     lower bounds: Long
39529: 3143:        //   where T is a type-variable:
39530: 3144:        //     T extends Object declared in
39531: 3145:        //       method <T>exact2(Holder<T>,T)
39532: 3146:        //   where CAP#1 is a fresh type-variable:
39533: 3147:        //     CAP#1 extends Object from capture of ?
39534: 3148:        // 1 error
39535: 3149:
39536: 3150:        //- Long r8 = exact2(bounded, lng);
39537: 3151:        // error: method exact2 in class Wildcards
39538: 3152:        // cannot be applied to given types;
39539: 3153:        //      Long r8 = exact2(bounded, lng);
39540: 3154:        //                ^
39541: 3155:        //   required: Holder<T>,T
39542: 3156:        //   found: Holder<CAP#1>,Long
39543: 3157:        //   reason: inference variable T
39544: 3158:        //     has incompatible bounds
39545: 3159:        //     equality constraints: CAP#1
39546: 3160:        //     lower bounds: Long
39547: 3161:        //   where T is a type-variable:
39548: 3162:        //     T extends Object declared in
39549: 3163:        //       method <T>exact2(Holder<T>,T)
39550: 3164:        //   where CAP#1 is a fresh type-variable:
39551: 3165:        //     CAP#1 extends Long from
39552: 3166:        //       capture of ? extends Long
39553: 3167:        // 1 error
39554: 3168:
39555: 3169:        //- Long r9 = wildSubtype(raw, lng);
39556: 3170:        // warning: [unchecked] unchecked method invocation:
39557: 3171:        // method wildSubtype in class Wildcards
39558: 3172:        // is applied to given types
39559: 3173:        //     Long r9 = wildSubtype(raw, lng);
39560: 3174:        //                          ^
39561: 3175:        //   required: Holder<? extends T>,T
39562: 3176:        //   found: Holder,Long
39563: 3177:        //   where T is a type-variable:
39564: 3178:        //     T extends Object declared in
39565: 3179:        //     method <T>wildSubtype(Holder<? extends T>,T)
39566: 3180:        // warning: [unchecked] unchecked conversion
39567: 3181:        //     Long r9 = wildSubtype(raw, lng);
39568: 3182:        //                           ^
39569: 3183:        //   required: Holder<? extends T>
39570: 3184:        //   found:    Holder
39571: 3185:        //   where T is a type-variable:
39572: 3186:        //     T extends Object declared in
39573: 3187:        //     method <T>wildSubtype(Holder<? extends T>,T)
39574: 3188:        // 2 warnings
39575: 3189:
39576: 3190:        Long r10 = wildSubtype(qualified, lng);
39577: 3191:        // OK, but can only return Object:
39578: 3192:        Object r11 = wildSubtype(unbounded, lng);
39579: 3193:        Long r12 = wildSubtype(bounded, lng);
39580: 3194:
39581: 3195:        //- wildSupertype(raw, lng);
39582: 3196:        // warning: [unchecked] unchecked method invocation:
39583: 3197:        //   method wildSupertype in class Wildcards
39584: 3198:        //   is applied to given types
39585: 3199:        //     wildSupertype(raw, lng);
39586: 3200:        //                  ^
39587: 3201:        //   required: Holder<? super T>,T
39588: 3202:        //   found: Holder,Long
39589: 3203:        //   where T is a type-variable:
39590: 3204:        //     T extends Object declared in
39591: 3205:        //     method <T>wildSupertype(Holder<? super T>,T)
39592: 3206:        // warning: [unchecked] unchecked conversion
39593: 3207:        //     wildSupertype(raw, lng);
39594: 3208:        //                   ^
39595: 3209:        //   required: Holder<? super T>
39596: 3210:        //   found:    Holder
39597: 3211:        //   where T is a type-variable:
39598: 3212:        //     T extends Object declared in
39599: 3213:        //     method <T>wildSupertype(Holder<? super T>,T)
39600: 3214:        // 2 warnings
39601: 3215:
39602: 3216:        wildSupertype(qualified, lng);
39603: 3217:
39604: 3218:        //- wildSupertype(unbounded, lng);
39605: 3219:        // error: method wildSupertype in class Wildcards
39606: 3220:        // cannot be applied to given types;
39607: 3221:        //     wildSupertype(unbounded, lng);
39608: 3222:        //     ^
39609: 3223:        //   required: Holder<? super T>,T
39610: 3224:        //   found: Holder<CAP#1>,Long
39611: 3225:        //   reason: cannot infer type-variable(s) T
39612: 3226:        //     (argument mismatch; Holder<CAP#1>
39613: 3227:        //     cannot be converted to Holder<? super T>)
39614: 3228:        //   where T is a type-variable:
39615: 3229:        //     T extends Object declared in
39616: 3230:        //     method <T>wildSupertype(Holder<? super T>,T)
39617: 3231:        //   where CAP#1 is a fresh type-variable:
39618: 3232:        //     CAP#1 extends Object from capture of ?
39619: 3233:        // 1 error
39620: 3234:
39621: 3235:        //- wildSupertype(bounded, lng);
39622: 3236:        // error: method wildSupertype in class Wildcards
39623: 3237:        // cannot be applied to given types;
39624: 3238:        //     wildSupertype(bounded, lng);
39625: 3239:        //     ^
39626: 3240:        //   required: Holder<? super T>,T
39627: 3241:        //   found: Holder<CAP#1>,Long
39628: 3242:        //   reason: cannot infer type-variable(s) T
39629: 3243:        //     (argument mismatch; Holder<CAP#1>
39630: 3244:        //     cannot be converted to Holder<? super T>)
39631: 3245:        //   where T is a type-variable:
39632: 3246:        //     T extends Object declared in
39633: 3247:        //     method <T>wildSupertype(Holder<? super T>,T)
39634: 3248:        //   where CAP#1 is a fresh type-variable:
39635: 3249:        //     CAP#1 extends Long from capture of
39636: 3250:        //     ? extends Long
39637: 3251:        // 1 error
39638: 3252:    }
39639: 3253:}
39640: 3254:```
39641: 3255:
39642: 3256:在 `rawArgs()` 中，编译器知道 `Holder` 是一个泛型类型，因此即使它在这里被表示成一个原生类型，编译器仍旧知道向 `set()` 传递一个 **Object** 是不安全的。由于它是原生类型，你可以将任何类型的对象传递给 `set()` ，而这个对象将被向上转型为 **Object** 。因此无论何时，只要使用了原生类型，都会放弃编译期检查。对 `get()` 的调用说明了相同的问题：没有任何 **T** 类型的对象，因此结果只能是一个 **Object**。
39643: 3257:人们很自然地会开始考虑原生 `Holder` 与 `Holder<?>` 是大致相同的事物。但是 `unboundedArg()` 强调它们是不同的——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，因为原生 **Holder** 将持有任何类型的组合，而 `Holder<?>` 将持有具有某种具体类型的同构集合，因此不能只是向其中传递 **Object** 。
39644: 3258:在 `exact1()` 和 `exact2()` 中，你可以看到使用了确切的泛型参数——没有任何通配符。你将看到，`exact2()`与 `exact1()` 具有不同的限制，因为它有额外的参数。
39645: 3259:在 `wildSubtype()` 中，在 **Holder** 类型上的限制被放松为包括持有任何扩展自 **T** 的对象的 **Holder** 。这还是意味着如果 T 是 **Fruit** ，那么 `holder` 可以是 `Holder<Apple>` ，这是合法的。为了防止将 **Orange** 放置到 `Holder<Apple>` 中，对 `set()` 的调用（或者对任何接受这个类型参数为参数的方法的调用）都是不允许的。但是，你仍旧知道任何来自 `Holder<？extends Fruit>` 的对象至少是 **Fruit** ，因此 `get()` （或者任何将产生具有这个类型参数的返回值的方法）都是允许的。
39646: 3260:`wildSupertype()` 展示了超类型通配符，这个方法展示了与 `wildSubtype()` 相反的行为：`holder` 可以是持有任何 T 的基类型的容器。因此， `set()` 可以接受 **T** ，因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是 **T** ）。但是，尝试着调用 `get()` 是没有用的，因为由 `holder` 持有的类型可以是任何超类型，因此唯一安全的类型就是 **Object** 。
39647: 3261:这个示例还展示了对于在 `unbounded()` 中使用无界通配符能够做什么不能做什么所做出的限制：因为你没有 **T**，所以你不能将 `set()` 或 `get()` 作用于 **T** 上。
39648: 3262:
39649: 3263:在 `main()` 方法中你看到了某些方法在接受某些类型的参数时没有报错和警告。为了迁移兼容性，`rawArgs()`  将接受所有 **Holder** 的不同变体，而不会产生警告。`unboundedArg()` 方法也可以接受相同的所有类型，尽管如前所述，它在方法体内部处理这些类型的方式并不相同。
39650: 3264:
39651: 3265:如果向接受“确切”泛型类型（没有通配符）的方法传递一个原生 **Holder** 引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息。如果向 `exact1()` 传递一个无界引用，就不会有任何可以确定返回类型的类型信息。
39652: 3266:可以看到，`exact2()` 具有最多的限制，因为它希望精确地得到一个 `Holder<T>` ，以及一个具有类型 **T** 的参数，正由于此，它将产生错误或警告，除非提供确切的参数。有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决于是否想要从泛型参数中返回类型确定的返回值（就像在 `wildSubtype()` 中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在 `wildSupertype()` 中看到的那样）。
39653: 3267:因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合你的需求的方法。
39654: 3268:
39655: 3269:### 捕获转换
39656: 3270:
39657: 3271:有一种特殊情况需要使用 `<?>` 而不是原生类型。如果向一个使用 `<?>` 的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。下面的示例演示了这种技术，它被称为捕获转换，因为未指定的通配符类型被捕获，并被转换为确切类型。这里，有关警告的注释只有在 `@SuppressWarnings` 注解被移除之后才能起作用：
39658: 3272:
39659: 3273:```java
39660: 3274:// generics/CaptureConversion.java
39661: 3275:
39662: 3276:public class CaptureConversion {
39663: 3277:    static <T> void f1(Holder<T> holder) {
39664: 3278:        T t = holder.get();
39665: 3279:        System.out.println(t.getClass().getSimpleName());
39666: 3280:    }
39667: 3281:  
39668: 3282:    static void f2(Holder<?> holder) {
39669: 3283:        f1(holder); // Call with captured type
39670: 3284:    }
39671: 3285:    
39672: 3286:    @SuppressWarnings("unchecked")
39673: 3287:    public static void main(String[] args) {
39674: 3288:        Holder raw = new Holder<>(1);
39675: 3289:        f1(raw);
39676: 3290:        // warning: [unchecked] unchecked method invocation:
39677: 3291:        // method f1 in class CaptureConversion
39678: 3292:        // is applied to given types
39679: 3293:        //     f1(raw);
39680: 3294:        //       ^
39681: 3295:        //   required: Holder<T>
39682: 3296:        //   found: Holder
39683: 3297:        //   where T is a type-variable:
39684: 3298:        //     T extends Object declared in
39685: 3299:        //     method <T>f1(Holder<T>)
39686: 3300:        // warning: [unchecked] unchecked conversion
39687: 3301:        //     f1(raw);
39688: 3302:        //        ^
39689: 3303:        //   required: Holder<T>
39690: 3304:        //   found:    Holder
39691: 3305:        //   where T is a type-variable:
39692: 3306:        //     T extends Object declared in
39693: 3307:        //     method <T>f1(Holder<T>)
39694: 3308:        // 2 warnings
39695: 3309:        f2(raw); // No warnings
39696: 3310:        
39697: 3311:        Holder rawBasic = new Holder();
39698: 3312:        rawBasic.set(new Object());
39699: 3313:        // warning: [unchecked] unchecked call to set(T)
39700: 3314:        // as a member of the raw type Holder
39701: 3315:        //     rawBasic.set(new Object());
39702: 3316:        //                 ^
39703: 3317:        //   where T is a type-variable:
39704: 3318:        //     T extends Object declared in class Holder
39705: 3319:        // 1 warning
39706: 3320:        f2(rawBasic); // No warnings
39707: 3321:        
39708: 3322:        // Upcast to Holder<?>, still figures it out:
39709: 3323:        Holder<?> wildcarded = new Holder<>(1.0);
39710: 3324:        f2(wildcarded);
39711: 3325:    }
39712: 3326:}
39713: 3327:/* Output:
39714: 3328:Integer
39715: 3329:Integer
39716: 3330:Object
39717: 3331:Double
39718: 3332:*/
39719: 3333:```
39720: 3334:
39721: 3335:`f1()` 中的类型参数都是确切的，没有通配符或边界。在 `f2()` 中，**Holder** 参数是一个无界通配符，因此它看起来是未知的。但是，在 `f2()` 中调用了 `f1()`，而 `f1()` 需要一个已知参数。这里所发生的是：在调用 `f2()` 的过程中捕获了参数类型，并在调用 `f1()` 时使用了这种类型。
39722: 3336:你可能想知道这项技术是否可以用于写入，但是这要求在传递 `Holder<?>` 时同时传递一个具体类型。捕获转换只有在这样的情况下可以工作：即在方法内部，你需要使用确切的类型。注意，不能从 `f2()` 中返回 **T**，因为 **T** 对于 `f2()` 来说是未知的。捕获转换十分有趣，但是非常受限。
39723: 3337:
39724: 3338:<!-- Issues -->
39725: 3339:
39726: 3340:## 问题
39727: 3341:
39728: 3342:本节将阐述在使用 Java 泛型时会出现的各类问题。
39729: 3343:
39730: 3344:### 任何基本类型都不能作为类型参数
39731: 3345:
39732: 3346:正如本章早先提到的，Java 泛型的限制之一是不能将基本类型用作类型参数。因此，不能创建  `ArrayList<int>` 之类的东西。
39733: 3347:解决方法是使用基本类型的包装器类以及自动装箱机制。如果创建一个 `ArrayList<Integer>`，并将基本类型 **int** 应用于这个集合，那么你将发现自动装箱机制将自动地实现 **int** 到 **Integer** 的双向转换——因此，这几乎就像是有一个 `ArrayList<int>` 一样：
39734: 3348:
39735: 3349:```java
39736: 3350:// generics/ListOfInt.java
39737: 3351:// Autoboxing compensates for the inability
39738: 3352:// to use primitives in generics
39739: 3353:import java.util.*;
39740: 3354:import java.util.stream.*;
39741: 3355:
39742: 3356:public class ListOfInt {
39743: 3357:    public static void main(String[] args) {
39744: 3358:        List<Integer> li = IntStream.range(38, 48)
39745: 3359:            .boxed() // Converts ints to Integers
39746: 3360:            .collect(Collectors.toList());
39747: 3361:        System.out.println(li);
39748: 3362:    }
39749: 3363:}
39750: 3364:/* Output:
39751: 3365:[38, 39, 40, 41, 42, 43, 44, 45, 46, 47]
39752: 3366:*/
39753: 3367:```
39754: 3368:
39755: 3369:通常，这种解决方案工作得很好——能够成功地存储和读取 **int**，自动装箱隐藏了转换的过程。但是如果性能成为问题的话，就需要使用专门为基本类型适配的特殊版本的集合；一个开源版本的实现是 **org.apache.commons.collections.primitives**。
39756: 3370:下面是另外一种方式，它可以创建持有 **Byte** 的 **Set**：
39757: 3371:
39758: 3372:```java
39759: 3373:// generics/ByteSet.java
39760: 3374:import java.util.*;
39761: 3375:
39762: 3376:public class ByteSet {
39763: 3377:    Byte[] possibles = { 1,2,3,4,5,6,7,8,9 };
39764: 3378:    Set<Byte> mySet = new HashSet<>(Arrays.asList(possibles));
39765: 3379:    // But you can't do this:
39766: 3380:    // Set<Byte> mySet2 = new HashSet<>(
39767: 3381:    // Arrays.<Byte>asList(1,2,3,4,5,6,7,8,9));
39768: 3382:}
39769: 3383:```
39770: 3384:
39771: 3385:自动装箱机制解决了一些问题，但并没有解决所有问题。
39772: 3386:
39773: 3387:在下面的示例中，**FillArray** 接口包含一些通用方法，这些方法使用 **Supplier** 来用对象填充数组（这使得类泛型在本例中无法工作，因为这个方法是静态的）。**Supplier** 实现来自 [数组](book/21-Arrays.md) 一章,并且在 `main()` 中，可以看到 `FillArray.fill()` 使用对象填充了数组：
39774: 3388:
39775: 3389:```java
39776: 3390:// generics/PrimitiveGenericTest.java
39777: 3391:import onjava.*;
39778: 3392:import java.util.*;
39779: 3393:import java.util.function.*;
39780: 3394:
39781: 3395:// Fill an array using a generator:
39782: 3396:interface FillArray {
39783: 3397:    static <T> T[] fill(T[] a, Supplier<T> gen) {
39784: 3398:        Arrays.setAll(a, n -> gen.get());
39785: 3399:        return a;
39786: 3400:    }
39787: 3401:    
39788: 3402:    static int[] fill(int[] a, IntSupplier gen) {
39789: 3403:        Arrays.setAll(a, n -> gen.getAsInt());
39790: 3404:        return a;
39791: 3405:    }
39792: 3406:    
39793: 3407:    static long[] fill(long[] a, LongSupplier gen) {
39794: 3408:        Arrays.setAll(a, n -> gen.getAsLong());
39795: 3409:        return a;
39796: 3410:    }
39797: 3411:    
39798: 3412:    static double[] fill(double[] a, DoubleSupplier gen) {
39799: 3413:        Arrays.setAll(a, n -> gen.getAsDouble());
39800: 3414:        return a;
39801: 3415:    }
39802: 3416:}
39803: 3417:
39804: 3418:public class PrimitiveGenericTest {
39805: 3419:    public static void main(String[] args) {
39806: 3420:        String[] strings = FillArray.fill(
39807: 3421:            new String[5], new Rand.String(9));
39808: 3422:        System.out.println(Arrays.toString(strings));
39809: 3423:        int[] integers = FillArray.fill(
39810: 3424:            new int[9], new Rand.Pint());
39811: 3425:        System.out.println(Arrays.toString(integers));
39812: 3426:    }
39813: 3427:}
39814: 3428:/* Output:
39815: 3429:[btpenpccu, xszgvgmei, nneeloztd, vewcippcy, gpoalkljl]
39816: 3430:[635, 8737, 3941, 4720, 6177, 8479, 6656, 3768, 4948]
39817: 3431:*/
39818: 3432:```
39819: 3433:
39820: 3434:自动装箱不适用于数组，因此我们必须创建 `FillArray.fill()` 的重载版本，或创建产生 **Wrapped** 输出的生成器。 **FillArray** 仅比 `java.util.Arrays.setAll()` 有用一点，因为它返回填充的数组。
39821: 3435:
39822: 3436:### 实现参数化接口
39823: 3437:
39824: 3438:一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。下面是产生这种冲突的情况：
39825: 3439:
39826: 3440:```java
39827: 3441:// generics/MultipleInterfaceVariants.java
39828: 3442:// {WillNotCompile}
39829: 3443:package generics;
39830: 3444:
39831: 3445:interface Payable<T> {}
39832: 3446:
39833: 3447:class Employee implements Payable<Employee> {}
39834: 3448:
39835: 3449:class Hourly extends Employee implements Payable<Hourly> {}
39836: 3450:```
39837: 3451:
39838: 3452:**Hourly** 不能编译，因为擦除会将  `Payable<Employe>` 和 `Payable<Hourly>` 简化为相同的类 **Payable**，这样，上面的代码就意味着在重复两次地实现相同的接口。十分有趣的是，如果从 **Payable** 的两种用法中都移除掉泛型参数（就像编译器在擦除阶段所做的那样）这段代码就可以编译。
39839: 3453:
39840: 3454:在使用某些更基本的 Java 接口，例如 `Comparable<T>` 时，这个问题可能会变得十分令人恼火，就像你在本节稍后看到的那样。
39841: 3455:
39842: 3456:### 转型和警告
39843: 3457:
39844: 3458:使用带有泛型类型参数的转型或 **instanceof** 不会有任何效果。下面的集合在内部将各个值存储为 **Object**，并在获取这些值时，再将它们转型回 **T**：
39845: 3459:
39846: 3460:```java
39847: 3461:// generics/GenericCast.java
39848: 3462:import java.util.*;
39849: 3463:import java.util.stream.*;
39850: 3464:
39851: 3465:class FixedSizeStack<T> {
39852: 3466:    private final int size;
39853: 3467:    private Object[] storage;
39854: 3468:    private int index = 0;
39855: 3469:    
39856: 3470:    FixedSizeStack(int size) {
39857: 3471:        this.size = size;
39858: 3472:        storage = new Object[size];
39859: 3473:    }
39860: 3474:    
39861: 3475:    public void push(T item) {
39862: 3476:        if(index < size)
39863: 3477:            storage[index++] = item;
39864: 3478:    }
39865: 3479:    
39866: 3480:    @SuppressWarnings("unchecked")
39867: 3481:    public T pop() {
39868: 3482:        return index == 0 ? null : (T)storage[--index];
39869: 3483:    }
39870: 3484:    
39871: 3485:    @SuppressWarnings("unchecked")
39872: 3486:    Stream<T> stream() {
39873: 3487:        return (Stream<T>)Arrays.stream(storage);
39874: 3488:    }
39875: 3489:}
39876: 3490:
39877: 3491:public class GenericCast {
39878: 3492:    static String[] letters = "ABCDEFGHIJKLMNOPQRS".split("");
39879: 3493:  
39880: 3494:    public static void main(String[] args) {
39881: 3495:        FixedSizeStack<String> strings =
39882: 3496:            new FixedSizeStack<>(letters.length);
39883: 3497:        Arrays.stream("ABCDEFGHIJKLMNOPQRS".split(""))
39884: 3498:            .forEach(strings::push);
39885: 3499:        System.out.println(strings.pop());
39886: 3500:        strings.stream()
39887: 3501:            .map(s -> s + " ")
39888: 3502:            .forEach(System.out::print);
39889: 3503:    }
39890: 3504:}
39891: 3505:/* Output:
39892: 3506:S
39893: 3507:A B C D E F G H I J K L M N O P Q R S
39894: 3508:*/
39895: 3509:```
39896: 3510:
39897: 3511:如果没有 **@SuppressWarnings** 注解，编译器将对 `pop()` 产生 “unchecked cast” 警告。由于擦除的原因，编译器无法知道这个转型是否是安全的，并且 `pop()` 方法实际上并没有执行任何转型。
39898: 3512:这是因为，**T** 被擦除到它的第一个边界，默认情况下是 **Object** ，因此 `pop()` 实际上只是将 **Object** 转型为 **Object**。
39899: 3513:有时，泛型没有消除对转型的需要，这就会由编译器产生警告，而这个警告是不恰当的。例如：
39900: 3514:
39901: 3515:```java
39902: 3516:// generics/NeedCasting.java
39903: 3517:import java.io.*;
39904: 3518:import java.util.*;
39905: 3519:
39906: 3520:public class NeedCasting {
39907: 3521:    @SuppressWarnings("unchecked")
39908: 3522:    public void f(String[] args) throws Exception {
39909: 3523:        ObjectInputStream in = new ObjectInputStream(
39910: 3524:            new FileInputStream(args[0]));
39911: 3525:        List<Widget> shapes = (List<Widget>)in.readObject();
39912: 3526:    }
39913: 3527:}
39914: 3528:```
39915: 3529:
39916: 3530:正如你将在 [附录：对象序列化](book/Appendix-Object-Serialization.md) 中学到的那样，`readObject()` 无法知道它正在读取的是什么，因此它返回的是必须转型的对象。但是当注释掉 **@SuppressWarnings** 注解并编译这个程序时，就会得到下面的警告。
39917: 3531:
39918: 3532:```
39919: 3533:NeedCasting.java uses unchecked or unsafe operations.
39920: 3534:Recompile with -Xlint:unchecked for details.
39921: 3535:
39922: 3536:And if you follow the instructions and recompile with  -
39923: 3537:Xlint:unchecked :(如果遵循这条指示，使用-Xlint:unchecked来重新编译：)
39924: 3538:
39925: 3539:NeedCasting.java:10: warning: [unchecked] unchecked cast
39926: 3540:    List<Widget> shapes = (List<Widget>)in.readObject();
39927: 3541:    required: List<Widget>
39928: 3542:    found: Object
39929: 3543:1 warning
39930: 3544:```
39931: 3545:
39932: 3546:你会被强制要求转型，但是又被告知不应该转型。为了解决这个问题，必须使用 Java 5 引入的新的转型形式，即通过泛型类来转型：
39933: 3547:
39934: 3548:```java
39935: 3549:// generics/ClassCasting.java
39936: 3550:import java.io.*;
39937: 3551:import java.util.*;
39938: 3552:
39939: 3553:public class ClassCasting {
39940: 3554:    @SuppressWarnings("unchecked")
39941: 3555:    public void f(String[] args) throws Exception {
39942: 3556:        ObjectInputStream in = new ObjectInputStream(
39943: 3557:            new FileInputStream(args[0]));
39944: 3558:        // Won't Compile:
39945: 3559:        //    List<Widget> lw1 =
39946: 3560:        //    List<>.class.cast(in.readObject());
39947: 3561:        List<Widget> lw2 = List.class.cast(in.readObject());
39948: 3562:    }
39949: 3563:}
39950: 3564:```
39951: 3565:
39952: 3566:但是，不能转型到实际类型（ `List<Widget>` ）。也就是说，不能声明：
39953: 3567:
39954: 3568:```
39955: 3569:List<Widget>.class.cast(in.readobject())
39956: 3570:```
39957: 3571:
39958: 3572:甚至当你添加一个像下面这样的另一个转型时：
39959: 3573:
39960: 3574:```
39961: 3575:(List<Widget>)List.class.cast(in.readobject())
39962: 3576:```
39963: 3577:
39964: 3578:仍旧会得到一个警告。
39965: 3579:
39966: 3580:### 重载
39967: 3581:
39968: 3582:下面的程序是不能编译的，即使它看起来是合理的：
39969: 3583:
39970: 3584:```java
39971: 3585:// generics/UseList.java
39972: 3586:// {WillNotCompile}
39973: 3587:import java.util.*;
39974: 3588:
39975: 3589:public class UseList<W, T> {
39976: 3590:    void f(List<T> v) {}
39977: 3591:    void f(List<W> v) {}
39978: 3592:}
39979: 3593:```
39980: 3594:
39981: 3595:因为擦除，所以重载方法产生了相同的类型签名。
39982: 3596:
39983: 3597:因而，当擦除后的参数不能产生唯一的参数列表时，你必须提供不同的方法名：
39984: 3598:
39985: 3599:```java
39986: 3600:// generics/UseList2.java
39987: 3601:
39988: 3602:import java.util.*;
39989: 3603:
39990: 3604:public class UseList2<W, T> {
39991: 3605:    void f1(List<T> v) {}
39992: 3606:    void f2(List<W> v) {}
39993: 3607:}
39994: 3608:```
39995: 3609:
39996: 3610:幸运的是，编译器可以检测到这类问题。
39997: 3611:
39998: 3612:### 基类劫持接口
39999: 3613:
40000: 3614:假设你有一个实现了 **Comparable** 接口的 **Pet** 类：
40001: 3615:
40002: 3616:```java
40003: 3617:// generics/ComparablePet.java
40004: 3618:
40005: 3619:public class ComparablePet implements Comparable<ComparablePet> {
40006: 3620:    @Override
40007: 3621:    public int compareTo(ComparablePet o) {
40008: 3622:        return 0;
40009: 3623:    }
40010: 3624:}
40011: 3625:```
40012: 3626:
40013: 3627:尝试缩小 **ComparablePet** 子类的比较类型是有意义的。例如，**Cat** 类可以与其他的 **Cat** 比较：
40014: 3628:
40015: 3629:```java
40016: 3630:// generics/HijackedInterface.java
40017: 3631:// {WillNotCompile}
40018: 3632:
40019: 3633:class Cat extends ComparablePet implements Comparable<Cat> {
40020: 3634:    // error: Comparable cannot be inherited with
40021: 3635:    // different arguments: <Cat> and <ComparablePet>
40022: 3636:    // class Cat
40023: 3637:    // ^
40024: 3638:    // 1 error
40025: 3639:    public int compareTo(Cat arg) {
40026: 3640:        return 0;
40027: 3641:    }
40028: 3642:}
40029: 3643:```
40030: 3644:
40031: 3645:不幸的是，这不能工作。一旦 **Comparable** 的类型参数设置为 **ComparablePet**，其他的实现类只能比较 **ComparablePet**：
40032: 3646:
40033: 3647:```java
40034: 3648:// generics/RestrictedComparablePets.java
40035: 3649:
40036: 3650:public class Hamster extends ComparablePet implements Comparable<ComparablePet> {
40037: 3651:
40038: 3652:    @Override
40039: 3653:    public int compareTo(ComparablePet arg) {
40040: 3654:        return 0;
40041: 3655:    }
40042: 3656:}
40043: 3657:// Or just:
40044: 3658:class Gecko extends ComparablePet {
40045: 3659:    public int compareTo(ComparablePet arg) {
40046: 3660:        return 0;
40047: 3661:    }
40048: 3662:}
40049: 3663:```
40050: 3664:
40051: 3665:**Hamster** 显示了重新实现 **ComparablePet** 中相同的接口是可能的，只要接口完全相同，包括参数类型。然而正如 **Gecko** 中所示，这与直接覆写基类的方法完全相同。
40052: 3666:
40053: 3667:<!-- Self-Bounded Types -->
40054: 3668:
40055: 3669:## 自限定的类型
40056: 3670:
40057: 3671:在 Java 泛型中，有一个似乎经常性出现的惯用法，它相当令人费解：
40058: 3672:
40059: 3673:```java
40060: 3674:class SelfBounded<T extends SelfBounded<T>> { // ...
40061: 3675:```
40062: 3676:
40063: 3677:这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。**SelfBounded** 类接受泛型参数 **T**，而 **T** 由一个边界类限定，这个边界就是拥有 **T** 作为其参数的 **SelfBounded**。
40064: 3678:
40065: 3679:当你首次看到它时，很难去解析它，它强调的是当 **extends** 关键字用于边界与用来创建子类明显是不同的。
40066: 3680:
40067: 3681:### 古怪的循环泛型
40068: 3682:
40069: 3683:为了理解自限定类型的含义，我们从这个惯用法的一个简单版本入手，它没有自限定的边界。
40070: 3684:
40071: 3685:不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类。也就是说，可以声明：
40072: 3686:
40073: 3687:```java
40074: 3688:// generics/CuriouslyRecurringGeneric.java
40075: 3689:
40076: 3690:class GenericType<T> {}
40077: 3691:
40078: 3692:public class CuriouslyRecurringGeneric
40079: 3693:  extends GenericType<CuriouslyRecurringGeneric> {}
40080: 3694:```
40081: 3695:
40082: 3696:这可以按照 Jim Coplien 在 C++ 中的*古怪的循环模版模式*的命名方式，称为古怪的循环泛型（CRG）。“古怪的循环”是指类相当古怪地出现在它自己的基类中这一事实。
40083: 3697:为了理解其含义，努力大声说：“我在创建一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为其参数。”当给出导出类的名字时，这个泛型基类能够实现什么呢？好吧，Java 中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为其参数和返回类型的基类。它还能将导出类型用作其域类型，尽管这些将被擦除为 **Object** 的类型。下面是表示了这种情况的一个泛型类：
40084: 3698:
40085: 3699:```java
40086: 3700:// generics/BasicHolder.java
40087: 3701:
40088: 3702:public class BasicHolder<T> {
40089: 3703:    T element;
40090: 3704:    void set(T arg) { element = arg; }
40091: 3705:    T get() { return element; }
40092: 3706:    void f() {
40093: 3707:        System.out.println(element.getClass().getSimpleName());
40094: 3708:    }
40095: 3709:}
40096: 3710:```
40097: 3711:
40098: 3712:这是一个普通的泛型类型，它的一些方法将接受和产生具有其参数类型的对象，还有一个方法在其存储的域上执行操作（尽管只是在这个域上执行 **Object** 操作）。
40099: 3713:我们可以在一个古怪的循环泛型中使用 **BasicHolder**：
40100: 3714:
40101: 3715:```java
40102: 3716:// generics/CRGWithBasicHolder.java
40103: 3717:
40104: 3718:class Subtype extends BasicHolder<Subtype> {}
40105: 3719:
40106: 3720:public class CRGWithBasicHolder {
40107: 3721:    public static void main(String[] args) {
40108: 3722:        Subtype st1 = new Subtype(), st2 = new Subtype();
40109: 3723:        st1.set(st2);
40110: 3724:        Subtype st3 = st1.get();
40111: 3725:        st1.f();
40112: 3726:    }
40113: 3727:}
40114: 3728:/* Output:
40115: 3729:Subtype
40116: 3730:*/
40117: 3731:```
40118: 3732:
40119: 3733:注意，这里有些东西很重要：新类 **Subtype** 接受的参数和返回的值具有 **Subtype** 类型而不仅仅是基类 **BasicHolder** 类型。这就是 CRG 的本质：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型。也就是说，在所产生的类中将使用确切类型而不是基类型。因此，在**Subtype** 中，传递给 `set()` 的参数和从 `get()` 返回的类型都是确切的 **Subtype**。
40120: 3734:
40121: 3735:### 自限定
40122: 3736:
40123: 3737:**BasicHolder** 可以使用任何类型作为其泛型参数，就像下面看到的那样：
40124: 3738:
40125: 3739:```java
40126: 3740:// generics/Unconstrained.java
40127: 3741:// (c)2017 MindView LLC: see Copyright.txt
40128: 3742:// We make no guarantees that this code is fit for any purpose.
40129: 3743:// Visit http://OnJava8.com for more book information.
40130: 3744:
40131: 3745:class Other {}
40132: 3746:class BasicOther extends BasicHolder<Other> {}
40133: 3747:
40134: 3748:public class Unconstrained {
40135: 3749:    public static void main(String[] args) {
40136: 3750:        BasicOther b = new BasicOther();
40137: 3751:        BasicOther b2 = new BasicOther();
40138: 3752:        b.set(new Other());
40139: 3753:        Other other = b.get();
40140: 3754:        b.f();
40141: 3755:    }
40142: 3756:}
40143: 3757:/* Output:
40144: 3758:Other
40145: 3759:*/
40146: 3760:```
40147: 3761:
40148: 3762:限定将采取额外的步骤，强制泛型当作其自身的边界参数来使用。观察所产生的类可以如何使用以及不可以如何使用：
40149: 3763:
40150: 3764:```java
40151: 3765:// generics/SelfBounding.java
40152: 3766:
40153: 3767:class SelfBounded<T extends SelfBounded<T>> {
40154: 3768:    T element;
40155: 3769:    SelfBounded<T> set(T arg) {
40156: 3770:        element = arg;
40157: 3771:        return this;
40158: 3772:    }
40159: 3773:    T get() { return element; }
40160: 3774:}
40161: 3775:
40162: 3776:class A extends SelfBounded<A> {}
40163: 3777:class B extends SelfBounded<A> {} // Also OK
40164: 3778:
40165: 3779:class C extends SelfBounded<C> {
40166: 3780:    C setAndGet(C arg) { 
40167: 3781:        set(arg); 
40168: 3782:        return get();
40169: 3783:    }
40170: 3784:}
40171: 3785:
40172: 3786:class D {}
40173: 3787:// Can't do this:
40174: 3788:// class E extends SelfBounded<D> {}
40175: 3789:// Compile error:
40176: 3790://   Type parameter D is not within its bound
40177: 3791:
40178: 3792:// Alas, you can do this, so you cannot force the idiom:
40179: 3793:class F extends SelfBounded {}
40180: 3794:
40181: 3795:public class SelfBounding {
40182: 3796:    public static void main(String[] args) {
40183: 3797:        A a = new A();
40184: 3798:        a.set(new A());
40185: 3799:        a = a.set(new A()).get();
40186: 3800:        a = a.get();
40187: 3801:        C c = new C();
40188: 3802:        c = c.setAndGet(new C());
40189: 3803:    }
40190: 3804:}
40191: 3805:```
40192: 3806:
40193: 3807:自限定所做的，就是要求在继承关系中，像下面这样使用这个类：
40194: 3808:
40195: 3809:```java
40196: 3810:class A extends SelfBounded<A>{}
40197: 3811:```
40198: 3812:
40199: 3813:这会强制要求将正在定义的类当作参数传递给基类。
40200: 3814:
40201: 3815:自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。正如你在 B 类的定义中所看到的，还可以从使用了另一个 **SelfBounded** 参数的 **SelfBounded** 中导出，尽管在 **A** 类看到的用法看起来是主要的用法。对定义 **E** 的尝试说明不能使用不是 **SelfBounded** 的类型参数。
40202: 3816:遗憾的是， **F** 可以编译，不会有任何警告，因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型。
40203: 3817:注意，可以移除自限定这个限制，这样所有的类仍旧是可以编译的，但是 **E** 也会因此而变得可编译：
40204: 3818:
40205: 3819:```java
40206: 3820:// generics/NotSelfBounded.java
40207: 3821:
40208: 3822:public class NotSelfBounded<T> {
40209: 3823:    T element;
40210: 3824:    NotSelfBounded<T> set(T arg) {
40211: 3825:        element = arg;
40212: 3826:        return this;
40213: 3827:    }
40214: 3828:    T get() { return element; }
40215: 3829:} 
40216: 3830:
40217: 3831:class A2 extends NotSelfBounded<A2> {}
40218: 3832:class B2 extends NotSelfBounded<A2> {}
40219: 3833:
40220: 3834:class C2 extends NotSelfBounded<C2> {
40221: 3835:    C2 setAndGet(C2 arg) { 
40222: 3836:        set(arg); 
40223: 3837:        return get(); 
40224: 3838:    }
40225: 3839:}
40226: 3840:
40227: 3841:class D2 {}
40228: 3842:// Now this is OK:
40229: 3843:class E2 extends NotSelfBounded<D2> {}
40230: 3844:```
40231: 3845:
40232: 3846:因此很明显，自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。这会强制要求使用这个类的每个人都要遵循这种形式。
40233: 3847:还可以将自限定用于泛型方法：
40234: 3848:
40235: 3849:```java
40236: 3850:// generics/SelfBoundingMethods.java
40237: 3851:// (c)2017 MindView LLC: see Copyright.txt
40238: 3852:// We make no guarantees that this code is fit for any purpose.
40239: 3853:// Visit http://OnJava8.com for more book information.
40240: 3854:
40241: 3855:public class SelfBoundingMethods {
40242: 3856:    static <T extends SelfBounded<T>> T f(T arg) {
40243: 3857:        return arg.set(arg).get();
40244: 3858:    }
40245: 3859:    
40246: 3860:    public static void main(String[] args) {
40247: 3861:        A a = f(new A());
40248: 3862:    }
40249: 3863:}
40250: 3864:```
40251: 3865:
40252: 3866:这可以防止这个方法被应用于除上述形式的自限定参数之外的任何事物上。
40253: 3867:
40254: 3868:### 参数协变
40255: 3869:
40256: 3870:自限定类型的价值在于它们可以产生*协变参数类型*——方法参数类型会随子类而变化。
40257: 3871:
40258: 3872:尽管自限定类型还可以产生与子类类型相同的返回类型，但是这并不十分重要，因为*协变返回类型*是在 Java 5 引入：
40259: 3873:
40260: 3874:```java
40261: 3875:// generics/CovariantReturnTypes.java
40262: 3876:
40263: 3877:class Base {}
40264: 3878:class Derived extends Base {}
40265: 3879:
40266: 3880:interface OrdinaryGetter {
40267: 3881:    Base get();
40268: 3882:}
40269: 3883:
40270: 3884:interface DerivedGetter extends OrdinaryGetter {
40271: 3885:    // Overridden method return type can vary:
40272: 3886:    @Override
40273: 3887:    Derived get();
40274: 3888:}
40275: 3889:
40276: 3890:public class CovariantReturnTypes {
40277: 3891:    void test(DerivedGetter d) {
40278: 3892:        Derived d2 = d.get();
40279: 3893:    }
40280: 3894:}
40281: 3895:```
40282: 3896:
40283: 3897:**DerivedGetter** 中的 `get()` 方法覆盖了 **OrdinaryGetter** 中的 `get()` ，并返回了一个从 `OrdinaryGetter.get()` 的返回类型中导出的类型。尽管这是完全合乎逻辑的事情（导出类方法应该能够返回比它覆盖的基类方法更具体的类型）但是这在早先的 Java 版本中是不合法的。
40284: 3898:
40285: 3899:自限定泛型事实上将产生确切的导出类型作为其返回值，就像在 `get()` 中所看到的一样：
40286: 3900:
40287: 3901:```java
40288: 3902:// generics/GenericsAndReturnTypes.java
40289: 3903:
40290: 3904:interface GenericGetter<T extends GenericGetter<T>> {
40291: 3905:    T get();
40292: 3906:}
40293: 3907:
40294: 3908:interface Getter extends GenericGetter<Getter> {}
40295: 3909:
40296: 3910:public class GenericsAndReturnTypes {
40297: 3911:    void test(Getter g) {
40298: 3912:        Getter result = g.get();
40299: 3913:        GenericGetter gg = g.get(); // Also the base type
40300: 3914:    }
40301: 3915:}
40302: 3916:```
40303: 3917:
40304: 3918:注意，这段代码不能编译，除非是使用囊括了协变返回类型的 Java 5。
40305: 3919:
40306: 3920:然而，在非泛型代码中，参数类型不能随子类型发生变化：
40307: 3921:
40308: 3922:```java
40309: 3923:// generics/OrdinaryArguments.java
40310: 3924:
40311: 3925:class OrdinarySetter {
40312: 3926:    void set(Base base) {
40313: 3927:        System.out.println("OrdinarySetter.set(Base)");
40314: 3928:    }
40315: 3929:}
40316: 3930:
40317: 3931:class DerivedSetter extends OrdinarySetter {
40318: 3932:    void set(Derived derived) {
40319: 3933:        System.out.println("DerivedSetter.set(Derived)");
40320: 3934:    }
40321: 3935:}
40322: 3936:
40323: 3937:public class OrdinaryArguments {
40324: 3938:    public static void main(String[] args) {
40325: 3939:        Base base = new Base();
40326: 3940:        Derived derived = new Derived();
40327: 3941:        DerivedSetter ds = new DerivedSetter();
40328: 3942:        ds.set(derived);
40329: 3943:        // Compiles--overloaded, not overridden!:
40330: 3944:        ds.set(base);
40331: 3945:    }
40332: 3946:}
40333: 3947:/* Output:
40334: 3948:DerivedSetter.set(Derived)
40335: 3949:OrdinarySetter.set(Base)
40336: 3950:*/
40337: 3951:```
40338: 3952:
40339: 3953:`set(derived)` 和 `set(base)` 都是合法的，因此 `DerivedSetter.set()` 没有覆盖 `OrdinarySetter.set()` ，而是重载了这个方法。从输出中可以看到，在 **DerivedSetter** 中有两个方法，因此基类版本仍旧是可用的，因此可以证明它被重载过。
40340: 3954:但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类型而不是基类型为参数：
40341: 3955:
40342: 3956:```java
40343: 3957:// generics/SelfBoundingAndCovariantArguments.java
40344: 3958:
40345: 3959:interface SelfBoundSetter<T extends SelfBoundSetter<T>> {
40346: 3960:    void set(T arg);
40347: 3961:}
40348: 3962:
40349: 3963:interface Setter extends SelfBoundSetter<Setter> {}
40350: 3964:
40351: 3965:public class SelfBoundingAndCovariantArguments {
40352: 3966:    void
40353: 3967:    testA(Setter s1, Setter s2, SelfBoundSetter sbs) {
40354: 3968:        s1.set(s2);
40355: 3969:        //- s1.set(sbs);
40356: 3970:        // error: method set in interface SelfBoundSetter<T>
40357: 3971:        // cannot be applied to given types;
40358: 3972:        //     s1.set(sbs);
40359: 3973:        //       ^
40360: 3974:        //   required: Setter
40361: 3975:        //   found: SelfBoundSetter
40362: 3976:        //   reason: argument mismatch;
40363: 3977:        // SelfBoundSetter cannot be converted to Setter
40364: 3978:        //   where T is a type-variable:
40365: 3979:        //     T extends SelfBoundSetter<T> declared in
40366: 3980:        //     interface SelfBoundSetter
40367: 3981:        // 1 error
40368: 3982:    }
40369: 3983:}
40370: 3984:```
40371: 3985:
40372: 3986:编译器不能识别将基类型当作参数传递给 `set()` 的尝试，因为没有任何方法具有这样的签名。实际上，这个参数已经被覆盖。
40373: 3987:如果不使用自限定类型，普通的继承机制就会介入，而你将能够重载，就像在非泛型的情况下一样：
40374: 3988:
40375: 3989:```java
40376: 3990:// generics/PlainGenericInheritance.java
40377: 3991:
40378: 3992:class GenericSetter<T> { // Not self-bounded
40379: 3993:    void set(T arg) {
40380: 3994:        System.out.println("GenericSetter.set(Base)");
40381: 3995:    }
40382: 3996:}
40383: 3997:
40384: 3998:class DerivedGS extends GenericSetter<Base> {
40385: 3999:    void set(Derived derived) {
40386: 4000:        System.out.println("DerivedGS.set(Derived)");
40387: 4001:    }
40388: 4002:}
40389: 4003:
40390: 4004:public class PlainGenericInheritance {
40391: 4005:    public static void main(String[] args) {
40392: 4006:        Base base = new Base();
40393: 4007:        Derived derived = new Derived();
40394: 4008:        DerivedGS dgs = new DerivedGS();
40395: 4009:        dgs.set(derived);
40396: 4010:        dgs.set(base); // Overloaded, not overridden!
40397: 4011:    }
40398: 4012:}
40399: 4013:/* Output:
40400: 4014:DerivedGS.set(Derived)
40401: 4015:GenericSetter.set(Base)
40402: 4016:*/
40403: 4017:```
40404: 4018:
40405: 4019:这段代码在模仿 **OrdinaryArguments.java**；在那个示例中，**DerivedSetter** 继承自包含一个 `set(Base)` 的**OrdinarySetter** 。而这里，**DerivedGS** 继承自泛型创建的也包含有一个 `set(Base)`的 `GenericSetter<Base>`。就像 **OrdinaryArguments.java** 一样，你可以从输出中看到， **DerivedGS** 包含两个  `set()` 的重载版本。如果不使用自限定，将重载参数类型。如果使用了自限定，只能获得方法的一个版本，它将接受确切的参数类型。
40406: 4020:
40407: 4021:<!-- Dynamic Type Safety -->
40408: 4022:
40409: 4023:## 动态类型安全
40410: 4024:
40411: 4025:因为可以向 Java 5 之前的代码传递泛型集合，所以旧式代码仍旧有可能会破坏你的集合。Java 5 的 **java.util.Collections** 中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：静态方法 `checkedCollection()` 、`checkedList()`、 `checkedMap()` 、 `checkedSet()` 、`checkedSortedMap()`和 `checkedSortedSet()`。这些方法每一个都会将你希望动态检查的集合当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。
40412: 4026:
40413: 4027:受检查的集合在你试图插入类型不正确的对象时抛出 **ClassCastException** ，这与泛型之前的（原生）集合形成了对比，对于后者来说，当你将对象从集合中取出时，才会通知你出现了问题。在后一种情况中，你知道存在问题，但是不知道罪魁祸首在哪里，如果使用受检查的集合，就可以发现谁在试图插入不良对象。
40414: 4028:让我们用受检查的集合来看看“将猫插入到狗列表中”这个问题。这里，`oldStyleMethod()` 表示遗留代码，因为它接受的是原生的 **List** ，而 **@SuppressWarnings（“unchecked”）** 注解对于压制所产生的警告是必需的：
40415: 4029:
40416: 4030:```java
40417: 4031:// generics/CheckedList.java
40418: 4032:// Using Collection.checkedList()
40419: 4033:import typeinfo.pets.*;
40420: 4034:import java.util.*;
40421: 4035:
40422: 4036:public class CheckedList {
40423: 4037:    @SuppressWarnings("unchecked")
40424: 4038:    static void oldStyleMethod(List probablyDogs) {
40425: 4039:        probablyDogs.add(new Cat());
40426: 4040:    }
40427: 4041:    
40428: 4042:    public static void main(String[] args) {
40429: 4043:        List<Dog> dogs1 = new ArrayList<>();
40430: 4044:        oldStyleMethod(dogs1); // Quietly accepts a Cat
40431: 4045:        List<Dog> dogs2 = Collections.checkedList(
40432: 4046:            new ArrayList<>(), Dog.class);
40433: 4047:        try {
40434: 4048:            oldStyleMethod(dogs2); // Throws an exception
40435: 4049:        } catch(Exception e) {
40436: 4050:            System.out.println("Expected: " + e);
40437: 4051:        }
40438: 4052:        // Derived types work fine:
40439: 4053:        List<Pet> pets = Collections.checkedList(
40440: 4054:            new ArrayList<>(), Pet.class);
40441: 4055:        pets.add(new Dog());
40442: 4056:        pets.add(new Cat());
40443: 4057:    }
40444: 4058:}
40445: 4059:/* Output:
40446: 4060:Expected: java.lang.ClassCastException: Attempt to
40447: 4061:insert class typeinfo.pets.Cat element into collection
40448: 4062:with element type class typeinfo.pets.Dog
40449: 4063:*/
40450: 4064:```
40451: 4065:
40452: 4066:运行这个程序时，你会发现插入一个 **Cat** 对于 **dogs1** 来说没有任何问题，而 **dogs2** 立即会在这个错误类型的插入操作上抛出一个异常。还可以看到，将导出类型的对象放置到将要检查基类型的受检查容器中是没有问题的。
40453: 4067:
40454: 4068:<!-- Exceptions -->
40455: 4069:
40456: 4070:## 泛型异常
40457: 4071:
40458: 4072:由于擦除的原因，**catch** 语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承自 **Throwable**（这将进一步阻止你去定义不能捕获的泛型异常）。
40459: 4073:但是，类型参数可能会在一个方法的 **throws** 子句中用到。这使得你可以编写随检查型异常类型变化的泛型代码：
40460: 4074:
40461: 4075:```java
40462: 4076:// generics/ThrowGenericException.java
40463: 4077:
40464: 4078:import java.util.*;
40465: 4079:
40466: 4080:interface Processor<T, E extends Exception> {
40467: 4081:    void process(List<T> resultCollector) throws E;
40468: 4082:}
40469: 4083:
40470: 4084:class ProcessRunner<T, E extends Exception>
40471: 4085:extends ArrayList<Processor<T, E>> {
40472: 4086:    List<T> processAll() throws E {
40473: 4087:        List<T> resultCollector = new ArrayList<>();
40474: 4088:        for(Processor<T, E> processor : this)
40475: 4089:            processor.process(resultCollector);
40476: 4090:        return resultCollector;
40477: 4091:    }
40478: 4092:}
40479: 4093:
40480: 4094:class Failure1 extends Exception {}
40481: 4095:
40482: 4096:class Processor1
40483: 4097:implements Processor<String, Failure1> {
40484: 4098:    static int count = 3;
40485: 4099:    @Override
40486: 4100:    public void process(List<String> resultCollector)
40487: 4101:    throws Failure1 {
40488: 4102:        if(count-- > 1)
40489: 4103:            resultCollector.add("Hep!");
40490: 4104:        else
40491: 4105:            resultCollector.add("Ho!");
40492: 4106:        if(count < 0)
40493: 4107:            throw new Failure1();
40494: 4108:    }
40495: 4109:}
40496: 4110:
40497: 4111:class Failure2 extends Exception {}
40498: 4112:
40499: 4113:class Processor2
40500: 4114:implements Processor<Integer, Failure2> {
40501: 4115:    static int count = 2;
40502: 4116:    @Override
40503: 4117:    public void process(List<Integer> resultCollector)
40504: 4118:    throws Failure2 {
40505: 4119:        if(count-- == 0)
40506: 4120:            resultCollector.add(47);
40507: 4121:        else {
40508: 4122:            resultCollector.add(11);
40509: 4123:        }
40510: 4124:        if(count < 0)
40511: 4125:            throw new Failure2();
40512: 4126:    }
40513: 4127:}
40514: 4128:
40515: 4129:public class ThrowGenericException {
40516: 4130:    public static void main(String[] args) {
40517: 4131:        ProcessRunner<String, Failure1> runner =
40518: 4132:            new ProcessRunner<>();
40519: 4133:        for(int i = 0; i < 3; i++)
40520: 4134:            runner.add(new Processor1());
40521: 4135:        try {
40522: 4136:            System.out.println(runner.processAll());
40523: 4137:        } catch(Failure1 e) {
40524: 4138:            System.out.println(e);
40525: 4139:        }
40526: 4140:
40527: 4141:        ProcessRunner<Integer, Failure2> runner2 =
40528: 4142:            new ProcessRunner<>();
40529: 4143:        for(int i = 0; i < 3; i++)
40530: 4144:            runner2.add(new Processor2());
40531: 4145:        try {
40532: 4146:            System.out.println(runner2.processAll());
40533: 4147:        } catch(Failure2 e) {
40534: 4148:            System.out.println(e);
40535: 4149:        }
40536: 4150:    }
40537: 4151:}
40538: 4152:/* Output:
40539: 4153:[Hep!, Hep!, Ho!]
40540: 4154:Failure2
40541: 4155:*/
40542: 4156:```
40543: 4157:
40544: 4158:**Processor** 执行 `process()` 方法，并且可能会抛出具有类型 **E** 的异常。`process()` 的结果存储在 `List<T>resultCollector` 中（这被称为*收集参数*）。**ProcessRunner** 有一个 `processAll()` 方法，它会在所持有的每个 **Process** 对象执行，并返回 **resultCollector** 。
40545: 4159:如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出这种泛化的代码。
40546: 4160:
40547: 4161:<!-- Mixins -->
40548: 4162:
40549: 4163:## 混型
40550: 4164:
40551: 4165:术语*混型*随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是你最后的手段，它将使组装多个类变得简单易行。
40552: 4166:混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点*面向切面编程* （AOP） 的味道，而切面经常被建议用来解决混型问题。
40553: 4167:
40554: 4168:### C++ 中的混型
40555: 4169:
40556: 4170:在 C++ 中，使用多重继承的最大理由，就是为了使用混型。但是，对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为混型就是继承自其类型参数的类。在 C++ 中，可以很容易地创建混型，因为 C++ 能够记住其模版参数的类型。
40557: 4171:下面是一个 C++ 示例，它有两个混型类型：一个使得你可以在每个对象中混入拥有一个时间戳这样的属性，而另一个可以混入一个序列号。
40558: 4172:
40559: 4173:```c++
40560: 4174:// generics/Mixins.cpp
40561: 4175:
40562: 4176:#include <string>
40563: 4177:#include <ctime>
40564: 4178:#include <iostream>
40565: 4179:using namespace std;
40566: 4180:
40567: 4181:template<class T> class TimeStamped : public T {
40568: 4182:    long timeStamp;
40569: 4183:public:
40570: 4184:    TimeStamped() { timeStamp = time(0); }
40571: 4185:    long getStamp() { return timeStamp; }
40572: 4186:};
40573: 4187:
40574: 4188:template<class T> class SerialNumbered : public T {
40575: 4189:    long serialNumber;
40576: 4190:    static long counter;
40577: 4191:public:
40578: 4192:    SerialNumbered() { serialNumber = counter++; }
40579: 4193:    long getSerialNumber() { return serialNumber; }
40580: 4194:};
40581: 4195:
40582: 4196:// Define and initialize the static storage:
40583: 4197:template<class T> long SerialNumbered<T>::counter = 1;
40584: 4198:
40585: 4199:class Basic {
40586: 4200:    string value;
40587: 4201:public:
40588: 4202:    void set(string val) { value = val; }
40589: 4203:    string get() { return value; }
40590: 4204:};
40591: 4205:
40592: 4206:int main() {
40593: 4207:    TimeStamped<SerialNumbered<Basic>> mixin1, mixin2;
40594: 4208:    mixin1.set("test string 1");
40595: 4209:    mixin2.set("test string 2");
40596: 4210:    cout << mixin1.get() << " " << mixin1.getStamp() <<
40597: 4211:      " " << mixin1.getSerialNumber() << endl;
40598: 4212:    cout << mixin2.get() << " " << mixin2.getStamp() <<
40599: 4213:      " " << mixin2.getSerialNumber() << endl;
40600: 4214:}
40601: 4215:/* Output:
40602: 4216:test string 1 1452987605 1
40603: 4217:test string 2 1452987605 2
40604: 4218:*/
40605: 4219:```
40606: 4220:
40607: 4221:在 `main()` 中， **mixin1** 和 **mixin2** 所产生的类型拥有所混入类型的所有方法。可以将混型看作是一种功能，它可以将现有类映射到新的子类上。注意，使用这种技术来创建一个混型是多么的轻而易举。基本上，只需要声明“这就是我想要的”，紧跟着它就发生了：
40608: 4222:
40609: 4223:```c++
40610: 4224:TimeStamped<SerialNumbered<Basic>> mixin1，mixin2；
40611: 4225:```
40612: 4226:
40613: 4227:遗憾的是，Java 泛型不允许这样。擦除会忘记基类类型，因此
40614: 4228:
40615: 4229:>  泛型类不能直接继承自一个泛型参数
40616: 4230:
40617: 4231:这突显了许多我在 Java 语言设计决策（以及与这些功能一起发布）中遇到的一大问题：处理一件事很有希望，但是当您实际尝试做一些有趣的事情时，您会发现自己做不到。
40618: 4232:
40619: 4233:### 与接口混合
40620: 4234:
40621: 4235:一种更常见的推荐解决方案是使用接口来产生混型效果，就像下面这样：
40622: 4236:
40623: 4237:```java
40624: 4238:// generics/Mixins.java
40625: 4239:
40626: 4240:import java.util.*;
40627: 4241:
40628: 4242:interface TimeStamped { long getStamp(); }
40629: 4243:
40630: 4244:class TimeStampedImp implements TimeStamped {
40631: 4245:    private final long timeStamp;
40632: 4246:    TimeStampedImp() {
40633: 4247:        timeStamp = new Date().getTime();
40634: 4248:    }
40635: 4249:    @Override
40636: 4250:    public long getStamp() { return timeStamp; }
40637: 4251:}
40638: 4252:
40639: 4253:interface SerialNumbered { long getSerialNumber(); }
40640: 4254:
40641: 4255:class SerialNumberedImp implements SerialNumbered {
40642: 4256:    private static long counter = 1;
40643: 4257:    private final long serialNumber = counter++;
40644: 4258:    @Override
40645: 4259:    public long getSerialNumber() { return serialNumber; }
40646: 4260:}
40647: 4261:
40648: 4262:interface Basic {
40649: 4263:    void set(String val);
40650: 4264:    String get();
40651: 4265:}
40652: 4266:
40653: 4267:class BasicImp implements Basic {
40654: 4268:    private String value;
40655: 4269:    @Override
40656: 4270:    public void set(String val) { value = val; }
40657: 4271:    @Override
40658: 4272:    public String get() { return value; }
40659: 4273:}
40660: 4274:
40661: 4275:class Mixin extends BasicImp
40662: 4276:implements TimeStamped, SerialNumbered {
40663: 4277:    private TimeStamped timeStamp = new TimeStampedImp();
40664: 4278:    private SerialNumbered serialNumber =
40665: 4279:        new SerialNumberedImp();
40666: 4280:    @Override
40667: 4281:    public long getStamp() {
40668: 4282:        return timeStamp.getStamp();
40669: 4283:    }
40670: 4284:    @Override
40671: 4285:    public long getSerialNumber() {
40672: 4286:        return serialNumber.getSerialNumber();
40673: 4287:    }
40674: 4288:}
40675: 4289:
40676: 4290:public class Mixins {
40677: 4291:    public static void main(String[] args) {
40678: 4292:        Mixin mixin1 = new Mixin(), mixin2 = new Mixin();
40679: 4293:        mixin1.set("test string 1");
40680: 4294:        mixin2.set("test string 2");
40681: 4295:        System.out.println(mixin1.get() + " " +
40682: 4296:            mixin1.getStamp() +  " " + mixin1.getSerialNumber());
40683: 4297:        System.out.println(mixin2.get() + " " +
40684: 4298:            mixin2.getStamp() +  " " + mixin2.getSerialNumber());
40685: 4299:    }
40686: 4300:}
40687: 4301:/* Output:
40688: 4302:test string 1 1494331663026 1
40689: 4303:test string 2 1494331663027 2
40690: 4304:*/
40691: 4305:```
40692: 4306:
40693: 4307:**Mixin** 类基本上是在使用*委托*，因此每个混入类型都要求在 **Mixin** 中有一个相应的域，而你必须在 **Mixin** 中编写所有必需的方法，将方法调用转发给恰当的对象。这个示例使用了非常简单的类，但是当使用更复杂的混型时，代码数量会急速增加。[^4]
40694: 4308:
40695: 4309:### 使用装饰器模式
40696: 4310:
40697: 4311:当你观察混型的使用方式时，就会发现混型概念好像与*装饰器*设计模式关系很近。装饰器经常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的。
40698: 4312:装饰器模式使用分层对象来动态透明地向单个对象中添加责任。装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。某些事物是可装饰的，可以通过将其他类包装在这个可装饰对象的四周，来将功能分层。这使得对装饰器的使用是透明的——无论对象是否被装饰，你都拥有一个可以向对象发送的公共消息集。装饰类也可以添加新方法，但是正如你所见，这将是受限的。
40699: 4313:装饰器是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。
40700: 4314:前面的示例可以被改写为使用装饰器：
40701: 4315:
40702: 4316:```java
40703: 4317:// generics/decorator/Decoration.java
40704: 4318:
40705: 4319:// {java generics.decorator.Decoration}
40706: 4320:package generics.decorator;
40707: 4321:import java.util.*;
40708: 4322:
40709: 4323:class Basic {
40710: 4324:    private String value;
40711: 4325:    public void set(String val) { value = val; }
40712: 4326:    public String get() { return value; }
40713: 4327:}
40714: 4328:
40715: 4329:class Decorator extends Basic {
40716: 4330:    protected Basic basic;
40717: 4331:    Decorator(Basic basic) { this.basic = basic; }
40718: 4332:    @Override
40719: 4333:    public void set(String val) { basic.set(val); }
40720: 4334:    @Override
40721: 4335:    public String get() { return basic.get(); }
40722: 4336:}
40723: 4337:
40724: 4338:class TimeStamped extends Decorator {
40725: 4339:    private final long timeStamp;
40726: 4340:    TimeStamped(Basic basic) {
40727: 4341:        super(basic);
40728: 4342:        timeStamp = new Date().getTime();
40729: 4343:    }
40730: 4344:    public long getStamp() { return timeStamp; }
40731: 4345:}
40732: 4346:
40733: 4347:class SerialNumbered extends Decorator {
40734: 4348:    private static long counter = 1;
40735: 4349:    private final long serialNumber = counter++;
40736: 4350:    SerialNumbered(Basic basic) { super(basic); }
40737: 4351:    public long getSerialNumber() { return serialNumber; }
40738: 4352:}
40739: 4353:
40740: 4354:public class Decoration {
40741: 4355:    public static void main(String[] args) {
40742: 4356:        TimeStamped t = new TimeStamped(new Basic());
40743: 4357:        TimeStamped t2 = new TimeStamped(
40744: 4358:            new SerialNumbered(new Basic()));
40745: 4359:        //- t2.getSerialNumber(); // Not available
40746: 4360:        SerialNumbered s = new SerialNumbered(new Basic());
40747: 4361:        SerialNumbered s2 = new SerialNumbered(
40748: 4362:            new TimeStamped(new Basic()));
40749: 4363:        //- s2.getStamp(); // Not available
40750: 4364:  }
40751: 4365:}
40752: 4366:```
40753: 4367:
40754: 4368:产生自泛型的类包含所有感兴趣的方法，但是由使用装饰器所产生的对象类型是最后被装饰的类型。也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。因此，装饰器只是对由混型提出的问题的一种局限的解决方案。
40755: 4369:
40756: 4370:### 与动态代理混合
40757: 4371:
40758: 4372:可以使用动态代理来创建一种比装饰器更贴近混型模型的机制（查看 [类型信息](book/19-Type-Information.md) 一章中关于 Java 的动态代理如何工作的解释）。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。
40759: 4373:由于动态代理的限制，每个被混入的类都必须是某个接口的实现：
40760: 4374:
40761: 4375:```java
40762: 4376:// generics/DynamicProxyMixin.java
40763: 4377:
40764: 4378:import java.lang.reflect.*;
40765: 4379:import java.util.*;
40766: 4380:import onjava.*;
40767: 4381:import static onjava.Tuple.*;
40768: 4382:
40769: 4383:class MixinProxy implements InvocationHandler {
40770: 4384:    Map<String, Object> delegatesByMethod;
40771: 4385:    @SuppressWarnings("unchecked")
40772: 4386:    MixinProxy(Tuple2<Object, Class<?>>... pairs) {
40773: 4387:        delegatesByMethod = new HashMap<>();
40774: 4388:        for(Tuple2<Object, Class<?>> pair : pairs) {
40775: 4389:            for(Method method : pair.a2.getMethods()) {
40776: 4390:                String methodName = method.getName();
40777: 4391:                // The first interface in the map
40778: 4392:                // implements the method.
40779: 4393:                if(!delegatesByMethod.containsKey(methodName))
40780: 4394:                    delegatesByMethod.put(methodName, pair.a1);
40781: 4395:            }
40782: 4396:        }
40783: 4397:    }
40784: 4398:    @Override
40785: 4399:    public Object invoke(Object proxy, Method method,
40786: 4400:      Object[] args) throws Throwable {
40787: 4401:        String methodName = method.getName();
40788: 4402:        Object delegate = delegatesByMethod.get(methodName);
40789: 4403:        return method.invoke(delegate, args);
40790: 4404:    }
40791: 4405:    
40792: 4406:    @SuppressWarnings("unchecked")
40793: 4407:    public static Object newInstance(Tuple2... pairs) {
40794: 4408:        Class[] interfaces = new Class[pairs.length];
40795: 4409:        for(int i = 0; i < pairs.length; i++) {
40796: 4410:            interfaces[i] = (Class)pairs[i].a2;
40797: 4411:        }
40798: 4412:        ClassLoader cl = pairs[0].a1.getClass().getClassLoader();
40799: 4413:        return Proxy.newProxyInstance(cl, interfaces, new MixinProxy(pairs));
40800: 4414:    }
40801: 4415:}
40802: 4416:
40803: 4417:public class DynamicProxyMixin {
40804: 4418:    public static void main(String[] args) {
40805: 4419:        Object mixin = MixinProxy.newInstance(
40806: 4420:          tuple(new BasicImp(), Basic.class),
40807: 4421:          tuple(new TimeStampedImp(), TimeStamped.class),
40808: 4422:          tuple(new SerialNumberedImp(), SerialNumbered.class));
40809: 4423:        Basic b = (Basic)mixin;
40810: 4424:        TimeStamped t = (TimeStamped)mixin;
40811: 4425:        SerialNumbered s = (SerialNumbered)mixin;
40812: 4426:        b.set("Hello");
40813: 4427:        System.out.println(b.get());
40814: 4428:        System.out.println(t.getStamp());
40815: 4429:        System.out.println(s.getSerialNumber());
40816: 4430:    }
40817: 4431:}
40818: 4432:/* Output:
40819: 4433:Hello
40820: 4434:1494331653339
40821: 4435:1
40822: 4436:*/
40823: 4437:```
40824: 4438:
40825: 4439:因为只有动态类型而不是静态类型才包含所有的混入类型，因此这仍旧不如 C++ 的方式好，因为可以在具有这些类型的对象上调用方法之前，你被强制要求必须先将这些对象向下转型到恰当的类型。但是，它明显地更接近于真正的混型。
40826: 4440:为了让 Java 支持混型，人们已经做了大量的工作朝着这个目标努力，包括创建了至少一种附加语言（ Jam 语言），它是专门用来支持混型的。
40827: 4441:
40828: 4442:<!-- Latent Typing -->
40829: 4443:
40830: 4444:## 潜在类型机制
40831: 4445:
40832: 4446:在本章的开头介绍过这样的思想，即要编写能够尽可能广泛地应用的代码。为了实现这一点，我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处。然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码。
40833: 4447:
40834: 4448:Java 泛型看起来是向这一方向迈进了一步。当你在编写或使用只是持有对象的泛型时，这些代码将可以工作于任何类型（除了基本类型，尽管正如你所见到的，自动装箱机制可以克服这一点）。或者，换个角度讲，“持有器”泛型能够声明：“我不关心你是什么类型”。如果代码不关心它将要作用的类型，那么这种代码就可以真正地应用于任何地方，并因此而相当泛化。
40835: 4449:
40836: 4450:还是正如你所见到的，当要在泛型类型上执行操作（即调用 **Object** 方法之外的方法）时，就会产生问题。擦除强制要求指定可能会用到的泛型类型的边界，以安全地调用代码中的泛型对象上的具体方法。这是对“泛化”概念的一种明显的限制，因为必须限制你的泛型类型，使它们继承自特定的类，或者实现特定的接口。在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类或接口没有任何区别。
40837: 4451:
40838: 4452:某些编程语言提供的一种解决方案称为*潜在类型机制*或*结构化类型机制*，而更古怪的术语称为*鸭子类型机制*，即“如果它走起来像鸭子，并且叫起来也像鸭子，那么你就可以将它当作鸭子对待。”鸭子类型机制变成了一种相当流行的术语，可能是因为它不像其他的术语那样承载着历史的包袱。
40839: 4453:
40840: 4454:泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得你可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以 `speak()` 和 `sit()` 即可。”由于不要求具体类型，因此代码就可以更加泛化。
40841: 4455:
40842: 4456:潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方。
40843: 4457:
40844: 4458:支持潜在类型机制的语言包括 Python（可以从 www.Python.org 免费下载）、C++、Ruby、SmallTalk 和 Go。Python 是动态类型语言（几乎所有的类型检查都发生在运行时），而 C++ 和 Go 是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查。
40845: 4459:
40846: 4460:### pyhton 中的潜在类型
40847: 4461:
40848: 4462:如果我们将上面的描述用 Python 来表示，如下所示：
40849: 4463:
40850: 4464:```python
40851: 4465:# generics/DogsAndRobots.py
40852: 4466:
40853: 4467:class Dog:
40854: 4468:    def speak(self):
40855: 4469:        print("Arf!")
40856: 4470:    def sit(self):
40857: 4471:        print("Sitting")
40858: 4472:    def reproduce(self):
40859: 4473:        pass
40860: 4474:
40861: 4475:class Robot:
40862: 4476:    def speak(self):
40863: 4477:        print("Click!")
40864: 4478:    def sit(self):
40865: 4479:        print("Clank!")
40866: 4480:    def oilChange(self):
40867: 4481:        pass
40868: 4482:
40869: 4483:def perform(anything):
40870: 4484:    anything.speak()
40871: 4485:    anything.sit()
40872: 4486:
40873: 4487:a = Dog()
40874: 4488:b = Robot()
40875: 4489:perform(a)
40876: 4490:perform(b)
40877: 4491:
40878: 4492:output = """
40879: 4493:Arf!
40880: 4494:Sitting
40881: 4495:Click!
40882: 4496:Clank!
40883: 4497:"""
40884: 4498:```
40885: 4499:
40886: 4500:Python 使用缩进来确定作用域（因此不需要任何花括号），而冒号将表示新的作用域的开始。“**#**” 表示注释到行尾，就像Java中的 “ **//** ”。类的方法需要显式地指定 **this** 引用的等价物作为第一个参数，按惯例成为 **self** 。构造器调用不要求任何类型的“ **new** ”关键字，并且 Python 允许普通（非成员）函数，就像 `perform()` 所表明的那样。注意，在 `perform(anything)` 中，没有任何针对 **anything** 的类型，**anything** 只是一个标识符，它必须能够执行 `perform()` 期望它执行的操作，因此这里隐含着一个接口。但是你从来都不必显式地写出这个接口——它是潜在的。`perform()` 不关心其参数的类型，因此我可以向它传递任何对象，只要该对象支持  `speak()` 和 `sit()` 方法。如果传递给 `perform()` 的对象不支持这些操作，那么将会得到运行时异常。
40887: 4501:
40888: 4502:输出规定使用三重引号创建带有内嵌换行符的字符串。
40889: 4503:
40890: 4504:### C++ 中的潜在类型
40891: 4505:
40892: 4506:我们可以用 C++ 产生相同的效果：
40893: 4507:
40894: 4508:```c++
40895: 4509:// generics/DogsAndRobots.cpp
40896: 4510:
40897: 4511:#include <iostream>
40898: 4512:using namespace std;
40899: 4513:
40900: 4514:class Dog {
40901: 4515:public:
40902: 4516:    void speak() { cout << "Arf!" << endl; }
40903: 4517:    void sit() { cout << "Sitting" << endl; }
40904: 4518:    void reproduce() {}
40905: 4519:};
40906: 4520:
40907: 4521:class Robot {
40908: 4522:public:
40909: 4523:    void speak() { cout << "Click!" << endl; }
40910: 4524:    void sit() { cout << "Clank!" << endl; }
40911: 4525:    void oilChange() {}
40912: 4526:};
40913: 4527:
40914: 4528:template<class T> void perform(T anything) {
40915: 4529:    anything.speak();
40916: 4530:    anything.sit();
40917: 4531:}
40918: 4532:
40919: 4533:int main() {
40920: 4534:    Dog d;
40921: 4535:    Robot r;
40922: 4536:    perform(d);
40923: 4537:    perform(r);
40924: 4538:}
40925: 4539:/* Output:
40926: 4540:Arf!
40927: 4541:Sitting
40928: 4542:Click!
40929: 4543:Clank!
40930: 4544:*/
40931: 4545:```
40932: 4546:
40933: 4547:在 Python 和 C++ 中，**Dog** 和 **Robot** 没有任何共同的东西，只是碰巧有两个方法具有相同的签名。从类型的观点看，它们是完全不同的类型。但是，`perform()` 不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。
40934: 4548:C++ 确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给你一个错误消息（这些错误消息从历史上看是相当可怕和冗长的，是 C++ 的模版名声欠佳的主要原因）。尽管它们是在不同时期实现这一点的，C++ 在编译期，而 Python 在运行时，但是这两种语言都可以确保类型不会被误用，因此被认为是强类型的。[^5]潜在类型机制没有损害强类型机制。
40935: 4549:
40936: 4550:### Go 中的潜在类型
40937: 4551:
40938: 4552:这里用 Go 语言编写相同的程序：
40939: 4553:
40940: 4554:```go
40941: 4555:// generics/dogsandrobots.go
40942: 4556:
40943: 4557:package main
40944: 4558:import "fmt"
40945: 4559:
40946: 4560:type Dog struct {}
40947: 4561:func (this Dog) speak() { fmt.Printf("Arf!\n")}
40948: 4562:func (this Dog) sit() { fmt.Printf("Sitting\n")}
40949: 4563:func (this Dog) reproduce() {}
40950: 4564:
40951: 4565:type Robot struct {}
40952: 4566:func (this Robot) speak() { fmt.Printf("Click!\n") }
40953: 4567:func (this Robot) sit() { fmt.Printf("Clank!\n") }
40954: 4568:func (this Robot) oilChange() {}
40955: 4569:
40956: 4570:func perform(speaker interface { speak(); sit() }) {
40957: 4571:  speaker.speak();
40958: 4572:  speaker.sit();
40959: 4573:}
40960: 4574:
40961: 4575:func main() {
40962: 4576:  perform(Dog{})
40963: 4577:  perform(Robot{})
40964: 4578:}
40965: 4579:/* Output:
40966: 4580:Arf!
40967: 4581:Sitting
40968: 4582:Click!
40969: 4583:Clank!
40970: 4584:*/
40971: 4585:```
40972: 4586:
40973: 4587:Go 没有 **class** 关键字，但是可以使用上述形式创建等效的基本类：它通常不定义为类，而是定义为 **struct** ，在其中定义数据字段（此处不存在）。 对于每种方法，都以 **func** 关键字开头，然后（为了将该方法附加到您的类上）放在括号中，该括号包含对象引用，该对象引用可以是任何标识符，但是我在这里使用 **this** 来提醒您，就像在 C ++ 或 Java 中的 **this** 一样。 然后，在Go中像这样定义其余的函数。
40974: 4588:
40975: 4589:Go也没有继承关系，因此这种“面向对象的目标”形式是相对原始的，并且可能是我无法花更多的时间来学习该语言的主要原因。 但是，Go 的组成很简单。
40976: 4590:
40977: 4591:`perform()` 函数使用潜在类型：参数的确切类型并不重要，只要它包含了 `speak()` 和  `sit()` 方法即可。 该接口在此处匿名定义，内联，如 `perform()` 的参数列表所示。
40978: 4592:
40979: 4593:`main()` 证明 `perform()` 确实对其参数的确切类型不在乎，只要可以在该参数上调用 `talk()` 和 `sit()` 即可。 但是，就像 C ++ 模板函数一样，在编译时检查类型。
40980: 4594:
40981: 4595:语法 **Dog {}** 和 **Robot {}** 创建匿名的 **Dog** 和 **Robot** 结构。
40982: 4596:
40983: 4597:### java中的直接潜在类型
40984: 4598:
40985: 4599:因为泛型是在这场竞赛的后期才添加到 Java 中，因此没有任何机会可以去实现任何类型的潜在类型机制，因此 Java 没有对这种特性的支持。所以，初看起来，Java 的泛型机制比支持潜在类型机制的语言更“缺乏泛化性”。（使用擦除来实现 Java 泛型的实现有时称为第二类泛型类型）例如，在 Java 8  之前如果我们试图用 Java 实现上面 dogs-and-robots 的示例，那么就会被强制要求使用一个类或接口，并在边界表达式中指定它：
40986: 4600:
40987: 4601:```java
40988: 4602:// generics/Performs.java
40989: 4603:
40990: 4604:public interface Performs {
40991: 4605:    void speak();
40992: 4606:    void sit();
40993: 4607:}
40994: 4608:```
40995: 4609:
40996: 4610:```java
40997: 4611:// generics/DogsAndRobots.java
40998: 4612:// No (direct) latent typing in Java
40999: 4613:import typeinfo.pets.*;
41000: 4614:
41001: 4615:class PerformingDog extends Dog implements Performs {
41002: 4616:    @Override
41003: 4617:    public void speak() { System.out.println("Woof!"); }
41004: 4618:    @Override
41005: 4619:    public void sit() { System.out.println("Sitting"); }
41006: 4620:    public void reproduce() {}
41007: 4621:}
41008: 4622:
41009: 4623:class Robot implements Performs {
41010: 4624:    public void speak() { System.out.println("Click!"); }
41011: 4625:    public void sit() { System.out.println("Clank!"); }
41012: 4626:    public void oilChange() {}
41013: 4627:}
41014: 4628:
41015: 4629:class Communicate {
41016: 4630:    public static <T extends Performs>
41017: 4631:      void perform(T performer) {
41018: 4632:        performer.speak();
41019: 4633:        performer.sit();
41020: 4634:    }
41021: 4635:}
41022: 4636:
41023: 4637:public class DogsAndRobots {
41024: 4638:    public static void main(String[] args) {
41025: 4639:        Communicate.perform(new PerformingDog());
41026: 4640:        Communicate.perform(new Robot());
41027: 4641:    }
41028: 4642:}
41029: 4643:/* Output:
41030: 4644:Woof!
41031: 4645:Sitting
41032: 4646:Click!
41033: 4647:Clank!
41034: 4648:*/
41035: 4649:```
41036: 4650:
41037: 4651:但是要注意，`perform()` 不需要使用泛型来工作，它可以被简单地指定为接受一个 **Performs** 对象：
41038: 4652:
41039: 4653:```java
41040: 4654:// generics/SimpleDogsAndRobots.java
41041: 4655:// Removing the generic; code still works
41042: 4656:
41043: 4657:class CommunicateSimply {
41044: 4658:    static void perform(Performs performer) {
41045: 4659:        performer.speak();
41046: 4660:        performer.sit();
41047: 4661:    }
41048: 4662:}
41049: 4663:
41050: 4664:public class SimpleDogsAndRobots {
41051: 4665:    public static void main(String[] args) {
41052: 4666:        CommunicateSimply.perform(new PerformingDog());
41053: 4667:        CommunicateSimply.perform(new Robot());
41054: 4668:    }
41055: 4669:}
41056: 4670:/* Output:
41057: 4671:Woof!
41058: 4672:Sitting
41059: 4673:Click!
41060: 4674:Clank!
41061: 4675:*/
41062: 4676:```
41063: 4677:
41064: 4678:在本例中，泛型不是必需的，因为这些类已经被强制要求实现 **Performs** 接口。
41065: 4679:
41066: 4680:<!-- Compensating for the Lack of (Direct) Latent -->
41067: 4681:
41068: 4682:## 对缺乏潜在类型机制的补偿
41069: 4683:
41070: 4684:尽管 Java 不直接支持潜在类型机制，但是这并不意味着泛型代码不能在不同的类型层次结构之间应用。也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。
41071: 4685:
41072: 4686:### 反射
41073: 4687:
41074: 4688:可以使用的一种方式是反射，下面的 `perform()` 方法就是用了潜在类型机制：
41075: 4689:
41076: 4690:```java
41077: 4691:// generics/LatentReflection.java
41078: 4692:// Using reflection for latent typing
41079: 4693:import java.lang.reflect.*;
41080: 4694:
41081: 4695:// Does not implement Performs:
41082: 4696:class Mime {
41083: 4697:    public void walkAgainstTheWind() {}
41084: 4698:    public void sit() {
41085: 4699:        System.out.println("Pretending to sit");
41086: 4700:    }
41087: 4701:    public void pushInvisibleWalls() {}
41088: 4702:    @Override
41089: 4703:    public String toString() { return "Mime"; }
41090: 4704:}
41091: 4705:
41092: 4706:// Does not implement Performs:
41093: 4707:class SmartDog {
41094: 4708:    public void speak() { System.out.println("Woof!"); }
41095: 4709:    public void sit() { System.out.println("Sitting"); }
41096: 4710:    public void reproduce() {}
41097: 4711:}
41098: 4712:
41099: 4713:class CommunicateReflectively {
41100: 4714:    public static void perform(Object speaker) {
41101: 4715:        Class<?> spkr = speaker.getClass();
41102: 4716:        try {
41103: 4717:            try {
41104: 4718:                Method speak = spkr.getMethod("speak");
41105: 4719:                speak.invoke(speaker);
41106: 4720:            } catch(NoSuchMethodException e) {
41107: 4721:                System.out.println(speaker + " cannot speak");
41108: 4722:            }
41109: 4723:            try {
41110: 4724:                Method sit = spkr.getMethod("sit");
41111: 4725:                sit.invoke(speaker);
41112: 4726:            } catch(NoSuchMethodException e) {
41113: 4727:                System.out.println(speaker + " cannot sit");
41114: 4728:            }
41115: 4729:        } catch(SecurityException |
41116: 4730:            IllegalAccessException |
41117: 4731:            IllegalArgumentException |
41118: 4732:            InvocationTargetException e) {
41119: 4733:            throw new RuntimeException(speaker.toString(), e);
41120: 4734:        }
41121: 4735:    }
41122: 4736:}
41123: 4737:
41124: 4738:public class LatentReflection {
41125: 4739:    public static void main(String[] args) {
41126: 4740:        CommunicateReflectively.perform(new SmartDog());
41127: 4741:        CommunicateReflectively.perform(new Robot());
41128: 4742:        CommunicateReflectively.perform(new Mime());
41129: 4743:    }
41130: 4744:}
41131: 4745:/* Output:
41132: 4746:Woof!
41133: 4747:Sitting
41134: 4748:Click!
41135: 4749:Clank!
41136: 4750:Mime cannot speak
41137: 4751:Pretending to sit
41138: 4752:*/
41139: 4753:```
41140: 4754:
41141: 4755:上例中，这些类完全是彼此分离的，没有任何公共基类（除了 **Object** ）或接口。通过反射, `CommunicateReflectively.perform()` 能够动态地确定所需要的方法是否可用并调用它们。它甚至能够处理 **Mime** 只具有一个必需的方法这一事实，并能够部分实现其目标。
41142: 4756:
41143: 4757:### 将一个方法应用于序列
41144: 4758:
41145: 4759:反射提供了一些有用的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。但是有可能实现编译期类型检查和潜在类型机制吗？
41146: 4760:
41147: 4761:让我们看一个说明这个问题的示例。假设想要创建一个 `apply()` 方法，它能够将任何方法应用于某个序列中的所有对象。这种情况下使用接口不适合，因为你想要将任何方法应用于一个对象集合，而接口不可能描述任何方法。如何用 Java 来实现这个需求呢？
41148: 4762:
41149: 4763:最初，我们可以用反射来解决这个问题，由于有了 Java 的可变参数，这种方式被证明是相当优雅的：
41150: 4764:
41151: 4765:```java
41152: 4766:// generics/Apply.java
41153: 4767:
41154: 4768:import java.lang.reflect.*;
41155: 4769:import java.util.*;
41156: 4770:
41157: 4771:public class Apply {
41158: 4772:    public static <T, S extends Iterable<T>>
41159: 4773:      void apply(S seq, Method f, Object... args) {
41160: 4774:        try {
41161: 4775:            for(T t: seq)
41162: 4776:                f.invoke(t, args);
41163: 4777:        } catch(IllegalAccessException |
41164: 4778:            IllegalArgumentException |
41165: 4779:            InvocationTargetException e) {
41166: 4780:            // Failures are programmer errors
41167: 4781:            throw new RuntimeException(e);
41168: 4782:        }
41169: 4783:    }
41170: 4784:}
41171: 4785:```
41172: 4786:
41173: 4787:在 **Apply.java** 中，异常被转换为 **RuntimeException** ，因为没有多少办法可以从这种异常中恢复——在这种情况下，它们实际上代表着程序员的错误。
41174: 4788:
41175: 4789:为什么我们不只使用 Java 8 方法参考（稍后显示）而不是反射方法 **f** ？ 注意，`invoke()` 和 `apply()` 的优点是它们可以接受任意数量的参数。 在某些情况下，灵活性可能至关重要。
41176: 4790:
41177: 4791:为了测试 **Apply** ，我们首先创建一个 **Shape** 类：
41178: 4792:
41179: 4793:```java
41180: 4794:// generics/Shape.java
41181: 4795:
41182: 4796:public class Shape {
41183: 4797:    private static long counter = 0;
41184: 4798:    private final long id = counter++;
41185: 4799:    @Override
41186: 4800:    public String toString() {
41187: 4801:        return getClass().getSimpleName() + " " + id;
41188: 4802:    }
41189: 4803:    public void rotate() {
41190: 4804:        System.out.println(this + " rotate");
41191: 4805:    }
41192: 4806:    public void resize(int newSize) {
41193: 4807:        System.out.println(this + " resize " + newSize);
41194: 4808:    }
41195: 4809:}
41196: 4810:```
41197: 4811:
41198: 4812:被一个子类 **Square** 继承：
41199: 4813:
41200: 4814:```java
41201: 4815:// generics/Square.java
41202: 4816:
41203: 4817:public class Square extends Shape {}
41204: 4818:```
41205: 4819:
41206: 4820:通过这些，我们可以测试 **Apply**：
41207: 4821:
41208: 4822:```java
41209: 4823:// generics/ApplyTest.java
41210: 4824:
41211: 4825:import java.util.*;
41212: 4826:import java.util.function.*;
41213: 4827:import onjava.*;
41214: 4828:
41215: 4829:public class ApplyTest {
41216: 4830:    public static
41217: 4831:    void main(String[] args) throws Exception {
41218: 4832:        List<Shape> shapes =
41219: 4833:          Suppliers.create(ArrayList::new, Shape::new, 3);
41220: 4834:        Apply.apply(shapes, Shape.class.getMethod("rotate"));
41221: 4835:        Apply.apply(shapes, Shape.class.getMethod("resize", int.class), 7);
41222: 4836:
41223: 4837:        List<Square> squares =
41224: 4838:          Suppliers.create(ArrayList::new, Square::new, 3);
41225: 4839:        Apply.apply(squares, Shape.class.getMethod("rotate"));
41226: 4840:        Apply.apply(squares, Shape.class.getMethod("resize", int.class), 7);
41227: 4841:
41228: 4842:        Apply.apply(new FilledList<>(Shape::new, 3),
41229: 4843:          Shape.class.getMethod("rotate"));
41230: 4844:        Apply.apply(new FilledList<>(Square::new, 3),
41231: 4845:          Shape.class.getMethod("rotate"));
41232: 4846:
41233: 4847:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
41234: 4848:          new SimpleQueue<>(), SimpleQueue::add,
41235: 4849:          Shape::new, 3);
41236: 4850:        Suppliers.fill(shapeQ, SimpleQueue::add,
41237: 4851:          Square::new, 3);
41238: 4852:        Apply.apply(shapeQ, Shape.class.getMethod("rotate"));
41239: 4853:    }
41240: 4854:}
41241: 4855:/* Output:
41242: 4856:Shape 0 rotate
41243: 4857:Shape 1 rotate
41244: 4858:Shape 2 rotate
41245: 4859:Shape 0 resize 7
41246: 4860:Shape 1 resize 7
41247: 4861:Shape 2 resize 7
41248: 4862:Square 3 rotate
41249: 4863:Square 4 rotate
41250: 4864:Square 5 rotate
41251: 4865:Square 3 resize 7
41252: 4866:Square 4 resize 7
41253: 4867:Square 5 resize 7
41254: 4868:Shape 6 rotate
41255: 4869:Shape 7 rotate
41256: 4870:Shape 8 rotate
41257: 4871:Square 9 rotate
41258: 4872:Square 10 rotate
41259: 4873:Square 11 rotate
41260: 4874:Shape 12 rotate
41261: 4875:Shape 13 rotate
41262: 4876:Shape 14 rotate
41263: 4877:Square 15 rotate
41264: 4878:Square 16 rotate
41265: 4879:Square 17 rotate
41266: 4880:*/
41267: 4881:```
41268: 4882:
41269: 4883:在 **Apply** 中，我们运气很好，因为碰巧在 Java 中内建了一个由 Java 集合类库使用的 **Iterable** 接口。正由于此， `apply()` 方法可以接受任何实现了 **Iterable** 接口的事物，包括诸如 **List** 这样的所有 **Collection** 类。但是它还可以接受其他任何事物，只要能够使这些事物是 **Iterable** 的——例如，在 `main()` 中使用下面定义的 **SimpleQueue** 类：
41270: 4884:
41271: 4885:```java
41272: 4886:// generics/SimpleQueue.java
41273: 4887:
41274: 4888:// A different kind of Iterable collection
41275: 4889:import java.util.*;
41276: 4890:
41277: 4891:public class SimpleQueue<T> implements Iterable<T> {
41278: 4892:    private LinkedList<T> storage = new LinkedList<>();
41279: 4893:    public void add(T t) { storage.offer(t); }
41280: 4894:    public T get() { return storage.poll(); }
41281: 4895:    @Override
41282: 4896:    public Iterator<T> iterator() {
41283: 4897:        return storage.iterator();
41284: 4898:    }
41285: 4899:}
41286: 4900:```
41287: 4901:
41288: 4902:正如反射解决方案看起来那样优雅，我们必须观察到反射（尽管在 Java 的最新版本中得到了显着改进）通常比非反射实现要慢，因为在运行时发生了很多事情。 但它不应阻止您尝试这种解决方案，这依然是值得考虑的一点。
41289: 4903:
41290: 4904:几乎可以肯定，你会首先使用 Java 8 的函数式方法，并且只有在解决了特殊需求时才诉诸反射。 这里对 **ApplyTest.java** 进行了重写，以利用 Java 8 的流和函数工具：
41291: 4905:
41292: 4906:```java
41293: 4907:// generics/ApplyFunctional.java
41294: 4908:
41295: 4909:import java.util.*;
41296: 4910:import java.util.stream.*;
41297: 4911:import java.util.function.*;
41298: 4912:import onjava.*;
41299: 4913:
41300: 4914:public class ApplyFunctional {
41301: 4915:    public static void main(String[] args) {
41302: 4916:        Stream.of(
41303: 4917:          Stream.generate(Shape::new).limit(2),
41304: 4918:          Stream.generate(Square::new).limit(2))
41305: 4919:        .flatMap(c -> c) // flatten into one stream
41306: 4920:        .peek(Shape::rotate)
41307: 4921:        .forEach(s -> s.resize(7));
41308: 4922:
41309: 4923:        new FilledList<>(Shape::new, 2)
41310: 4924:          .forEach(Shape::rotate);
41311: 4925:        new FilledList<>(Square::new, 2)
41312: 4926:          .forEach(Shape::rotate);
41313: 4927:
41314: 4928:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
41315: 4929:          new SimpleQueue<>(), SimpleQueue::add,
41316: 4930:          Shape::new, 2);
41317: 4931:        Suppliers.fill(shapeQ, SimpleQueue::add,
41318: 4932:          Square::new, 2);
41319: 4933:        shapeQ.forEach(Shape::rotate);
41320: 4934:    }
41321: 4935:}
41322: 4936:/* Output:
41323: 4937:Shape 0 rotate
41324: 4938:Shape 0 resize 7
41325: 4939:Shape 1 rotate
41326: 4940:Shape 1 resize 7
41327: 4941:Square 2 rotate
41328: 4942:Square 2 resize 7
41329: 4943:Square 3 rotate
41330: 4944:Square 3 resize 7
41331: 4945:Shape 4 rotate
41332: 4946:Shape 5 rotate
41333: 4947:Square 6 rotate
41334: 4948:Square 7 rotate
41335: 4949:Shape 8 rotate
41336: 4950:Shape 9 rotate
41337: 4951:Square 10 rotate
41338: 4952:Square 11 rotate
41339: 4953:*/
41340: 4954:```
41341: 4955:
41342: 4956:由于使用 Java 8，因此不需要 `Apply.apply()` 。
41343: 4957:
41344: 4958:我们首先生成两个 **Stream** ： 一个是 **Shape** ，一个是 **Square** ，并将它们展平为单个流。 尽管 Java 缺少功能语言中经常出现的 `flatten()` ，但是我们可以使用 `flatMap(c-> c)` 产生相同的结果，后者使用身份映射将操作简化为“  **flatten** ”。
41345: 4959:
41346: 4960:我们使用 `peek()` 当做对 `rotate()` 的调用，因为 `peek()` 执行一个操作（此处是出于副作用），并在未更改的情况下传递对象。
41347: 4961:
41348: 4962:注意，使用 **FilledList** 和 **shapeQ** 调用 `forEach()` 比 `Apply.apply()` 代码整洁得多。 在代码简单性和可读性方面，结果比以前的方法好得多。 并且，现在也不可能从  `main()` 引发异常。
41349: 4963:
41350: 4964:<!-- Assisted Latent Typing in Java 8 -->
41351: 4965:
41352: 4966:## Java8 中的辅助潜在类型
41353: 4967:
41354: 4968:先前声明关于 Java 缺乏对潜在类型的支持在 Java 8 之前是完全正确的。但是，Java 8 中的非绑定方法引用使我们能够产生一种潜在类型的形式，以满足创建一段可工作在不相干类型上的代码。因为 Java 最初并不是如此设计，所以结果可想而知，比其他语言中要尴尬一些。但是，至少现在成为了可能，只是缺乏令人惊艳之处。
41355: 4969:
41356: 4970:我在其他地方从没遇过这种技术，因此我将其称为辅助潜在类型。
41357: 4971:
41358: 4972:我们将重写 **DogsAndRobots.java** 来演示该技术。 为使外观看起来与原始示例尽可能相似，我仅向每个原始类名添加了 **A**：
41359: 4973:
41360: 4974:```java
41361: 4975:// generics/DogsAndRobotMethodReferences.java
41362: 4976:
41363: 4977:// "Assisted Latent Typing"
41364: 4978:import typeinfo.pets.*;
41365: 4979:import java.util.function.*;
41366: 4980:
41367: 4981:class PerformingDogA extends Dog {
41368: 4982:    public void speak() { System.out.println("Woof!"); }
41369: 4983:    public void sit() { System.out.println("Sitting"); }
41370: 4984:    public void reproduce() {}
41371: 4985:}
41372: 4986:
41373: 4987:class RobotA {
41374: 4988:    public void speak() { System.out.println("Click!"); }
41375: 4989:    public void sit() { System.out.println("Clank!"); }
41376: 4990:    public void oilChange() {}
41377: 4991:}
41378: 4992:
41379: 4993:class CommunicateA {
41380: 4994:    public static <P> void perform(P performer,
41381: 4995:      Consumer<P> action1, Consumer<P> action2) {
41382: 4996:        action1.accept(performer);
41383: 4997:        action2.accept(performer);
41384: 4998:    }
41385: 4999:}
41386: 5000:
41387: 5001:public class DogsAndRobotMethodReferences {
41388: 5002:    public static void main(String[] args) {
41389: 5003:        CommunicateA.perform(new PerformingDogA(),
41390: 5004:          PerformingDogA::speak, PerformingDogA::sit);
41391: 5005:        CommunicateA.perform(new RobotA(),
41392: 5006:          RobotA::speak, RobotA::sit);
41393: 5007:        CommunicateA.perform(new Mime(),
41394: 5008:          Mime::walkAgainstTheWind,
41395: 5009:          Mime::pushInvisibleWalls);
41396: 5010:    }
41397: 5011:}
41398: 5012:/* Output:
41399: 5013:Woof!
41400: 5014:Sitting
41401: 5015:Click!
41402: 5016:Clank!
41403: 5017:*/
41404: 5018:```
41405: 5019:
41406: 5020:**PerformingDogA** 和 **RobotA** 与 **DogsAndRobots.java** 中的相同，不同之处在于它们不继承通用接口 **Performs** ，因此它们没有通用性。
41407: 5021:
41408: 5022:`CommunicateA.perform()` 在没有约束的 **P** 上生成。 只要可以使用 `Consumer <P>`，它在这里就可以是任何东西，这些 `Consumer<P>` 代表不带参数的 **P** 方法的未绑定方法引用。当您调用 **Consumer**  的 `accept()` 方法时，它将方法引用绑定到执行者对象并调用该方法。 由于 [函数式编程](book/13-Functional-Programming.md) 一章中描述的“魔术”，我们可以将任何符合签名的未绑定方法引用传递给 `CommunicateA.perform()` 。
41409: 5023:
41410: 5024:之所以称其为“辅助”，是因为您必须显式地为 `perform()` 提供要使用的方法引用。 它不能只按名称调用方法。
41411: 5025:
41412: 5026:尽管传递未绑定的方法引用似乎要花很多力气，但潜在类型的最终目标还是可以实现的。 我们创建了一个代码片段 `CommunicateA.perform()` ，该代码可用于任何具有符合签名的方法引用的类型。 请注意，这与我们看到的其他语言中的潜在类型有所不同，因为这些语言不仅需要签名以符合规范，还需要方法名称。 因此，该技术可以说产生了更多的通用代码。
41413: 5027:
41414: 5028:为了证明这一点，我还从 **LatentReflection.java** 中引入了 **Mime**。
41415: 5029:
41416: 5030:### 使用**Suppliers**类的通用方法
41417: 5031:
41418: 5032:通过辅助潜在类型，我们可以定义本章其他部分中使用的 **Suppliers** 类。 此类包含使用生成器填充 **Collection** 的工具方法。 泛化这些操作很有意义：
41419: 5033:
41420: 5034:```java
41421: 5035:// onjava/Suppliers.java
41422: 5036:
41423: 5037:// A utility to use with Suppliers
41424: 5038:package onjava;
41425: 5039:import java.util.*;
41426: 5040:import java.util.function.*;
41427: 5041:import java.util.stream.*;
41428: 5042:
41429: 5043:public class Suppliers {
41430: 5044:    // Create a collection and fill it:
41431: 5045:    public static <T, C extends Collection<T>> C
41432: 5046:      create(Supplier<C> factory, Supplier<T> gen, int n) {
41433: 5047:        return Stream.generate(gen)
41434: 5048:            .limit(n)
41435: 5049:            .collect(factory, C::add, C::addAll);
41436: 5050:    }
41437: 5051:    
41438: 5052:    // Fill an existing collection:
41439: 5053:    public static <T, C extends Collection<T>>
41440: 5054:      C fill(C coll, Supplier<T> gen, int n) {
41441: 5055:        Stream.generate(gen)
41442: 5056:            .limit(n)
41443: 5057:            .forEach(coll::add);
41444: 5058:        return coll;
41445: 5059:    }
41446: 5060:    
41447: 5061:    // Use an unbound method reference to
41448: 5062:    // produce a more general method:
41449: 5063:    public static <H, A> H fill(H holder,
41450: 5064:      BiConsumer<H, A> adder, Supplier<A> gen, int n) {
41451: 5065:        Stream.generate(gen)
41452: 5066:            .limit(n)
41453: 5067:            .forEach(a -> adder.accept(holder, a));
41454: 5068:        return holder;
41455: 5069:    }
41456: 5070:}
41457: 5071:```
41458: 5072:
41459: 5073:`create()` 为你创建一个新的 **Collection** 子类型，而 `fill()` 的第一个版本将元素放入 **Collection** 的现有子类型中。 请注意，还会返回传入的容器的确切类型，因此不会丢失类型信息。[^6]
41460: 5074:
41461: 5075:前两种方法一般都受约束，只能与 **Collection** 子类型一起使用。`fill()` 的第二个版本适用于任何类型的 **holder** 。 它需要一个附加参数：未绑定方法引用 `adder. fill()` ，使用辅助潜在类型来使其与任何具有添加元素方法的 **holder** 类型一起使用。因为此未绑定方法 **adder** 必须带有一个参数（要添加到 **holder** 的元素），所以 **adder** 必须是 `BiConsumer <H，A>` ，其中 **H** 是要绑定到的 **holder** 对象的类型，而 **A** 是要被添加的绑定元素类型。 对 `accept()` 的调用将使用参数 a 调用对象 **holder** 上的未绑定方法 **holder**。
41462: 5076:
41463: 5077:在一个稍作模拟的测试中对 **Suppliers** 工具程序进行了测试，该仿真还使用了本章前面定义的 **RandomList** ：
41464: 5078:
41465: 5079:```java
41466: 5080:// generics/BankTeller.java
41467: 5081:
41468: 5082:// A very simple bank teller simulation
41469: 5083:import java.util.*;
41470: 5084:import onjava.*;
41471: 5085:
41472: 5086:class Customer {
41473: 5087:    private static long counter = 1;
41474: 5088:    private final long id = counter++;
41475: 5089:    @Override
41476: 5090:    public String toString() {
41477: 5091:        return "Customer " + id;
41478: 5092:    }
41479: 5093:}
41480: 5094:
41481: 5095:class Teller {
41482: 5096:    private static long counter = 1;
41483: 5097:    private final long id = counter++;
41484: 5098:    @Override
41485: 5099:    public String toString() {
41486: 5100:        return "Teller " + id;
41487: 5101:    }
41488: 5102:}
41489: 5103:
41490: 5104:class Bank {
41491: 5105:    private List<BankTeller> tellers =
41492: 5106:        new ArrayList<>();
41493: 5107:    public void put(BankTeller bt) {
41494: 5108:        tellers.add(bt);
41495: 5109:    }
41496: 5110:}
41497: 5111:
41498: 5112:public class BankTeller {
41499: 5113:    public static void serve(Teller t, Customer c) {
41500: 5114:        System.out.println(t + " serves " + c);
41501: 5115:    }
41502: 5116:    public static void main(String[] args) {
41503: 5117:        // Demonstrate create():
41504: 5118:        RandomList<Teller> tellers =
41505: 5119:            Suppliers.create(
41506: 5120:            RandomList::new, Teller::new, 4);
41507: 5121:        // Demonstrate fill():
41508: 5122:        List<Customer> customers = Suppliers.fill(
41509: 5123:            new ArrayList<>(), Customer::new, 12);
41510: 5124:        customers.forEach(c ->
41511: 5125:            serve(tellers.select(), c));
41512: 5126:        // Demonstrate assisted latent typing:
41513: 5127:        Bank bank = Suppliers.fill(
41514: 5128:            new Bank(), Bank::put, BankTeller::new, 3);
41515: 5129:        // Can also use second version of fill():
41516: 5130:        List<Customer> customers2 = Suppliers.fill(
41517: 5131:            new ArrayList<>(),
41518: 5132:            List::add, Customer::new, 12);
41519: 5133:    }
41520: 5134:}
41521: 5135:/* Output:
41522: 5136:Teller 3 serves Customer 1
41523: 5137:Teller 2 serves Customer 2
41524: 5138:Teller 3 serves Customer 3
41525: 5139:Teller 1 serves Customer 4
41526: 5140:Teller 1 serves Customer 5
41527: 5141:Teller 3 serves Customer 6
41528: 5142:Teller 1 serves Customer 7
41529: 5143:Teller 2 serves Customer 8
41530: 5144:Teller 3 serves Customer 9
41531: 5145:Teller 3 serves Customer 10
41532: 5146:Teller 2 serves Customer 11
41533: 5147:Teller 4 serves Customer 12
41534: 5148:*/
41535: 5149:```
41536: 5150:
41537: 5151:可以看到 `create()` 生成一个新的 **Collection** 对象，而 `fill()` 添加到现有 **Collection** 中。第二个版本`fill()` 显示，它不仅与无关的新类型 **Bank** 一起使用，还能与 **List** 一起使用。因此，从技术上讲，`fill()` 的第一个版本在技术上不是必需的，但在使用 **Collection** 时提供了较短的语法。
41538: 5152:
41539: 5153:<!-- Summary: Is Casting Really So Bad? -->
41540: 5154:
41541: 5155:## 总结：类型转换真的如此之糟吗？
41542: 5156:
41543: 5157:自从 C++ 模版出现以来，我就一直在致力于解释它，我可能比大多数人都更早地提出了下面的论点。直到最近，我才停下来，去思考这个论点到底在多少时间内是有效的——我将要描述的问题到底有多少次可以穿越障碍得以解决。
41544: 5158:
41545: 5159:这个论点就是：使用泛型类型机制的最吸引人的地方，就是在使用集合类的地方，这些类包括诸如各种 **List** 、各种 **Set** 、各种 **Map** 等你在 [集合](book/12-Collections.md) 和 [附录：集合主题](book/Appendix-Collection-Topics.md) 这两章所见。在 Java 5 之前，当你将一个对象放置到集合中时，这个对象就会被向上转型为 **Object** ，因此你会丢失类型信息。当你想要将这个对象从集合中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。我用的示例是持有 **Cat** 的 **List** （这个示例的一种使用苹果和桔子的变体在 [集合](book/12-Collections.md) 章节的开头展示过）。如果没有 Java 5 泛型版本的集合，你放到容集里和从集合中取回的都是 **Object** 。因此，我们很可能会将一个 **Dog** 放置到 **Cat** 的 **List** 中。
41546: 5160:
41547: 5161:但是，泛型出现之前的 Java 并不会让你误用放入到集合中的对象。如果将一个 **Dog** 扔到 **Cat** 的集合中，并且试图将这个集合中的所有东西都当作 **Cat** 处理，那么当你从这个 **Cat** 集合中取回那个 **Dog** 引用，并试图将其转型为 **Cat** 时，就会得到一个 **RuntimeException** 。你仍旧可以发现问题，但是是在运行时而非编译期发现它的。
41548: 5162:
41549: 5163:在本书以前的版本中，我曾经说过：
41550: 5164:
41551: 5165:> 这不止令人恼火，它还可能会产生难以发现的缺陷。如果这个程序的某个部分（或数个部分）向集合中插入了对象，并且通过异常，你在程序的另一个独立的部分中发现有不良对象被放置到了集合中，那么必须发现这个不良插入到底是在何处发生的。
41552: 5166:
41553: 5167:但是，随着对这个论点的进一步检查，我开始怀疑它了。首先，这会多么频繁地发生呢？我记得这类事情从未发生在我身上，并且当我在会议上询问其他人时，我也从来没有听说过有人碰上过。另一本书使用了一个称为 **files** 的 list 示例，它包含 **String** 对象。在这个示例中，向 **files** 中添加一个 **File** 对象看起来相当自然，因此这个对象的名字可能叫 **fileNames** 更好。无论 Java 提供了多少类型检查，仍旧可能会写出晦涩的程序，而编写差劲儿的程序即便可以编译，它仍旧是编写差劲儿的程序。可能大多数人都会使用命名良好的集合，例如 **cats** ，因为它们可以向试图添加非 **Cat** 对象的程序员提供可视的警告。并且即便这类事情发生了，它真正又能潜伏多久呢？只要你开始用真实数据来运行测试，就会非常快地看到异常。
41554: 5168:
41555: 5169:有一位作者甚至断言，这样的缺陷将“*潜伏数年*”。但是我不记得有任何大量的相关报告，来说明人们在查找“狗在猫列表中”这类缺陷时困难重重，或者是说明人们会非常频繁地产生这种错误。然而，你将在 [多线程编程](book/24-Concurrent-Programming.md) 章节中看到，在使用线程时，出现那些可能看起来极罕见的缺陷，是很寻常并容易发生的事，而且，对于到底出了什么错，这些缺陷只能给你一个很模糊的概念。因此，对于泛型是添加到 Java 中的非常显著和相当复杂的特性这一点，“狗在猫列表中”这个论据真的能够成为它的理由吗？
41556: 5170:我相信被称为*泛型*的通用语言特性（并非必须是其在 Java 中的特定实现）的目的在于可表达性，而不仅仅是为了创建类型安全的集合。类型安全的集合是能够创建更通用代码这一能力所带来的副作用。
41557: 5171:因此，即便“狗在猫列表中”这个论据经常被用来证明泛型是必要的，但是它仍旧是有问题的。就像我在本章开头声称的，我不相信这就是泛型这个概念真正的含义。相反，泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。正如你在本章中看到的，编写真正泛化的“持有器”类（ Java 的容器就是这种类）相当简单，但是编写出能够操作其泛型类型的泛化代码就需要额外的努力了，这些努力需要类创建者和类消费者共同付出，他们必须理解这些代码的概念和实现。这些额外的努力会增加使用这种特性的难度，并可能会因此而使其在某些场合缺乏可应用性，而在这些场合中，它可能会带来附加的价值。
41558: 5172:
41559: 5173:还要注意到，因为泛型是后来添加到 Java 中，而不是从一开始就设计到这种语言中的，所以某些容器无法达到它们应该具备的健壮性。例如，观察一下 **Map** ，在特定的方法 `containsKey(Object key) `和 `get(Object key)` 中就包含这类情况。如果这些类是使用在它们之前就存在的泛型设计的，那么这些方法将会使用参数化类型而不是 **Object** ，因此也就可以提供这些泛型假设会提供的编译期检查。例如，在 C++ 的 **map** 中，键的类型总是在编译期检查的。
41560: 5174:
41561: 5175:有一件事很明显：在一种语言已经被广泛应用之后，在其较新的版本中引入任何种类的泛型机制，都会是一项非常非常棘手的任务，并且是一项不付出艰辛就无法完成的任务。在 C++ 中，模版是在其最初的 ISO 版本中就引入的（即便如此，也引发了阵痛，因为在第一个标准 C++ 出现之前，有很多非模版版本在使用），因此实际上模版一直都是这种语言的一部分。在 Java 中，泛型是在这种语言首次发布大约 10 年之后才引入的，因此向泛型迁移的问题特别多，并且对泛型的设计产生了明显的影响。其结果就是，程序员将承受这些痛苦，而这一切都是由于 Java 设计者在设计 1.0 版本时所表现出来的短视造成的。当 Java 最初被创建时，它的设计者们当然了解 C++ 的模版，他们甚至考虑将其囊括到 Java 语言中，但是出于这样或那样的原因，他们决定将模版排除在外（其迹象就是他们过于匆忙）。因此， Java 语言和使用它的程序员都将承受这些痛苦。只有时间将会说明 Java 的泛型方式对这种语言所造成的最终影响。
41562: 5176:某些语言，已经融入了更简洁、影响更小的方式，来实现参数化类型。我们不可能不去想象这样的语言将会成为 Java 的继任者，因为它们采用的方式，与 C++ 通过 C 来实现的方式相同：按原样使用它，然后对其进行改进。
41563: 5177:
41564: 5178:## 进阶阅读
41565: 5179:
41566: 5180:泛型的入门文档是 《Generics in the Java Programming Language》，作者是 Gilad Bracha，可以从 http://java.oracle.com 获取。
41567: 5181:
41568: 5182:Angelika Langer 的《Java Generics FAQs》是一份非常有帮助的资料，可以从 http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html 获取。
41569: 5183:
41570: 5184:你可以从 《Adding Wildcards to the Java Programming Language》中学到更多关于通配符的知识，作者是 Torgerson、Ernst、Hansen、von der Ahe、Bracha 和 Gafter，地址是 http://www.jot.fm/issues/issue_2004_12/article5。
41571: 5185:
41572: 5186:Neal After 对于 Java 问题（尤其是擦除）的看法可以从这里找到：http://www.infoq.com/articles/neal-gafter-on-java。
41573: 5187:
41574: 5188:[^1]: 在编写本章期间，Angelika Langer的 Java 泛型常见问题解答以及她的其他著作（与Klaus Kreft一起）是非常宝贵的。
41575: 5189:[^2]: [http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html](http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html)
41576: 5190:[^3]: 参见本章章末引文。
41577: 5191:[^4]: 注意，一些编程环境，如 Eclipse 和 IntelliJ IDEA，将会自动生成委托代码。
41578: 5192:[^5]: 因为可以使用转型，有效地禁止了类型系统，一些人就认为 C++ 是弱类型，但这太极端了。一种可能更好的说法是 C++ 是有一道暗门的强类型语言。
41579: 5193:[^6]: 我再次从 Brian Goetz 那获得帮助。
41580: 5194:
41581: 5195:<!-- 分页 -->
41582: 5196:
41583: 5197:<div style="page-break-after: always;"></div>
41584: 
41585: 1:[TOC]
41586: 2:
41587: 3:<!-- Generics -->
41588: 4:
41589: 5:# 第二十章 泛型
41590: 6:
41591: 7:> 普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。
41592: 8:
41593: 9:多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。除了 `final` 类（或只提供私有构造函数的类）任何类型都可被扩展，所以大部分时候这种灵活性是自带的。
41594: 10:
41595: 11:拘泥于单一的继承体系太过局限，因为只有继承体系中的对象才能适用基类作为参数的方法中。如果方法以接口而不是类作为参数，限制就宽松多了，只要实现了接口就可以。这给予调用方一种选项，通过调整现有的类来实现接口，满足方法参数要求。接口可以突破继承体系的限制。
41596: 12:
41597: 13:即便是接口也还是有诸多限制。一旦指定了接口，它就要求你的代码必须使用特定的接口。而我们希望编写更通用的代码，能够适用“非特定的类型”，而不是一个具体的接口或类。
41598: 14:
41599: 15:这就是泛型的概念，是 Java 5 的重大变化之一。泛型实现了*参数化类型*，这样你编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。随后你会发现 Java 中泛型的实现并没有那么“泛”，你可能会质疑“泛型”这个词是否合适用来描述这一功能。
41600: 16:
41601: 17:如果你从未接触过参数化类型机制，你会发现泛型对 Java 语言确实是个很有益的补充。在你实例化一个类型参数时，编译器会负责转型并确保类型的正确性。这是一大进步。
41602: 18:
41603: 19:然而，如果你了解其他语言（例如 C++ ）的参数化机制，你会发现，Java 泛型并不能满足所有的预期。使用别人创建好的泛型相对容易，但是创建自己的泛型时，就会遇到很多意料之外的麻烦。
41604: 20:
41605: 21:这并不是说 Java 泛型毫无用处。在很多情况下，它可以使代码更直接更优雅。不过，如果你见识过那种实现了更纯粹的泛型的编程语言，那么，Java 可能会令你失望。本章会介绍 Java 泛型的优点与局限。我会解释 Java 的泛型是如何发展成现在这样的，希望能够帮助你更有效地使用这个特性。[^1]
41606: 22:
41607: 23:### 与 C++ 的比较
41608: 24:
41609: 25:Java 的设计者曾说过，这门语言的灵感主要来自 C++ 。尽管如此，学习 Java 时基本不用参考 C++ 。
41610: 26:
41611: 27:但是，Java 中的泛型需要与 C++ 进行对比，理由有两个：首先，理解 C++ *模板*（泛型的主要灵感来源，包括基本语法）的某些特性，有助于理解泛型的基础理念。同时，非常重要的一点是，你可以了解 Java 泛型的局限是什么，以及为什么会有这些局限。最终的目标是明确 Java 泛型的边界，让你成为一个程序高手。只有知道了某个技术不能做什么，你才能更好地做到所能做的（部分原因是，不必浪费时间在死胡同里）。
41612: 28:
41613: 29:第二个原因是，在 Java 社区中，大家普遍对 C++ 模板有一种误解，而这种误解可能会令你在理解泛型的意图时产生偏差。
41614: 30:
41615: 31:因此，本章中会介绍少量 C++ 模板的例子，仅当它们确实可以加深理解时才会引入。
41616: 32:
41617: 33:<!-- Simple Generics -->
41618: 34:
41619: 35:## 简单泛型
41620: 36:
41621: 37:促成泛型出现的最主要的动机之一是为了创建*集合类*，参见 [集合](book/12-Collections.md) 章节。集合用于存放要使用到的对象。数组也是如此，不过集合比数组更加灵活，功能更丰富。几乎所有程序在运行过程中都会涉及到一组对象，因此集合是可复用性最高的类库之一。
41622: 38:
41623: 39:我们先看一个只能持有单个对象的类。这个类可以明确指定其持有的对象的类型：
41624: 40:
41625: 41:```java
41626: 42:// generics/Holder1.java
41627: 43:
41628: 44:class Automobile {}
41629: 45:
41630: 46:public class Holder1 {
41631: 47:    private Automobile a;
41632: 48:    public Holder1(Automobile a) { this.a = a; }
41633: 49:    Automobile get() { return a; }
41634: 50:}
41635: 51:```
41636: 52:
41637: 53:这个类的可复用性不高，它无法持有其他类型的对象。我们可不希望为碰到的每个类型都编写一个新的类。
41638: 54:
41639: 55:在 Java 5 之前，我们可以让这个类直接持有 `Object` 类型的对象：
41640: 56:
41641: 57:```java
41642: 58:// generics/ObjectHolder.java
41643: 59:
41644: 60:public class ObjectHolder {
41645: 61:    private Object a;
41646: 62:    public ObjectHolder(Object a) { this.a = a; }
41647: 63:    public void set(Object a) { this.a = a; }
41648: 64:    public Object get() { return a; }
41649: 65:    
41650: 66:    public static void main(String[] args) {
41651: 67:        ObjectHolder h2 = new ObjectHolder(new Automobile());
41652: 68:        Automobile a = (Automobile)h2.get();
41653: 69:        h2.set("Not an Automobile");
41654: 70:        String s = (String)h2.get();
41655: 71:        h2.set(1); // 自动装箱为 Integer
41656: 72:        Integer x = (Integer)h2.get();
41657: 73:    }
41658: 74:}
41659: 75:```
41660: 76:
41661: 77:现在，`ObjectHolder` 可以持有任何类型的对象，在上面的示例中，一个 `ObjectHolder` 先后持有了三种不同类型的对象。
41662: 78:
41663: 79:一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。
41664: 80:
41665: 81:因此，与其使用 `Object` ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用*类型参数*，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，`T` 就是类型参数：
41666: 82:
41667: 83:```java
41668: 84:// generics/GenericHolder.java
41669: 85:
41670: 86:public class GenericHolder<T> {
41671: 87:    private T a;
41672: 88:    public GenericHolder() {}
41673: 89:    public void set(T a) { this.a = a; }
41674: 90:    public T get() { return a; }
41675: 91:    
41676: 92:    public static void main(String[] args) {
41677: 93:        GenericHolder<Automobile> h3 = new GenericHolder<Automobile>();
41678: 94:        h3.set(new Automobile()); // 此处有类型校验
41679: 95:        Automobile a = h3.get();  // 无需类型转换
41680: 96:        //- h3.set("Not an Automobile"); // 报错
41681: 97:        //- h3.set(1);  // 报错
41682: 98:    }
41683: 99:}
41684: 100:```
41685: 101:
41686: 102:创建 `GenericHolder` 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 `main()` 中那样使用。然后，你就只能在 `GenericHolder` 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当你调用 `get()` 取值时，直接就是正确的类型。
41687: 103:
41688: 104:这就是 Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。
41689: 105:
41690: 106:你可能注意到 `h3` 的定义非常繁复。在 `=` 左边有 `GenericHolder<Automobile>`, 右边又重复了一次。在 Java 5 中，这种写法被解释成“必要的”，但在 Java 7 中设计者修正了这个问题（新的简写语法随后成为备受欢迎的特性）。以下是简写的例子：
41691: 107:
41692: 108:```java
41693: 109:// generics/Diamond.java
41694: 110:
41695: 111:class Bob {}
41696: 112:
41697: 113:public class Diamond<T> {
41698: 114:    public static void main(String[] args) {
41699: 115:        GenericHolder<Bob> h3 = new GenericHolder<>();
41700: 116:        h3.set(new Bob());
41701: 117:    }
41702: 118:}
41703: 119:```
41704: 120:
41705: 121:注意，在 `h3` 的定义处，`=` 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。在本书剩余部分都会使用这种语法。
41706: 122:
41707: 123:一般来说，你可以认为泛型和其他类型差不多，只不过它们碰巧有类型参数罢了。在使用泛型时，你只需要指定它们的名称和类型参数列表即可。
41708: 124:
41709: 125:### 一个元组类库
41710: 126:
41711: 127:有时一个方法需要能返回多个对象。而 **return** 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得了编译时的类型安全。
41712: 128:
41713: 129:这个概念称为*元组*，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 *数据传输对象* 或 *信使* ）。
41714: 130:
41715: 131:通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组：
41716: 132:
41717: 133:```java
41718: 134:// onjava/Tuple2.java
41719: 135:package onjava;
41720: 136:
41721: 137:public class Tuple2<A, B> {
41722: 138:    public final A a1;
41723: 139:    public final B a2;
41724: 140:    public Tuple2(A a, B b) { a1 = a; a2 = b; }
41725: 141:    public String rep() { return a1 + ", " + a2; }
41726: 142:  
41727: 143:    @Override
41728: 144:    public String toString() {
41729: 145:        return "(" + rep() + ")";
41730: 146:    }
41731: 147:}
41732: 148:```
41733: 149:
41734: 150:构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。
41735: 151:
41736: 152:初次阅读上面的代码时，你可能认为这违反了 Java 编程的封装原则。`a1` 和 `a2` 应该声明为 **private**，然后提供 `getFirst()` 和 `getSecond()` 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取 `a1` 和 `a2` 然后对它们执行任何操作，但无法对 `a1` 和 `a2` 重新赋值。例子中的 `final` 可以实现同样的效果，并且更为简洁明了。
41737: 153:
41738: 154:另一种设计思路是允许元组的用户给 `a1` 和 `a2` 重新赋值。然而，采用上例中的形式无疑更加安全，如果用户想存储不同的元素，就会强制他们创建新的 `Tuple2` 对象。
41739: 155:
41740: 156:我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了：
41741: 157:
41742: 158:```java
41743: 159:// onjava/Tuple3.java
41744: 160:package onjava;
41745: 161:
41746: 162:public class Tuple3<A, B, C> extends Tuple2<A, B> {
41747: 163:    public final C a3;
41748: 164:    public Tuple3(A a, B b, C c) {
41749: 165:        super(a, b);
41750: 166:        a3 = c;
41751: 167:    }
41752: 168:    
41753: 169:    @Override
41754: 170:    public String rep() {
41755: 171:        return super.rep() + ", " + a3;
41756: 172:    }
41757: 173:}
41758: 174:
41759: 175:// onjava/Tuple4.java
41760: 176:package onjava;
41761: 177:
41762: 178:public class Tuple4<A, B, C, D>
41763: 179:  extends Tuple3<A, B, C> {
41764: 180:    public final D a4;
41765: 181:    public Tuple4(A a, B b, C c, D d) {
41766: 182:        super(a, b, c);
41767: 183:        a4 = d;
41768: 184:    }
41769: 185:    
41770: 186:    @Override
41771: 187:    public String rep() {
41772: 188:        return super.rep() + ", " + a4;
41773: 189:    }
41774: 190:}
41775: 191:
41776: 192:// onjava/Tuple5.java
41777: 193:package onjava;
41778: 194:
41779: 195:public class Tuple5<A, B, C, D, E>
41780: 196:  extends Tuple4<A, B, C, D> {
41781: 197:    public final E a5;
41782: 198:    public Tuple5(A a, B b, C c, D d, E e) {
41783: 199:        super(a, b, c, d);
41784: 200:        a5 = e;
41785: 201:    }
41786: 202:    
41787: 203:    @Override
41788: 204:    public String rep() {
41789: 205:        return super.rep() + ", " + a5;
41790: 206:    }
41791: 207:}
41792: 208:```
41793: 209:
41794: 210:演示需要，再定义两个类：
41795: 211:
41796: 212:```java
41797: 213:// generics/Amphibian.java
41798: 214:public class Amphibian {}
41799: 215:
41800: 216:// generics/Vehicle.java
41801: 217:public class Vehicle {}
41802: 218:```
41803: 219:
41804: 220:使用元组时，你只需要定义一个长度适合的元组，将其作为返回值即可。注意下面例子中方法的返回类型：
41805: 221:
41806: 222:```java
41807: 223:// generics/TupleTest.java
41808: 224:import onjava.*;
41809: 225:
41810: 226:public class TupleTest {
41811: 227:    static Tuple2<String, Integer> f() {
41812: 228:        // 47 自动装箱为 Integer
41813: 229:        return new Tuple2<>("hi", 47);
41814: 230:    }
41815: 231:  
41816: 232:    static Tuple3<Amphibian, String, Integer> g() {
41817: 233:        return new Tuple3<>(new Amphibian(), "hi", 47);
41818: 234:    }
41819: 235:  
41820: 236:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
41821: 237:        return new Tuple4<>(new Vehicle(), new Amphibian(), "hi", 47);
41822: 238:    }
41823: 239:  
41824: 240:    static Tuple5<Vehicle, Amphibian, String, Integer, Double> k() {
41825: 241:        return new Tuple5<>(new Vehicle(), new Amphibian(), "hi", 47, 11.1);
41826: 242:    }
41827: 243:  
41828: 244:    public static void main(String[] args) {
41829: 245:        Tuple2<String, Integer> ttsi = f();
41830: 246:        System.out.println(ttsi);
41831: 247:        // ttsi.a1 = "there"; // 编译错误，因为 final 不能重新赋值
41832: 248:        System.out.println(g());
41833: 249:        System.out.println(h());
41834: 250:        System.out.println(k());
41835: 251:    }
41836: 252:}
41837: 253:
41838: 254:/* 输出：
41839: 255: (hi, 47)
41840: 256: (Amphibian@1540e19d, hi, 47)
41841: 257: (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47)
41842: 258: (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1)
41843: 259: */
41844: 260:```
41845: 261:
41846: 262:有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。
41847: 263:
41848: 264:通过 `ttsi.a1 = "there"` 语句的报错，我们可以看出，**final** 声明确实可以确保 **public** 字段在对象被构造出来之后就不能重新赋值了。
41849: 265:
41850: 266:在上面的程序中，`new` 表达式有些啰嗦。本章稍后会介绍，如何利用 *泛型方法* 简化它们。
41851: 267:
41852: 268:### 一个堆栈类
41853: 269:
41854: 270:接下来我们看一个稍微复杂一点的例子：堆栈。在 [集合](book/12-Collections.md) 一章中，我们用 `LinkedList` 实现了 `onjava.Stack` 类。在那个例子中，`LinkedList` 本身已经具备了创建堆栈所需的方法。`Stack` 是通过两个泛型类 `Stack<T>` 和 `LinkedList<T>` 的组合来创建。我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。
41855: 271:
41856: 272:这次我们不用 `LinkedList` 来实现自己的内部链式存储机制。
41857: 273:
41858: 274:```java
41859: 275:// generics/LinkedStack.java
41860: 276:// 用链式结构实现的堆栈
41861: 277:
41862: 278:public class LinkedStack<T> {
41863: 279:    private static class Node<U> {
41864: 280:        U item;
41865: 281:        Node<U> next;
41866: 282:    
41867: 283:        Node() { item = null; next = null; }
41868: 284:        
41869: 285:        Node(U item, Node<U> next) {
41870: 286:            this.item = item;
41871: 287:            this.next = next;
41872: 288:        }
41873: 289:    
41874: 290:        boolean end() {
41875: 291:            return item == null && next == null;
41876: 292:        }
41877: 293:    }
41878: 294:  
41879: 295:    private Node<T> top = new Node<>();  // 栈顶
41880: 296:  
41881: 297:    public void push(T item) {
41882: 298:        top = new Node<>(item, top);
41883: 299:    }
41884: 300:  
41885: 301:    public T pop() {
41886: 302:        T result = top.item;
41887: 303:        if (!top.end()) {
41888: 304:            top = top.next;
41889: 305:        }
41890: 306:        return result;
41891: 307:    }
41892: 308:  
41893: 309:    public static void main(String[] args) {
41894: 310:        LinkedStack<String> lss = new LinkedStack<>();
41895: 311:        for (String s : "Phasers on stun!".split(" ")) {
41896: 312:            lss.push(s);
41897: 313:        }
41898: 314:        String s;
41899: 315:        while ((s = lss.pop()) != null) {
41900: 316:            System.out.println(s);
41901: 317:        }
41902: 318:    }
41903: 319:}
41904: 320:```
41905: 321:
41906: 322:输出结果：
41907: 323:
41908: 324:```java
41909: 325:stun!
41910: 326:on
41911: 327:Phasers
41912: 328:```
41913: 329:
41914: 330:内部类 `Node` 也是一个泛型，它拥有自己的类型参数。
41915: 331:
41916: 332:这个例子使用了一个 *末端标识* (end sentinel) 来判断栈何时为空。这个末端标识是在构造 `LinkedStack` 时创建的。然后，每次调用 `push()` 就会创建一个 `Node<T>` 对象，并将其链接到前一个 `Node<T>` 对象。当你调用 `pop()` 方法时，总是返回 `top.item`，然后丢弃当前 `top` 所指向的 `Node<T>`，并将 `top` 指向下一个 `Node<T>`，除非到达末端标识，这时就不能再移动 `top` 了。如果已经到达末端，程序还继续调用 `pop()` 方法，它只能得到 `null`，说明栈已经空了。
41917: 333:
41918: 334:### RandomList
41919: 335:
41920: 336:作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 `select()` 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型：
41921: 337:
41922: 338:```java
41923: 339:// generics/RandomList.java
41924: 340:import java.util.*;
41925: 341:import java.util.stream.*;
41926: 342:
41927: 343:public class RandomList<T> extends ArrayList<T> {
41928: 344:    private Random rand = new Random(47);
41929: 345:  
41930: 346:    public T select() {
41931: 347:        return get(rand.nextInt(size()));
41932: 348:    }
41933: 349:  
41934: 350:    public static void main(String[] args) {
41935: 351:        RandomList<String> rs = new RandomList<>();
41936: 352:        Arrays.stream("The quick brown fox jumped over the lazy brown dog".split(" ")).forEach(rs::add);
41937: 353:        IntStream.range(0, 11).forEach(i -> 
41938: 354:            System.out.print(rs.select() + " "));
41939: 355:    }
41940: 356:}
41941: 357:```
41942: 358:
41943: 359:输出结果：
41944: 360:
41945: 361:```java
41946: 362:brown over fox quick quick dog brown The brown lazy brown
41947: 363:```
41948: 364:
41949: 365:`RandomList` 继承了 `ArrayList` 的所有方法。本例中只添加了 `select()` 这个方法。
41950: 366:
41951: 367:<!-- Generic Interfaces -->
41952: 368:
41953: 369:## 泛型接口
41954: 370:
41955: 371:泛型也可以应用于接口。例如 *生成器*，这是一种专门负责创建对象的类。实际上，这是 *工厂方法* 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。
41956: 372:
41957: 373:一般而言，一个生成器只定义一个方法，用于创建对象。例如 `java.util.function` 类库中的 `Supplier` 就是一个生成器，调用其 `get()` 获取对象。`get()` 是泛型方法，返回值为类型参数 `T`。
41958: 374:
41959: 375:为了演示 `Supplier`，我们需要定义几个类。下面是个咖啡相关的继承体系：
41960: 376:
41961: 377:```java
41962: 378:// generics/coffee/Coffee.java
41963: 379:package generics.coffee;
41964: 380:
41965: 381:public class Coffee {
41966: 382:    private static long counter = 0;
41967: 383:    private final long id = counter++;
41968: 384:  
41969: 385:    @Override
41970: 386:    public String toString() {
41971: 387:        return getClass().getSimpleName() + " " + id;
41972: 388:    }
41973: 389:}
41974: 390:
41975: 391:
41976: 392:// generics/coffee/Latte.java
41977: 393:package generics.coffee;
41978: 394:public class Latte extends Coffee {}
41979: 395:
41980: 396:
41981: 397:// generics/coffee/Mocha.java
41982: 398:package generics.coffee;
41983: 399:public class Mocha extends Coffee {}
41984: 400:
41985: 401:
41986: 402:// generics/coffee/Cappuccino.java
41987: 403:package generics.coffee;
41988: 404:public class Cappuccino extends Coffee {}
41989: 405:
41990: 406:
41991: 407:// generics/coffee/Americano.java
41992: 408:package generics.coffee;
41993: 409:public class Americano extends Coffee {}
41994: 410:
41995: 411:
41996: 412:// generics/coffee/Breve.java
41997: 413:package generics.coffee;
41998: 414:public class Breve extends Coffee {}
41999: 415:```
42000: 416:
42001: 417:现在，我们可以编写一个类，实现 `Supplier<Coffee>` 接口，它能够随机生成不同类型的 `Coffee` 对象：
42002: 418:
42003: 419:```java
42004: 420:// generics/coffee/CoffeeSupplier.java
42005: 421:// {java generics.coffee.CoffeeSupplier}
42006: 422:package generics.coffee;
42007: 423:import java.util.*;
42008: 424:import java.util.function.*;
42009: 425:import java.util.stream.*;
42010: 426:
42011: 427:public class CoffeeSupplier
42012: 428:implements Supplier<Coffee>, Iterable<Coffee> {
42013: 429:    private Class<?>[] types = { Latte.class, Mocha.class, 
42014: 430:        Cappuccino.class, Americano.class, Breve.class };
42015: 431:    private static Random rand = new Random(47);
42016: 432:  
42017: 433:    public CoffeeSupplier() {}
42018: 434:    // For iteration:
42019: 435:    private int size = 0;
42020: 436:    public CoffeeSupplier(int sz) { size = sz; }
42021: 437:  
42022: 438:    @Override
42023: 439:    public Coffee get() {
42024: 440:        try {
42025: 441:            return (Coffee) types[rand.nextInt(types.length)].newInstance();
42026: 442:        } catch (InstantiationException | IllegalAccessException e) {
42027: 443:            throw new RuntimeException(e);
42028: 444:        }
42029: 445:    }
42030: 446:  
42031: 447:    class CoffeeIterator implements Iterator<Coffee> {
42032: 448:        int count = size;
42033: 449:        @Override
42034: 450:        public boolean hasNext() { return count > 0; }
42035: 451:        @Override
42036: 452:        public Coffee next() {
42037: 453:            count--;
42038: 454:            return CoffeeSupplier.this.get();
42039: 455:        }
42040: 456:        @Override
42041: 457:        public void remove() {
42042: 458:            throw new UnsupportedOperationException();
42043: 459:        }
42044: 460:    }
42045: 461:  
42046: 462:    @Override
42047: 463:    public Iterator<Coffee> iterator() {
42048: 464:        return new CoffeeIterator();
42049: 465:    }
42050: 466:  
42051: 467:    public static void main(String[] args) {
42052: 468:        Stream.generate(new CoffeeSupplier())
42053: 469:              .limit(5)
42054: 470:              .forEach(System.out::println);
42055: 471:        for (Coffee c : new CoffeeSupplier(5)) {
42056: 472:            System.out.println(c);
42057: 473:        }
42058: 474:    }
42059: 475:}
42060: 476:```
42061: 477:
42062: 478:输出结果：
42063: 479:
42064: 480:```java
42065: 481:Americano 0
42066: 482:Latte 1
42067: 483:Americano 2
42068: 484:Mocha 3
42069: 485:Mocha 4
42070: 486:Breve 5
42071: 487:Americano 6
42072: 488:Latte 7
42073: 489:Cappuccino 8
42074: 490:Cappuccino 9
42075: 491:```
42076: 492:
42077: 493:参数化的 `Supplier` 接口确保 `get()` 返回值是参数的类型。`CoffeeSupplier` 同时还实现了 `Iterable` 接口，所以能用于 *for-in* 语句。不过，它还需要知道何时终止循环，这正是第二个构造函数的作用。
42078: 494:
42079: 495:下面是另一个实现 `Supplier<T>` 接口的例子，它负责生成 Fibonacci 数列：
42080: 496:
42081: 497:```java
42082: 498:// generics/Fibonacci.java
42083: 499:// Generate a Fibonacci sequence
42084: 500:import java.util.function.*;
42085: 501:import java.util.stream.*;
42086: 502:
42087: 503:public class Fibonacci implements Supplier<Integer> {
42088: 504:    private int count = 0;
42089: 505:    @Override
42090: 506:    public Integer get() { return fib(count++); }
42091: 507:  
42092: 508:    private int fib(int n) {
42093: 509:        if(n < 2) return 1;
42094: 510:        return fib(n-2) + fib(n-1);
42095: 511:    }
42096: 512:  
42097: 513:    public static void main(String[] args) {
42098: 514:        Stream.generate(new Fibonacci())
42099: 515:              .limit(18)
42100: 516:              .map(n -> n + " ")
42101: 517:              .forEach(System.out::print);
42102: 518:    }
42103: 519:}
42104: 520:```
42105: 521:
42106: 522:输出结果：
42107: 523:
42108: 524:```java
42109: 525:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
42110: 526:```
42111: 527:
42112: 528:虽然我们在 `Fibonacci` 类的里里外外使用的都是 `int` 类型，但是其参数类型却是 `Integer`。这个例子引出了 Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备自动装箱和拆箱的功能，可以很方便地在基本类型和相应的包装类之间进行转换。通过这个例子中 `Fibonacci` 类对 `int` 的使用，我们已经看到了这种效果。
42113: 529:
42114: 530:如果还想更进一步，编写一个实现了 `Iterable` 的 `Fibnoacci` 生成器。我们的一个选择是重写这个类，令其实现 `Iterable` 接口。不过，你并不是总能拥有源代码的控制权，并且，除非必须这么做，否则，我们也不愿意重写一个类。而且我们还有另一种选择，就是创建一个 *适配器* (Adapter) 来实现所需的接口，我们在前面介绍过这个设计模式。
42115: 531:
42116: 532:有多种方法可以实现适配器。例如，可以通过继承来创建适配器类：
42117: 533:
42118: 534:```java
42119: 535:// generics/IterableFibonacci.java
42120: 536:// Adapt the Fibonacci class to make it Iterable
42121: 537:import java.util.*;
42122: 538:
42123: 539:public class IterableFibonacci
42124: 540:extends Fibonacci implements Iterable<Integer> {
42125: 541:    private int n;
42126: 542:    public IterableFibonacci(int count) { n = count; }
42127: 543:  
42128: 544:    @Override
42129: 545:    public Iterator<Integer> iterator() {
42130: 546:        return new Iterator<Integer>() {
42131: 547:            @Override
42132: 548:            public boolean hasNext() { return n > 0; }
42133: 549:            @Override
42134: 550:            public Integer next() {
42135: 551:                n--;
42136: 552:                return IterableFibonacci.this.get();
42137: 553:            }
42138: 554:            @Override
42139: 555:            public void remove() { // Not implemented
42140: 556:                throw new UnsupportedOperationException();
42141: 557:            }
42142: 558:        };
42143: 559:    }
42144: 560:  
42145: 561:    public static void main(String[] args) {
42146: 562:        for(int i : new IterableFibonacci(18))
42147: 563:            System.out.print(i + " ");
42148: 564:    }
42149: 565:}
42150: 566:```
42151: 567:
42152: 568:输出结果：
42153: 569:
42154: 570:```java
42155: 571:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
42156: 572:```
42157: 573:
42158: 574:在 *for-in* 语句中使用 `IterableFibonacci`，必须在构造函数中提供一个边界值，这样 `hasNext()` 才知道何时返回 **false**，结束循环。
42159: 575:
42160: 576:<!-- Generic Methods -->
42161: 577:
42162: 578:## 泛型方法
42163: 579:
42164: 580:到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。
42165: 581:
42166: 582:泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。
42167: 583:
42168: 584:如果方法是 **static** 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型类型参数，则它必须是泛型方法。
42169: 585:
42170: 586:要定义泛型方法，请将泛型参数列表放置在返回值之前，如下所示：
42171: 587:
42172: 588:```java
42173: 589:// generics/GenericMethods.java
42174: 590:
42175: 591:public class GenericMethods {
42176: 592:    public <T> void f(T x) {
42177: 593:        System.out.println(x.getClass().getName());
42178: 594:    }
42179: 595:
42180: 596:    public static void main(String[] args) {
42181: 597:        GenericMethods gm = new GenericMethods();
42182: 598:        gm.f("");
42183: 599:        gm.f(1);
42184: 600:        gm.f(1.0);
42185: 601:        gm.f(1.0F);
42186: 602:        gm.f('c');
42187: 603:        gm.f(gm);
42188: 604:    }
42189: 605:}
42190: 606:/* Output:
42191: 607:java.lang.String
42192: 608:java.lang.Integer
42193: 609:java.lang.Double
42194: 610:java.lang.Float
42195: 611:java.lang.Character
42196: 612:GenericMethods
42197: 613:*/
42198: 614:```
42199: 615:
42200: 616:尽管可以同时对类及其方法进行参数化，但这里未将 **GenericMethods** 类参数化。只有方法 `f()` 具有类型参数，该参数由方法返回类型之前的参数列表指示。
42201: 617:
42202: 618:对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 *类型参数推断*。因此，对 `f()` 的调用看起来像普通的方法调用，并且 `f()` 看起来像被重载了无数次一样。它甚至会接受 **GenericMethods** 类型的参数。
42203: 619:
42204: 620:如果使用基本类型调用 `f()` ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。
42205: 621:
42206: 622:<!-- Varargs and Generic Methods -->
42207: 623:
42208: 624:### 变长参数和泛型方法
42209: 625:
42210: 626:泛型方法和变长参数列表可以很好地共存：
42211: 627:
42212: 628:```java
42213: 629:// generics/GenericVarargs.java
42214: 630:
42215: 631:import java.util.ArrayList;
42216: 632:import java.util.List;
42217: 633:
42218: 634:public class GenericVarargs {
42219: 635:    @SafeVarargs
42220: 636:    public static <T> List<T> makeList(T... args) {
42221: 637:        List<T> result = new ArrayList<>();
42222: 638:        for (T item : args)
42223: 639:            result.add(item);
42224: 640:        return result;
42225: 641:    }
42226: 642:
42227: 643:    public static void main(String[] args) {
42228: 644:        List<String> ls = makeList("A");
42229: 645:        System.out.println(ls);
42230: 646:        ls = makeList("A", "B", "C");
42231: 647:        System.out.println(ls);
42232: 648:        ls = makeList(
42233: 649:                "ABCDEFFHIJKLMNOPQRSTUVWXYZ".split(""));
42234: 650:        System.out.println(ls);
42235: 651:    }
42236: 652:}
42237: 653:/* Output:
42238: 654:[A]
42239: 655:[A, B, C]
42240: 656:[A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R,
42241: 657:S, T, U, V, W, X, Y, Z]
42242: 658:*/
42243: 659:```
42244: 660:
42245: 661:此处显示的 `makeList()` 方法产生的功能与标准库的 `java.util.Arrays.asList()` 方法相同。
42246: 662:
42247: 663:`@SafeVarargs` 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。
42248: 664:
42249: 665:<!-- A General-Purpose Supplier -->
42250: 666:
42251: 667:### 一个泛型的 Supplier
42252: 668:
42253: 669:这是一个为任意具有无参构造方法的类生成 **Supplier** 的类。为了减少键入，它还包括一个用于生成 **BasicSupplier** 的泛型方法：
42254: 670:
42255: 671:```java
42256: 672:// onjava/BasicSupplier.java
42257: 673:// Supplier from a class with a no-arg constructor
42258: 674:package onjava;
42259: 675:
42260: 676:import java.util.function.Supplier;
42261: 677:
42262: 678:public class BasicSupplier<T> implements Supplier<T> {
42263: 679:    private Class<T> type;
42264: 680:
42265: 681:    public BasicSupplier(Class<T> type) {
42266: 682:        this.type = type;
42267: 683:    }
42268: 684:
42269: 685:    @Override
42270: 686:    public T get() {
42271: 687:        try {
42272: 688:            // Assumes type is a public class:
42273: 689:            return type.newInstance();
42274: 690:        } catch (InstantiationException |
42275: 691:                IllegalAccessException e) {
42276: 692:            throw new RuntimeException(e);
42277: 693:        }
42278: 694:    }
42279: 695:
42280: 696:    // Produce a default Supplier from a type token:
42281: 697:    public static <T> Supplier<T> create(Class<T> type) {
42282: 698:        return new BasicSupplier<>(type);
42283: 699:    }
42284: 700:}
42285: 701:```
42286: 702:
42287: 703:此类提供了产生以下对象的基本实现：
42288: 704:
42289: 705:1. 是 **public** 的。 因为 **BasicSupplier** 在单独的包中，所以相关的类必须具有 **public** 权限，而不仅仅是包级访问权限。
42290: 706:
42291: 707:2. 具有无参构造方法。要创建一个这样的 **BasicSupplier** 对象，请调用 `create()` 方法，并将要生成类型的类型令牌传递给它。通用的 `create()` 方法提供了 `BasicSupplier.create(MyType.class)` 这种较简洁的语法来代替较笨拙的 `new BasicSupplier <MyType>(MyType.class)`。
42292: 708:
42293: 709:例如，这是一个具有无参构造方法的简单类：
42294: 710:
42295: 711:```java
42296: 712:// generics/CountedObject.java
42297: 713:
42298: 714:public class CountedObject {
42299: 715:    private static long counter = 0;
42300: 716:    private final long id = counter++;
42301: 717:
42302: 718:    public long id() {
42303: 719:        return id;
42304: 720:    }
42305: 721:
42306: 722:    @Override
42307: 723:    public String toString() {
42308: 724:        return "CountedObject " + id;
42309: 725:    }
42310: 726:}
42311: 727:```
42312: 728:
42313: 729:**CountedObject** 类可以跟踪自身创建了多少个实例，并通过 `toString()` 报告这些实例的数量。 **BasicSupplier** 可以轻松地为 **CountedObject** 创建 **Supplier**：
42314: 730:
42315: 731:```java
42316: 732:  // generics/BasicSupplierDemo.java
42317: 733:
42318: 734:import onjava.BasicSupplier;
42319: 735:
42320: 736:import java.util.stream.Stream;
42321: 737:
42322: 738:public class BasicSupplierDemo {
42323: 739:    public static void main(String[] args) {
42324: 740:        Stream.generate(
42325: 741:                BasicSupplier.create(CountedObject.class))
42326: 742:                .limit(5)
42327: 743:                .forEach(System.out::println);
42328: 744:    }
42329: 745:}
42330: 746:/* Output:
42331: 747:CountedObject 0
42332: 748:CountedObject 1
42333: 749:CountedObject 2
42334: 750:CountedObject 3
42335: 751:CountedObject 4
42336: 752:*/
42337: 753:```
42338: 754:
42339: 755:泛型方法减少了产生 **Supplier** 对象所需的代码量。 Java 泛型强制传递 **Class** 对象，以便在 `create()` 方法中将其用于类型推断。
42340: 756:
42341: 757:<!-- Simplifying Tuple Use -->
42342: 758:
42343: 759:### 简化元组的使用
42344: 760:
42345: 761:使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库。在这里，我们使用重载的静态方法创建元组：
42346: 762:
42347: 763:```java
42348: 764:// onjava/Tuple.java
42349: 765:// Tuple library using type argument inference
42350: 766:package onjava;
42351: 767:
42352: 768:public class Tuple {
42353: 769:    public static <A, B> Tuple2<A, B> tuple(A a, B b) {
42354: 770:        return new Tuple2<>(a, b);
42355: 771:    }
42356: 772:
42357: 773:    public static <A, B, C> Tuple3<A, B, C>
42358: 774:    tuple(A a, B b, C c) {
42359: 775:        return new Tuple3<>(a, b, c);
42360: 776:    }
42361: 777:
42362: 778:    public static <A, B, C, D> Tuple4<A, B, C, D>
42363: 779:    tuple(A a, B b, C c, D d) {
42364: 780:        return new Tuple4<>(a, b, c, d);
42365: 781:    }
42366: 782:
42367: 783:    public static <A, B, C, D, E>
42368: 784:    Tuple5<A, B, C, D, E> tuple(A a, B b, C c, D d, E e) {
42369: 785:        return new Tuple5<>(a, b, c, d, e);
42370: 786:    }
42371: 787:}
42372: 788:```
42373: 789:
42374: 790:我们修改 **TupleTest.java** 来测试 **Tuple.java** :
42375: 791:
42376: 792:```java
42377: 793:// generics/TupleTest2.java
42378: 794:
42379: 795:import onjava.Tuple2;
42380: 796:import onjava.Tuple3;
42381: 797:import onjava.Tuple4;
42382: 798:import onjava.Tuple5;
42383: 799:
42384: 800:import static onjava.Tuple.tuple;
42385: 801:
42386: 802:public class TupleTest2 {
42387: 803:    static Tuple2<String, Integer> f() {
42388: 804:        return tuple("hi", 47);
42389: 805:    }
42390: 806:
42391: 807:    static Tuple2 f2() {
42392: 808:        return tuple("hi", 47);
42393: 809:    }
42394: 810:
42395: 811:    static Tuple3<Amphibian, String, Integer> g() {
42396: 812:        return tuple(new Amphibian(), "hi", 47);
42397: 813:    }
42398: 814:
42399: 815:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
42400: 816:        return tuple(
42401: 817:                new Vehicle(), new Amphibian(), "hi", 47);
42402: 818:    }
42403: 819:
42404: 820:    static Tuple5<Vehicle, Amphibian,
42405: 821:            String, Integer, Double> k() {
42406: 822:        return tuple(new Vehicle(), new Amphibian(),
42407: 823:                "hi", 47, 11.1);
42408: 824:    }
42409: 825:
42410: 826:    public static void main(String[] args) {
42411: 827:        Tuple2<String, Integer> ttsi = f();
42412: 828:        System.out.println(ttsi);
42413: 829:        System.out.println(f2());
42414: 830:        System.out.println(g());
42415: 831:        System.out.println(h());
42416: 832:        System.out.println(k());
42417: 833:    }
42418: 834:}
42419: 835:/* Output:
42420: 836:(hi, 47)
42421: 837:(hi, 47)
42422: 838:(Amphibian@14ae5a5, hi, 47)
42423: 839:(Vehicle@135fbaa4, Amphibian@45ee12a7, hi, 47)
42424: 840:(Vehicle@4b67cf4d, Amphibian@7ea987ac, hi, 47, 11.1)
42425: 841:*/
42426: 842:```
42427: 843:
42428: 844:请注意，`f()` 返回一个参数化的 **Tuple2** 对象，而 `f2()` 返回一个未参数化的 **Tuple2** 对象。编译器不会在这里警告 `f2()` ，因为返回值未以参数化方式使用。从某种意义上说，它被“向上转型”为一个未参数化的 **Tuple2** 。 但是，如果尝试将 `f2()` 的结果放入到参数化的 **Tuple2** 中，则编译器将发出警告。
42429: 845:
42430: 846:<!-- A Set Utility -->
42431: 847:
42432: 848:### 一个 Set 工具
42433: 849:
42434: 850:对于泛型方法的另一个示例，请考虑由 **Set** 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法：
42435: 851:
42436: 852:```java
42437: 853:// onjava/Sets.java
42438: 854:
42439: 855:package onjava;
42440: 856:
42441: 857:import java.util.HashSet;
42442: 858:import java.util.Set;
42443: 859:
42444: 860:public class Sets {
42445: 861:    public static <T> Set<T> union(Set<T> a, Set<T> b) {
42446: 862:        Set<T> result = new HashSet<>(a);
42447: 863:        result.addAll(b);
42448: 864:        return result;
42449: 865:    }
42450: 866:
42451: 867:    public static <T>
42452: 868:    Set<T> intersection(Set<T> a, Set<T> b) {
42453: 869:        Set<T> result = new HashSet<>(a);
42454: 870:        result.retainAll(b);
42455: 871:        return result;
42456: 872:    }
42457: 873:
42458: 874:    // Subtract subset from superset:
42459: 875:    public static <T> Set<T>
42460: 876:    difference(Set<T> superset, Set<T> subset) {
42461: 877:        Set<T> result = new HashSet<>(superset);
42462: 878:        result.removeAll(subset);
42463: 879:        return result;
42464: 880:    }
42465: 881:
42466: 882:    // Reflexive--everything not in the intersection:
42467: 883:    public static <T> Set<T> complement(Set<T> a, Set<T> b) {
42468: 884:        return difference(union(a, b), intersection(a, b));
42469: 885:    }
42470: 886:}
42471: 887:```
42472: 888:
42473: 889:前三个方法通过将第一个参数的引用复制到新的 **HashSet** 对象中来复制第一个参数，因此不会直接修改参数集合。因此，返回值是一个新的 **Set** 对象。
42474: 890:
42475: 891:这四种方法代表数学集合操作： `union()` 返回一个包含两个参数并集的 **Set** ， `intersection()` 返回一个包含两个参数集合交集的 **Set** ， `difference()` 从 **superset** 中减去 **subset** 的元素 ，而 `complement()` 返回所有不在交集中的元素的 **Set**。作为显示这些方法效果的简单示例的一部分，下面是一个包含不同水彩名称的 **enum** ：
42476: 892:
42477: 893:```java
42478: 894:// generics/watercolors/Watercolors.java
42479: 895:
42480: 896:package watercolors;
42481: 897:
42482: 898:public enum Watercolors {
42483: 899:    ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW,
42484: 900:    ORANGE, BRILLIANT_RED, CRIMSON, MAGENTA,
42485: 901:    ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE,
42486: 902:    PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE,
42487: 903:    PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN,
42488: 904:    YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
42489: 905:    BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK
42490: 906:}
42491: 907:```
42492: 908:
42493: 909:为了方便起见（不必全限定所有名称），将其静态导入到以下示例中。本示例使用 **EnumSet** 轻松从 **enum** 中创建 **Set** 。（可以在[第二十二章 枚举](book/22-Enumerations.md)一章中了解有关 **EnumSet** 的更多信息。）在这里，静态方法 `EnumSet.range()` 要求提供所要在结果 **Set** 中创建的元素范围的第一个和最后一个元素：
42494: 910:
42495: 911:```java
42496: 912:// generics/WatercolorSets.java
42497: 913:
42498: 914:import watercolors.*;
42499: 915:
42500: 916:import java.util.EnumSet;
42501: 917:import java.util.Set;
42502: 918:
42503: 919:import static watercolors.Watercolors.*;
42504: 920:import static onjava.Sets.*;
42505: 921:
42506: 922:public class WatercolorSets {
42507: 923:    public static void main(String[] args) {
42508: 924:        Set<Watercolors> set1 =
42509: 925:                EnumSet.range(BRILLIANT_RED, VIRIDIAN_HUE);
42510: 926:        Set<Watercolors> set2 =
42511: 927:                EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER);
42512: 928:        System.out.println("set1: " + set1);
42513: 929:        System.out.println("set2: " + set2);
42514: 930:        System.out.println(
42515: 931:                "union(set1, set2): " + union(set1, set2));
42516: 932:        Set<Watercolors> subset = intersection(set1, set2);
42517: 933:        System.out.println(
42518: 934:                "intersection(set1, set2): " + subset);
42519: 935:        System.out.println("difference(set1, subset): " +
42520: 936:                difference(set1, subset));
42521: 937:        System.out.println("difference(set2, subset): " +
42522: 938:                difference(set2, subset));
42523: 939:        System.out.println("complement(set1, set2): " +
42524: 940:                complement(set1, set2));
42525: 941:    }
42526: 942:}
42527: 943:/* Output:
42528: 944:set1: [BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER,
42529: 945:VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
42530: 946:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE]
42531: 947:set2: [CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
42532: 948:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE,
42533: 949:SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
42534: 950:BURNT_UMBER]
42535: 951:union(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
42536: 952:YELLOW_OCHRE, MAGENTA, SAP_GREEN, CERULEAN_BLUE_HUE,
42537: 953:ULTRAMARINE, VIRIDIAN_HUE, VIOLET, RAW_UMBER,
42538: 954:ROSE_MADDER, PERMANENT_GREEN, BURNT_UMBER,
42539: 955:PHTHALO_BLUE, CRIMSON, COBALT_BLUE_HUE]
42540: 956:intersection(set1, set2): [PERMANENT_GREEN,
42541: 957:CERULEAN_BLUE_HUE, ULTRAMARINE, VIRIDIAN_HUE,
42542: 958:PHTHALO_BLUE, COBALT_BLUE_HUE]
42543: 959:difference(set1, subset): [BRILLIANT_RED, MAGENTA,
42544: 960:VIOLET, CRIMSON, ROSE_MADDER]
42545: 961:difference(set2, subset): [BURNT_SIENNA, YELLOW_OCHRE,
42546: 962:BURNT_UMBER, SAP_GREEN, RAW_UMBER]
42547: 963:complement(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
42548: 964:YELLOW_OCHRE, MAGENTA, SAP_GREEN, VIOLET, RAW_UMBER,
42549: 965:ROSE_MADDER, BURNT_UMBER, CRIMSON]
42550: 966:*/
42551: 967:```
42552: 968:
42553: 969:接下来的例子使用 `Sets.difference()` 方法来展示 **java.util** 包中各种 **Collection** 和 **Map** 类之间的方法差异：
42554: 970:
42555: 971:```java
42556: 972:// onjava/CollectionMethodDifferences.java
42557: 973:// {java onjava.CollectionMethodDifferences}
42558: 974:
42559: 975:package onjava;
42560: 976:
42561: 977:import java.lang.reflect.Method;
42562: 978:import java.util.*;
42563: 979:import java.util.stream.Collectors;
42564: 980:
42565: 981:public class CollectionMethodDifferences {
42566: 982:    static Set<String> methodSet(Class<?> type) {
42567: 983:        return Arrays.stream(type.getMethods())
42568: 984:                .map(Method::getName)
42569: 985:                .collect(Collectors.toCollection(TreeSet::new));
42570: 986:    }
42571: 987:
42572: 988:    static void interfaces(Class<?> type) {
42573: 989:        System.out.print("Interfaces in " +
42574: 990:                type.getSimpleName() + ": ");
42575: 991:        System.out.println(
42576: 992:                Arrays.stream(type.getInterfaces())
42577: 993:                        .map(Class::getSimpleName)
42578: 994:                        .collect(Collectors.toList()));
42579: 995:    }
42580: 996:
42581: 997:    static Set<String> object = methodSet(Object.class);
42582: 998:
42583: 999:    static {
42584: 1000:        object.add("clone");
42585: 1001:    }
42586: 1002:
42587: 1003:    static void
42588: 1004:    difference(Class<?> superset, Class<?> subset) {
42589: 1005:        System.out.print(superset.getSimpleName() +
42590: 1006:                " extends " + subset.getSimpleName() +
42591: 1007:                ", adds: ");
42592: 1008:        Set<String> comp = Sets.difference(
42593: 1009:                methodSet(superset), methodSet(subset));
42594: 1010:        comp.removeAll(object); // Ignore 'Object' methods
42595: 1011:        System.out.println(comp);
42596: 1012:        interfaces(superset);
42597: 1013:    }
42598: 1014:
42599: 1015:    public static void main(String[] args) {
42600: 1016:        System.out.println("Collection: " +
42601: 1017:                methodSet(Collection.class));
42602: 1018:        interfaces(Collection.class);
42603: 1019:        difference(Set.class, Collection.class);
42604: 1020:        difference(HashSet.class, Set.class);
42605: 1021:        difference(LinkedHashSet.class, HashSet.class);
42606: 1022:        difference(TreeSet.class, Set.class);
42607: 1023:        difference(List.class, Collection.class);
42608: 1024:        difference(ArrayList.class, List.class);
42609: 1025:        difference(LinkedList.class, List.class);
42610: 1026:        difference(Queue.class, Collection.class);
42611: 1027:        difference(PriorityQueue.class, Queue.class);
42612: 1028:        System.out.println("Map: " + methodSet(Map.class));
42613: 1029:        difference(HashMap.class, Map.class);
42614: 1030:        difference(LinkedHashMap.class, HashMap.class);
42615: 1031:        difference(SortedMap.class, Map.class);
42616: 1032:        difference(TreeMap.class, Map.class);
42617: 1033:    }
42618: 1034:}
42619: 1035:/* Output:
42620: 1036:Collection: [add, addAll, clear, contains, containsAll,
42621: 1037:equals, forEach, hashCode, isEmpty, iterator,
42622: 1038:parallelStream, remove, removeAll, removeIf, retainAll,
42623: 1039:size, spliterator, stream, toArray]
42624: 1040:Interfaces in Collection: [Iterable]
42625: 1041:Set extends Collection, adds: []
42626: 1042:Interfaces in Set: [Collection]
42627: 1043:HashSet extends Set, adds: []
42628: 1044:Interfaces in HashSet: [Set, Cloneable, Serializable]
42629: 1045:LinkedHashSet extends HashSet, adds: []
42630: 1046:Interfaces in LinkedHashSet: [Set, Cloneable,
42631: 1047:Serializable]
42632: 1048:TreeSet extends Set, adds: [headSet,
42633: 1049:descendingIterator, descendingSet, pollLast, subSet,
42634: 1050:floor, tailSet, ceiling, last, lower, comparator,
42635: 1051:pollFirst, first, higher]
42636: 1052:Interfaces in TreeSet: [NavigableSet, Cloneable,
42637: 1053:Serializable]
42638: 1054:List extends Collection, adds: [replaceAll, get,
42639: 1055:indexOf, subList, set, sort, lastIndexOf, listIterator]
42640: 1056:Interfaces in List: [Collection]
42641: 1057:ArrayList extends List, adds: [trimToSize,
42642: 1058:ensureCapacity]
42643: 1059:Interfaces in ArrayList: [List, RandomAccess,
42644: 1060:Cloneable, Serializable]
42645: 1061:LinkedList extends List, adds: [offerFirst, poll,
42646: 1062:getLast, offer, getFirst, removeFirst, element,
42647: 1063:removeLastOccurrence, peekFirst, peekLast, push,
42648: 1064:pollFirst, removeFirstOccurrence, descendingIterator,
42649: 1065:pollLast, removeLast, pop, addLast, peek, offerLast,
42650: 1066:addFirst]
42651: 1067:Interfaces in LinkedList: [List, Deque, Cloneable,
42652: 1068:Serializable]
42653: 1069:Queue extends Collection, adds: [poll, peek, offer,
42654: 1070:element]
42655: 1071:Interfaces in Queue: [Collection]
42656: 1072:PriorityQueue extends Queue, adds: [comparator]
42657: 1073:Interfaces in PriorityQueue: [Serializable]
42658: 1074:Map: [clear, compute, computeIfAbsent,
42659: 1075:computeIfPresent, containsKey, containsValue, entrySet,
42660: 1076:equals, forEach, get, getOrDefault, hashCode, isEmpty,
42661: 1077:keySet, merge, put, putAll, putIfAbsent, remove,
42662: 1078:replace, replaceAll, size, values]
42663: 1079:HashMap extends Map, adds: []
42664: 1080:Interfaces in HashMap: [Map, Cloneable, Serializable]
42665: 1081:LinkedHashMap extends HashMap, adds: []
42666: 1082:Interfaces in LinkedHashMap: [Map]
42667: 1083:SortedMap extends Map, adds: [lastKey, subMap,
42668: 1084:comparator, firstKey, headMap, tailMap]
42669: 1085:Interfaces in SortedMap: [Map]
42670: 1086:TreeMap extends Map, adds: [descendingKeySet,
42671: 1087:navigableKeySet, higherEntry, higherKey, floorKey,
42672: 1088:subMap, ceilingKey, pollLastEntry, firstKey, lowerKey,
42673: 1089:headMap, tailMap, lowerEntry, ceilingEntry,
42674: 1090:descendingMap, pollFirstEntry, lastKey, firstEntry,
42675: 1091:floorEntry, comparator, lastEntry]
42676: 1092:Interfaces in TreeMap: [NavigableMap, Cloneable,
42677: 1093:Serializable]
42678: 1094:*/
42679: 1095:```
42680: 1096:
42681: 1097:在第十二章 [集合的本章小结](book/12-Collections.md#本章小结) 部分将会用到这里的输出结果。
42682: 1098:
42683: 1099:<!-- Building Complex Models -->
42684: 1100:
42685: 1101:## 构建复杂模型
42686: 1102:
42687: 1103:泛型的一个重要好处是能够简单安全地创建复杂模型。例如，我们可以轻松地创建一个元组列表：
42688: 1104:
42689: 1105:```java
42690: 1106:// generics/TupleList.java
42691: 1107:// Combining generic types to make complex generic types
42692: 1108:
42693: 1109:import onjava.Tuple4;
42694: 1110:
42695: 1111:import java.util.ArrayList;
42696: 1112:
42697: 1113:public class TupleList<A, B, C, D>
42698: 1114:        extends ArrayList<Tuple4<A, B, C, D>> {
42699: 1115:    public static void main(String[] args) {
42700: 1116:        TupleList<Vehicle, Amphibian, String, Integer> tl =
42701: 1117:                new TupleList<>();
42702: 1118:        tl.add(TupleTest2.h());
42703: 1119:        tl.add(TupleTest2.h());
42704: 1120:        tl.forEach(System.out::println);
42705: 1121:    }
42706: 1122:}
42707: 1123:/* Output:
42708: 1124:(Vehicle@7cca494b, Amphibian@7ba4f24f, hi, 47)
42709: 1125:(Vehicle@3b9a45b3, Amphibian@7699a589, hi, 47)
42710: 1126:*/
42711: 1127:```
42712: 1128:
42713: 1129:这将产生一个功能强大的数据结构，而无需太多代码。
42714: 1130:
42715: 1131:下面是第二个例子。每个类都是组成块，总体包含很多个块。在这里，该模型是一个具有过道，货架和产品的零售商店：
42716: 1132:
42717: 1133:```java
42718: 1134:// generics/Store.java
42719: 1135:// Building a complex model using generic collections
42720: 1136:
42721: 1137:import onjava.Suppliers;
42722: 1138:
42723: 1139:import java.util.ArrayList;
42724: 1140:import java.util.Random;
42725: 1141:import java.util.function.Supplier;
42726: 1142:
42727: 1143:class Product {
42728: 1144:    private final int id;
42729: 1145:    private String description;
42730: 1146:    private double price;
42731: 1147:
42732: 1148:    Product(int idNumber, String descr, double price) {
42733: 1149:        id = idNumber;
42734: 1150:        description = descr;
42735: 1151:        this.price = price;
42736: 1152:        System.out.println(toString());
42737: 1153:    }
42738: 1154:
42739: 1155:    @Override
42740: 1156:    public String toString() {
42741: 1157:        return id + ": " + description +
42742: 1158:                ", price: $" + price;
42743: 1159:    }
42744: 1160:
42745: 1161:    public void priceChange(double change) {
42746: 1162:        price += change;
42747: 1163:    }
42748: 1164:
42749: 1165:    public static Supplier<Product> generator =
42750: 1166:            new Supplier<Product>() {
42751: 1167:                private Random rand = new Random(47);
42752: 1168:
42753: 1169:                @Override
42754: 1170:                public Product get() {
42755: 1171:                    return new Product(rand.nextInt(1000), "Test",
42756: 1172:                            Math.round(
42757: 1173:                                    rand.nextDouble() * 1000.0) + 0.99);
42758: 1174:                }
42759: 1175:            };
42760: 1176:}
42761: 1177:
42762: 1178:class Shelf extends ArrayList<Product> {
42763: 1179:    Shelf(int nProducts) {
42764: 1180:        Suppliers.fill(this, Product.generator, nProducts);
42765: 1181:    }
42766: 1182:}
42767: 1183:
42768: 1184:class Aisle extends ArrayList<Shelf> {
42769: 1185:    Aisle(int nShelves, int nProducts) {
42770: 1186:        for (int i = 0; i < nShelves; i++)
42771: 1187:            add(new Shelf(nProducts));
42772: 1188:    }
42773: 1189:}
42774: 1190:
42775: 1191:class CheckoutStand {
42776: 1192:}
42777: 1193:
42778: 1194:class Office {
42779: 1195:}
42780: 1196:
42781: 1197:public class Store extends ArrayList<Aisle> {
42782: 1198:    private ArrayList<CheckoutStand> checkouts =
42783: 1199:            new ArrayList<>();
42784: 1200:    private Office office = new Office();
42785: 1201:
42786: 1202:    public Store(
42787: 1203:            int nAisles, int nShelves, int nProducts) {
42788: 1204:        for (int i = 0; i < nAisles; i++)
42789: 1205:            add(new Aisle(nShelves, nProducts));
42790: 1206:    }
42791: 1207:
42792: 1208:    @Override
42793: 1209:    public String toString() {
42794: 1210:        StringBuilder result = new StringBuilder();
42795: 1211:        for (Aisle a : this)
42796: 1212:            for (Shelf s : a)
42797: 1213:                for (Product p : s) {
42798: 1214:                    result.append(p);
42799: 1215:                    result.append("\n");
42800: 1216:                }
42801: 1217:        return result.toString();
42802: 1218:    }
42803: 1219:
42804: 1220:    public static void main(String[] args) {
42805: 1221:        System.out.println(new Store(5, 4, 3));
42806: 1222:    }
42807: 1223:}
42808: 1224:/* Output: (First 8 Lines)
42809: 1225:258: Test, price: $400.99
42810: 1226:861: Test, price: $160.99
42811: 1227:868: Test, price: $417.99
42812: 1228:207: Test, price: $268.99
42813: 1229:551: Test, price: $114.99
42814: 1230:278: Test, price: $804.99
42815: 1231:520: Test, price: $554.99
42816: 1232:140: Test, price: $530.99
42817: 1233:                  ...
42818: 1234:*/
42819: 1235:```
42820: 1236:
42821: 1237:`Store.toString()` 显示了结果：尽管有复杂的层次结构，但多层的集合仍然是类型安全的和可管理的。令人印象深刻的是，组装这样的模型并不需要耗费过多精力。
42822: 1238:
42823: 1239:**Shelf** 使用 `Suppliers.fill()` 这个实用程序，该实用程序接受 **Collection** （第一个参数），并使用 **Supplier** （第二个参数），以元素的数量为 **n** （第三个参数）来填充它。 **Suppliers** 类将会在本章末尾定义，其中的方法都是在执行某种填充操作，并在本章的其他示例中使用。
42824: 1240:
42825: 1241:<!-- The Mystery of Erasure -->
42826: 1242:
42827: 1243:## 泛型擦除
42828: 1244:
42829: 1245:当你开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的。例如，尽管可以说  `ArrayList.class`，但不能说成 `ArrayList<Integer>.class`。考虑下面的情况：
42830: 1246:
42831: 1247:```java
42832: 1248:// generics/ErasedTypeEquivalence.java
42833: 1249:
42834: 1250:import java.util.*;
42835: 1251:
42836: 1252:public class ErasedTypeEquivalence {
42837: 1253:    
42838: 1254:    public static void main(String[] args) {
42839: 1255:        Class c1 = new ArrayList<String>().getClass();
42840: 1256:        Class c2 = new ArrayList<Integer>().getClass();
42841: 1257:        System.out.println(c1 == c2);
42842: 1258:    }
42843: 1259:    
42844: 1260:}
42845: 1261:/* Output:
42846: 1262:true
42847: 1263:*/
42848: 1264:```
42849: 1265:
42850: 1266:`ArrayList<String>` 和 `ArrayList<Integer>` 应该是不同的类型。不同的类型会有不同的行为。例如，如果尝试向 `ArrayList<String>` 中放入一个 `Integer`，所得到的行为（失败）和向 `ArrayList<Integer>` 中放入一个 `Integer` 所得到的行为（成功）完全不同。然而上面的程序认为它们是相同的类型。
42851: 1267:
42852: 1268:下面的例子是对该谜题的补充：
42853: 1269:
42854: 1270:```java
42855: 1271:// generics/LostInformation.java
42856: 1272:
42857: 1273:import java.util.*;
42858: 1274:
42859: 1275:class Frob {}
42860: 1276:class Fnorkle {}
42861: 1277:class Quark<Q> {}
42862: 1278:
42863: 1279:class Particle<POSITION, MOMENTUM> {}
42864: 1280:
42865: 1281:public class LostInformation {
42866: 1282:
42867: 1283:    public static void main(String[] args) {
42868: 1284:        List<Frob> list = new ArrayList<>();
42869: 1285:        Map<Frob, Fnorkle> map = new HashMap<>();
42870: 1286:        Quark<Fnorkle> quark = new Quark<>();
42871: 1287:        Particle<Long, Double> p = new Particle<>();
42872: 1288:        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));
42873: 1289:        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));
42874: 1290:        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));
42875: 1291:        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));
42876: 1292:    }
42877: 1293:
42878: 1294:}
42879: 1295:/* Output:
42880: 1296:[E]
42881: 1297:[K,V]
42882: 1298:[Q]
42883: 1299:[POSITION,MOMENTUM]
42884: 1300:*/
42885: 1301:```
42886: 1302:
42887: 1303:根据 JDK 文档，**Class.getTypeParameters()** “返回一个 **TypeVariable** 对象数组，表示泛型声明中声明的类型参数...” 这暗示你可以发现这些参数类型。但是正如上例中输出所示，你只能看到用作参数占位符的标识符，这并非有用的信息。
42888: 1304:
42889: 1305:残酷的现实是：
42890: 1306:
42891: 1307:在泛型代码内部，无法获取任何有关泛型参数类型的信息。
42892: 1308:
42893: 1309:因此，你可以知道如类型参数标识符和泛型边界这些信息，但无法得知实际的类型参数从而用来创建特定的实例。如果你曾是 C++ 程序员，那么这个事实会让你很沮丧，在使用 Java 泛型工作时，它是必须处理的最基本的问题。
42894: 1310:
42895: 1311:Java 泛型是使用擦除实现的。这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此，`List<String>` 和 `List<Integer>` 在运行时实际上是相同的类型。它们都被擦除成原生类型 `List`。
42896: 1312:
42897: 1313:理解擦除并知道如何处理它，是你在学习 Java 泛型时面临的最大障碍之一。这也是本节将要探讨的内容。
42898: 1314:
42899: 1315:### C++ 的方式
42900: 1316:
42901: 1317:下面是使用模版的 C++ 示例。你会看到类型参数的语法十分相似，因为 Java 是受 C++ 启发的：
42902: 1318:
42903: 1319:```c++
42904: 1320:// generics/Templates.cpp
42905: 1321:
42906: 1322:#include <iostream>
42907: 1323:using namespace std;
42908: 1324:
42909: 1325:template<class T> class Manipulator {
42910: 1326:    T obj;
42911: 1327:public:
42912: 1328:    Manipulator(T x) { obj = x; }
42913: 1329:    void manipulate() { obj.f(); }
42914: 1330:};
42915: 1331:
42916: 1332:class HasF {
42917: 1333:public:
42918: 1334:    void f() { cout << "HasF::f()" << endl; }
42919: 1335:};
42920: 1336:
42921: 1337:int main() {
42922: 1338:    HasF hf;
42923: 1339:    Manipulator<HasF> manipulator(hf);
42924: 1340:    manipulator.manipulate();
42925: 1341:}
42926: 1342:/* Output:
42927: 1343:HasF::f()
42928: 1344:*/
42929: 1345:```
42930: 1346:
42931: 1347:**Manipulator** 类存储了一个 **T** 类型的对象。`manipulate()` 方法会调用 **obj** 上的 `f()` 方法。它是如何知道类型参数 **T** 中存在 `f()` 方法的呢？C++ 编译器会在你实例化模版时进行检查，所以在 `Manipulator<HasF>` 实例化的那一刻，它看到 **HasF** 中含有一个方法 `f()`。如果情况并非如此，你就会得到一个编译期错误，保持类型安全。
42932: 1348:
42933: 1349:用 C++ 编写这种代码很简单，因为当模版被实例化时，模版代码就知道模版参数的类型。Java 泛型就不同了。下面是 **HasF** 的 Java 版本：
42934: 1350:
42935: 1351:```java
42936: 1352:// generics/HasF.java
42937: 1353:
42938: 1354:public class HasF {
42939: 1355:    public void f() {
42940: 1356:        System.out.println("HasF.f()");
42941: 1357:    }
42942: 1358:}
42943: 1359:```
42944: 1360:
42945: 1361:如果我们将示例的其余代码用 Java 实现，就不会通过编译：
42946: 1362:
42947: 1363:```java
42948: 1364:// generics/Manipulation.java
42949: 1365:// {WillNotCompile}
42950: 1366:
42951: 1367:class Manipulator<T> {
42952: 1368:    private T obj;
42953: 1369:    
42954: 1370:    Manipulator(T x) {
42955: 1371:        obj = x;
42956: 1372:    }
42957: 1373:    
42958: 1374:    // Error: cannot find symbol: method f():
42959: 1375:    public void manipulate() {
42960: 1376:        obj.f();
42961: 1377:    }
42962: 1378:}
42963: 1379:
42964: 1380:public class Manipulation {
42965: 1381:	public static void main(String[] args) {
42966: 1382:        HasF hf = new HasF();
42967: 1383:        Manipulator<HasF> manipulator = new Manipulator<>(hf);
42968: 1384:        manipulator.manipulate();
42969: 1385:    }
42970: 1386:}
42971: 1387:```
42972: 1388:
42973: 1389:因为擦除，Java 编译器无法将 `manipulate()` 方法必须能调用 **obj** 的 `f()` 方法这一需求映射到 HasF 具有 `f()` 方法这个事实上。为了调用 `f()`，我们必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。这里重用了 **extends** 关键字。由于有了边界，下面的代码就能通过编译：
42974: 1390:
42975: 1391:```java
42976: 1392:public class Manipulator2<T extends HasF> {
42977: 1393:    private T obj;
42978: 1394:
42979: 1395:    Manipulator2(T x) {
42980: 1396:        obj = x;
42981: 1397:    }
42982: 1398:
42983: 1399:    public void manipulate() {
42984: 1400:        obj.f();
42985: 1401:    }
42986: 1402:}
42987: 1403:```
42988: 1404:
42989: 1405:边界 `<T extends HasF>` 声明 T 必须是 HasF 类型或其子类。如果情况确实如此，就可以安全地在 **obj** 上调用 `f()` 方法。
42990: 1406:
42991: 1407:我们说泛型类型参数会擦除到它的第一个边界（可能有多个边界，稍后你将看到）。我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的示例，**T** 擦除到了 **HasF**，就像在类的声明中用 **HasF** 替换了 **T** 一样。
42992: 1408:
42993: 1409:你可能正确地观察到了泛型在 **Manipulator2.java** 中没有贡献任何事。你可以很轻松地自己去执行擦除，生成没有泛型的类：
42994: 1410:
42995: 1411:```java
42996: 1412:// generics/Manipulator3.java
42997: 1413:
42998: 1414:class Manipulator3 {
42999: 1415:    private HasF obj;
43000: 1416:    
43001: 1417:    Manipulator3(HasF x) {
43002: 1418:        obj = x;
43003: 1419:    }
43004: 1420:    
43005: 1421:    public void manipulate() {
43006: 1422:        obj.f();
43007: 1423:    }
43008: 1424:}
43009: 1425:```
43010: 1426:
43011: 1427:这提出了很重要的一点：泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用。因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换更加复杂。但是，不能因此认为使用 `<T extends HasF>` 形式就是有缺陷的。例如，如果某个类有一个返回 **T** 的方法，那么泛型就有所帮助，因为它们之后将返回确切的类型：
43012: 1428:
43013: 1429:```java
43014: 1430:// generics/ReturnGenericType.java
43015: 1431:
43016: 1432:public class ReturnGenericType<T extends HasF> {
43017: 1433:    private T obj;
43018: 1434:    
43019: 1435:    ReturnGenericType(T x) {
43020: 1436:        obj = x;
43021: 1437:    }
43022: 1438:    
43023: 1439:    public T get() {
43024: 1440:        return obj;
43025: 1441:    }
43026: 1442:}
43027: 1443:```
43028: 1444:
43029: 1445:你必须查看所有的代码，从而确定代码是否复杂到必须使用泛型的程度。
43030: 1446:
43031: 1447:我们将在本章稍后看到有关边界的更多细节。
43032: 1448:
43033: 1449:### 迁移兼容性
43034: 1450:
43035: 1451:为了减少潜在的关于擦除的困惑，你必须清楚地认识到这不是一个语言特性。它是 Java 实现泛型的一种妥协，因为泛型不是 Java 语言出现时就有的，所以就有了这种妥协。它会使你痛苦，因此你需要尽早习惯它并了解为什么它会这样。
43036: 1452:
43037: 1453:如果 Java 1.0 就含有泛型的话，那么这个特性就不会使用擦除来实现——它会使用具体化，保持参数类型为第一类实体，因此你就能在类型参数上执行基于类型的语言操作和反射操作。本章稍后你会看到，擦除减少了泛型的泛化性。泛型在 Java 中仍然是有用的，只是不如它们本来设想的那么有用，而原因就是擦除。
43038: 1454:
43039: 1455:在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文使用泛型类型。泛型类型只有在静态类型检测期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如， `List<T>` 这样的类型注解会被擦除为 **List**，普通的类型变量在未指定边界的情况下会被擦除为 **Object**。
43040: 1456:
43041: 1457:擦除的核心动机是你可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称为“迁移兼容性”。在理想情况下，所有事物将在指定的某天被泛化。在现实中，即使程序员只编写泛型代码，他们也必须处理 Java 5 之前编写的非泛型类库。这些类库的作者可能从没想过要泛化他们的代码，或许他们可能刚刚开始接触泛型。
43042: 1458:
43043: 1459:因此 Java 泛型不仅必须支持向后兼容性——现有的代码和类文件仍然合法，继续保持之前的含义——而且还必须支持迁移兼容性，使得类库能按照它们自己的步调变为泛型，当某个类库变为泛型时，不会破坏依赖于它的代码和应用。在确定了这个目标后，Java 设计者们和从事此问题相关工作的各个团队决策认为擦除是唯一可行的解决方案。擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。
43044: 1460:
43045: 1461:例如，假设一个应用使用了两个类库 **X** 和 **Y**，**Y** 使用了类库 **Z**。随着 Java 5 的出现，这个应用和这些类库的创建者最终可能希望迁移到泛型上。但是当进行迁移时，它们有着不同的动机和限制。为了实现迁移兼容性，每个类库与应用必须与其他所有的部分是否使用泛型无关。因此，它们不能探测其他类库是否使用了泛型。因此，某个特定的类库使用了泛型这样的证据必须被”擦除“。
43046: 1462:
43047: 1463:如果没有某种类型的迁移途径，所有已经构建了很长时间的类库就需要与希望迁移到 Java 泛型上的开发者们说再见了。类库毫无争议是编程语言的一部分，对生产效率有着极大的影响，所以这种代码无法接受。擦除是否是最佳的或唯一的迁移途径，还待时间来证明。
43048: 1464:
43049: 1465:### 擦除的问题
43050: 1466:
43051: 1467:因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。擦除允许你继续使用现有的非泛型客户端代码，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会骤然破坏所有现有的代码。
43052: 1468:
43053: 1469:擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作中，例如转型、**instanceof** 操作和 **new** 表达式。因为所有关于参数的类型信息都丢失了，当你在编写泛型代码时，必须时刻提醒自己，你只是看起来拥有有关参数的类型信息而已。
43054: 1470:
43055: 1471:考虑如下的代码段：
43056: 1472:
43057: 1473:```java
43058: 1474:class Foo<T> {
43059: 1475:    T var;
43060: 1476:}
43061: 1477:```
43062: 1478:
43063: 1479:看上去当你创建一个 **Foo** 实例时：
43064: 1480:
43065: 1481:```java
43066: 1482:Foo<Cat> f = new Foo<>();
43067: 1483:```
43068: 1484:
43069: 1485:**class** **Foo** 中的代码应该知道现在工作于 **Cat** 之上。泛型语法也在强烈暗示整个类中所有 T 出现的地方都被替换，就像在 C++ 中一样。但是事实并非如此，当你在编写这个类的代码时，必须提醒自己：“不，这只是一个 **Object**“。
43070: 1486:
43071: 1487:另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管你可能希望这样：
43072: 1488:
43073: 1489:```java
43074: 1490:// generics/ErasureAndInheritance.java
43075: 1491:
43076: 1492:class GenericBase<T> {
43077: 1493:    private T element;
43078: 1494:    
43079: 1495:    public void set(T arg) {
43080: 1496:        element = arg;
43081: 1497:    }
43082: 1498:    
43083: 1499:    public T get() {
43084: 1500:        return element;
43085: 1501:    }
43086: 1502:}
43087: 1503:
43088: 1504:class Derived1<T> extends GenericBase<T> {}
43089: 1505:
43090: 1506:class Derived2 extends GenericBase {} // No warning
43091: 1507:
43092: 1508:// class Derived3 extends GenericBase<?> {}
43093: 1509:// Strange error:
43094: 1510:// unexpected type
43095: 1511:// required: class or interface without bounds
43096: 1512:public class ErasureAndInteritance {
43097: 1513:    @SuppressWarnings("unchecked")
43098: 1514:    public static void main(String[] args) {
43099: 1515:        Derived2 d2 = new Derived2();
43100: 1516:        Object obj = d2.get();
43101: 1517:        d2.set(obj); // Warning here!
43102: 1518:    }
43103: 1519:}
43104: 1520:```
43105: 1521:
43106: 1522:**Derived2** 继承自 **GenericBase**，但是没有任何类型参数，编译器没有发出任何警告。直到调用 `set()` 方法时才出现警告。
43107: 1523:
43108: 1524:为了关闭警告，Java 提供了一个注解，我们可以在列表中看到它：
43109: 1525:
43110: 1526:```java
43111: 1527:@SuppressWarnings("unchecked")
43112: 1528:```
43113: 1529:
43114: 1530:这个注解放置在产生警告的方法上，而不是整个类上。当你要关闭警告时，最好尽可能地“聚焦”，这样就不会因为过于宽泛地关闭警告，而导致意外地遮蔽掉真正的问题。
43115: 1531:
43116: 1532:可以推断，**Derived3** 产生的错误意味着编译器期望得到一个原生基类。
43117: 1533:
43118: 1534:当你希望将类型参数不仅仅当作 Object 处理时，就需要付出额外努力来管理边界，并且与在 C++、Ada 和 Eiffel 这样的语言中获得参数化类型相比，你需要付出多得多的努力来获得少得多的回报。这并不是说，对于大多数的编程问题而言，这些语言通常都会比 Java 更得心应手，只是说它们的参数化类型机制相比 Java 更灵活、更强大。
43119: 1535:
43120: 1536:### 边界处的动作
43121: 1537:
43122: 1538:因为擦除，我发现了泛型最令人困惑的方面是可以表示没有任何意义的事物。例如：
43123: 1539:
43124: 1540:```java
43125: 1541:// generics/ArrayMaker.java
43126: 1542:
43127: 1543:import java.lang.reflect.*;
43128: 1544:import java.util.*;
43129: 1545:
43130: 1546:public class ArrayMaker<T> {
43131: 1547:    private Class<T> kind;
43132: 1548:
43133: 1549:    public ArrayMaker(Class<T> kind) {
43134: 1550:        this.kind = kind;
43135: 1551:    }
43136: 1552:
43137: 1553:    @SuppressWarnings("unchecked")
43138: 1554:    T[] create(int size) {
43139: 1555:        return (T[]) Array.newInstance(kind, size);
43140: 1556:    }
43141: 1557:
43142: 1558:    public static void main(String[] args) {
43143: 1559:        ArrayMaker<String> stringMaker = new ArrayMaker<>(String.class);
43144: 1560:        String[] stringArray = stringMaker.create(9);
43145: 1561:        System.out.println(Arrays.toString(stringArray));
43146: 1562:    }
43147: 1563:}
43148: 1564:/* Output
43149: 1565:[null,null,null,null,null,null,null,null,null]
43150: 1566:*/
43151: 1567:```
43152: 1568:
43153: 1569:即使 **kind** 被存储为 `Class<T>`，擦除也意味着它实际被存储为没有任何参数的 **Class**。因此，当你在使用它时，例如创建数组，`Array.newInstance()` 实际上并未拥有 **kind** 所蕴含的类型信息。所以它不会产生具体的结果，因而必须转型，这会产生一条令你无法满意的警告。
43154: 1570:
43155: 1571:注意，对于在泛型中创建数组，使用 `Array.newInstance()` 是推荐的方式。
43156: 1572:
43157: 1573:如果我们创建一个集合而不是数组，情况就不同了：
43158: 1574:
43159: 1575:```java
43160: 1576:// generics/ListMaker.java
43161: 1577:
43162: 1578:import java.util.*;
43163: 1579:
43164: 1580:public class ListMaker<T> {
43165: 1581:    List<T> create() {
43166: 1582:        return new ArrayList<>();
43167: 1583:    }
43168: 1584:    
43169: 1585:    public static void main(String[] args) {
43170: 1586:        ListMaker<String> stringMaker = new ListMaker<>();
43171: 1587:        List<String> stringList = stringMaker.create();
43172: 1588:    }
43173: 1589:}
43174: 1590:```
43175: 1591:
43176: 1592:编译器不会给出任何警告，尽管我们知道（从擦除中）在 `create()` 内部的 `new ArrayList<>()` 中的 `<T>` 被移除了——在运行时，类内部没有任何 `<T>`，因此这看起来毫无意义。但是如果你遵从这种思路，并将这个表达式改为 `new ArrayList()`，编译器就会发出警告。
43177: 1593:
43178: 1594:本例中这么做真的毫无意义吗？如果在创建 **List** 的同时向其中放入一些对象呢，像这样：
43179: 1595:
43180: 1596:```java
43181: 1597:// generics/FilledList.java
43182: 1598:
43183: 1599:import java.util.*;
43184: 1600:import java.util.function.*;
43185: 1601:import onjava.*;
43186: 1602:
43187: 1603:public class FilledList<T> extends ArrayList<T> {
43188: 1604:    FilledList(Supplier<T> gen, int size) {
43189: 1605:        Suppliers.fill(this, gen, size);
43190: 1606:    }
43191: 1607:    
43192: 1608:    public FilledList(T t, int size) {
43193: 1609:        for (int i = 0; i < size; i++) {
43194: 1610:            this.add(t);
43195: 1611:        }
43196: 1612:    }
43197: 1613:    
43198: 1614:    public static void main(String[] args) {
43199: 1615:        List<String> list = new FilledList<>("Hello", 4);
43200: 1616:        System.out.println(list);
43201: 1617:        // Supplier version:
43202: 1618:        List<Integer> ilist = new FilledList<>(() -> 47, 4);
43203: 1619:        System.out.println(ilist);
43204: 1620:    }
43205: 1621:}
43206: 1622:/* Output:
43207: 1623:[Hello,Hello,Hello,Hello]
43208: 1624:[47,47,47,47]
43209: 1625:*/
43210: 1626:```
43211: 1627:
43212: 1628:即使编译器无法得知 `add()` 中的 **T** 的任何信息，但它仍可以在编译期确保你放入 **FilledList** 中的对象是 **T** 类型。因此，即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。
43213: 1629:
43214: 1630:因为擦除移除了方法体中的类型信息，所以在运行时的问题就是*边界*：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。
43215: 1631:
43216: 1632:考虑如下这段非泛型示例：
43217: 1633:
43218: 1634:```java
43219: 1635:// generics/SimpleHolder.java
43220: 1636:
43221: 1637:public class SimpleHolder {
43222: 1638:    private Object obj;
43223: 1639:    
43224: 1640:    public void set(Object obj) {
43225: 1641:        this.obj = obj;
43226: 1642:    }
43227: 1643:    
43228: 1644:    public Object get() {
43229: 1645:        return obj;
43230: 1646:    }
43231: 1647:    
43232: 1648:    public static void main(String[] args) {
43233: 1649:        SimpleHolder holder = new SimpleHolder();
43234: 1650:        holder.set("Item");
43235: 1651:        String s = (String) holder.get();
43236: 1652:    }
43237: 1653:}
43238: 1654:```
43239: 1655:
43240: 1656:如果用 **javap -c SimpleHolder** 反编译这个类，会得到如下内容（经过编辑）：
43241: 1657:
43242: 1658:```java
43243: 1659:public void set(java.lang.Object);
43244: 1660:   0: aload_0
43245: 1661:   1: aload_1
43246: 1662:   2: putfield #2; // Field obj:Object;
43247: 1663:   5: return
43248: 1664:    
43249: 1665:public java.lang.Object get();
43250: 1666:   0: aload_0
43251: 1667:   1: getfield #2; // Field obj:Object;
43252: 1668:   4: areturn
43253: 1669:    
43254: 1670:public static void main(java.lang.String[]);
43255: 1671:   0: new #3; // class SimpleHolder
43256: 1672:   3: dup
43257: 1673:   4: invokespecial #4; // Method "<init>":()V
43258: 1674:   7: astore_1
43259: 1675:   8: aload_1
43260: 1676:   9: ldc #5; // String Item
43261: 1677:   11: invokevirtual #6; // Method set:(Object;)V
43262: 1678:   14: aload_1
43263: 1679:   15: invokevirtual #7; // Method get:()Object;
43264: 1680:   18: checkcast #8; // class java/lang/String
43265: 1681:   21: astore_2
43266: 1682:   22: return
43267: 1683:```
43268: 1684:
43269: 1685:`set()` 和 `get()` 方法存储和产生值，转型在调用 `get()` 时接受检查。
43270: 1686:
43271: 1687:现在将泛型融入上例代码中：
43272: 1688:
43273: 1689:```java
43274: 1690:// generics/GenericHolder2.java
43275: 1691:
43276: 1692:public class GenericHolder2<T> {
43277: 1693:    private T obj;
43278: 1694:
43279: 1695:    public void set(T obj) {
43280: 1696:        this.obj = obj;
43281: 1697:    }
43282: 1698:
43283: 1699:    public T get() {
43284: 1700:        return obj;
43285: 1701:    }
43286: 1702:
43287: 1703:    public static void main(String[] args) {
43288: 1704:        GenericHolder2<String> holder =  new GenericHolder2<>();
43289: 1705:        holder.set("Item");
43290: 1706:        String s = holder.get();
43291: 1707:    }
43292: 1708:}
43293: 1709:```
43294: 1710:
43295: 1711:从 `get()` 返回后的转型消失了，但是我们还知道传递给 `set()` 的值在编译期会被检查。下面是相关的字节码：
43296: 1712:
43297: 1713:```java
43298: 1714:public void set(java.lang.Object);
43299: 1715:   0: aload_0
43300: 1716:   1: aload_1
43301: 1717:   2: putfield #2; // Field obj:Object;
43302: 1718:   5: return
43303: 1719:       
43304: 1720:public java.lang.Object get();
43305: 1721:   0: aload_0
43306: 1722:   1: getfield #2; // Field obj:Object;
43307: 1723:   4: areturn
43308: 1724:       
43309: 1725:public static void main(java.lang.String[]);
43310: 1726:   0: new #3; // class GenericHolder2
43311: 1727:   3: dup
43312: 1728:   4: invokespecial #4; // Method "<init>":()V
43313: 1729:   7: astore_1
43314: 1730:   8: aload_1
43315: 1731:   9: ldc #5; // String Item
43316: 1732:   11: invokevirtual #6; // Method set:(Object;)V
43317: 1733:   14: aload_1
43318: 1734:   15: invokevirtual #7; // Method get:()Object;
43319: 1735:   18: checkcast #8; // class java/lang/String
43320: 1736:   21: astore_2
43321: 1737:   22: return
43322: 1738:```
43323: 1739:
43324: 1740:所产生的字节码是相同的。对进入 `set()` 的类型进行检查是不需要的，因为这将由编译器执行。而对 `get()` 返回的值进行转型仍然是需要的，只不过不需要你来操作，它由编译器自动插入，这样你就不用编写（阅读）杂乱的代码。
43325: 1741:
43326: 1742:`get()` 和 `set()` 产生了相同的字节码，这就告诉我们泛型的所有动作都发生在边界处——对入参的编译器检查和对返回值的转型。这有助于澄清对擦除的困惑，记住：“边界就是动作发生的地方”。
43327: 1743:
43328: 1744:<!-- Compensating for Erasure -->
43329: 1745:
43330: 1746:## 补偿擦除
43331: 1747:
43332: 1748:因为擦除，我们将失去执行泛型代码中某些操作的能力。无法在运行时知道确切类型：
43333: 1749:
43334: 1750:```java
43335: 1751:// generics/Erased.java
43336: 1752:// {WillNotCompile}
43337: 1753:
43338: 1754:public class Erased<T> {
43339: 1755:    private final int SIZE = 100;
43340: 1756:
43341: 1757:    public void f(Object arg) {
43342: 1758:        // error: illegal generic type for instanceof
43343: 1759:        if (arg instanceof T) {
43344: 1760:        }
43345: 1761:        // error: unexpected type
43346: 1762:        T var = new T();
43347: 1763:        // error: generic array creation
43348: 1764:        T[] array = new T[SIZE];
43349: 1765:        // warning: [unchecked] unchecked cast
43350: 1766:        T[] array = (T[]) new Object[SIZE];
43351: 1767:
43352: 1768:    }
43353: 1769:}
43354: 1770:```
43355: 1771:
43356: 1772:有时，我们可以对这些问题进行编程，但是有时必须通过引入类型标签来补偿擦除。这意味着为所需的类型显式传递一个 **Class** 对象，以在类型表达式中使用它。
43357: 1773:
43358: 1774:例如，由于擦除了类型信息，因此在上一个程序中尝试使用 **instanceof** 将会失败。类型标签可以使用动态 `isInstance()` ：
43359: 1775:
43360: 1776:```java
43361: 1777:// generics/ClassTypeCapture.java
43362: 1778:
43363: 1779:class Building {
43364: 1780:}
43365: 1781:
43366: 1782:class House extends Building {
43367: 1783:}
43368: 1784:
43369: 1785:public class ClassTypeCapture<T> {
43370: 1786:    Class<T> kind;
43371: 1787:
43372: 1788:    public ClassTypeCapture(Class<T> kind) {
43373: 1789:        this.kind = kind;
43374: 1790:    }
43375: 1791:
43376: 1792:    public boolean f(Object arg) {
43377: 1793:        return kind.isInstance(arg);
43378: 1794:    }
43379: 1795:
43380: 1796:    public static void main(String[] args) {
43381: 1797:        ClassTypeCapture<Building> ctt1 =
43382: 1798:                new ClassTypeCapture<>(Building.class);
43383: 1799:        System.out.println(ctt1.f(new Building()));
43384: 1800:        System.out.println(ctt1.f(new House()));
43385: 1801:        ClassTypeCapture<House> ctt2 =
43386: 1802:                new ClassTypeCapture<>(House.class);
43387: 1803:        System.out.println(ctt2.f(new Building()));
43388: 1804:        System.out.println(ctt2.f(new House()));
43389: 1805:    }
43390: 1806:}
43391: 1807:/* Output:
43392: 1808:true
43393: 1809:true
43394: 1810:false
43395: 1811:true
43396: 1812:*/
43397: 1813:```
43398: 1814:
43399: 1815:编译器来保证类型标签与泛型参数相匹配。
43400: 1816:
43401: 1817:<!-- Creating Instances of Types -->
43402: 1818:
43403: 1819:### 创建类型的实例
43404: 1820:
43405: 1821:试图在 **Erased.java** 中 `new T()` 是行不通的，部分原因是由于擦除，部分原因是编译器无法验证 **T** 是否具有默认（无参）构造函数。但是在 C++ 中，此操作自然，直接且安全（在编译时检查）：
43406: 1822:
43407: 1823:```C++
43408: 1824:// generics/InstantiateGenericType.cpp
43409: 1825:// C++, not Java!
43410: 1826:
43411: 1827:template<class T> class Foo {
43412: 1828:  T x; // Create a field of type T
43413: 1829:  T* y; // Pointer to T
43414: 1830:public:
43415: 1831:  // Initialize the pointer:
43416: 1832:  Foo() { y = new T(); }
43417: 1833:};
43418: 1834:
43419: 1835:class Bar {};
43420: 1836:
43421: 1837:int main() {
43422: 1838:  Foo<Bar> fb;
43423: 1839:  Foo<int> fi; // ... and it works with primitives
43424: 1840:}
43425: 1841:```
43426: 1842:
43427: 1843:Java 中的解决方案是传入一个工厂对象，并使用该对象创建新实例。方便的工厂对象只是 **Class** 对象，因此，如果使用类型标记，则可以使用 `newInstance()` 创建该类型的新对象：
43428: 1844:
43429: 1845:```java
43430: 1846:// generics/InstantiateGenericType.java
43431: 1847:
43432: 1848:import java.util.function.Supplier;
43433: 1849:
43434: 1850:class ClassAsFactory<T> implements Supplier<T> {
43435: 1851:    Class<T> kind;
43436: 1852:
43437: 1853:    ClassAsFactory(Class<T> kind) {
43438: 1854:        this.kind = kind;
43439: 1855:    }
43440: 1856:
43441: 1857:    @Override
43442: 1858:    public T get() {
43443: 1859:        try {
43444: 1860:            return kind.newInstance();
43445: 1861:        } catch (InstantiationException |
43446: 1862:                IllegalAccessException e) {
43447: 1863:            throw new RuntimeException(e);
43448: 1864:        }
43449: 1865:    }
43450: 1866:}
43451: 1867:
43452: 1868:class Employee {
43453: 1869:    @Override
43454: 1870:    public String toString() {
43455: 1871:        return "Employee";
43456: 1872:    }
43457: 1873:}
43458: 1874:
43459: 1875:public class InstantiateGenericType {
43460: 1876:    public static void main(String[] args) {
43461: 1877:        ClassAsFactory<Employee> fe =
43462: 1878:                new ClassAsFactory<>(Employee.class);
43463: 1879:        System.out.println(fe.get());
43464: 1880:        ClassAsFactory<Integer> fi =
43465: 1881:                new ClassAsFactory<>(Integer.class);
43466: 1882:        try {
43467: 1883:            System.out.println(fi.get());
43468: 1884:        } catch (Exception e) {
43469: 1885:            System.out.println(e.getMessage());
43470: 1886:        }
43471: 1887:    }
43472: 1888:}
43473: 1889:/* Output:
43474: 1890:Employee
43475: 1891:java.lang.InstantiationException: java.lang.Integer
43476: 1892:*/
43477: 1893:```
43478: 1894:
43479: 1895:这样可以编译，但对于 `ClassAsFactory<Integer>` 会失败，这是因为 **Integer** 没有无参构造函数。由于错误不是在编译时捕获的，因此语言创建者不赞成这种方法。他们建议使用显式工厂（**Supplier**）并约束类型，以便只有实现该工厂的类可以这样创建对象。这是创建工厂的两种不同方法：
43480: 1896:
43481: 1897:```java
43482: 1898:// generics/FactoryConstraint.java
43483: 1899:
43484: 1900:import onjava.Suppliers;
43485: 1901:
43486: 1902:import java.util.ArrayList;
43487: 1903:import java.util.List;
43488: 1904:import java.util.function.Supplier;
43489: 1905:
43490: 1906:class IntegerFactory implements Supplier<Integer> {
43491: 1907:    private int i = 0;
43492: 1908:
43493: 1909:    @Override
43494: 1910:    public Integer get() {
43495: 1911:        return ++i;
43496: 1912:    }
43497: 1913:}
43498: 1914:
43499: 1915:class Widget {
43500: 1916:    private int id;
43501: 1917:
43502: 1918:    Widget(int n) {
43503: 1919:        id = n;
43504: 1920:    }
43505: 1921:
43506: 1922:    @Override
43507: 1923:    public String toString() {
43508: 1924:        return "Widget " + id;
43509: 1925:    }
43510: 1926:
43511: 1927:    public static
43512: 1928:    class Factory implements Supplier<Widget> {
43513: 1929:        private int i = 0;
43514: 1930:
43515: 1931:        @Override
43516: 1932:        public Widget get() {
43517: 1933:            return new Widget(++i);
43518: 1934:        }
43519: 1935:    }
43520: 1936:}
43521: 1937:
43522: 1938:class Fudge {
43523: 1939:    private static int count = 1;
43524: 1940:    private int n = count++;
43525: 1941:
43526: 1942:    @Override
43527: 1943:    public String toString() {
43528: 1944:        return "Fudge " + n;
43529: 1945:    }
43530: 1946:}
43531: 1947:
43532: 1948:class Foo2<T> {
43533: 1949:    private List<T> x = new ArrayList<>();
43534: 1950:
43535: 1951:    Foo2(Supplier<T> factory) {
43536: 1952:        Suppliers.fill(x, factory, 5);
43537: 1953:    }
43538: 1954:
43539: 1955:    @Override
43540: 1956:    public String toString() {
43541: 1957:        return x.toString();
43542: 1958:    }
43543: 1959:}
43544: 1960:
43545: 1961:public class FactoryConstraint {
43546: 1962:    public static void main(String[] args) {
43547: 1963:        System.out.println(
43548: 1964:                new Foo2<>(new IntegerFactory()));
43549: 1965:        System.out.println(
43550: 1966:                new Foo2<>(new Widget.Factory()));
43551: 1967:        System.out.println(
43552: 1968:                new Foo2<>(Fudge::new));
43553: 1969:    }
43554: 1970:}
43555: 1971:/* Output:
43556: 1972:[1, 2, 3, 4, 5]
43557: 1973:[Widget 1, Widget 2, Widget 3, Widget 4, Widget 5]
43558: 1974:[Fudge 1, Fudge 2, Fudge 3, Fudge 4, Fudge 5]
43559: 1975:*/
43560: 1976:```
43561: 1977:
43562: 1978:**IntegerFactory** 本身就是通过实现 `Supplier<Integer>` 的工厂。 **Widget** 包含一个内部类，它是一个工厂。还要注意，**Fudge** 并没有做任何类似于工厂的操作，并且传递 `Fudge::new` 仍然会产生工厂行为，因为编译器将对函数方法 `::new` 的调用转换为对 `get()` 的调用。
43563: 1979:
43564: 1980:另一种方法是模板方法设计模式。在以下示例中，`create()` 是模板方法，在子类中被重写以生成该类型的对象：
43565: 1981:
43566: 1982:```java
43567: 1983:// generics/CreatorGeneric.java
43568: 1984:
43569: 1985:abstract class GenericWithCreate<T> {
43570: 1986:    final T element;
43571: 1987:
43572: 1988:    GenericWithCreate() {
43573: 1989:        element = create();
43574: 1990:    }
43575: 1991:
43576: 1992:    abstract T create();
43577: 1993:}
43578: 1994:
43579: 1995:class X {
43580: 1996:}
43581: 1997:
43582: 1998:class XCreator extends GenericWithCreate<X> {
43583: 1999:    @Override
43584: 2000:    X create() {
43585: 2001:        return new X();
43586: 2002:    }
43587: 2003:
43588: 2004:    void f() {
43589: 2005:        System.out.println(
43590: 2006:                element.getClass().getSimpleName());
43591: 2007:    }
43592: 2008:}
43593: 2009:
43594: 2010:public class CreatorGeneric {
43595: 2011:    public static void main(String[] args) {
43596: 2012:        XCreator xc = new XCreator();
43597: 2013:        xc.f();
43598: 2014:    }
43599: 2015:}
43600: 2016:/* Output:
43601: 2017:X
43602: 2018:*/
43603: 2019:```
43604: 2020:
43605: 2021:**GenericWithCreate** 包含 `element` 字段，并通过无参构造函数强制其初始化，该构造函数又调用抽象的 `create()` 方法。这种创建方式可以在子类中定义，同时建立 **T** 的类型。
43606: 2022:
43607: 2023:<!-- Arrays of Generics -->
43608: 2024:
43609: 2025:### 泛型数组
43610: 2026:
43611: 2027:正如在 **Erased.java** 中所看到的，我们无法创建泛型数组。通用解决方案是在试图创建泛型数组的时候使用 **ArrayList** ：
43612: 2028:
43613: 2029:```java
43614: 2030:// generics/ListOfGenerics.java
43615: 2031:
43616: 2032:import java.util.ArrayList;
43617: 2033:import java.util.List;
43618: 2034:
43619: 2035:public class ListOfGenerics<T> {
43620: 2036:    private List<T> array = new ArrayList<>();
43621: 2037:
43622: 2038:    public void add(T item) {
43623: 2039:        array.add(item);
43624: 2040:    }
43625: 2041:
43626: 2042:    public T get(int index) {
43627: 2043:        return array.get(index);
43628: 2044:    }
43629: 2045:}
43630: 2046:```
43631: 2047:
43632: 2048:这样做可以获得数组的行为，并且还具有泛型提供的编译时类型安全性。
43633: 2049:
43634: 2050:有时，仍然会创建泛型类型的数组（例如， **ArrayList** 在内部使用数组）。可以通过使编译器满意的方式定义对数组的通用引用：
43635: 2051:
43636: 2052:```java
43637: 2053:// generics/ArrayOfGenericReference.java
43638: 2054:
43639: 2055:class Generic<T> {
43640: 2056:}
43641: 2057:
43642: 2058:public class ArrayOfGenericReference {
43643: 2059:    static Generic<Integer>[] gia;
43644: 2060:}
43645: 2061:```
43646: 2062:
43647: 2063:编译器接受此操作而不产生警告。但是我们永远无法创建具有该确切类型（包括类型参数）的数组，因此有点令人困惑。由于所有数组，无论它们持有什么类型，都具有相同的结构（每个数组插槽的大小和数组布局），因此似乎可以创建一个 **Object** 数组并将其转换为所需的数组类型。实际上，这确实可以编译，但是会产生 **ClassCastException** ：
43648: 2064:
43649: 2065:```java
43650: 2066:// generics/ArrayOfGeneric.java
43651: 2067:
43652: 2068:public class ArrayOfGeneric {
43653: 2069:    static final int SIZE = 100;
43654: 2070:    static Generic<Integer>[] gia;
43655: 2071:
43656: 2072:    @SuppressWarnings("unchecked")
43657: 2073:    public static void main(String[] args) {
43658: 2074:        try {
43659: 2075:            gia = (Generic<Integer>[]) new Object[SIZE];
43660: 2076:        } catch (ClassCastException e) {
43661: 2077:            System.out.println(e.getMessage());
43662: 2078:        }
43663: 2079:        // Runtime type is the raw (erased) type:
43664: 2080:        gia = (Generic<Integer>[]) new Generic[SIZE];
43665: 2081:        System.out.println(gia.getClass().getSimpleName());
43666: 2082:        gia[0] = new Generic<>();
43667: 2083:        //- gia[1] = new Object(); // Compile-time error
43668: 2084:        // Discovers type mismatch at compile time:
43669: 2085:        //- gia[2] = new Generic<Double>();
43670: 2086:    }
43671: 2087:}
43672: 2088:/* Output:
43673: 2089:[Ljava.lang.Object; cannot be cast to [LGeneric;
43674: 2090:Generic[]
43675: 2091:*/
43676: 2092:```
43677: 2093:
43678: 2094:问题在于数组会跟踪其实际类型，而该类型是在创建数组时建立的。因此，即使 `gia` 被强制转换为 `Generic<Integer>[]` ，该信息也仅在编译时存在（并且没有 **@SuppressWarnings** 注解，将会收到有关该强制转换的警告）。在运行时，它仍然是一个 **Object** 数组，这会引起问题。成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换。
43679: 2095:
43680: 2096:让我们看一个更复杂的示例。考虑一个包装数组的简单泛型包装器：
43681: 2097:
43682: 2098:```java
43683: 2099:// generics/GenericArray.java
43684: 2100:
43685: 2101:public class GenericArray<T> {
43686: 2102:    private T[] array;
43687: 2103:
43688: 2104:    @SuppressWarnings("unchecked")
43689: 2105:    public GenericArray(int sz) {
43690: 2106:        array = (T[]) new Object[sz];
43691: 2107:    }
43692: 2108:
43693: 2109:    public void put(int index, T item) {
43694: 2110:        array[index] = item;
43695: 2111:    }
43696: 2112:
43697: 2113:    public T get(int index) {
43698: 2114:        return array[index];
43699: 2115:    }
43700: 2116:
43701: 2117:    // Method that exposes the underlying representation:
43702: 2118:    public T[] rep() {
43703: 2119:        return array;
43704: 2120:    }
43705: 2121:
43706: 2122:    public static void main(String[] args) {
43707: 2123:        GenericArray<Integer> gai = new GenericArray<>(10);
43708: 2124:        try {
43709: 2125:            Integer[] ia = gai.rep();
43710: 2126:        } catch (ClassCastException e) {
43711: 2127:            System.out.println(e.getMessage());
43712: 2128:        }
43713: 2129:        // This is OK:
43714: 2130:        Object[] oa = gai.rep();
43715: 2131:    }
43716: 2132:}
43717: 2133:/* Output:
43718: 2134:[Ljava.lang.Object; cannot be cast to
43719: 2135:[Ljava.lang.Integer;
43720: 2136:*/
43721: 2137:```
43722: 2138:
43723: 2139:和以前一样，我们不能说 `T[] array = new T[sz]` ，所以我们创建了一个 **Object** 数组并将其强制转换。
43724: 2140:
43725: 2141:`rep()` 方法返回一个 `T[]` ，在主方法中它应该是 `gai` 的 `Integer[]`，但是如果调用它并尝试将结果转换为 `Integer[]` 引用，则会得到 **ClassCastException** ，这再次是因为实际的运行时类型为 `Object[]` 。
43726: 2142:
43727: 2143:如果再注释掉 **@SuppressWarnings** 注解后编译 **GenericArray.java** ，则编译器会产生警告：
43728: 2144:
43729: 2145:```java
43730: 2146:GenericArray.java uses unchecked or unsafe operations.
43731: 2147:Recompile with -Xlint:unchecked for details.
43732: 2148:```
43733: 2149:
43734: 2150:在这里，我们收到了一个警告，我们认为这是有关强制转换的。
43735: 2151:
43736: 2152:但是要真正确定，请使用 `-Xlint：unchecked` 进行编译：
43737: 2153:
43738: 2154:```java
43739: 2155:GenericArray.java:7: warning: [unchecked] unchecked cast    array = (T[])new Object[sz];                 ^  required: T[]  found:    Object[]  where T is a type-variable:    T extends Object declared in class GenericArray 1 warning
43740: 2156:```
43741: 2157:
43742: 2158:确实是在抱怨那个强制转换。由于警告会变成噪音，因此，一旦我们确认预期会出现特定警告，我们可以做的最好的办法就是使用 **@SuppressWarnings** 将其关闭。这样，当警告确实出现时，我们将进行实际调查。
43743: 2159:
43744: 2160:由于擦除，数组的运行时类型只能是 `Object[]` 。 如果我们立即将其转换为 `T[]` ，则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。因此，最好在集合中使用 `Object[]` ，并在使用数组元素时向 **T** 添加强制类型转换。让我们来看看在 **GenericArray.java** 示例中会是怎么样的：
43745: 2161:
43746: 2162:```java
43747: 2163:// generics/GenericArray2.java
43748: 2164:
43749: 2165:public class GenericArray2<T> {
43750: 2166:    private Object[] array;
43751: 2167:
43752: 2168:    public GenericArray2(int sz) {
43753: 2169:        array = new Object[sz];
43754: 2170:    }
43755: 2171:
43756: 2172:    public void put(int index, T item) {
43757: 2173:        array[index] = item;
43758: 2174:    }
43759: 2175:
43760: 2176:    @SuppressWarnings("unchecked")
43761: 2177:    public T get(int index) {
43762: 2178:        return (T) array[index];
43763: 2179:    }
43764: 2180:
43765: 2181:    @SuppressWarnings("unchecked")
43766: 2182:    public T[] rep() {
43767: 2183:        return (T[]) array; // Unchecked cast
43768: 2184:    }
43769: 2185:
43770: 2186:    public static void main(String[] args) {
43771: 2187:        GenericArray2<Integer> gai =
43772: 2188:                new GenericArray2<>(10);
43773: 2189:        for (int i = 0; i < 10; i++)
43774: 2190:            gai.put(i, i);
43775: 2191:        for (int i = 0; i < 10; i++)
43776: 2192:            System.out.print(gai.get(i) + " ");
43777: 2193:        System.out.println();
43778: 2194:        try {
43779: 2195:            Integer[] ia = gai.rep();
43780: 2196:        } catch (Exception e) {
43781: 2197:            System.out.println(e);
43782: 2198:        }
43783: 2199:    }
43784: 2200:}
43785: 2201:/* Output:
43786: 2202:0 1 2 3 4 5 6 7 8 9
43787: 2203:java.lang.ClassCastException: [Ljava.lang.Object;
43788: 2204:cannot be cast to [Ljava.lang.Integer;
43789: 2205:*/
43790: 2206:```
43791: 2207:
43792: 2208:最初，看起来并没有太大不同，只是转换的位置移动了。没有 **@SuppressWarnings** 注解，仍然会收到“unchecked”警告。但是，内部表示现在是 `Object[]` 而不是 `T[]` 。 调用 `get()` 时，它将对象强制转换为 **T** ，实际上这是正确的类型，因此很安全。但是，如果调用 `rep()` ，它将再次尝试将 `Object[]` 强制转换为 `T[]` ，但仍然不正确，并在编译时生成警告，并在运行时生成异常。因此，无法破坏基础数组的类型，该基础数组只能是 `Object[]` 。在内部将数组视为 `Object[]` 而不是 `T[]` 的优点是，我们不太可能会忘记数组的运行时类型并意外地引入了bug，尽管大多数（也许是全部）此类错误会在运行时被迅速检测到。
43793: 2209:
43794: 2210:对于新代码，请传入类型标记。在这种情况下，**GenericArray** 如下所示：
43795: 2211:
43796: 2212:```java
43797: 2213:// generics/GenericArrayWithTypeToken.java
43798: 2214:
43799: 2215:import java.lang.reflect.Array;
43800: 2216:
43801: 2217:public class GenericArrayWithTypeToken<T> {
43802: 2218:    private T[] array;
43803: 2219:
43804: 2220:    @SuppressWarnings("unchecked")
43805: 2221:    public GenericArrayWithTypeToken(Class<T> type, int sz) {
43806: 2222:        array = (T[]) Array.newInstance(type, sz);
43807: 2223:    }
43808: 2224:
43809: 2225:    public void put(int index, T item) {
43810: 2226:        array[index] = item;
43811: 2227:    }
43812: 2228:
43813: 2229:    public T get(int index) {
43814: 2230:        return array[index];
43815: 2231:    }
43816: 2232:
43817: 2233:    // Expose the underlying representation:
43818: 2234:    public T[] rep() {
43819: 2235:        return array;
43820: 2236:    }
43821: 2237:
43822: 2238:    public static void main(String[] args) {
43823: 2239:        GenericArrayWithTypeToken<Integer> gai =
43824: 2240:                new GenericArrayWithTypeToken<>(
43825: 2241:                        Integer.class, 10);
43826: 2242:        // This now works:
43827: 2243:        Integer[] ia = gai.rep();
43828: 2244:    }
43829: 2245:}
43830: 2246:```
43831: 2247:
43832: 2248:类型标记 **Class\<T\>** 被传递到构造函数中以从擦除中恢复，因此尽管必须使用 **@SuppressWarnings** 关闭来自强制类型转换的警告，但我们仍可以创建所需的实际数组类型。一旦获得了实际的类型，就可以返回它并产生所需的结果，如在主方法中看到的那样。数组的运行时类型是确切的类型 `T[]` 。
43833: 2249:
43834: 2250:不幸的是，如果查看 Java 标准库中的源代码，你会发现到处都有从 **Object** 数组到参数化类型的转换。例如，这是**ArrayList** 中，复制一个 **Collection** 的构造函数，这里为了简化，去除了源码中对此不重要的代码：
43835: 2251:
43836: 2252:```java
43837: 2253:public ArrayList(Collection c) {
43838: 2254:  size = c.size();
43839: 2255:  elementData = (E[])new Object[size];
43840: 2256:  c.toArray(elementData);
43841: 2257:}
43842: 2258:```
43843: 2259:
43844: 2260:如果你浏览 **ArrayList.java** 的代码，将会发现很多此类强制转换。当我们编译它时会发生什么？
43845: 2261:
43846: 2262:```java
43847: 2263:Note: ArrayList.java uses unchecked or unsafe operations
43848: 2264:Note: Recompile with -Xlint:unchecked for details.
43849: 2265:```
43850: 2266:
43851: 2267:果然，标准库会产生很多警告。如果你使用过 C 语言，尤其是使用 ANSI C 之前的语言，你会记住警告的特殊效果：发现警告后，可以忽略它们。因此，除非程序员必须对其进行处理，否则最好不要从编译器发出任何类型的消息。
43852: 2268:
43853: 2269:Neal Gafter（Java 5 的主要开发人员之一）在他的博客中[^2]指出，他在重写 Java 库时是很随意、马虎的，我们不应该像他那样做。Neal 还指出，他在不破坏现有接口的情况下无法修复某些 Java 库代码。因此，即使在 Java 库源代码中出现了一些习惯用法，它们也不一定是正确的做法。当查看库代码时，我们不能认为这就是要在自己代码中必须遵循的示例。
43854: 2270:
43855: 2271:请注意，在 Java 文献中推荐使用类型标记技术，例如 Gilad Bracha 的论文《Generics in the Java Programming Language》[^3]，他指出：“例如，这种用法已广泛用于新的 API 中以处理注解。” 我发现此技术在人们对于舒适度的看法方面存在一些不一致之处；有些人强烈喜欢本章前面介绍的工厂方法。
43856: 2272:
43857: 2273:<!-- Bounds -->
43858: 2274:
43859: 2275:## 边界
43860: 2276:
43861: 2277:*边界*（bounds）在本章的前面进行了简要介绍。边界允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法。
43862: 2278:
43863: 2279:由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 **Object** 可用的方法。但是，如果将该参数限制为某类型的子集，则可以调用该子集中的方法。为了应用约束，Java 泛型使用了 `extends` 关键字。
43864: 2280:
43865: 2281:重要的是要理解，当用于限定泛型类型时，`extends` 的含义与通常的意义截然不同。此示例展示边界的基础应用：
43866: 2282:
43867: 2283:```java
43868: 2284:// generics/BasicBounds.java
43869: 2285:
43870: 2286:interface HasColor {
43871: 2287:    java.awt.Color getColor();
43872: 2288:}
43873: 2289:
43874: 2290:class WithColor<T extends HasColor> {
43875: 2291:    T item;
43876: 2292:
43877: 2293:    WithColor(T item) {
43878: 2294:        this.item = item;
43879: 2295:    }
43880: 2296:
43881: 2297:    T getItem() {
43882: 2298:        return item;
43883: 2299:    }
43884: 2300:
43885: 2301:    // The bound allows you to call a method:
43886: 2302:    java.awt.Color color() {
43887: 2303:        return item.getColor();
43888: 2304:    }
43889: 2305:}
43890: 2306:
43891: 2307:class Coord {
43892: 2308:    public int x, y, z;
43893: 2309:}
43894: 2310:
43895: 2311:// This fails. Class must be first, then interfaces:
43896: 2312:// class WithColorCoord<T extends HasColor & Coord> {
43897: 2313:
43898: 2314:// Multiple bounds:
43899: 2315:class WithColorCoord<T extends Coord & HasColor> {
43900: 2316:    T item;
43901: 2317:
43902: 2318:    WithColorCoord(T item) {
43903: 2319:        this.item = item;
43904: 2320:    }
43905: 2321:
43906: 2322:    T getItem() {
43907: 2323:        return item;
43908: 2324:    }
43909: 2325:
43910: 2326:    java.awt.Color color() {
43911: 2327:        return item.getColor();
43912: 2328:    }
43913: 2329:
43914: 2330:    int getX() {
43915: 2331:        return item.x;
43916: 2332:    }
43917: 2333:
43918: 2334:    int getY() {
43919: 2335:        return item.y;
43920: 2336:    }
43921: 2337:
43922: 2338:    int getZ() {
43923: 2339:        return item.z;
43924: 2340:    }
43925: 2341:}
43926: 2342:
43927: 2343:interface Weight {
43928: 2344:    int weight();
43929: 2345:}
43930: 2346:
43931: 2347:// As with inheritance, you can have only one
43932: 2348:// concrete class but multiple interfaces:
43933: 2349:class Solid<T extends Coord & HasColor & Weight> {
43934: 2350:    T item;
43935: 2351:
43936: 2352:    Solid(T item) {
43937: 2353:        this.item = item;
43938: 2354:    }
43939: 2355:
43940: 2356:    T getItem() {
43941: 2357:        return item;
43942: 2358:    }
43943: 2359:
43944: 2360:    java.awt.Color color() {
43945: 2361:        return item.getColor();
43946: 2362:    }
43947: 2363:
43948: 2364:    int getX() {
43949: 2365:        return item.x;
43950: 2366:    }
43951: 2367:
43952: 2368:    int getY() {
43953: 2369:        return item.y;
43954: 2370:    }
43955: 2371:
43956: 2372:    int getZ() {
43957: 2373:        return item.z;
43958: 2374:    }
43959: 2375:
43960: 2376:    int weight() {
43961: 2377:        return item.weight();
43962: 2378:    }
43963: 2379:}
43964: 2380:
43965: 2381:class Bounded
43966: 2382:        extends Coord implements HasColor, Weight {
43967: 2383:    @Override
43968: 2384:    public java.awt.Color getColor() {
43969: 2385:        return null;
43970: 2386:    }
43971: 2387:
43972: 2388:    @Override
43973: 2389:    public int weight() {
43974: 2390:        return 0;
43975: 2391:    }
43976: 2392:}
43977: 2393:
43978: 2394:public class BasicBounds {
43979: 2395:    public static void main(String[] args) {
43980: 2396:        Solid<Bounded> solid =
43981: 2397:                new Solid<>(new Bounded());
43982: 2398:        solid.color();
43983: 2399:        solid.getY();
43984: 2400:        solid.weight();
43985: 2401:    }
43986: 2402:}
43987: 2403:```
43988: 2404:
43989: 2405:你可能会观察到 **BasicBounds.java** 中似乎包含一些冗余，它们可以通过继承来消除。在这里，每个继承级别还添加了边界约束：
43990: 2406:
43991: 2407:```java
43992: 2408:// generics/InheritBounds.java
43993: 2409:
43994: 2410:class HoldItem<T> {
43995: 2411:    T item;
43996: 2412:
43997: 2413:    HoldItem(T item) {
43998: 2414:        this.item = item;
43999: 2415:    }
44000: 2416:
44001: 2417:    T getItem() {
44002: 2418:        return item;
44003: 2419:    }
44004: 2420:}
44005: 2421:
44006: 2422:class WithColor2<T extends HasColor>
44007: 2423:        extends HoldItem<T> {
44008: 2424:    WithColor2(T item) {
44009: 2425:        super(item);
44010: 2426:    }
44011: 2427:
44012: 2428:    java.awt.Color color() {
44013: 2429:        return item.getColor();
44014: 2430:    }
44015: 2431:}
44016: 2432:
44017: 2433:class WithColorCoord2<T extends Coord & HasColor>
44018: 2434:        extends WithColor2<T> {
44019: 2435:    WithColorCoord2(T item) {
44020: 2436:        super(item);
44021: 2437:    }
44022: 2438:
44023: 2439:    int getX() {
44024: 2440:        return item.x;
44025: 2441:    }
44026: 2442:
44027: 2443:    int getY() {
44028: 2444:        return item.y;
44029: 2445:    }
44030: 2446:
44031: 2447:    int getZ() {
44032: 2448:        return item.z;
44033: 2449:    }
44034: 2450:}
44035: 2451:
44036: 2452:class Solid2<T extends Coord & HasColor & Weight>
44037: 2453:        extends WithColorCoord2<T> {
44038: 2454:    Solid2(T item) {
44039: 2455:        super(item);
44040: 2456:    }
44041: 2457:
44042: 2458:    int weight() {
44043: 2459:        return item.weight();
44044: 2460:    }
44045: 2461:}
44046: 2462:
44047: 2463:public class InheritBounds {
44048: 2464:    public static void main(String[] args) {
44049: 2465:        Solid2<Bounded> solid2 =
44050: 2466:                new Solid2<>(new Bounded());
44051: 2467:        solid2.color();
44052: 2468:        solid2.getY();
44053: 2469:        solid2.weight();
44054: 2470:    }
44055: 2471:}
44056: 2472:```
44057: 2473:
44058: 2474:**HoldItem** 拥有一个对象，因此此行为将继承到 **WithColor2** 中，这也需要其参数符合 **HasColor**。 **WithColorCoord2** 和 **Solid2** 进一步扩展了层次结构，并在每个级别添加了边界。现在，这些方法已被继承，并且在每个类中不再重复。
44059: 2475:
44060: 2476:这是一个具有更多层次的示例：
44061: 2477:
44062: 2478:```java
44063: 2479:// generics/EpicBattle.java
44064: 2480:// Bounds in Java generics
44065: 2481:
44066: 2482:import java.util.List;
44067: 2483:
44068: 2484:interface SuperPower {
44069: 2485:}
44070: 2486:
44071: 2487:interface XRayVision extends SuperPower {
44072: 2488:    void seeThroughWalls();
44073: 2489:}
44074: 2490:
44075: 2491:interface SuperHearing extends SuperPower {
44076: 2492:    void hearSubtleNoises();
44077: 2493:}
44078: 2494:
44079: 2495:interface SuperSmell extends SuperPower {
44080: 2496:    void trackBySmell();
44081: 2497:}
44082: 2498:
44083: 2499:class SuperHero<POWER extends SuperPower> {
44084: 2500:    POWER power;
44085: 2501:
44086: 2502:    SuperHero(POWER power) {
44087: 2503:        this.power = power;
44088: 2504:    }
44089: 2505:
44090: 2506:    POWER getPower() {
44091: 2507:        return power;
44092: 2508:    }
44093: 2509:}
44094: 2510:
44095: 2511:class SuperSleuth<POWER extends XRayVision>
44096: 2512:        extends SuperHero<POWER> {
44097: 2513:    SuperSleuth(POWER power) {
44098: 2514:        super(power);
44099: 2515:    }
44100: 2516:
44101: 2517:    void see() {
44102: 2518:        power.seeThroughWalls();
44103: 2519:    }
44104: 2520:}
44105: 2521:
44106: 2522:class
44107: 2523:CanineHero<POWER extends SuperHearing & SuperSmell>
44108: 2524:        extends SuperHero<POWER> {
44109: 2525:    CanineHero(POWER power) {
44110: 2526:        super(power);
44111: 2527:    }
44112: 2528:
44113: 2529:    void hear() {
44114: 2530:        power.hearSubtleNoises();
44115: 2531:    }
44116: 2532:
44117: 2533:    void smell() {
44118: 2534:        power.trackBySmell();
44119: 2535:    }
44120: 2536:}
44121: 2537:
44122: 2538:class SuperHearSmell
44123: 2539:        implements SuperHearing, SuperSmell {
44124: 2540:    @Override
44125: 2541:    public void hearSubtleNoises() {
44126: 2542:    }
44127: 2543:
44128: 2544:    @Override
44129: 2545:    public void trackBySmell() {
44130: 2546:    }
44131: 2547:}
44132: 2548:
44133: 2549:class DogPerson extends CanineHero<SuperHearSmell> {
44134: 2550:    DogPerson() {
44135: 2551:        super(new SuperHearSmell());
44136: 2552:    }
44137: 2553:}
44138: 2554:
44139: 2555:public class EpicBattle {
44140: 2556:    // Bounds in generic methods:
44141: 2557:    static <POWER extends SuperHearing>
44142: 2558:    void useSuperHearing(SuperHero<POWER> hero) {
44143: 2559:        hero.getPower().hearSubtleNoises();
44144: 2560:    }
44145: 2561:
44146: 2562:    static <POWER extends SuperHearing & SuperSmell>
44147: 2563:    void superFind(SuperHero<POWER> hero) {
44148: 2564:        hero.getPower().hearSubtleNoises();
44149: 2565:        hero.getPower().trackBySmell();
44150: 2566:    }
44151: 2567:
44152: 2568:    public static void main(String[] args) {
44153: 2569:        DogPerson dogPerson = new DogPerson();
44154: 2570:        useSuperHearing(dogPerson);
44155: 2571:        superFind(dogPerson);
44156: 2572:        // You can do this:
44157: 2573:        List<? extends SuperHearing> audioPeople;
44158: 2574:        // But you can't do this:
44159: 2575:        // List<? extends SuperHearing & SuperSmell> dogPs;
44160: 2576:    }
44161: 2577:}
44162: 2578:```
44163: 2579:
44164: 2580:接下来将要研究的通配符将会把范围限制在单个类型。
44165: 2581:
44166: 2582:<!-- Wildcards -->
44167: 2583:
44168: 2584:## 通配符
44169: 2585:
44170: 2586:你已经在 [集合](book/12-Collections.md) 章节中看到了一些简单示例使用了通配符——在泛型参数表达式中的问号，在 [类型信息](book/19-Type-Information.md) 一章中这种示例更多。本节将更深入地探讨这个特性。
44171: 2587:
44172: 2588:我们的起始示例要展示数组的一种特殊行为：你可以将派生类的数组赋值给基类的引用：
44173: 2589:
44174: 2590:```java
44175: 2591:// generics/CovariantArrays.java
44176: 2592:
44177: 2593:class Fruit {}
44178: 2594:
44179: 2595:class Apple extends Fruit {}
44180: 2596:
44181: 2597:class Jonathan extends Apple {}
44182: 2598:
44183: 2599:class Orange extends Fruit {}
44184: 2600:
44185: 2601:public class CovariantArrays {
44186: 2602:    
44187: 2603:    public static void main(String[] args) {
44188: 2604:        Fruit[] fruit = new Apple[10];
44189: 2605:        fruit[0] = new Apple(); // OK
44190: 2606:        fruit[1] = new Jonathan(); // OK
44191: 2607:        // Runtime type is Apple[], not Fruit[] or Orange[]:
44192: 2608:        try {
44193: 2609:            // Compiler allows you to add Fruit:
44194: 2610:            fruit[0] = new Fruit(); // ArrayStoreException
44195: 2611:        } catch (Exception e) {
44196: 2612:            System.out.println(e);
44197: 2613:        }
44198: 2614:        try {
44199: 2615:            // Compiler allows you to add Oranges:
44200: 2616:            fruit[0] = new Orange(); // ArrayStoreException
44201: 2617:        } catch (Exception e) {
44202: 2618:            System.out.println(e);
44203: 2619:        }
44204: 2620:    }
44205: 2621:}
44206: 2622:/* Output:
44207: 2623:java.lang.ArrayStoreException: Fruit
44208: 2624:java.lang.ArrayStoreException: Orange
44209: 2625:```
44210: 2626:
44211: 2627:`main()` 中的第一行创建了 **Apple** 数组，并赋值给一个 **Fruit** 数组引用。这是有意义的，因为 **Apple** 也是一种 **Fruit**，因此 **Apple** 数组应该也是一个 **Fruit** 数组。
44212: 2628:
44213: 2629:但是，如果实际的数组类型是 **Apple[]**，你可以在其中放置 **Apple** 或 **Apple** 的子类型，这在编译期和运行时都可以工作。但是你也可以在数组中放置 **Fruit** 对象。这对编译器来说是有意义的，因为它有一个 **Fruit[]** 引用——它有什么理由不允许将 **Fruit** 对象或任何从 **Fruit** 继承出来的对象（比如 **Orange**），放置到这个数组中呢？因此在编译期，这是允许的。然而，运行时的数组机制知道它处理的是 **Apple[]**，因此会在向数组中放置异构类型时抛出异常。
44214: 2630:
44215: 2631:向上转型用在这里不合适。你真正在做的是将一个数组赋值给另一个数组。数组的行为是持有其他对象，这里只是因为我们能够向上转型而已，所以很明显，数组对象可以保留有关它们包含的对象类型的规则。看起来就像数组对它们持有的对象是有意识的，因此在编译期检查和运行时检查之间，你不能滥用它们。
44216: 2632:
44217: 2633:数组的这种赋值并不是那么可怕，因为在运行时你可以发现插入了错误的类型。但是泛型的主要目标之一是将这种错误检测移到编译期。所以当我们试图使用泛型集合代替数组时，会发生什么呢？
44218: 2634:
44219: 2635:```java
44220: 2636:// generics/NonCovariantGenerics.java
44221: 2637:// {WillNotCompile}
44222: 2638:
44223: 2639:import java.util.*;
44224: 2640:
44225: 2641:public class NonCovariantGenerics {
44226: 2642:    // Compile Error: incompatible types:
44227: 2643:    List<Fruit> flist = new ArrayList<Apple>();
44228: 2644:}
44229: 2645:```
44230: 2646:
44231: 2647:尽管你在首次阅读这段代码时会认为“不能将一个 **Apple** 集合赋值给一个 **Fruit** 集合”。记住，泛型不仅仅是关于集合，它真正要表达的是“不能把一个涉及 **Apple** 的泛型赋值给一个涉及 **Fruit** 的泛型”。如果像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及到的集合，那么它可能会留下一些余地。但是它不知道任何有关这方面的信息，因此它拒绝向上转型。然而实际上这也不是向上转型—— **Apple** 的 **List** 不是 **Fruit** 的 **List**。**Apple** 的 **List** 将持有 **Apple** 和 **Apple** 的子类型，**Fruit** 的 **List** 将持有任何类型的 **Fruit**。是的，这包括 **Apple**，但是它不是一个 **Apple** 的 **List**，它仍然是 **Fruit** 的 **List**。**Apple** 的 **List** 在类型上不等价于 **Fruit** 的 **List**，即使 **Apple** 是一种 **Fruit** 类型。
44232: 2648:
44233: 2649:真正的问题是我们在讨论的集合类型，而不是集合持有对象的类型。与数组不同，泛型没有内建的协变类型。这是因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查，但是在使用泛型时，编译器和运行时系统不知道你想用类型做什么，以及应该采用什么规则。
44234: 2650:
44235: 2651:但是，有时你想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。
44236: 2652:
44237: 2653:```java
44238: 2654:// generics/GenericsAndCovariance.java
44239: 2655:
44240: 2656:import java.util.*;
44241: 2657:
44242: 2658:public class GenericsAndCovariance {
44243: 2659:    
44244: 2660:    public static void main(String[] args) {
44245: 2661:        // Wildcards allow covariance:
44246: 2662:        List<? extends Fruit> flist = new ArrayList<>();
44247: 2663:        // Compile Error: can't add any type of object:
44248: 2664:        // flist.add(new Apple());
44249: 2665:        // flist.add(new Fruit());
44250: 2666:        // flist.add(new Object());
44251: 2667:        flist.add(null); // Legal but uninteresting
44252: 2668:        // We know it returns at least Fruit:
44253: 2669:        Fruit f = flist.get(0);
44254: 2670:    }
44255: 2671:    
44256: 2672:}
44257: 2673:```
44258: 2674:
44259: 2675:**flist** 的类型现在是 `List<? extends Fruit>`，你可以读作“一个具有任何从 **Fruit** 继承的类型的列表”。然而，这实际上并不意味着这个 **List** 将持有任何类型的 **Fruit**。通配符引用的是明确的类型，因此它意味着“某种 **flist** 引用没有指定的具体类型”。因此这个被赋值的 **List** 必须持有诸如 **Fruit** 或 **Apple** 这样的指定类型，但是为了向上转型为 **Fruit**，这个类型是什么没人在意。
44260: 2676:
44261: 2677:**List** 必须持有一种具体的 **Fruit** 或 **Fruit** 的子类型，但是如果你不关心具体的类型是什么，那么你能对这样的 **List** 做什么呢？如果不知道 **List** 中持有的对象是什么类型，你怎能保证安全地向其中添加对象呢？就像在 **CovariantArrays.java** 中向上转型一样，你不能，除非编译器而不是运行时系统可以阻止这种操作的发生。你很快就会发现这个问题。
44262: 2678:
44263: 2679:你可能认为事情开始变得有点走极端了，因为现在你甚至不能向刚刚声明过将持有 **Apple** 对象的 **List** 中放入一个 **Apple** 对象。是的，但编译器并不知道这一点。`List<? extends Fruit>` 可能合法地指向一个 `List<Orange>`。一旦执行这种类型的向上转型，你就丢失了向其中传递任何对象的能力，甚至传递 **Object** 也不行。
44264: 2680:
44265: 2681:另一方面，如果你调用了一个返回 **Fruit** 的方法，则是安全的，因为你知道这个 **List** 中的任何对象至少具有 **Fruit** 类型，因此编译器允许这么做。
44266: 2682:
44267: 2683:### 编译器有多聪明
44268: 2684:
44269: 2685:现在你可能会猜想自己不能去调用任何接受参数的方法，但是考虑下面的代码：
44270: 2686:
44271: 2687:```java
44272: 2688:// generics/CompilerIntelligence.java
44273: 2689:
44274: 2690:import java.util.*;
44275: 2691:
44276: 2692:public class CompilerIntelligence {
44277: 2693:    
44278: 2694:    public static void main(String[] args) {
44279: 2695:        List<? extends Fruit> flist = Arrays.asList(new Apple());
44280: 2696:        Apple a = (Apple) flist.get(0); // No warning
44281: 2697:        flist.contains(new Apple()); // Argument is 'Object'
44282: 2698:        flist.indexOf(new Apple()); // Argument is 'Object'
44283: 2699:    }
44284: 2700:    
44285: 2701:}
44286: 2702:```
44287: 2703:
44288: 2704:这里对 `contains()` 和 `indexOf()` 的调用接受 **Apple** 对象作为参数，执行没问题。这是否意味着编译器实际上会检查代码，以查看是否有某个特定的方法修改了它的对象？
44289: 2705:
44290: 2706:通过查看 **ArrayList** 的文档，我们发现编译器没有那么聪明。尽管 `add()` 接受一个泛型参数类型的参数，但 `contains()` 和 `indexOf()` 接受的参数类型是 **Object**。因此当你指定一个 `ArrayList<? extends Fruit>` 时，`add()` 的参数就变成了"**? extends Fruit**"。从这个描述中，编译器无法得知这里需要 **Fruit** 的哪个具体子类型，因此它不会接受任何类型的 **Fruit**。如果你先把 **Apple** 向上转型为 **Fruit**，也没有关系——编译器仅仅会拒绝调用像 `add()` 这样参数列表中涉及通配符的方法。
44291: 2707:
44292: 2708:`contains()` 和 `indexOf()` 的参数类型是 **Object**，不涉及通配符，所以编译器允许调用它们。这意味着将由泛型类的设计者来决定哪些调用是“安全的”，并使用 **Object** 类作为它们的参数类型。为了禁止对类型中使用了通配符的方法调用，需要在参数列表中使用类型参数。
44293: 2709:
44294: 2710:下面展示一个简单的 **Holder** 类：
44295: 2711:
44296: 2712:```java
44297: 2713:// generics/Holder.java
44298: 2714:
44299: 2715:public class Holder<T> {
44300: 2716:
44301: 2717:    private T value;
44302: 2718:
44303: 2719:    public Holder() {}
44304: 2720:
44305: 2721:    public Holder(T val) {
44306: 2722:        value = val;
44307: 2723:    }
44308: 2724:
44309: 2725:    public void set(T val) {
44310: 2726:        value = val;
44311: 2727:    }
44312: 2728:
44313: 2729:    public T get() {
44314: 2730:        return value;
44315: 2731:    }
44316: 2732:
44317: 2733:    @Override
44318: 2734:    public boolean equals(Object o) {
44319: 2735:        return o instanceof Holder && Objects.equals(value, ((Holder) o).value);
44320: 2736:    }
44321: 2737:
44322: 2738:    @Override
44323: 2739:    public int hashCode() {
44324: 2740:        return Objects.hashCode(value);
44325: 2741:    }
44326: 2742:
44327: 2743:    public static void main(String[] args) {
44328: 2744:        Holder<Apple> apple = new Holder<>(new Apple());
44329: 2745:        Apple d = apple.get();
44330: 2746:        apple.set(d);
44331: 2747:        // Holder<Fruit> fruit = apple; // Cannot upcast
44332: 2748:        Holder<? extends Fruit> fruit = apple; // OK
44333: 2749:        Fruit p = fruit.get();
44334: 2750:        d = (Apple) fruit.get();
44335: 2751:        try {
44336: 2752:            Orange c = (Orange) fruit.get(); // No warning
44337: 2753:        } catch (Exception e) {
44338: 2754:            System.out.println(e);
44339: 2755:        }
44340: 2756:        // fruit.set(new Apple()); // Cannot call set()
44341: 2757:        // fruit.set(new Fruit()); // Cannot call set()
44342: 2758:        System.out.println(fruit.equals(d)); // OK
44343: 2759:    }
44344: 2760:}
44345: 2761:/* Output
44346: 2762:java.lang.ClassCastException: Apple cannot be cast to Orange
44347: 2763:false
44348: 2764:*/
44349: 2765:```
44350: 2766:
44351: 2767:**Holder** 有一个接受 **T** 类型对象的 `set()` 方法，一个返回 T 对象的 `get()` 方法和一个接受 Object 对象的 `equals()` 方法。正如你所见，如果创建了一个 `Holder<Apple>`，就不能将其向上转型为 `Holder<Fruit>`，但是可以向上转型为 `Holder<? extends Fruit>`。如果调用 `get()`，只能返回一个 **Fruit**——这就是在给定“任何扩展自 **Fruit** 的对象”这一边界后，它所能知道的一切了。如果你知道更多的信息，就可以将其转型到某种具体的 **Fruit** 而不会导致任何警告，但是存在得到 **ClassCastException** 的风险。`set()` 方法不能工作在 **Apple** 和 **Fruit** 上，因为 `set()` 的参数也是"**? extends Fruit**"，意味着它可以是任何事物，编译器无法验证“任何事物”的类型安全性。
44352: 2768:
44353: 2769:但是，`equals()` 方法可以正常工作，因为它接受的参数是 **Object** 而不是 **T** 类型。因此，编译器只关注传递进来和要返回的对象类型。它不会分析代码，以查看是否执行了任何实际的写入和读取操作。
44354: 2770:
44355: 2771:Java 7 引入了 **java.util.Objects** 库，使创建 `equals()` 和 `hashCode()` 方法变得更加容易，当然还有很多其他功能。`equals()` 方法的标准形式参考 [附录：理解 equals 和 hashCode 方法](book/Appendix-Understanding-equals-and-hashCode) 一章。
44356: 2772:
44357: 2773:### 逆变
44358: 2774:
44359: 2775:还可以走另外一条路，即使用超类型通配符。这里，可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 `<？super MyClass>` ，或者甚至使用类型参数： `<？super T>`（尽管你不能对泛型参数给出一个超类型边界；即不能声明 `<T super MyClass>` ）。这使得你可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，就可以向 **Collection** 写入了：
44360: 2776:
44361: 2777:```java
44362: 2778:// generics/SuperTypeWildcards.java
44363: 2779:import java.util.*;
44364: 2780:public class SuperTypeWildcards {
44365: 2781:    static void writeTo(List<? super Apple> apples) {
44366: 2782:        apples.add(new Apple());
44367: 2783:        apples.add(new Jonathan());
44368: 2784:        // apples.add(new Fruit()); // Error
44369: 2785:    }
44370: 2786:}
44371: 2787:```
44372: 2788:
44373: 2789:参数 **apples** 是 **Apple** 的某种基类型的 **List**，这样你就知道向其中添加 **Apple** 或 **Apple** 的子类型是安全的。但是因为 **Apple** 是下界，所以你知道向这样的 **List** 中添加 **Fruit** 是不安全的，因为这将使这个 **List** 敞开口子，从而可以向其中添加非 **Apple** 类型的对象，而这是违反静态类型安全的。
44374: 2790:下面的示例复习了一下逆变和通配符的的使用：
44375: 2791:
44376: 2792:```java
44377: 2793:// generics/GenericReading.java
44378: 2794:import java.util.*;
44379: 2795:
44380: 2796:public class GenericReading {
44381: 2797:    static List<Apple> apples = Arrays.asList(new Apple());
44382: 2798:    static List<Fruit> fruit = Arrays.asList(new Fruit());
44383: 2799:    
44384: 2800:    static <T> T readExact(List<T> list) {
44385: 2801:        return list.get(0);
44386: 2802:    }
44387: 2803:    
44388: 2804:    // A static method adapts to each call:
44389: 2805:    static void f1() {
44390: 2806:        Apple a = readExact(apples);
44391: 2807:        Fruit f = readExact(fruit);
44392: 2808:        f = readExact(apples);
44393: 2809:    }
44394: 2810:    
44395: 2811:    // A class type is established
44396: 2812:    // when the class is instantiated:
44397: 2813:    static class Reader<T> {
44398: 2814:        T readExact(List<T> list) { 
44399: 2815:            return list.get(0); 
44400: 2816:        }
44401: 2817:    }
44402: 2818:    
44403: 2819:    static void f2() {
44404: 2820:        Reader<Fruit> fruitReader = new Reader<>();
44405: 2821:        Fruit f = fruitReader.readExact(fruit);
44406: 2822:        //- Fruit a = fruitReader.readExact(apples);
44407: 2823:        // error: incompatible types: List<Apple>
44408: 2824:        // cannot be converted to List<Fruit>
44409: 2825:    }
44410: 2826:    
44411: 2827:    static class CovariantReader<T> {
44412: 2828:        T readCovariant(List<? extends T> list) {
44413: 2829:            return list.get(0);
44414: 2830:        }
44415: 2831:    }
44416: 2832:    
44417: 2833:    static void f3() {
44418: 2834:        CovariantReader<Fruit> fruitReader = new CovariantReader<>();
44419: 2835:        Fruit f = fruitReader.readCovariant(fruit);
44420: 2836:        Fruit a = fruitReader.readCovariant(apples);
44421: 2837:    }
44422: 2838:    
44423: 2839:    public static void main(String[] args) {
44424: 2840:        f1(); 
44425: 2841:        f2(); 
44426: 2842:        f3();
44427: 2843:    }
44428: 2844:}
44429: 2845:```
44430: 2846:
44431: 2847:`readExact()` 方法使用了精确的类型。如果使用这个没有任何通配符的精确类型，就可以向 **List** 中写入和读取这个精确类型。另外，对于返回值，静态的泛型方法 `readExact()` 可以有效地“适应”每个方法调用，并能够从 `List<Apple>` 中返回一个 **Apple** ，从 `List<Fruit>` 中返回一个 **Fruit** ，就像在 `f1()` 中看到的那样。因此，如果可以摆脱静态泛型方法，那么在读取时就不需要协变类型了。
44432: 2848:然而对于泛型类来说，当你创建这个类的实例时，就要为这个类确定参数。就像在 `f2()` 中看到的，**fruitReader** 实例可以从 `List<Fruit>` 中读取一个 **Fruit** ，因为这就是它的确切类型。但是 `List<Apple>` 也应该产生 **Fruit** 对象，而 **fruitReader** 不允许这么做。
44433: 2849:为了修正这个问题，`CovariantReader.readCovariant()` 方法将接受 `List<？extends T>` ，因此，从这个列表中读取一个 **T** 是安全的（你知道在这个列表中的所有对象至少是一个 **T** ，并且可能是从 T 导出的某种对象）。在 `f3()` 中，你可以看到现在可以从 `List<Apple>` 中读取 **Fruit** 了。
44434: 2850:
44435: 2851:### 无界通配符
44436: 2852:
44437: 2853:无界通配符 `<?>` 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器初看起来是支持这种判断的：
44438: 2854:
44439: 2855:```java
44440: 2856:// generics/UnboundedWildcards1.java
44441: 2857:import java.util.*;
44442: 2858:
44443: 2859:public class UnboundedWildcards1 {
44444: 2860:    static List list1;
44445: 2861:    static List<?> list2;
44446: 2862:    static List<? extends Object> list3;
44447: 2863:  
44448: 2864:    static void assign1(List list) {
44449: 2865:        list1 = list;
44450: 2866:        list2 = list;
44451: 2867:        //- list3 = list;
44452: 2868:        // warning: [unchecked] unchecked conversion
44453: 2869:        // list3 = list;
44454: 2870:        //         ^
44455: 2871:        // required: List<? extends Object>
44456: 2872:        // found:    List
44457: 2873:    }
44458: 2874:    
44459: 2875:    static void assign2(List<?> list) {
44460: 2876:        list1 = list;
44461: 2877:        list2 = list;
44462: 2878:        list3 = list;
44463: 2879:    }
44464: 2880:    
44465: 2881:    static void assign3(List<? extends Object> list) {
44466: 2882:        list1 = list;
44467: 2883:        list2 = list;
44468: 2884:        list3 = list;
44469: 2885:    }
44470: 2886:    
44471: 2887:    public static void main(String[] args) {
44472: 2888:        assign1(new ArrayList());
44473: 2889:        assign2(new ArrayList());
44474: 2890:        //- assign3(new ArrayList());
44475: 2891:        // warning: [unchecked] unchecked method invocation:
44476: 2892:        // method assign3 in class UnboundedWildcards1
44477: 2893:        // is applied to given types
44478: 2894:        // assign3(new ArrayList());
44479: 2895:        //        ^
44480: 2896:        // required: List<? extends Object>
44481: 2897:        // found: ArrayList
44482: 2898:        // warning: [unchecked] unchecked conversion
44483: 2899:        // assign3(new ArrayList());
44484: 2900:        //         ^
44485: 2901:        // required: List<? extends Object>
44486: 2902:        // found:    ArrayList
44487: 2903:        // 2 warnings
44488: 2904:        assign1(new ArrayList<>());
44489: 2905:        assign2(new ArrayList<>());
44490: 2906:        assign3(new ArrayList<>());
44491: 2907:        // Both forms are acceptable as List<?>:
44492: 2908:        List<?> wildList = new ArrayList();
44493: 2909:        wildList = new ArrayList<>();
44494: 2910:        assign1(wildList);
44495: 2911:        assign2(wildList);
44496: 2912:        assign3(wildList);
44497: 2913:    }
44498: 2914:}
44499: 2915:```
44500: 2916:
44501: 2917:有很多情况都和你在这里看到的情况类似，即编译器很少关心使用的是原生类型还是 `<?>` 。在这些情况中，`<?>` 可以被认为是一种装饰，但是它仍旧是很有价值的，因为，实际上它是在声明：“我是想用 Java 的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型。”
44502: 2918:第二个示例展示了无界通配符的一个重要应用。当你在处理多个泛型参数时，有时允许一个参数可以是任何类型，同时为其他参数确定某种特定类型的这种能力会显得很重要：
44503: 2919:
44504: 2920:```java
44505: 2921:// generics/UnboundedWildcards2.java
44506: 2922:import java.util.*;
44507: 2923:
44508: 2924:public class UnboundedWildcards2 {
44509: 2925:    static Map map1;
44510: 2926:    static Map<?,?> map2;
44511: 2927:    static Map<String,?> map3;
44512: 2928:  
44513: 2929:    static void assign1(Map map) { 
44514: 2930:        map1 = map; 
44515: 2931:    }
44516: 2932:    
44517: 2933:    static void assign2(Map<?,?> map) { 
44518: 2934:        map2 = map; 
44519: 2935:    }
44520: 2936:    
44521: 2937:    static void assign3(Map<String,?> map) { 
44522: 2938:        map3 = map; 
44523: 2939:    }
44524: 2940:    
44525: 2941:    public static void main(String[] args) {
44526: 2942:        assign1(new HashMap());
44527: 2943:        assign2(new HashMap());
44528: 2944:        //- assign3(new HashMap());
44529: 2945:        // warning: [unchecked] unchecked method invocation:
44530: 2946:        // method assign3 in class UnboundedWildcards2
44531: 2947:        // is applied to given types
44532: 2948:        //     assign3(new HashMap());
44533: 2949:        //            ^
44534: 2950:        //   required: Map<String,?>
44535: 2951:        //   found: HashMap
44536: 2952:        // warning: [unchecked] unchecked conversion
44537: 2953:        //     assign3(new HashMap());
44538: 2954:        //             ^
44539: 2955:        //   required: Map<String,?>
44540: 2956:        //   found:    HashMap
44541: 2957:        // 2 warnings
44542: 2958:        assign1(new HashMap<>());
44543: 2959:        assign2(new HashMap<>());
44544: 2960:        assign3(new HashMap<>());
44545: 2961:    }
44546: 2962:}
44547: 2963:```
44548: 2964:
44549: 2965:但是，当你拥有的全都是无界通配符时，就像在 `Map<?,?>` 中看到的那样，编译器看起来就无法将其与原生 **Map** 区分开了。另外， **UnboundedWildcards1.java** 展示了编译器处理  `List<?>` 和 `List<? extends Object>` 是不同的。
44550: 2966:令人困惑的是，编译器并非总是关注像 `List` 和 `List<?>` 之间的这种差异，因此它们看起来就像是相同的事物。事实上，因为泛型参数擦除到它的第一个边界，因此 `List<?>` 看起来等价于 `List<Object>` ，而 **List** 实际上也是 `List<Object>` ——除非这些语句都不为真。**List** 实际上表示“持有任何 **Object** 类型的原生 **List** ”，而 `List<?>` 表示“具有某种特定类型的非原生 **List** ，只是我们不知道类型是什么。”
44551: 2967:编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？下面的示例使用了前面定义的 `Holder<T>` 类，它包含接受 **Holder** 作为参数的各种方法，但是它们具有不同的形式：作为原生类型，具有具体的类型参数以及具有无界通配符参数：
44552: 2968:
44553: 2969:```java
44554: 2970:// generics/Wildcards.java
44555: 2971:// Exploring the meaning of wildcards
44556: 2972:
44557: 2973:public class Wildcards {
44558: 2974:    // Raw argument:
44559: 2975:    static void rawArgs(Holder holder, Object arg) {
44560: 2976:        //- holder.set(arg);
44561: 2977:        // warning: [unchecked] unchecked call to set(T)
44562: 2978:        // as a member of the raw type Holder
44563: 2979:        //     holder.set(arg);
44564: 2980:        //               ^
44565: 2981:        //   where T is a type-variable:
44566: 2982:        //     T extends Object declared in class Holder
44567: 2983:        // 1 warning
44568: 2984:
44569: 2985:        // Can't do this; don't have any 'T':
44570: 2986:        // T t = holder.get();
44571: 2987:
44572: 2988:        // OK, but type information is lost:
44573: 2989:        Object obj = holder.get();
44574: 2990:    }
44575: 2991:    
44576: 2992:    // Like rawArgs(), but errors instead of warnings:
44577: 2993:    static void unboundedArg(Holder<?> holder, Object arg) {
44578: 2994:        //- holder.set(arg);
44579: 2995:        // error: method set in class Holder<T>
44580: 2996:        // cannot be applied to given types;
44581: 2997:        //     holder.set(arg);
44582: 2998:        //           ^
44583: 2999:        //   required: CAP#1
44584: 3000:        //   found: Object
44585: 3001:        //   reason: argument mismatch;
44586: 3002:        //     Object cannot be converted to CAP#1
44587: 3003:        //   where T is a type-variable:
44588: 3004:        //     T extends Object declared in class Holder
44589: 3005:        //   where CAP#1 is a fresh type-variable:
44590: 3006:        //     CAP#1 extends Object from capture of ?
44591: 3007:        // 1 error
44592: 3008:
44593: 3009:        // Can't do this; don't have any 'T':
44594: 3010:        // T t = holder.get();
44595: 3011:
44596: 3012:        // OK, but type information is lost:
44597: 3013:        Object obj = holder.get();
44598: 3014:    }
44599: 3015:    
44600: 3016:    static <T> T exact1(Holder<T> holder) {
44601: 3017:        return holder.get();
44602: 3018:    }
44603: 3019:    
44604: 3020:    static <T> T exact2(Holder<T> holder, T arg) {
44605: 3021:        holder.set(arg);
44606: 3022:        return holder.get();
44607: 3023:    }
44608: 3024:    
44609: 3025:    static <T> T wildSubtype(Holder<? extends T> holder, T arg) {
44610: 3026:        //- holder.set(arg);
44611: 3027:        // error: method set in class Holder<T#2>
44612: 3028:        // cannot be applied to given types;
44613: 3029:        //     holder.set(arg);
44614: 3030:        //           ^
44615: 3031:        //   required: CAP#1
44616: 3032:        //   found: T#1
44617: 3033:        //   reason: argument mismatch;
44618: 3034:        //     T#1 cannot be converted to CAP#1
44619: 3035:        //   where T#1,T#2 are type-variables:
44620: 3036:        //     T#1 extends Object declared in method
44621: 3037:        //     <T#1>wildSubtype(Holder<? extends T#1>,T#1)
44622: 3038:        //     T#2 extends Object declared in class Holder
44623: 3039:        //   where CAP#1 is a fresh type-variable:
44624: 3040:        //     CAP#1 extends T#1 from
44625: 3041:        //       capture of ? extends T#1
44626: 3042:        // 1 error
44627: 3043:        return holder.get();
44628: 3044:    }
44629: 3045:    
44630: 3046:    static <T> void wildSupertype(Holder<? super T> holder, T arg) {
44631: 3047:        holder.set(arg);
44632: 3048:        //- T t = holder.get();
44633: 3049:        // error: incompatible types:
44634: 3050:        // CAP#1 cannot be converted to T
44635: 3051:        //     T t = holder.get();
44636: 3052:        //                     ^
44637: 3053:        //   where T is a type-variable:
44638: 3054:        //     T extends Object declared in method
44639: 3055:        //       <T>wildSupertype(Holder<? super T>,T)
44640: 3056:        //   where CAP#1 is a fresh type-variable:
44641: 3057:        //     CAP#1 extends Object super:
44642: 3058:        //       T from capture of ? super T
44643: 3059:        // 1 error
44644: 3060:
44645: 3061:        // OK, but type information is lost:
44646: 3062:        Object obj = holder.get();
44647: 3063:    }
44648: 3064:    
44649: 3065:    public static void main(String[] args) {
44650: 3066:        Holder raw = new Holder<>();
44651: 3067:        // Or:
44652: 3068:        raw = new Holder();
44653: 3069:        Holder<Long> qualified = new Holder<>();
44654: 3070:        Holder<?> unbounded = new Holder<>();
44655: 3071:        Holder<? extends Long> bounded = new Holder<>();
44656: 3072:        Long lng = 1L;
44657: 3073:
44658: 3074:        rawArgs(raw, lng);
44659: 3075:        rawArgs(qualified, lng);
44660: 3076:        rawArgs(unbounded, lng);
44661: 3077:        rawArgs(bounded, lng);
44662: 3078:
44663: 3079:        unboundedArg(raw, lng);
44664: 3080:        unboundedArg(qualified, lng);
44665: 3081:        unboundedArg(unbounded, lng);
44666: 3082:        unboundedArg(bounded, lng);
44667: 3083:
44668: 3084:        //- Object r1 = exact1(raw);
44669: 3085:        // warning: [unchecked] unchecked method invocation:
44670: 3086:        // method exact1 in class Wildcards is applied
44671: 3087:        // to given types
44672: 3088:        //      Object r1 = exact1(raw);
44673: 3089:        //                        ^
44674: 3090:        //   required: Holder<T>
44675: 3091:        //   found: Holder
44676: 3092:        //   where T is a type-variable:
44677: 3093:        //     T extends Object declared in
44678: 3094:        //     method <T>exact1(Holder<T>)
44679: 3095:        // warning: [unchecked] unchecked conversion
44680: 3096:        //      Object r1 = exact1(raw);
44681: 3097:        //                         ^
44682: 3098:        //   required: Holder<T>
44683: 3099:        //   found:    Holder
44684: 3100:        //   where T is a type-variable:
44685: 3101:        //     T extends Object declared in
44686: 3102:        //     method <T>exact1(Holder<T>)
44687: 3103:        // 2 warnings
44688: 3104:
44689: 3105:        Long r2 = exact1(qualified);
44690: 3106:        Object r3 = exact1(unbounded); // Must return Object
44691: 3107:        Long r4 = exact1(bounded);
44692: 3108:
44693: 3109:        //- Long r5 = exact2(raw, lng);
44694: 3110:        // warning: [unchecked] unchecked method invocation:
44695: 3111:        // method exact2 in class Wildcards is
44696: 3112:        // applied to given types
44697: 3113:        //     Long r5 = exact2(raw, lng);
44698: 3114:        //                     ^
44699: 3115:        //   required: Holder<T>,T
44700: 3116:        //   found: Holder,Long
44701: 3117:        //   where T is a type-variable:
44702: 3118:        //     T extends Object declared in
44703: 3119:        //       method <T>exact2(Holder<T>,T)
44704: 3120:        // warning: [unchecked] unchecked conversion
44705: 3121:        //     Long r5 = exact2(raw, lng);
44706: 3122:        //                      ^
44707: 3123:        //   required: Holder<T>
44708: 3124:        //   found:    Holder
44709: 3125:        //   where T is a type-variable:
44710: 3126:        //     T extends Object declared in
44711: 3127:        //       method <T>exact2(Holder<T>,T)
44712: 3128:        // 2 warnings
44713: 3129:
44714: 3130:        Long r6 = exact2(qualified, lng);
44715: 3131:
44716: 3132:        //- Long r7 = exact2(unbounded, lng);
44717: 3133:        // error: method exact2 in class Wildcards
44718: 3134:        // cannot be applied to given types;
44719: 3135:        //     Long r7 = exact2(unbounded, lng);
44720: 3136:        //               ^
44721: 3137:        //   required: Holder<T>,T
44722: 3138:        //   found: Holder<CAP#1>,Long
44723: 3139:        //   reason: inference variable T has
44724: 3140:        //     incompatible bounds
44725: 3141:        //     equality constraints: CAP#1
44726: 3142:        //     lower bounds: Long
44727: 3143:        //   where T is a type-variable:
44728: 3144:        //     T extends Object declared in
44729: 3145:        //       method <T>exact2(Holder<T>,T)
44730: 3146:        //   where CAP#1 is a fresh type-variable:
44731: 3147:        //     CAP#1 extends Object from capture of ?
44732: 3148:        // 1 error
44733: 3149:
44734: 3150:        //- Long r8 = exact2(bounded, lng);
44735: 3151:        // error: method exact2 in class Wildcards
44736: 3152:        // cannot be applied to given types;
44737: 3153:        //      Long r8 = exact2(bounded, lng);
44738: 3154:        //                ^
44739: 3155:        //   required: Holder<T>,T
44740: 3156:        //   found: Holder<CAP#1>,Long
44741: 3157:        //   reason: inference variable T
44742: 3158:        //     has incompatible bounds
44743: 3159:        //     equality constraints: CAP#1
44744: 3160:        //     lower bounds: Long
44745: 3161:        //   where T is a type-variable:
44746: 3162:        //     T extends Object declared in
44747: 3163:        //       method <T>exact2(Holder<T>,T)
44748: 3164:        //   where CAP#1 is a fresh type-variable:
44749: 3165:        //     CAP#1 extends Long from
44750: 3166:        //       capture of ? extends Long
44751: 3167:        // 1 error
44752: 3168:
44753: 3169:        //- Long r9 = wildSubtype(raw, lng);
44754: 3170:        // warning: [unchecked] unchecked method invocation:
44755: 3171:        // method wildSubtype in class Wildcards
44756: 3172:        // is applied to given types
44757: 3173:        //     Long r9 = wildSubtype(raw, lng);
44758: 3174:        //                          ^
44759: 3175:        //   required: Holder<? extends T>,T
44760: 3176:        //   found: Holder,Long
44761: 3177:        //   where T is a type-variable:
44762: 3178:        //     T extends Object declared in
44763: 3179:        //     method <T>wildSubtype(Holder<? extends T>,T)
44764: 3180:        // warning: [unchecked] unchecked conversion
44765: 3181:        //     Long r9 = wildSubtype(raw, lng);
44766: 3182:        //                           ^
44767: 3183:        //   required: Holder<? extends T>
44768: 3184:        //   found:    Holder
44769: 3185:        //   where T is a type-variable:
44770: 3186:        //     T extends Object declared in
44771: 3187:        //     method <T>wildSubtype(Holder<? extends T>,T)
44772: 3188:        // 2 warnings
44773: 3189:
44774: 3190:        Long r10 = wildSubtype(qualified, lng);
44775: 3191:        // OK, but can only return Object:
44776: 3192:        Object r11 = wildSubtype(unbounded, lng);
44777: 3193:        Long r12 = wildSubtype(bounded, lng);
44778: 3194:
44779: 3195:        //- wildSupertype(raw, lng);
44780: 3196:        // warning: [unchecked] unchecked method invocation:
44781: 3197:        //   method wildSupertype in class Wildcards
44782: 3198:        //   is applied to given types
44783: 3199:        //     wildSupertype(raw, lng);
44784: 3200:        //                  ^
44785: 3201:        //   required: Holder<? super T>,T
44786: 3202:        //   found: Holder,Long
44787: 3203:        //   where T is a type-variable:
44788: 3204:        //     T extends Object declared in
44789: 3205:        //     method <T>wildSupertype(Holder<? super T>,T)
44790: 3206:        // warning: [unchecked] unchecked conversion
44791: 3207:        //     wildSupertype(raw, lng);
44792: 3208:        //                   ^
44793: 3209:        //   required: Holder<? super T>
44794: 3210:        //   found:    Holder
44795: 3211:        //   where T is a type-variable:
44796: 3212:        //     T extends Object declared in
44797: 3213:        //     method <T>wildSupertype(Holder<? super T>,T)
44798: 3214:        // 2 warnings
44799: 3215:
44800: 3216:        wildSupertype(qualified, lng);
44801: 3217:
44802: 3218:        //- wildSupertype(unbounded, lng);
44803: 3219:        // error: method wildSupertype in class Wildcards
44804: 3220:        // cannot be applied to given types;
44805: 3221:        //     wildSupertype(unbounded, lng);
44806: 3222:        //     ^
44807: 3223:        //   required: Holder<? super T>,T
44808: 3224:        //   found: Holder<CAP#1>,Long
44809: 3225:        //   reason: cannot infer type-variable(s) T
44810: 3226:        //     (argument mismatch; Holder<CAP#1>
44811: 3227:        //     cannot be converted to Holder<? super T>)
44812: 3228:        //   where T is a type-variable:
44813: 3229:        //     T extends Object declared in
44814: 3230:        //     method <T>wildSupertype(Holder<? super T>,T)
44815: 3231:        //   where CAP#1 is a fresh type-variable:
44816: 3232:        //     CAP#1 extends Object from capture of ?
44817: 3233:        // 1 error
44818: 3234:
44819: 3235:        //- wildSupertype(bounded, lng);
44820: 3236:        // error: method wildSupertype in class Wildcards
44821: 3237:        // cannot be applied to given types;
44822: 3238:        //     wildSupertype(bounded, lng);
44823: 3239:        //     ^
44824: 3240:        //   required: Holder<? super T>,T
44825: 3241:        //   found: Holder<CAP#1>,Long
44826: 3242:        //   reason: cannot infer type-variable(s) T
44827: 3243:        //     (argument mismatch; Holder<CAP#1>
44828: 3244:        //     cannot be converted to Holder<? super T>)
44829: 3245:        //   where T is a type-variable:
44830: 3246:        //     T extends Object declared in
44831: 3247:        //     method <T>wildSupertype(Holder<? super T>,T)
44832: 3248:        //   where CAP#1 is a fresh type-variable:
44833: 3249:        //     CAP#1 extends Long from capture of
44834: 3250:        //     ? extends Long
44835: 3251:        // 1 error
44836: 3252:    }
44837: 3253:}
44838: 3254:```
44839: 3255:
44840: 3256:在 `rawArgs()` 中，编译器知道 `Holder` 是一个泛型类型，因此即使它在这里被表示成一个原生类型，编译器仍旧知道向 `set()` 传递一个 **Object** 是不安全的。由于它是原生类型，你可以将任何类型的对象传递给 `set()` ，而这个对象将被向上转型为 **Object** 。因此无论何时，只要使用了原生类型，都会放弃编译期检查。对 `get()` 的调用说明了相同的问题：没有任何 **T** 类型的对象，因此结果只能是一个 **Object**。
44841: 3257:人们很自然地会开始考虑原生 `Holder` 与 `Holder<?>` 是大致相同的事物。但是 `unboundedArg()` 强调它们是不同的——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，因为原生 **Holder** 将持有任何类型的组合，而 `Holder<?>` 将持有具有某种具体类型的同构集合，因此不能只是向其中传递 **Object** 。
44842: 3258:在 `exact1()` 和 `exact2()` 中，你可以看到使用了确切的泛型参数——没有任何通配符。你将看到，`exact2()`与 `exact1()` 具有不同的限制，因为它有额外的参数。
44843: 3259:在 `wildSubtype()` 中，在 **Holder** 类型上的限制被放松为包括持有任何扩展自 **T** 的对象的 **Holder** 。这还是意味着如果 T 是 **Fruit** ，那么 `holder` 可以是 `Holder<Apple>` ，这是合法的。为了防止将 **Orange** 放置到 `Holder<Apple>` 中，对 `set()` 的调用（或者对任何接受这个类型参数为参数的方法的调用）都是不允许的。但是，你仍旧知道任何来自 `Holder<？extends Fruit>` 的对象至少是 **Fruit** ，因此 `get()` （或者任何将产生具有这个类型参数的返回值的方法）都是允许的。
44844: 3260:`wildSupertype()` 展示了超类型通配符，这个方法展示了与 `wildSubtype()` 相反的行为：`holder` 可以是持有任何 T 的基类型的容器。因此， `set()` 可以接受 **T** ，因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是 **T** ）。但是，尝试着调用 `get()` 是没有用的，因为由 `holder` 持有的类型可以是任何超类型，因此唯一安全的类型就是 **Object** 。
44845: 3261:这个示例还展示了对于在 `unbounded()` 中使用无界通配符能够做什么不能做什么所做出的限制：因为你没有 **T**，所以你不能将 `set()` 或 `get()` 作用于 **T** 上。
44846: 3262:
44847: 3263:在 `main()` 方法中你看到了某些方法在接受某些类型的参数时没有报错和警告。为了迁移兼容性，`rawArgs()`  将接受所有 **Holder** 的不同变体，而不会产生警告。`unboundedArg()` 方法也可以接受相同的所有类型，尽管如前所述，它在方法体内部处理这些类型的方式并不相同。
44848: 3264:
44849: 3265:如果向接受“确切”泛型类型（没有通配符）的方法传递一个原生 **Holder** 引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息。如果向 `exact1()` 传递一个无界引用，就不会有任何可以确定返回类型的类型信息。
44850: 3266:可以看到，`exact2()` 具有最多的限制，因为它希望精确地得到一个 `Holder<T>` ，以及一个具有类型 **T** 的参数，正由于此，它将产生错误或警告，除非提供确切的参数。有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决于是否想要从泛型参数中返回类型确定的返回值（就像在 `wildSubtype()` 中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在 `wildSupertype()` 中看到的那样）。
44851: 3267:因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合你的需求的方法。
44852: 3268:
44853: 3269:### 捕获转换
44854: 3270:
44855: 3271:有一种特殊情况需要使用 `<?>` 而不是原生类型。如果向一个使用 `<?>` 的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。下面的示例演示了这种技术，它被称为捕获转换，因为未指定的通配符类型被捕获，并被转换为确切类型。这里，有关警告的注释只有在 `@SuppressWarnings` 注解被移除之后才能起作用：
44856: 3272:
44857: 3273:```java
44858: 3274:// generics/CaptureConversion.java
44859: 3275:
44860: 3276:public class CaptureConversion {
44861: 3277:    static <T> void f1(Holder<T> holder) {
44862: 3278:        T t = holder.get();
44863: 3279:        System.out.println(t.getClass().getSimpleName());
44864: 3280:    }
44865: 3281:  
44866: 3282:    static void f2(Holder<?> holder) {
44867: 3283:        f1(holder); // Call with captured type
44868: 3284:    }
44869: 3285:    
44870: 3286:    @SuppressWarnings("unchecked")
44871: 3287:    public static void main(String[] args) {
44872: 3288:        Holder raw = new Holder<>(1);
44873: 3289:        f1(raw);
44874: 3290:        // warning: [unchecked] unchecked method invocation:
44875: 3291:        // method f1 in class CaptureConversion
44876: 3292:        // is applied to given types
44877: 3293:        //     f1(raw);
44878: 3294:        //       ^
44879: 3295:        //   required: Holder<T>
44880: 3296:        //   found: Holder
44881: 3297:        //   where T is a type-variable:
44882: 3298:        //     T extends Object declared in
44883: 3299:        //     method <T>f1(Holder<T>)
44884: 3300:        // warning: [unchecked] unchecked conversion
44885: 3301:        //     f1(raw);
44886: 3302:        //        ^
44887: 3303:        //   required: Holder<T>
44888: 3304:        //   found:    Holder
44889: 3305:        //   where T is a type-variable:
44890: 3306:        //     T extends Object declared in
44891: 3307:        //     method <T>f1(Holder<T>)
44892: 3308:        // 2 warnings
44893: 3309:        f2(raw); // No warnings
44894: 3310:        
44895: 3311:        Holder rawBasic = new Holder();
44896: 3312:        rawBasic.set(new Object());
44897: 3313:        // warning: [unchecked] unchecked call to set(T)
44898: 3314:        // as a member of the raw type Holder
44899: 3315:        //     rawBasic.set(new Object());
44900: 3316:        //                 ^
44901: 3317:        //   where T is a type-variable:
44902: 3318:        //     T extends Object declared in class Holder
44903: 3319:        // 1 warning
44904: 3320:        f2(rawBasic); // No warnings
44905: 3321:        
44906: 3322:        // Upcast to Holder<?>, still figures it out:
44907: 3323:        Holder<?> wildcarded = new Holder<>(1.0);
44908: 3324:        f2(wildcarded);
44909: 3325:    }
44910: 3326:}
44911: 3327:/* Output:
44912: 3328:Integer
44913: 3329:Integer
44914: 3330:Object
44915: 3331:Double
44916: 3332:*/
44917: 3333:```
44918: 3334:
44919: 3335:`f1()` 中的类型参数都是确切的，没有通配符或边界。在 `f2()` 中，**Holder** 参数是一个无界通配符，因此它看起来是未知的。但是，在 `f2()` 中调用了 `f1()`，而 `f1()` 需要一个已知参数。这里所发生的是：在调用 `f2()` 的过程中捕获了参数类型，并在调用 `f1()` 时使用了这种类型。
44920: 3336:你可能想知道这项技术是否可以用于写入，但是这要求在传递 `Holder<?>` 时同时传递一个具体类型。捕获转换只有在这样的情况下可以工作：即在方法内部，你需要使用确切的类型。注意，不能从 `f2()` 中返回 **T**，因为 **T** 对于 `f2()` 来说是未知的。捕获转换十分有趣，但是非常受限。
44921: 3337:
44922: 3338:<!-- Issues -->
44923: 3339:
44924: 3340:## 问题
44925: 3341:
44926: 3342:本节将阐述在使用 Java 泛型时会出现的各类问题。
44927: 3343:
44928: 3344:### 任何基本类型都不能作为类型参数
44929: 3345:
44930: 3346:正如本章早先提到的，Java 泛型的限制之一是不能将基本类型用作类型参数。因此，不能创建  `ArrayList<int>` 之类的东西。
44931: 3347:解决方法是使用基本类型的包装器类以及自动装箱机制。如果创建一个 `ArrayList<Integer>`，并将基本类型 **int** 应用于这个集合，那么你将发现自动装箱机制将自动地实现 **int** 到 **Integer** 的双向转换——因此，这几乎就像是有一个 `ArrayList<int>` 一样：
44932: 3348:
44933: 3349:```java
44934: 3350:// generics/ListOfInt.java
44935: 3351:// Autoboxing compensates for the inability
44936: 3352:// to use primitives in generics
44937: 3353:import java.util.*;
44938: 3354:import java.util.stream.*;
44939: 3355:
44940: 3356:public class ListOfInt {
44941: 3357:    public static void main(String[] args) {
44942: 3358:        List<Integer> li = IntStream.range(38, 48)
44943: 3359:            .boxed() // Converts ints to Integers
44944: 3360:            .collect(Collectors.toList());
44945: 3361:        System.out.println(li);
44946: 3362:    }
44947: 3363:}
44948: 3364:/* Output:
44949: 3365:[38, 39, 40, 41, 42, 43, 44, 45, 46, 47]
44950: 3366:*/
44951: 3367:```
44952: 3368:
44953: 3369:通常，这种解决方案工作得很好——能够成功地存储和读取 **int**，自动装箱隐藏了转换的过程。但是如果性能成为问题的话，就需要使用专门为基本类型适配的特殊版本的集合；一个开源版本的实现是 **org.apache.commons.collections.primitives**。
44954: 3370:下面是另外一种方式，它可以创建持有 **Byte** 的 **Set**：
44955: 3371:
44956: 3372:```java
44957: 3373:// generics/ByteSet.java
44958: 3374:import java.util.*;
44959: 3375:
44960: 3376:public class ByteSet {
44961: 3377:    Byte[] possibles = { 1,2,3,4,5,6,7,8,9 };
44962: 3378:    Set<Byte> mySet = new HashSet<>(Arrays.asList(possibles));
44963: 3379:    // But you can't do this:
44964: 3380:    // Set<Byte> mySet2 = new HashSet<>(
44965: 3381:    // Arrays.<Byte>asList(1,2,3,4,5,6,7,8,9));
44966: 3382:}
44967: 3383:```
44968: 3384:
44969: 3385:自动装箱机制解决了一些问题，但并没有解决所有问题。
44970: 3386:
44971: 3387:在下面的示例中，**FillArray** 接口包含一些通用方法，这些方法使用 **Supplier** 来用对象填充数组（这使得类泛型在本例中无法工作，因为这个方法是静态的）。**Supplier** 实现来自 [数组](book/21-Arrays.md) 一章,并且在 `main()` 中，可以看到 `FillArray.fill()` 使用对象填充了数组：
44972: 3388:
44973: 3389:```java
44974: 3390:// generics/PrimitiveGenericTest.java
44975: 3391:import onjava.*;
44976: 3392:import java.util.*;
44977: 3393:import java.util.function.*;
44978: 3394:
44979: 3395:// Fill an array using a generator:
44980: 3396:interface FillArray {
44981: 3397:    static <T> T[] fill(T[] a, Supplier<T> gen) {
44982: 3398:        Arrays.setAll(a, n -> gen.get());
44983: 3399:        return a;
44984: 3400:    }
44985: 3401:    
44986: 3402:    static int[] fill(int[] a, IntSupplier gen) {
44987: 3403:        Arrays.setAll(a, n -> gen.getAsInt());
44988: 3404:        return a;
44989: 3405:    }
44990: 3406:    
44991: 3407:    static long[] fill(long[] a, LongSupplier gen) {
44992: 3408:        Arrays.setAll(a, n -> gen.getAsLong());
44993: 3409:        return a;
44994: 3410:    }
44995: 3411:    
44996: 3412:    static double[] fill(double[] a, DoubleSupplier gen) {
44997: 3413:        Arrays.setAll(a, n -> gen.getAsDouble());
44998: 3414:        return a;
44999: 3415:    }
45000: 3416:}
45001: 3417:
45002: 3418:public class PrimitiveGenericTest {
45003: 3419:    public static void main(String[] args) {
45004: 3420:        String[] strings = FillArray.fill(
45005: 3421:            new String[5], new Rand.String(9));
45006: 3422:        System.out.println(Arrays.toString(strings));
45007: 3423:        int[] integers = FillArray.fill(
45008: 3424:            new int[9], new Rand.Pint());
45009: 3425:        System.out.println(Arrays.toString(integers));
45010: 3426:    }
45011: 3427:}
45012: 3428:/* Output:
45013: 3429:[btpenpccu, xszgvgmei, nneeloztd, vewcippcy, gpoalkljl]
45014: 3430:[635, 8737, 3941, 4720, 6177, 8479, 6656, 3768, 4948]
45015: 3431:*/
45016: 3432:```
45017: 3433:
45018: 3434:自动装箱不适用于数组，因此我们必须创建 `FillArray.fill()` 的重载版本，或创建产生 **Wrapped** 输出的生成器。 **FillArray** 仅比 `java.util.Arrays.setAll()` 有用一点，因为它返回填充的数组。
45019: 3435:
45020: 3436:### 实现参数化接口
45021: 3437:
45022: 3438:一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。下面是产生这种冲突的情况：
45023: 3439:
45024: 3440:```java
45025: 3441:// generics/MultipleInterfaceVariants.java
45026: 3442:// {WillNotCompile}
45027: 3443:package generics;
45028: 3444:
45029: 3445:interface Payable<T> {}
45030: 3446:
45031: 3447:class Employee implements Payable<Employee> {}
45032: 3448:
45033: 3449:class Hourly extends Employee implements Payable<Hourly> {}
45034: 3450:```
45035: 3451:
45036: 3452:**Hourly** 不能编译，因为擦除会将  `Payable<Employe>` 和 `Payable<Hourly>` 简化为相同的类 **Payable**，这样，上面的代码就意味着在重复两次地实现相同的接口。十分有趣的是，如果从 **Payable** 的两种用法中都移除掉泛型参数（就像编译器在擦除阶段所做的那样）这段代码就可以编译。
45037: 3453:
45038: 3454:在使用某些更基本的 Java 接口，例如 `Comparable<T>` 时，这个问题可能会变得十分令人恼火，就像你在本节稍后看到的那样。
45039: 3455:
45040: 3456:### 转型和警告
45041: 3457:
45042: 3458:使用带有泛型类型参数的转型或 **instanceof** 不会有任何效果。下面的集合在内部将各个值存储为 **Object**，并在获取这些值时，再将它们转型回 **T**：
45043: 3459:
45044: 3460:```java
45045: 3461:// generics/GenericCast.java
45046: 3462:import java.util.*;
45047: 3463:import java.util.stream.*;
45048: 3464:
45049: 3465:class FixedSizeStack<T> {
45050: 3466:    private final int size;
45051: 3467:    private Object[] storage;
45052: 3468:    private int index = 0;
45053: 3469:    
45054: 3470:    FixedSizeStack(int size) {
45055: 3471:        this.size = size;
45056: 3472:        storage = new Object[size];
45057: 3473:    }
45058: 3474:    
45059: 3475:    public void push(T item) {
45060: 3476:        if(index < size)
45061: 3477:            storage[index++] = item;
45062: 3478:    }
45063: 3479:    
45064: 3480:    @SuppressWarnings("unchecked")
45065: 3481:    public T pop() {
45066: 3482:        return index == 0 ? null : (T)storage[--index];
45067: 3483:    }
45068: 3484:    
45069: 3485:    @SuppressWarnings("unchecked")
45070: 3486:    Stream<T> stream() {
45071: 3487:        return (Stream<T>)Arrays.stream(storage);
45072: 3488:    }
45073: 3489:}
45074: 3490:
45075: 3491:public class GenericCast {
45076: 3492:    static String[] letters = "ABCDEFGHIJKLMNOPQRS".split("");
45077: 3493:  
45078: 3494:    public static void main(String[] args) {
45079: 3495:        FixedSizeStack<String> strings =
45080: 3496:            new FixedSizeStack<>(letters.length);
45081: 3497:        Arrays.stream("ABCDEFGHIJKLMNOPQRS".split(""))
45082: 3498:            .forEach(strings::push);
45083: 3499:        System.out.println(strings.pop());
45084: 3500:        strings.stream()
45085: 3501:            .map(s -> s + " ")
45086: 3502:            .forEach(System.out::print);
45087: 3503:    }
45088: 3504:}
45089: 3505:/* Output:
45090: 3506:S
45091: 3507:A B C D E F G H I J K L M N O P Q R S
45092: 3508:*/
45093: 3509:```
45094: 3510:
45095: 3511:如果没有 **@SuppressWarnings** 注解，编译器将对 `pop()` 产生 “unchecked cast” 警告。由于擦除的原因，编译器无法知道这个转型是否是安全的，并且 `pop()` 方法实际上并没有执行任何转型。
45096: 3512:这是因为，**T** 被擦除到它的第一个边界，默认情况下是 **Object** ，因此 `pop()` 实际上只是将 **Object** 转型为 **Object**。
45097: 3513:有时，泛型没有消除对转型的需要，这就会由编译器产生警告，而这个警告是不恰当的。例如：
45098: 3514:
45099: 3515:```java
45100: 3516:// generics/NeedCasting.java
45101: 3517:import java.io.*;
45102: 3518:import java.util.*;
45103: 3519:
45104: 3520:public class NeedCasting {
45105: 3521:    @SuppressWarnings("unchecked")
45106: 3522:    public void f(String[] args) throws Exception {
45107: 3523:        ObjectInputStream in = new ObjectInputStream(
45108: 3524:            new FileInputStream(args[0]));
45109: 3525:        List<Widget> shapes = (List<Widget>)in.readObject();
45110: 3526:    }
45111: 3527:}
45112: 3528:```
45113: 3529:
45114: 3530:正如你将在 [附录：对象序列化](book/Appendix-Object-Serialization.md) 中学到的那样，`readObject()` 无法知道它正在读取的是什么，因此它返回的是必须转型的对象。但是当注释掉 **@SuppressWarnings** 注解并编译这个程序时，就会得到下面的警告。
45115: 3531:
45116: 3532:```
45117: 3533:NeedCasting.java uses unchecked or unsafe operations.
45118: 3534:Recompile with -Xlint:unchecked for details.
45119: 3535:
45120: 3536:And if you follow the instructions and recompile with  -
45121: 3537:Xlint:unchecked :(如果遵循这条指示，使用-Xlint:unchecked来重新编译：)
45122: 3538:
45123: 3539:NeedCasting.java:10: warning: [unchecked] unchecked cast
45124: 3540:    List<Widget> shapes = (List<Widget>)in.readObject();
45125: 3541:    required: List<Widget>
45126: 3542:    found: Object
45127: 3543:1 warning
45128: 3544:```
45129: 3545:
45130: 3546:你会被强制要求转型，但是又被告知不应该转型。为了解决这个问题，必须使用 Java 5 引入的新的转型形式，即通过泛型类来转型：
45131: 3547:
45132: 3548:```java
45133: 3549:// generics/ClassCasting.java
45134: 3550:import java.io.*;
45135: 3551:import java.util.*;
45136: 3552:
45137: 3553:public class ClassCasting {
45138: 3554:    @SuppressWarnings("unchecked")
45139: 3555:    public void f(String[] args) throws Exception {
45140: 3556:        ObjectInputStream in = new ObjectInputStream(
45141: 3557:            new FileInputStream(args[0]));
45142: 3558:        // Won't Compile:
45143: 3559:        //    List<Widget> lw1 =
45144: 3560:        //    List<>.class.cast(in.readObject());
45145: 3561:        List<Widget> lw2 = List.class.cast(in.readObject());
45146: 3562:    }
45147: 3563:}
45148: 3564:```
45149: 3565:
45150: 3566:但是，不能转型到实际类型（ `List<Widget>` ）。也就是说，不能声明：
45151: 3567:
45152: 3568:```
45153: 3569:List<Widget>.class.cast(in.readobject())
45154: 3570:```
45155: 3571:
45156: 3572:甚至当你添加一个像下面这样的另一个转型时：
45157: 3573:
45158: 3574:```
45159: 3575:(List<Widget>)List.class.cast(in.readobject())
45160: 3576:```
45161: 3577:
45162: 3578:仍旧会得到一个警告。
45163: 3579:
45164: 3580:### 重载
45165: 3581:
45166: 3582:下面的程序是不能编译的，即使它看起来是合理的：
45167: 3583:
45168: 3584:```java
45169: 3585:// generics/UseList.java
45170: 3586:// {WillNotCompile}
45171: 3587:import java.util.*;
45172: 3588:
45173: 3589:public class UseList<W, T> {
45174: 3590:    void f(List<T> v) {}
45175: 3591:    void f(List<W> v) {}
45176: 3592:}
45177: 3593:```
45178: 3594:
45179: 3595:因为擦除，所以重载方法产生了相同的类型签名。
45180: 3596:
45181: 3597:因而，当擦除后的参数不能产生唯一的参数列表时，你必须提供不同的方法名：
45182: 3598:
45183: 3599:```java
45184: 3600:// generics/UseList2.java
45185: 3601:
45186: 3602:import java.util.*;
45187: 3603:
45188: 3604:public class UseList2<W, T> {
45189: 3605:    void f1(List<T> v) {}
45190: 3606:    void f2(List<W> v) {}
45191: 3607:}
45192: 3608:```
45193: 3609:
45194: 3610:幸运的是，编译器可以检测到这类问题。
45195: 3611:
45196: 3612:### 基类劫持接口
45197: 3613:
45198: 3614:假设你有一个实现了 **Comparable** 接口的 **Pet** 类：
45199: 3615:
45200: 3616:```java
45201: 3617:// generics/ComparablePet.java
45202: 3618:
45203: 3619:public class ComparablePet implements Comparable<ComparablePet> {
45204: 3620:    @Override
45205: 3621:    public int compareTo(ComparablePet o) {
45206: 3622:        return 0;
45207: 3623:    }
45208: 3624:}
45209: 3625:```
45210: 3626:
45211: 3627:尝试缩小 **ComparablePet** 子类的比较类型是有意义的。例如，**Cat** 类可以与其他的 **Cat** 比较：
45212: 3628:
45213: 3629:```java
45214: 3630:// generics/HijackedInterface.java
45215: 3631:// {WillNotCompile}
45216: 3632:
45217: 3633:class Cat extends ComparablePet implements Comparable<Cat> {
45218: 3634:    // error: Comparable cannot be inherited with
45219: 3635:    // different arguments: <Cat> and <ComparablePet>
45220: 3636:    // class Cat
45221: 3637:    // ^
45222: 3638:    // 1 error
45223: 3639:    public int compareTo(Cat arg) {
45224: 3640:        return 0;
45225: 3641:    }
45226: 3642:}
45227: 3643:```
45228: 3644:
45229: 3645:不幸的是，这不能工作。一旦 **Comparable** 的类型参数设置为 **ComparablePet**，其他的实现类只能比较 **ComparablePet**：
45230: 3646:
45231: 3647:```java
45232: 3648:// generics/RestrictedComparablePets.java
45233: 3649:
45234: 3650:public class Hamster extends ComparablePet implements Comparable<ComparablePet> {
45235: 3651:
45236: 3652:    @Override
45237: 3653:    public int compareTo(ComparablePet arg) {
45238: 3654:        return 0;
45239: 3655:    }
45240: 3656:}
45241: 3657:// Or just:
45242: 3658:class Gecko extends ComparablePet {
45243: 3659:    public int compareTo(ComparablePet arg) {
45244: 3660:        return 0;
45245: 3661:    }
45246: 3662:}
45247: 3663:```
45248: 3664:
45249: 3665:**Hamster** 显示了重新实现 **ComparablePet** 中相同的接口是可能的，只要接口完全相同，包括参数类型。然而正如 **Gecko** 中所示，这与直接覆写基类的方法完全相同。
45250: 3666:
45251: 3667:<!-- Self-Bounded Types -->
45252: 3668:
45253: 3669:## 自限定的类型
45254: 3670:
45255: 3671:在 Java 泛型中，有一个似乎经常性出现的惯用法，它相当令人费解：
45256: 3672:
45257: 3673:```java
45258: 3674:class SelfBounded<T extends SelfBounded<T>> { // ...
45259: 3675:```
45260: 3676:
45261: 3677:这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。**SelfBounded** 类接受泛型参数 **T**，而 **T** 由一个边界类限定，这个边界就是拥有 **T** 作为其参数的 **SelfBounded**。
45262: 3678:
45263: 3679:当你首次看到它时，很难去解析它，它强调的是当 **extends** 关键字用于边界与用来创建子类明显是不同的。
45264: 3680:
45265: 3681:### 古怪的循环泛型
45266: 3682:
45267: 3683:为了理解自限定类型的含义，我们从这个惯用法的一个简单版本入手，它没有自限定的边界。
45268: 3684:
45269: 3685:不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类。也就是说，可以声明：
45270: 3686:
45271: 3687:```java
45272: 3688:// generics/CuriouslyRecurringGeneric.java
45273: 3689:
45274: 3690:class GenericType<T> {}
45275: 3691:
45276: 3692:public class CuriouslyRecurringGeneric
45277: 3693:  extends GenericType<CuriouslyRecurringGeneric> {}
45278: 3694:```
45279: 3695:
45280: 3696:这可以按照 Jim Coplien 在 C++ 中的*古怪的循环模版模式*的命名方式，称为古怪的循环泛型（CRG）。“古怪的循环”是指类相当古怪地出现在它自己的基类中这一事实。
45281: 3697:为了理解其含义，努力大声说：“我在创建一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为其参数。”当给出导出类的名字时，这个泛型基类能够实现什么呢？好吧，Java 中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为其参数和返回类型的基类。它还能将导出类型用作其域类型，尽管这些将被擦除为 **Object** 的类型。下面是表示了这种情况的一个泛型类：
45282: 3698:
45283: 3699:```java
45284: 3700:// generics/BasicHolder.java
45285: 3701:
45286: 3702:public class BasicHolder<T> {
45287: 3703:    T element;
45288: 3704:    void set(T arg) { element = arg; }
45289: 3705:    T get() { return element; }
45290: 3706:    void f() {
45291: 3707:        System.out.println(element.getClass().getSimpleName());
45292: 3708:    }
45293: 3709:}
45294: 3710:```
45295: 3711:
45296: 3712:这是一个普通的泛型类型，它的一些方法将接受和产生具有其参数类型的对象，还有一个方法在其存储的域上执行操作（尽管只是在这个域上执行 **Object** 操作）。
45297: 3713:我们可以在一个古怪的循环泛型中使用 **BasicHolder**：
45298: 3714:
45299: 3715:```java
45300: 3716:// generics/CRGWithBasicHolder.java
45301: 3717:
45302: 3718:class Subtype extends BasicHolder<Subtype> {}
45303: 3719:
45304: 3720:public class CRGWithBasicHolder {
45305: 3721:    public static void main(String[] args) {
45306: 3722:        Subtype st1 = new Subtype(), st2 = new Subtype();
45307: 3723:        st1.set(st2);
45308: 3724:        Subtype st3 = st1.get();
45309: 3725:        st1.f();
45310: 3726:    }
45311: 3727:}
45312: 3728:/* Output:
45313: 3729:Subtype
45314: 3730:*/
45315: 3731:```
45316: 3732:
45317: 3733:注意，这里有些东西很重要：新类 **Subtype** 接受的参数和返回的值具有 **Subtype** 类型而不仅仅是基类 **BasicHolder** 类型。这就是 CRG 的本质：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型。也就是说，在所产生的类中将使用确切类型而不是基类型。因此，在**Subtype** 中，传递给 `set()` 的参数和从 `get()` 返回的类型都是确切的 **Subtype**。
45318: 3734:
45319: 3735:### 自限定
45320: 3736:
45321: 3737:**BasicHolder** 可以使用任何类型作为其泛型参数，就像下面看到的那样：
45322: 3738:
45323: 3739:```java
45324: 3740:// generics/Unconstrained.java
45325: 3741:// (c)2017 MindView LLC: see Copyright.txt
45326: 3742:// We make no guarantees that this code is fit for any purpose.
45327: 3743:// Visit http://OnJava8.com for more book information.
45328: 3744:
45329: 3745:class Other {}
45330: 3746:class BasicOther extends BasicHolder<Other> {}
45331: 3747:
45332: 3748:public class Unconstrained {
45333: 3749:    public static void main(String[] args) {
45334: 3750:        BasicOther b = new BasicOther();
45335: 3751:        BasicOther b2 = new BasicOther();
45336: 3752:        b.set(new Other());
45337: 3753:        Other other = b.get();
45338: 3754:        b.f();
45339: 3755:    }
45340: 3756:}
45341: 3757:/* Output:
45342: 3758:Other
45343: 3759:*/
45344: 3760:```
45345: 3761:
45346: 3762:限定将采取额外的步骤，强制泛型当作其自身的边界参数来使用。观察所产生的类可以如何使用以及不可以如何使用：
45347: 3763:
45348: 3764:```java
45349: 3765:// generics/SelfBounding.java
45350: 3766:
45351: 3767:class SelfBounded<T extends SelfBounded<T>> {
45352: 3768:    T element;
45353: 3769:    SelfBounded<T> set(T arg) {
45354: 3770:        element = arg;
45355: 3771:        return this;
45356: 3772:    }
45357: 3773:    T get() { return element; }
45358: 3774:}
45359: 3775:
45360: 3776:class A extends SelfBounded<A> {}
45361: 3777:class B extends SelfBounded<A> {} // Also OK
45362: 3778:
45363: 3779:class C extends SelfBounded<C> {
45364: 3780:    C setAndGet(C arg) { 
45365: 3781:        set(arg); 
45366: 3782:        return get();
45367: 3783:    }
45368: 3784:}
45369: 3785:
45370: 3786:class D {}
45371: 3787:// Can't do this:
45372: 3788:// class E extends SelfBounded<D> {}
45373: 3789:// Compile error:
45374: 3790://   Type parameter D is not within its bound
45375: 3791:
45376: 3792:// Alas, you can do this, so you cannot force the idiom:
45377: 3793:class F extends SelfBounded {}
45378: 3794:
45379: 3795:public class SelfBounding {
45380: 3796:    public static void main(String[] args) {
45381: 3797:        A a = new A();
45382: 3798:        a.set(new A());
45383: 3799:        a = a.set(new A()).get();
45384: 3800:        a = a.get();
45385: 3801:        C c = new C();
45386: 3802:        c = c.setAndGet(new C());
45387: 3803:    }
45388: 3804:}
45389: 3805:```
45390: 3806:
45391: 3807:自限定所做的，就是要求在继承关系中，像下面这样使用这个类：
45392: 3808:
45393: 3809:```java
45394: 3810:class A extends SelfBounded<A>{}
45395: 3811:```
45396: 3812:
45397: 3813:这会强制要求将正在定义的类当作参数传递给基类。
45398: 3814:
45399: 3815:自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。正如你在 B 类的定义中所看到的，还可以从使用了另一个 **SelfBounded** 参数的 **SelfBounded** 中导出，尽管在 **A** 类看到的用法看起来是主要的用法。对定义 **E** 的尝试说明不能使用不是 **SelfBounded** 的类型参数。
45400: 3816:遗憾的是， **F** 可以编译，不会有任何警告，因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型。
45401: 3817:注意，可以移除自限定这个限制，这样所有的类仍旧是可以编译的，但是 **E** 也会因此而变得可编译：
45402: 3818:
45403: 3819:```java
45404: 3820:// generics/NotSelfBounded.java
45405: 3821:
45406: 3822:public class NotSelfBounded<T> {
45407: 3823:    T element;
45408: 3824:    NotSelfBounded<T> set(T arg) {
45409: 3825:        element = arg;
45410: 3826:        return this;
45411: 3827:    }
45412: 3828:    T get() { return element; }
45413: 3829:} 
45414: 3830:
45415: 3831:class A2 extends NotSelfBounded<A2> {}
45416: 3832:class B2 extends NotSelfBounded<A2> {}
45417: 3833:
45418: 3834:class C2 extends NotSelfBounded<C2> {
45419: 3835:    C2 setAndGet(C2 arg) { 
45420: 3836:        set(arg); 
45421: 3837:        return get(); 
45422: 3838:    }
45423: 3839:}
45424: 3840:
45425: 3841:class D2 {}
45426: 3842:// Now this is OK:
45427: 3843:class E2 extends NotSelfBounded<D2> {}
45428: 3844:```
45429: 3845:
45430: 3846:因此很明显，自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。这会强制要求使用这个类的每个人都要遵循这种形式。
45431: 3847:还可以将自限定用于泛型方法：
45432: 3848:
45433: 3849:```java
45434: 3850:// generics/SelfBoundingMethods.java
45435: 3851:// (c)2017 MindView LLC: see Copyright.txt
45436: 3852:// We make no guarantees that this code is fit for any purpose.
45437: 3853:// Visit http://OnJava8.com for more book information.
45438: 3854:
45439: 3855:public class SelfBoundingMethods {
45440: 3856:    static <T extends SelfBounded<T>> T f(T arg) {
45441: 3857:        return arg.set(arg).get();
45442: 3858:    }
45443: 3859:    
45444: 3860:    public static void main(String[] args) {
45445: 3861:        A a = f(new A());
45446: 3862:    }
45447: 3863:}
45448: 3864:```
45449: 3865:
45450: 3866:这可以防止这个方法被应用于除上述形式的自限定参数之外的任何事物上。
45451: 3867:
45452: 3868:### 参数协变
45453: 3869:
45454: 3870:自限定类型的价值在于它们可以产生*协变参数类型*——方法参数类型会随子类而变化。
45455: 3871:
45456: 3872:尽管自限定类型还可以产生与子类类型相同的返回类型，但是这并不十分重要，因为*协变返回类型*是在 Java 5 引入：
45457: 3873:
45458: 3874:```java
45459: 3875:// generics/CovariantReturnTypes.java
45460: 3876:
45461: 3877:class Base {}
45462: 3878:class Derived extends Base {}
45463: 3879:
45464: 3880:interface OrdinaryGetter {
45465: 3881:    Base get();
45466: 3882:}
45467: 3883:
45468: 3884:interface DerivedGetter extends OrdinaryGetter {
45469: 3885:    // Overridden method return type can vary:
45470: 3886:    @Override
45471: 3887:    Derived get();
45472: 3888:}
45473: 3889:
45474: 3890:public class CovariantReturnTypes {
45475: 3891:    void test(DerivedGetter d) {
45476: 3892:        Derived d2 = d.get();
45477: 3893:    }
45478: 3894:}
45479: 3895:```
45480: 3896:
45481: 3897:**DerivedGetter** 中的 `get()` 方法覆盖了 **OrdinaryGetter** 中的 `get()` ，并返回了一个从 `OrdinaryGetter.get()` 的返回类型中导出的类型。尽管这是完全合乎逻辑的事情（导出类方法应该能够返回比它覆盖的基类方法更具体的类型）但是这在早先的 Java 版本中是不合法的。
45482: 3898:
45483: 3899:自限定泛型事实上将产生确切的导出类型作为其返回值，就像在 `get()` 中所看到的一样：
45484: 3900:
45485: 3901:```java
45486: 3902:// generics/GenericsAndReturnTypes.java
45487: 3903:
45488: 3904:interface GenericGetter<T extends GenericGetter<T>> {
45489: 3905:    T get();
45490: 3906:}
45491: 3907:
45492: 3908:interface Getter extends GenericGetter<Getter> {}
45493: 3909:
45494: 3910:public class GenericsAndReturnTypes {
45495: 3911:    void test(Getter g) {
45496: 3912:        Getter result = g.get();
45497: 3913:        GenericGetter gg = g.get(); // Also the base type
45498: 3914:    }
45499: 3915:}
45500: 3916:```
45501: 3917:
45502: 3918:注意，这段代码不能编译，除非是使用囊括了协变返回类型的 Java 5。
45503: 3919:
45504: 3920:然而，在非泛型代码中，参数类型不能随子类型发生变化：
45505: 3921:
45506: 3922:```java
45507: 3923:// generics/OrdinaryArguments.java
45508: 3924:
45509: 3925:class OrdinarySetter {
45510: 3926:    void set(Base base) {
45511: 3927:        System.out.println("OrdinarySetter.set(Base)");
45512: 3928:    }
45513: 3929:}
45514: 3930:
45515: 3931:class DerivedSetter extends OrdinarySetter {
45516: 3932:    void set(Derived derived) {
45517: 3933:        System.out.println("DerivedSetter.set(Derived)");
45518: 3934:    }
45519: 3935:}
45520: 3936:
45521: 3937:public class OrdinaryArguments {
45522: 3938:    public static void main(String[] args) {
45523: 3939:        Base base = new Base();
45524: 3940:        Derived derived = new Derived();
45525: 3941:        DerivedSetter ds = new DerivedSetter();
45526: 3942:        ds.set(derived);
45527: 3943:        // Compiles--overloaded, not overridden!:
45528: 3944:        ds.set(base);
45529: 3945:    }
45530: 3946:}
45531: 3947:/* Output:
45532: 3948:DerivedSetter.set(Derived)
45533: 3949:OrdinarySetter.set(Base)
45534: 3950:*/
45535: 3951:```
45536: 3952:
45537: 3953:`set(derived)` 和 `set(base)` 都是合法的，因此 `DerivedSetter.set()` 没有覆盖 `OrdinarySetter.set()` ，而是重载了这个方法。从输出中可以看到，在 **DerivedSetter** 中有两个方法，因此基类版本仍旧是可用的，因此可以证明它被重载过。
45538: 3954:但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类型而不是基类型为参数：
45539: 3955:
45540: 3956:```java
45541: 3957:// generics/SelfBoundingAndCovariantArguments.java
45542: 3958:
45543: 3959:interface SelfBoundSetter<T extends SelfBoundSetter<T>> {
45544: 3960:    void set(T arg);
45545: 3961:}
45546: 3962:
45547: 3963:interface Setter extends SelfBoundSetter<Setter> {}
45548: 3964:
45549: 3965:public class SelfBoundingAndCovariantArguments {
45550: 3966:    void
45551: 3967:    testA(Setter s1, Setter s2, SelfBoundSetter sbs) {
45552: 3968:        s1.set(s2);
45553: 3969:        //- s1.set(sbs);
45554: 3970:        // error: method set in interface SelfBoundSetter<T>
45555: 3971:        // cannot be applied to given types;
45556: 3972:        //     s1.set(sbs);
45557: 3973:        //       ^
45558: 3974:        //   required: Setter
45559: 3975:        //   found: SelfBoundSetter
45560: 3976:        //   reason: argument mismatch;
45561: 3977:        // SelfBoundSetter cannot be converted to Setter
45562: 3978:        //   where T is a type-variable:
45563: 3979:        //     T extends SelfBoundSetter<T> declared in
45564: 3980:        //     interface SelfBoundSetter
45565: 3981:        // 1 error
45566: 3982:    }
45567: 3983:}
45568: 3984:```
45569: 3985:
45570: 3986:编译器不能识别将基类型当作参数传递给 `set()` 的尝试，因为没有任何方法具有这样的签名。实际上，这个参数已经被覆盖。
45571: 3987:如果不使用自限定类型，普通的继承机制就会介入，而你将能够重载，就像在非泛型的情况下一样：
45572: 3988:
45573: 3989:```java
45574: 3990:// generics/PlainGenericInheritance.java
45575: 3991:
45576: 3992:class GenericSetter<T> { // Not self-bounded
45577: 3993:    void set(T arg) {
45578: 3994:        System.out.println("GenericSetter.set(Base)");
45579: 3995:    }
45580: 3996:}
45581: 3997:
45582: 3998:class DerivedGS extends GenericSetter<Base> {
45583: 3999:    void set(Derived derived) {
45584: 4000:        System.out.println("DerivedGS.set(Derived)");
45585: 4001:    }
45586: 4002:}
45587: 4003:
45588: 4004:public class PlainGenericInheritance {
45589: 4005:    public static void main(String[] args) {
45590: 4006:        Base base = new Base();
45591: 4007:        Derived derived = new Derived();
45592: 4008:        DerivedGS dgs = new DerivedGS();
45593: 4009:        dgs.set(derived);
45594: 4010:        dgs.set(base); // Overloaded, not overridden!
45595: 4011:    }
45596: 4012:}
45597: 4013:/* Output:
45598: 4014:DerivedGS.set(Derived)
45599: 4015:GenericSetter.set(Base)
45600: 4016:*/
45601: 4017:```
45602: 4018:
45603: 4019:这段代码在模仿 **OrdinaryArguments.java**；在那个示例中，**DerivedSetter** 继承自包含一个 `set(Base)` 的**OrdinarySetter** 。而这里，**DerivedGS** 继承自泛型创建的也包含有一个 `set(Base)`的 `GenericSetter<Base>`。就像 **OrdinaryArguments.java** 一样，你可以从输出中看到， **DerivedGS** 包含两个  `set()` 的重载版本。如果不使用自限定，将重载参数类型。如果使用了自限定，只能获得方法的一个版本，它将接受确切的参数类型。
45604: 4020:
45605: 4021:<!-- Dynamic Type Safety -->
45606: 4022:
45607: 4023:## 动态类型安全
45608: 4024:
45609: 4025:因为可以向 Java 5 之前的代码传递泛型集合，所以旧式代码仍旧有可能会破坏你的集合。Java 5 的 **java.util.Collections** 中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：静态方法 `checkedCollection()` 、`checkedList()`、 `checkedMap()` 、 `checkedSet()` 、`checkedSortedMap()`和 `checkedSortedSet()`。这些方法每一个都会将你希望动态检查的集合当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。
45610: 4026:
45611: 4027:受检查的集合在你试图插入类型不正确的对象时抛出 **ClassCastException** ，这与泛型之前的（原生）集合形成了对比，对于后者来说，当你将对象从集合中取出时，才会通知你出现了问题。在后一种情况中，你知道存在问题，但是不知道罪魁祸首在哪里，如果使用受检查的集合，就可以发现谁在试图插入不良对象。
45612: 4028:让我们用受检查的集合来看看“将猫插入到狗列表中”这个问题。这里，`oldStyleMethod()` 表示遗留代码，因为它接受的是原生的 **List** ，而 **@SuppressWarnings（“unchecked”）** 注解对于压制所产生的警告是必需的：
45613: 4029:
45614: 4030:```java
45615: 4031:// generics/CheckedList.java
45616: 4032:// Using Collection.checkedList()
45617: 4033:import typeinfo.pets.*;
45618: 4034:import java.util.*;
45619: 4035:
45620: 4036:public class CheckedList {
45621: 4037:    @SuppressWarnings("unchecked")
45622: 4038:    static void oldStyleMethod(List probablyDogs) {
45623: 4039:        probablyDogs.add(new Cat());
45624: 4040:    }
45625: 4041:    
45626: 4042:    public static void main(String[] args) {
45627: 4043:        List<Dog> dogs1 = new ArrayList<>();
45628: 4044:        oldStyleMethod(dogs1); // Quietly accepts a Cat
45629: 4045:        List<Dog> dogs2 = Collections.checkedList(
45630: 4046:            new ArrayList<>(), Dog.class);
45631: 4047:        try {
45632: 4048:            oldStyleMethod(dogs2); // Throws an exception
45633: 4049:        } catch(Exception e) {
45634: 4050:            System.out.println("Expected: " + e);
45635: 4051:        }
45636: 4052:        // Derived types work fine:
45637: 4053:        List<Pet> pets = Collections.checkedList(
45638: 4054:            new ArrayList<>(), Pet.class);
45639: 4055:        pets.add(new Dog());
45640: 4056:        pets.add(new Cat());
45641: 4057:    }
45642: 4058:}
45643: 4059:/* Output:
45644: 4060:Expected: java.lang.ClassCastException: Attempt to
45645: 4061:insert class typeinfo.pets.Cat element into collection
45646: 4062:with element type class typeinfo.pets.Dog
45647: 4063:*/
45648: 4064:```
45649: 4065:
45650: 4066:运行这个程序时，你会发现插入一个 **Cat** 对于 **dogs1** 来说没有任何问题，而 **dogs2** 立即会在这个错误类型的插入操作上抛出一个异常。还可以看到，将导出类型的对象放置到将要检查基类型的受检查容器中是没有问题的。
45651: 4067:
45652: 4068:<!-- Exceptions -->
45653: 4069:
45654: 4070:## 泛型异常
45655: 4071:
45656: 4072:由于擦除的原因，**catch** 语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承自 **Throwable**（这将进一步阻止你去定义不能捕获的泛型异常）。
45657: 4073:但是，类型参数可能会在一个方法的 **throws** 子句中用到。这使得你可以编写随检查型异常类型变化的泛型代码：
45658: 4074:
45659: 4075:```java
45660: 4076:// generics/ThrowGenericException.java
45661: 4077:
45662: 4078:import java.util.*;
45663: 4079:
45664: 4080:interface Processor<T, E extends Exception> {
45665: 4081:    void process(List<T> resultCollector) throws E;
45666: 4082:}
45667: 4083:
45668: 4084:class ProcessRunner<T, E extends Exception>
45669: 4085:extends ArrayList<Processor<T, E>> {
45670: 4086:    List<T> processAll() throws E {
45671: 4087:        List<T> resultCollector = new ArrayList<>();
45672: 4088:        for(Processor<T, E> processor : this)
45673: 4089:            processor.process(resultCollector);
45674: 4090:        return resultCollector;
45675: 4091:    }
45676: 4092:}
45677: 4093:
45678: 4094:class Failure1 extends Exception {}
45679: 4095:
45680: 4096:class Processor1
45681: 4097:implements Processor<String, Failure1> {
45682: 4098:    static int count = 3;
45683: 4099:    @Override
45684: 4100:    public void process(List<String> resultCollector)
45685: 4101:    throws Failure1 {
45686: 4102:        if(count-- > 1)
45687: 4103:            resultCollector.add("Hep!");
45688: 4104:        else
45689: 4105:            resultCollector.add("Ho!");
45690: 4106:        if(count < 0)
45691: 4107:            throw new Failure1();
45692: 4108:    }
45693: 4109:}
45694: 4110:
45695: 4111:class Failure2 extends Exception {}
45696: 4112:
45697: 4113:class Processor2
45698: 4114:implements Processor<Integer, Failure2> {
45699: 4115:    static int count = 2;
45700: 4116:    @Override
45701: 4117:    public void process(List<Integer> resultCollector)
45702: 4118:    throws Failure2 {
45703: 4119:        if(count-- == 0)
45704: 4120:            resultCollector.add(47);
45705: 4121:        else {
45706: 4122:            resultCollector.add(11);
45707: 4123:        }
45708: 4124:        if(count < 0)
45709: 4125:            throw new Failure2();
45710: 4126:    }
45711: 4127:}
45712: 4128:
45713: 4129:public class ThrowGenericException {
45714: 4130:    public static void main(String[] args) {
45715: 4131:        ProcessRunner<String, Failure1> runner =
45716: 4132:            new ProcessRunner<>();
45717: 4133:        for(int i = 0; i < 3; i++)
45718: 4134:            runner.add(new Processor1());
45719: 4135:        try {
45720: 4136:            System.out.println(runner.processAll());
45721: 4137:        } catch(Failure1 e) {
45722: 4138:            System.out.println(e);
45723: 4139:        }
45724: 4140:
45725: 4141:        ProcessRunner<Integer, Failure2> runner2 =
45726: 4142:            new ProcessRunner<>();
45727: 4143:        for(int i = 0; i < 3; i++)
45728: 4144:            runner2.add(new Processor2());
45729: 4145:        try {
45730: 4146:            System.out.println(runner2.processAll());
45731: 4147:        } catch(Failure2 e) {
45732: 4148:            System.out.println(e);
45733: 4149:        }
45734: 4150:    }
45735: 4151:}
45736: 4152:/* Output:
45737: 4153:[Hep!, Hep!, Ho!]
45738: 4154:Failure2
45739: 4155:*/
45740: 4156:```
45741: 4157:
45742: 4158:**Processor** 执行 `process()` 方法，并且可能会抛出具有类型 **E** 的异常。`process()` 的结果存储在 `List<T>resultCollector` 中（这被称为*收集参数*）。**ProcessRunner** 有一个 `processAll()` 方法，它会在所持有的每个 **Process** 对象执行，并返回 **resultCollector** 。
45743: 4159:如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出这种泛化的代码。
45744: 4160:
45745: 4161:<!-- Mixins -->
45746: 4162:
45747: 4163:## 混型
45748: 4164:
45749: 4165:术语*混型*随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是你最后的手段，它将使组装多个类变得简单易行。
45750: 4166:混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点*面向切面编程* （AOP） 的味道，而切面经常被建议用来解决混型问题。
45751: 4167:
45752: 4168:### C++ 中的混型
45753: 4169:
45754: 4170:在 C++ 中，使用多重继承的最大理由，就是为了使用混型。但是，对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为混型就是继承自其类型参数的类。在 C++ 中，可以很容易地创建混型，因为 C++ 能够记住其模版参数的类型。
45755: 4171:下面是一个 C++ 示例，它有两个混型类型：一个使得你可以在每个对象中混入拥有一个时间戳这样的属性，而另一个可以混入一个序列号。
45756: 4172:
45757: 4173:```c++
45758: 4174:// generics/Mixins.cpp
45759: 4175:
45760: 4176:#include <string>
45761: 4177:#include <ctime>
45762: 4178:#include <iostream>
45763: 4179:using namespace std;
45764: 4180:
45765: 4181:template<class T> class TimeStamped : public T {
45766: 4182:    long timeStamp;
45767: 4183:public:
45768: 4184:    TimeStamped() { timeStamp = time(0); }
45769: 4185:    long getStamp() { return timeStamp; }
45770: 4186:};
45771: 4187:
45772: 4188:template<class T> class SerialNumbered : public T {
45773: 4189:    long serialNumber;
45774: 4190:    static long counter;
45775: 4191:public:
45776: 4192:    SerialNumbered() { serialNumber = counter++; }
45777: 4193:    long getSerialNumber() { return serialNumber; }
45778: 4194:};
45779: 4195:
45780: 4196:// Define and initialize the static storage:
45781: 4197:template<class T> long SerialNumbered<T>::counter = 1;
45782: 4198:
45783: 4199:class Basic {
45784: 4200:    string value;
45785: 4201:public:
45786: 4202:    void set(string val) { value = val; }
45787: 4203:    string get() { return value; }
45788: 4204:};
45789: 4205:
45790: 4206:int main() {
45791: 4207:    TimeStamped<SerialNumbered<Basic>> mixin1, mixin2;
45792: 4208:    mixin1.set("test string 1");
45793: 4209:    mixin2.set("test string 2");
45794: 4210:    cout << mixin1.get() << " " << mixin1.getStamp() <<
45795: 4211:      " " << mixin1.getSerialNumber() << endl;
45796: 4212:    cout << mixin2.get() << " " << mixin2.getStamp() <<
45797: 4213:      " " << mixin2.getSerialNumber() << endl;
45798: 4214:}
45799: 4215:/* Output:
45800: 4216:test string 1 1452987605 1
45801: 4217:test string 2 1452987605 2
45802: 4218:*/
45803: 4219:```
45804: 4220:
45805: 4221:在 `main()` 中， **mixin1** 和 **mixin2** 所产生的类型拥有所混入类型的所有方法。可以将混型看作是一种功能，它可以将现有类映射到新的子类上。注意，使用这种技术来创建一个混型是多么的轻而易举。基本上，只需要声明“这就是我想要的”，紧跟着它就发生了：
45806: 4222:
45807: 4223:```c++
45808: 4224:TimeStamped<SerialNumbered<Basic>> mixin1，mixin2；
45809: 4225:```
45810: 4226:
45811: 4227:遗憾的是，Java 泛型不允许这样。擦除会忘记基类类型，因此
45812: 4228:
45813: 4229:>  泛型类不能直接继承自一个泛型参数
45814: 4230:
45815: 4231:这突显了许多我在 Java 语言设计决策（以及与这些功能一起发布）中遇到的一大问题：处理一件事很有希望，但是当您实际尝试做一些有趣的事情时，您会发现自己做不到。
45816: 4232:
45817: 4233:### 与接口混合
45818: 4234:
45819: 4235:一种更常见的推荐解决方案是使用接口来产生混型效果，就像下面这样：
45820: 4236:
45821: 4237:```java
45822: 4238:// generics/Mixins.java
45823: 4239:
45824: 4240:import java.util.*;
45825: 4241:
45826: 4242:interface TimeStamped { long getStamp(); }
45827: 4243:
45828: 4244:class TimeStampedImp implements TimeStamped {
45829: 4245:    private final long timeStamp;
45830: 4246:    TimeStampedImp() {
45831: 4247:        timeStamp = new Date().getTime();
45832: 4248:    }
45833: 4249:    @Override
45834: 4250:    public long getStamp() { return timeStamp; }
45835: 4251:}
45836: 4252:
45837: 4253:interface SerialNumbered { long getSerialNumber(); }
45838: 4254:
45839: 4255:class SerialNumberedImp implements SerialNumbered {
45840: 4256:    private static long counter = 1;
45841: 4257:    private final long serialNumber = counter++;
45842: 4258:    @Override
45843: 4259:    public long getSerialNumber() { return serialNumber; }
45844: 4260:}
45845: 4261:
45846: 4262:interface Basic {
45847: 4263:    void set(String val);
45848: 4264:    String get();
45849: 4265:}
45850: 4266:
45851: 4267:class BasicImp implements Basic {
45852: 4268:    private String value;
45853: 4269:    @Override
45854: 4270:    public void set(String val) { value = val; }
45855: 4271:    @Override
45856: 4272:    public String get() { return value; }
45857: 4273:}
45858: 4274:
45859: 4275:class Mixin extends BasicImp
45860: 4276:implements TimeStamped, SerialNumbered {
45861: 4277:    private TimeStamped timeStamp = new TimeStampedImp();
45862: 4278:    private SerialNumbered serialNumber =
45863: 4279:        new SerialNumberedImp();
45864: 4280:    @Override
45865: 4281:    public long getStamp() {
45866: 4282:        return timeStamp.getStamp();
45867: 4283:    }
45868: 4284:    @Override
45869: 4285:    public long getSerialNumber() {
45870: 4286:        return serialNumber.getSerialNumber();
45871: 4287:    }
45872: 4288:}
45873: 4289:
45874: 4290:public class Mixins {
45875: 4291:    public static void main(String[] args) {
45876: 4292:        Mixin mixin1 = new Mixin(), mixin2 = new Mixin();
45877: 4293:        mixin1.set("test string 1");
45878: 4294:        mixin2.set("test string 2");
45879: 4295:        System.out.println(mixin1.get() + " " +
45880: 4296:            mixin1.getStamp() +  " " + mixin1.getSerialNumber());
45881: 4297:        System.out.println(mixin2.get() + " " +
45882: 4298:            mixin2.getStamp() +  " " + mixin2.getSerialNumber());
45883: 4299:    }
45884: 4300:}
45885: 4301:/* Output:
45886: 4302:test string 1 1494331663026 1
45887: 4303:test string 2 1494331663027 2
45888: 4304:*/
45889: 4305:```
45890: 4306:
45891: 4307:**Mixin** 类基本上是在使用*委托*，因此每个混入类型都要求在 **Mixin** 中有一个相应的域，而你必须在 **Mixin** 中编写所有必需的方法，将方法调用转发给恰当的对象。这个示例使用了非常简单的类，但是当使用更复杂的混型时，代码数量会急速增加。[^4]
45892: 4308:
45893: 4309:### 使用装饰器模式
45894: 4310:
45895: 4311:当你观察混型的使用方式时，就会发现混型概念好像与*装饰器*设计模式关系很近。装饰器经常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的。
45896: 4312:装饰器模式使用分层对象来动态透明地向单个对象中添加责任。装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。某些事物是可装饰的，可以通过将其他类包装在这个可装饰对象的四周，来将功能分层。这使得对装饰器的使用是透明的——无论对象是否被装饰，你都拥有一个可以向对象发送的公共消息集。装饰类也可以添加新方法，但是正如你所见，这将是受限的。
45897: 4313:装饰器是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。
45898: 4314:前面的示例可以被改写为使用装饰器：
45899: 4315:
45900: 4316:```java
45901: 4317:// generics/decorator/Decoration.java
45902: 4318:
45903: 4319:// {java generics.decorator.Decoration}
45904: 4320:package generics.decorator;
45905: 4321:import java.util.*;
45906: 4322:
45907: 4323:class Basic {
45908: 4324:    private String value;
45909: 4325:    public void set(String val) { value = val; }
45910: 4326:    public String get() { return value; }
45911: 4327:}
45912: 4328:
45913: 4329:class Decorator extends Basic {
45914: 4330:    protected Basic basic;
45915: 4331:    Decorator(Basic basic) { this.basic = basic; }
45916: 4332:    @Override
45917: 4333:    public void set(String val) { basic.set(val); }
45918: 4334:    @Override
45919: 4335:    public String get() { return basic.get(); }
45920: 4336:}
45921: 4337:
45922: 4338:class TimeStamped extends Decorator {
45923: 4339:    private final long timeStamp;
45924: 4340:    TimeStamped(Basic basic) {
45925: 4341:        super(basic);
45926: 4342:        timeStamp = new Date().getTime();
45927: 4343:    }
45928: 4344:    public long getStamp() { return timeStamp; }
45929: 4345:}
45930: 4346:
45931: 4347:class SerialNumbered extends Decorator {
45932: 4348:    private static long counter = 1;
45933: 4349:    private final long serialNumber = counter++;
45934: 4350:    SerialNumbered(Basic basic) { super(basic); }
45935: 4351:    public long getSerialNumber() { return serialNumber; }
45936: 4352:}
45937: 4353:
45938: 4354:public class Decoration {
45939: 4355:    public static void main(String[] args) {
45940: 4356:        TimeStamped t = new TimeStamped(new Basic());
45941: 4357:        TimeStamped t2 = new TimeStamped(
45942: 4358:            new SerialNumbered(new Basic()));
45943: 4359:        //- t2.getSerialNumber(); // Not available
45944: 4360:        SerialNumbered s = new SerialNumbered(new Basic());
45945: 4361:        SerialNumbered s2 = new SerialNumbered(
45946: 4362:            new TimeStamped(new Basic()));
45947: 4363:        //- s2.getStamp(); // Not available
45948: 4364:  }
45949: 4365:}
45950: 4366:```
45951: 4367:
45952: 4368:产生自泛型的类包含所有感兴趣的方法，但是由使用装饰器所产生的对象类型是最后被装饰的类型。也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。因此，装饰器只是对由混型提出的问题的一种局限的解决方案。
45953: 4369:
45954: 4370:### 与动态代理混合
45955: 4371:
45956: 4372:可以使用动态代理来创建一种比装饰器更贴近混型模型的机制（查看 [类型信息](book/19-Type-Information.md) 一章中关于 Java 的动态代理如何工作的解释）。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。
45957: 4373:由于动态代理的限制，每个被混入的类都必须是某个接口的实现：
45958: 4374:
45959: 4375:```java
45960: 4376:// generics/DynamicProxyMixin.java
45961: 4377:
45962: 4378:import java.lang.reflect.*;
45963: 4379:import java.util.*;
45964: 4380:import onjava.*;
45965: 4381:import static onjava.Tuple.*;
45966: 4382:
45967: 4383:class MixinProxy implements InvocationHandler {
45968: 4384:    Map<String, Object> delegatesByMethod;
45969: 4385:    @SuppressWarnings("unchecked")
45970: 4386:    MixinProxy(Tuple2<Object, Class<?>>... pairs) {
45971: 4387:        delegatesByMethod = new HashMap<>();
45972: 4388:        for(Tuple2<Object, Class<?>> pair : pairs) {
45973: 4389:            for(Method method : pair.a2.getMethods()) {
45974: 4390:                String methodName = method.getName();
45975: 4391:                // The first interface in the map
45976: 4392:                // implements the method.
45977: 4393:                if(!delegatesByMethod.containsKey(methodName))
45978: 4394:                    delegatesByMethod.put(methodName, pair.a1);
45979: 4395:            }
45980: 4396:        }
45981: 4397:    }
45982: 4398:    @Override
45983: 4399:    public Object invoke(Object proxy, Method method,
45984: 4400:      Object[] args) throws Throwable {
45985: 4401:        String methodName = method.getName();
45986: 4402:        Object delegate = delegatesByMethod.get(methodName);
45987: 4403:        return method.invoke(delegate, args);
45988: 4404:    }
45989: 4405:    
45990: 4406:    @SuppressWarnings("unchecked")
45991: 4407:    public static Object newInstance(Tuple2... pairs) {
45992: 4408:        Class[] interfaces = new Class[pairs.length];
45993: 4409:        for(int i = 0; i < pairs.length; i++) {
45994: 4410:            interfaces[i] = (Class)pairs[i].a2;
45995: 4411:        }
45996: 4412:        ClassLoader cl = pairs[0].a1.getClass().getClassLoader();
45997: 4413:        return Proxy.newProxyInstance(cl, interfaces, new MixinProxy(pairs));
45998: 4414:    }
45999: 4415:}
46000: 4416:
46001: 4417:public class DynamicProxyMixin {
46002: 4418:    public static void main(String[] args) {
46003: 4419:        Object mixin = MixinProxy.newInstance(
46004: 4420:          tuple(new BasicImp(), Basic.class),
46005: 4421:          tuple(new TimeStampedImp(), TimeStamped.class),
46006: 4422:          tuple(new SerialNumberedImp(), SerialNumbered.class));
46007: 4423:        Basic b = (Basic)mixin;
46008: 4424:        TimeStamped t = (TimeStamped)mixin;
46009: 4425:        SerialNumbered s = (SerialNumbered)mixin;
46010: 4426:        b.set("Hello");
46011: 4427:        System.out.println(b.get());
46012: 4428:        System.out.println(t.getStamp());
46013: 4429:        System.out.println(s.getSerialNumber());
46014: 4430:    }
46015: 4431:}
46016: 4432:/* Output:
46017: 4433:Hello
46018: 4434:1494331653339
46019: 4435:1
46020: 4436:*/
46021: 4437:```
46022: 4438:
46023: 4439:因为只有动态类型而不是静态类型才包含所有的混入类型，因此这仍旧不如 C++ 的方式好，因为可以在具有这些类型的对象上调用方法之前，你被强制要求必须先将这些对象向下转型到恰当的类型。但是，它明显地更接近于真正的混型。
46024: 4440:为了让 Java 支持混型，人们已经做了大量的工作朝着这个目标努力，包括创建了至少一种附加语言（ Jam 语言），它是专门用来支持混型的。
46025: 4441:
46026: 4442:<!-- Latent Typing -->
46027: 4443:
46028: 4444:## 潜在类型机制
46029: 4445:
46030: 4446:在本章的开头介绍过这样的思想，即要编写能够尽可能广泛地应用的代码。为了实现这一点，我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处。然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码。
46031: 4447:
46032: 4448:Java 泛型看起来是向这一方向迈进了一步。当你在编写或使用只是持有对象的泛型时，这些代码将可以工作于任何类型（除了基本类型，尽管正如你所见到的，自动装箱机制可以克服这一点）。或者，换个角度讲，“持有器”泛型能够声明：“我不关心你是什么类型”。如果代码不关心它将要作用的类型，那么这种代码就可以真正地应用于任何地方，并因此而相当泛化。
46033: 4449:
46034: 4450:还是正如你所见到的，当要在泛型类型上执行操作（即调用 **Object** 方法之外的方法）时，就会产生问题。擦除强制要求指定可能会用到的泛型类型的边界，以安全地调用代码中的泛型对象上的具体方法。这是对“泛化”概念的一种明显的限制，因为必须限制你的泛型类型，使它们继承自特定的类，或者实现特定的接口。在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类或接口没有任何区别。
46035: 4451:
46036: 4452:某些编程语言提供的一种解决方案称为*潜在类型机制*或*结构化类型机制*，而更古怪的术语称为*鸭子类型机制*，即“如果它走起来像鸭子，并且叫起来也像鸭子，那么你就可以将它当作鸭子对待。”鸭子类型机制变成了一种相当流行的术语，可能是因为它不像其他的术语那样承载着历史的包袱。
46037: 4453:
46038: 4454:泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得你可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以 `speak()` 和 `sit()` 即可。”由于不要求具体类型，因此代码就可以更加泛化。
46039: 4455:
46040: 4456:潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方。
46041: 4457:
46042: 4458:支持潜在类型机制的语言包括 Python（可以从 www.Python.org 免费下载）、C++、Ruby、SmallTalk 和 Go。Python 是动态类型语言（几乎所有的类型检查都发生在运行时），而 C++ 和 Go 是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查。
46043: 4459:
46044: 4460:### pyhton 中的潜在类型
46045: 4461:
46046: 4462:如果我们将上面的描述用 Python 来表示，如下所示：
46047: 4463:
46048: 4464:```python
46049: 4465:# generics/DogsAndRobots.py
46050: 4466:
46051: 4467:class Dog:
46052: 4468:    def speak(self):
46053: 4469:        print("Arf!")
46054: 4470:    def sit(self):
46055: 4471:        print("Sitting")
46056: 4472:    def reproduce(self):
46057: 4473:        pass
46058: 4474:
46059: 4475:class Robot:
46060: 4476:    def speak(self):
46061: 4477:        print("Click!")
46062: 4478:    def sit(self):
46063: 4479:        print("Clank!")
46064: 4480:    def oilChange(self):
46065: 4481:        pass
46066: 4482:
46067: 4483:def perform(anything):
46068: 4484:    anything.speak()
46069: 4485:    anything.sit()
46070: 4486:
46071: 4487:a = Dog()
46072: 4488:b = Robot()
46073: 4489:perform(a)
46074: 4490:perform(b)
46075: 4491:
46076: 4492:output = """
46077: 4493:Arf!
46078: 4494:Sitting
46079: 4495:Click!
46080: 4496:Clank!
46081: 4497:"""
46082: 4498:```
46083: 4499:
46084: 4500:Python 使用缩进来确定作用域（因此不需要任何花括号），而冒号将表示新的作用域的开始。“**#**” 表示注释到行尾，就像Java中的 “ **//** ”。类的方法需要显式地指定 **this** 引用的等价物作为第一个参数，按惯例成为 **self** 。构造器调用不要求任何类型的“ **new** ”关键字，并且 Python 允许普通（非成员）函数，就像 `perform()` 所表明的那样。注意，在 `perform(anything)` 中，没有任何针对 **anything** 的类型，**anything** 只是一个标识符，它必须能够执行 `perform()` 期望它执行的操作，因此这里隐含着一个接口。但是你从来都不必显式地写出这个接口——它是潜在的。`perform()` 不关心其参数的类型，因此我可以向它传递任何对象，只要该对象支持  `speak()` 和 `sit()` 方法。如果传递给 `perform()` 的对象不支持这些操作，那么将会得到运行时异常。
46085: 4501:
46086: 4502:输出规定使用三重引号创建带有内嵌换行符的字符串。
46087: 4503:
46088: 4504:### C++ 中的潜在类型
46089: 4505:
46090: 4506:我们可以用 C++ 产生相同的效果：
46091: 4507:
46092: 4508:```c++
46093: 4509:// generics/DogsAndRobots.cpp
46094: 4510:
46095: 4511:#include <iostream>
46096: 4512:using namespace std;
46097: 4513:
46098: 4514:class Dog {
46099: 4515:public:
46100: 4516:    void speak() { cout << "Arf!" << endl; }
46101: 4517:    void sit() { cout << "Sitting" << endl; }
46102: 4518:    void reproduce() {}
46103: 4519:};
46104: 4520:
46105: 4521:class Robot {
46106: 4522:public:
46107: 4523:    void speak() { cout << "Click!" << endl; }
46108: 4524:    void sit() { cout << "Clank!" << endl; }
46109: 4525:    void oilChange() {}
46110: 4526:};
46111: 4527:
46112: 4528:template<class T> void perform(T anything) {
46113: 4529:    anything.speak();
46114: 4530:    anything.sit();
46115: 4531:}
46116: 4532:
46117: 4533:int main() {
46118: 4534:    Dog d;
46119: 4535:    Robot r;
46120: 4536:    perform(d);
46121: 4537:    perform(r);
46122: 4538:}
46123: 4539:/* Output:
46124: 4540:Arf!
46125: 4541:Sitting
46126: 4542:Click!
46127: 4543:Clank!
46128: 4544:*/
46129: 4545:```
46130: 4546:
46131: 4547:在 Python 和 C++ 中，**Dog** 和 **Robot** 没有任何共同的东西，只是碰巧有两个方法具有相同的签名。从类型的观点看，它们是完全不同的类型。但是，`perform()` 不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。
46132: 4548:C++ 确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给你一个错误消息（这些错误消息从历史上看是相当可怕和冗长的，是 C++ 的模版名声欠佳的主要原因）。尽管它们是在不同时期实现这一点的，C++ 在编译期，而 Python 在运行时，但是这两种语言都可以确保类型不会被误用，因此被认为是强类型的。[^5]潜在类型机制没有损害强类型机制。
46133: 4549:
46134: 4550:### Go 中的潜在类型
46135: 4551:
46136: 4552:这里用 Go 语言编写相同的程序：
46137: 4553:
46138: 4554:```go
46139: 4555:// generics/dogsandrobots.go
46140: 4556:
46141: 4557:package main
46142: 4558:import "fmt"
46143: 4559:
46144: 4560:type Dog struct {}
46145: 4561:func (this Dog) speak() { fmt.Printf("Arf!\n")}
46146: 4562:func (this Dog) sit() { fmt.Printf("Sitting\n")}
46147: 4563:func (this Dog) reproduce() {}
46148: 4564:
46149: 4565:type Robot struct {}
46150: 4566:func (this Robot) speak() { fmt.Printf("Click!\n") }
46151: 4567:func (this Robot) sit() { fmt.Printf("Clank!\n") }
46152: 4568:func (this Robot) oilChange() {}
46153: 4569:
46154: 4570:func perform(speaker interface { speak(); sit() }) {
46155: 4571:  speaker.speak();
46156: 4572:  speaker.sit();
46157: 4573:}
46158: 4574:
46159: 4575:func main() {
46160: 4576:  perform(Dog{})
46161: 4577:  perform(Robot{})
46162: 4578:}
46163: 4579:/* Output:
46164: 4580:Arf!
46165: 4581:Sitting
46166: 4582:Click!
46167: 4583:Clank!
46168: 4584:*/
46169: 4585:```
46170: 4586:
46171: 4587:Go 没有 **class** 关键字，但是可以使用上述形式创建等效的基本类：它通常不定义为类，而是定义为 **struct** ，在其中定义数据字段（此处不存在）。 对于每种方法，都以 **func** 关键字开头，然后（为了将该方法附加到您的类上）放在括号中，该括号包含对象引用，该对象引用可以是任何标识符，但是我在这里使用 **this** 来提醒您，就像在 C ++ 或 Java 中的 **this** 一样。 然后，在Go中像这样定义其余的函数。
46172: 4588:
46173: 4589:Go也没有继承关系，因此这种“面向对象的目标”形式是相对原始的，并且可能是我无法花更多的时间来学习该语言的主要原因。 但是，Go 的组成很简单。
46174: 4590:
46175: 4591:`perform()` 函数使用潜在类型：参数的确切类型并不重要，只要它包含了 `speak()` 和  `sit()` 方法即可。 该接口在此处匿名定义，内联，如 `perform()` 的参数列表所示。
46176: 4592:
46177: 4593:`main()` 证明 `perform()` 确实对其参数的确切类型不在乎，只要可以在该参数上调用 `talk()` 和 `sit()` 即可。 但是，就像 C ++ 模板函数一样，在编译时检查类型。
46178: 4594:
46179: 4595:语法 **Dog {}** 和 **Robot {}** 创建匿名的 **Dog** 和 **Robot** 结构。
46180: 4596:
46181: 4597:### java中的直接潜在类型
46182: 4598:
46183: 4599:因为泛型是在这场竞赛的后期才添加到 Java 中，因此没有任何机会可以去实现任何类型的潜在类型机制，因此 Java 没有对这种特性的支持。所以，初看起来，Java 的泛型机制比支持潜在类型机制的语言更“缺乏泛化性”。（使用擦除来实现 Java 泛型的实现有时称为第二类泛型类型）例如，在 Java 8  之前如果我们试图用 Java 实现上面 dogs-and-robots 的示例，那么就会被强制要求使用一个类或接口，并在边界表达式中指定它：
46184: 4600:
46185: 4601:```java
46186: 4602:// generics/Performs.java
46187: 4603:
46188: 4604:public interface Performs {
46189: 4605:    void speak();
46190: 4606:    void sit();
46191: 4607:}
46192: 4608:```
46193: 4609:
46194: 4610:```java
46195: 4611:// generics/DogsAndRobots.java
46196: 4612:// No (direct) latent typing in Java
46197: 4613:import typeinfo.pets.*;
46198: 4614:
46199: 4615:class PerformingDog extends Dog implements Performs {
46200: 4616:    @Override
46201: 4617:    public void speak() { System.out.println("Woof!"); }
46202: 4618:    @Override
46203: 4619:    public void sit() { System.out.println("Sitting"); }
46204: 4620:    public void reproduce() {}
46205: 4621:}
46206: 4622:
46207: 4623:class Robot implements Performs {
46208: 4624:    public void speak() { System.out.println("Click!"); }
46209: 4625:    public void sit() { System.out.println("Clank!"); }
46210: 4626:    public void oilChange() {}
46211: 4627:}
46212: 4628:
46213: 4629:class Communicate {
46214: 4630:    public static <T extends Performs>
46215: 4631:      void perform(T performer) {
46216: 4632:        performer.speak();
46217: 4633:        performer.sit();
46218: 4634:    }
46219: 4635:}
46220: 4636:
46221: 4637:public class DogsAndRobots {
46222: 4638:    public static void main(String[] args) {
46223: 4639:        Communicate.perform(new PerformingDog());
46224: 4640:        Communicate.perform(new Robot());
46225: 4641:    }
46226: 4642:}
46227: 4643:/* Output:
46228: 4644:Woof!
46229: 4645:Sitting
46230: 4646:Click!
46231: 4647:Clank!
46232: 4648:*/
46233: 4649:```
46234: 4650:
46235: 4651:但是要注意，`perform()` 不需要使用泛型来工作，它可以被简单地指定为接受一个 **Performs** 对象：
46236: 4652:
46237: 4653:```java
46238: 4654:// generics/SimpleDogsAndRobots.java
46239: 4655:// Removing the generic; code still works
46240: 4656:
46241: 4657:class CommunicateSimply {
46242: 4658:    static void perform(Performs performer) {
46243: 4659:        performer.speak();
46244: 4660:        performer.sit();
46245: 4661:    }
46246: 4662:}
46247: 4663:
46248: 4664:public class SimpleDogsAndRobots {
46249: 4665:    public static void main(String[] args) {
46250: 4666:        CommunicateSimply.perform(new PerformingDog());
46251: 4667:        CommunicateSimply.perform(new Robot());
46252: 4668:    }
46253: 4669:}
46254: 4670:/* Output:
46255: 4671:Woof!
46256: 4672:Sitting
46257: 4673:Click!
46258: 4674:Clank!
46259: 4675:*/
46260: 4676:```
46261: 4677:
46262: 4678:在本例中，泛型不是必需的，因为这些类已经被强制要求实现 **Performs** 接口。
46263: 4679:
46264: 4680:<!-- Compensating for the Lack of (Direct) Latent -->
46265: 4681:
46266: 4682:## 对缺乏潜在类型机制的补偿
46267: 4683:
46268: 4684:尽管 Java 不直接支持潜在类型机制，但是这并不意味着泛型代码不能在不同的类型层次结构之间应用。也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。
46269: 4685:
46270: 4686:### 反射
46271: 4687:
46272: 4688:可以使用的一种方式是反射，下面的 `perform()` 方法就是用了潜在类型机制：
46273: 4689:
46274: 4690:```java
46275: 4691:// generics/LatentReflection.java
46276: 4692:// Using reflection for latent typing
46277: 4693:import java.lang.reflect.*;
46278: 4694:
46279: 4695:// Does not implement Performs:
46280: 4696:class Mime {
46281: 4697:    public void walkAgainstTheWind() {}
46282: 4698:    public void sit() {
46283: 4699:        System.out.println("Pretending to sit");
46284: 4700:    }
46285: 4701:    public void pushInvisibleWalls() {}
46286: 4702:    @Override
46287: 4703:    public String toString() { return "Mime"; }
46288: 4704:}
46289: 4705:
46290: 4706:// Does not implement Performs:
46291: 4707:class SmartDog {
46292: 4708:    public void speak() { System.out.println("Woof!"); }
46293: 4709:    public void sit() { System.out.println("Sitting"); }
46294: 4710:    public void reproduce() {}
46295: 4711:}
46296: 4712:
46297: 4713:class CommunicateReflectively {
46298: 4714:    public static void perform(Object speaker) {
46299: 4715:        Class<?> spkr = speaker.getClass();
46300: 4716:        try {
46301: 4717:            try {
46302: 4718:                Method speak = spkr.getMethod("speak");
46303: 4719:                speak.invoke(speaker);
46304: 4720:            } catch(NoSuchMethodException e) {
46305: 4721:                System.out.println(speaker + " cannot speak");
46306: 4722:            }
46307: 4723:            try {
46308: 4724:                Method sit = spkr.getMethod("sit");
46309: 4725:                sit.invoke(speaker);
46310: 4726:            } catch(NoSuchMethodException e) {
46311: 4727:                System.out.println(speaker + " cannot sit");
46312: 4728:            }
46313: 4729:        } catch(SecurityException |
46314: 4730:            IllegalAccessException |
46315: 4731:            IllegalArgumentException |
46316: 4732:            InvocationTargetException e) {
46317: 4733:            throw new RuntimeException(speaker.toString(), e);
46318: 4734:        }
46319: 4735:    }
46320: 4736:}
46321: 4737:
46322: 4738:public class LatentReflection {
46323: 4739:    public static void main(String[] args) {
46324: 4740:        CommunicateReflectively.perform(new SmartDog());
46325: 4741:        CommunicateReflectively.perform(new Robot());
46326: 4742:        CommunicateReflectively.perform(new Mime());
46327: 4743:    }
46328: 4744:}
46329: 4745:/* Output:
46330: 4746:Woof!
46331: 4747:Sitting
46332: 4748:Click!
46333: 4749:Clank!
46334: 4750:Mime cannot speak
46335: 4751:Pretending to sit
46336: 4752:*/
46337: 4753:```
46338: 4754:
46339: 4755:上例中，这些类完全是彼此分离的，没有任何公共基类（除了 **Object** ）或接口。通过反射, `CommunicateReflectively.perform()` 能够动态地确定所需要的方法是否可用并调用它们。它甚至能够处理 **Mime** 只具有一个必需的方法这一事实，并能够部分实现其目标。
46340: 4756:
46341: 4757:### 将一个方法应用于序列
46342: 4758:
46343: 4759:反射提供了一些有用的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。但是有可能实现编译期类型检查和潜在类型机制吗？
46344: 4760:
46345: 4761:让我们看一个说明这个问题的示例。假设想要创建一个 `apply()` 方法，它能够将任何方法应用于某个序列中的所有对象。这种情况下使用接口不适合，因为你想要将任何方法应用于一个对象集合，而接口不可能描述任何方法。如何用 Java 来实现这个需求呢？
46346: 4762:
46347: 4763:最初，我们可以用反射来解决这个问题，由于有了 Java 的可变参数，这种方式被证明是相当优雅的：
46348: 4764:
46349: 4765:```java
46350: 4766:// generics/Apply.java
46351: 4767:
46352: 4768:import java.lang.reflect.*;
46353: 4769:import java.util.*;
46354: 4770:
46355: 4771:public class Apply {
46356: 4772:    public static <T, S extends Iterable<T>>
46357: 4773:      void apply(S seq, Method f, Object... args) {
46358: 4774:        try {
46359: 4775:            for(T t: seq)
46360: 4776:                f.invoke(t, args);
46361: 4777:        } catch(IllegalAccessException |
46362: 4778:            IllegalArgumentException |
46363: 4779:            InvocationTargetException e) {
46364: 4780:            // Failures are programmer errors
46365: 4781:            throw new RuntimeException(e);
46366: 4782:        }
46367: 4783:    }
46368: 4784:}
46369: 4785:```
46370: 4786:
46371: 4787:在 **Apply.java** 中，异常被转换为 **RuntimeException** ，因为没有多少办法可以从这种异常中恢复——在这种情况下，它们实际上代表着程序员的错误。
46372: 4788:
46373: 4789:为什么我们不只使用 Java 8 方法参考（稍后显示）而不是反射方法 **f** ？ 注意，`invoke()` 和 `apply()` 的优点是它们可以接受任意数量的参数。 在某些情况下，灵活性可能至关重要。
46374: 4790:
46375: 4791:为了测试 **Apply** ，我们首先创建一个 **Shape** 类：
46376: 4792:
46377: 4793:```java
46378: 4794:// generics/Shape.java
46379: 4795:
46380: 4796:public class Shape {
46381: 4797:    private static long counter = 0;
46382: 4798:    private final long id = counter++;
46383: 4799:    @Override
46384: 4800:    public String toString() {
46385: 4801:        return getClass().getSimpleName() + " " + id;
46386: 4802:    }
46387: 4803:    public void rotate() {
46388: 4804:        System.out.println(this + " rotate");
46389: 4805:    }
46390: 4806:    public void resize(int newSize) {
46391: 4807:        System.out.println(this + " resize " + newSize);
46392: 4808:    }
46393: 4809:}
46394: 4810:```
46395: 4811:
46396: 4812:被一个子类 **Square** 继承：
46397: 4813:
46398: 4814:```java
46399: 4815:// generics/Square.java
46400: 4816:
46401: 4817:public class Square extends Shape {}
46402: 4818:```
46403: 4819:
46404: 4820:通过这些，我们可以测试 **Apply**：
46405: 4821:
46406: 4822:```java
46407: 4823:// generics/ApplyTest.java
46408: 4824:
46409: 4825:import java.util.*;
46410: 4826:import java.util.function.*;
46411: 4827:import onjava.*;
46412: 4828:
46413: 4829:public class ApplyTest {
46414: 4830:    public static
46415: 4831:    void main(String[] args) throws Exception {
46416: 4832:        List<Shape> shapes =
46417: 4833:          Suppliers.create(ArrayList::new, Shape::new, 3);
46418: 4834:        Apply.apply(shapes, Shape.class.getMethod("rotate"));
46419: 4835:        Apply.apply(shapes, Shape.class.getMethod("resize", int.class), 7);
46420: 4836:
46421: 4837:        List<Square> squares =
46422: 4838:          Suppliers.create(ArrayList::new, Square::new, 3);
46423: 4839:        Apply.apply(squares, Shape.class.getMethod("rotate"));
46424: 4840:        Apply.apply(squares, Shape.class.getMethod("resize", int.class), 7);
46425: 4841:
46426: 4842:        Apply.apply(new FilledList<>(Shape::new, 3),
46427: 4843:          Shape.class.getMethod("rotate"));
46428: 4844:        Apply.apply(new FilledList<>(Square::new, 3),
46429: 4845:          Shape.class.getMethod("rotate"));
46430: 4846:
46431: 4847:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
46432: 4848:          new SimpleQueue<>(), SimpleQueue::add,
46433: 4849:          Shape::new, 3);
46434: 4850:        Suppliers.fill(shapeQ, SimpleQueue::add,
46435: 4851:          Square::new, 3);
46436: 4852:        Apply.apply(shapeQ, Shape.class.getMethod("rotate"));
46437: 4853:    }
46438: 4854:}
46439: 4855:/* Output:
46440: 4856:Shape 0 rotate
46441: 4857:Shape 1 rotate
46442: 4858:Shape 2 rotate
46443: 4859:Shape 0 resize 7
46444: 4860:Shape 1 resize 7
46445: 4861:Shape 2 resize 7
46446: 4862:Square 3 rotate
46447: 4863:Square 4 rotate
46448: 4864:Square 5 rotate
46449: 4865:Square 3 resize 7
46450: 4866:Square 4 resize 7
46451: 4867:Square 5 resize 7
46452: 4868:Shape 6 rotate
46453: 4869:Shape 7 rotate
46454: 4870:Shape 8 rotate
46455: 4871:Square 9 rotate
46456: 4872:Square 10 rotate
46457: 4873:Square 11 rotate
46458: 4874:Shape 12 rotate
46459: 4875:Shape 13 rotate
46460: 4876:Shape 14 rotate
46461: 4877:Square 15 rotate
46462: 4878:Square 16 rotate
46463: 4879:Square 17 rotate
46464: 4880:*/
46465: 4881:```
46466: 4882:
46467: 4883:在 **Apply** 中，我们运气很好，因为碰巧在 Java 中内建了一个由 Java 集合类库使用的 **Iterable** 接口。正由于此， `apply()` 方法可以接受任何实现了 **Iterable** 接口的事物，包括诸如 **List** 这样的所有 **Collection** 类。但是它还可以接受其他任何事物，只要能够使这些事物是 **Iterable** 的——例如，在 `main()` 中使用下面定义的 **SimpleQueue** 类：
46468: 4884:
46469: 4885:```java
46470: 4886:// generics/SimpleQueue.java
46471: 4887:
46472: 4888:// A different kind of Iterable collection
46473: 4889:import java.util.*;
46474: 4890:
46475: 4891:public class SimpleQueue<T> implements Iterable<T> {
46476: 4892:    private LinkedList<T> storage = new LinkedList<>();
46477: 4893:    public void add(T t) { storage.offer(t); }
46478: 4894:    public T get() { return storage.poll(); }
46479: 4895:    @Override
46480: 4896:    public Iterator<T> iterator() {
46481: 4897:        return storage.iterator();
46482: 4898:    }
46483: 4899:}
46484: 4900:```
46485: 4901:
46486: 4902:正如反射解决方案看起来那样优雅，我们必须观察到反射（尽管在 Java 的最新版本中得到了显着改进）通常比非反射实现要慢，因为在运行时发生了很多事情。 但它不应阻止您尝试这种解决方案，这依然是值得考虑的一点。
46487: 4903:
46488: 4904:几乎可以肯定，你会首先使用 Java 8 的函数式方法，并且只有在解决了特殊需求时才诉诸反射。 这里对 **ApplyTest.java** 进行了重写，以利用 Java 8 的流和函数工具：
46489: 4905:
46490: 4906:```java
46491: 4907:// generics/ApplyFunctional.java
46492: 4908:
46493: 4909:import java.util.*;
46494: 4910:import java.util.stream.*;
46495: 4911:import java.util.function.*;
46496: 4912:import onjava.*;
46497: 4913:
46498: 4914:public class ApplyFunctional {
46499: 4915:    public static void main(String[] args) {
46500: 4916:        Stream.of(
46501: 4917:          Stream.generate(Shape::new).limit(2),
46502: 4918:          Stream.generate(Square::new).limit(2))
46503: 4919:        .flatMap(c -> c) // flatten into one stream
46504: 4920:        .peek(Shape::rotate)
46505: 4921:        .forEach(s -> s.resize(7));
46506: 4922:
46507: 4923:        new FilledList<>(Shape::new, 2)
46508: 4924:          .forEach(Shape::rotate);
46509: 4925:        new FilledList<>(Square::new, 2)
46510: 4926:          .forEach(Shape::rotate);
46511: 4927:
46512: 4928:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
46513: 4929:          new SimpleQueue<>(), SimpleQueue::add,
46514: 4930:          Shape::new, 2);
46515: 4931:        Suppliers.fill(shapeQ, SimpleQueue::add,
46516: 4932:          Square::new, 2);
46517: 4933:        shapeQ.forEach(Shape::rotate);
46518: 4934:    }
46519: 4935:}
46520: 4936:/* Output:
46521: 4937:Shape 0 rotate
46522: 4938:Shape 0 resize 7
46523: 4939:Shape 1 rotate
46524: 4940:Shape 1 resize 7
46525: 4941:Square 2 rotate
46526: 4942:Square 2 resize 7
46527: 4943:Square 3 rotate
46528: 4944:Square 3 resize 7
46529: 4945:Shape 4 rotate
46530: 4946:Shape 5 rotate
46531: 4947:Square 6 rotate
46532: 4948:Square 7 rotate
46533: 4949:Shape 8 rotate
46534: 4950:Shape 9 rotate
46535: 4951:Square 10 rotate
46536: 4952:Square 11 rotate
46537: 4953:*/
46538: 4954:```
46539: 4955:
46540: 4956:由于使用 Java 8，因此不需要 `Apply.apply()` 。
46541: 4957:
46542: 4958:我们首先生成两个 **Stream** ： 一个是 **Shape** ，一个是 **Square** ，并将它们展平为单个流。 尽管 Java 缺少功能语言中经常出现的 `flatten()` ，但是我们可以使用 `flatMap(c-> c)` 产生相同的结果，后者使用身份映射将操作简化为“  **flatten** ”。
46543: 4959:
46544: 4960:我们使用 `peek()` 当做对 `rotate()` 的调用，因为 `peek()` 执行一个操作（此处是出于副作用），并在未更改的情况下传递对象。
46545: 4961:
46546: 4962:注意，使用 **FilledList** 和 **shapeQ** 调用 `forEach()` 比 `Apply.apply()` 代码整洁得多。 在代码简单性和可读性方面，结果比以前的方法好得多。 并且，现在也不可能从  `main()` 引发异常。
46547: 4963:
46548: 4964:<!-- Assisted Latent Typing in Java 8 -->
46549: 4965:
46550: 4966:## Java8 中的辅助潜在类型
46551: 4967:
46552: 4968:先前声明关于 Java 缺乏对潜在类型的支持在 Java 8 之前是完全正确的。但是，Java 8 中的非绑定方法引用使我们能够产生一种潜在类型的形式，以满足创建一段可工作在不相干类型上的代码。因为 Java 最初并不是如此设计，所以结果可想而知，比其他语言中要尴尬一些。但是，至少现在成为了可能，只是缺乏令人惊艳之处。
46553: 4969:
46554: 4970:我在其他地方从没遇过这种技术，因此我将其称为辅助潜在类型。
46555: 4971:
46556: 4972:我们将重写 **DogsAndRobots.java** 来演示该技术。 为使外观看起来与原始示例尽可能相似，我仅向每个原始类名添加了 **A**：
46557: 4973:
46558: 4974:```java
46559: 4975:// generics/DogsAndRobotMethodReferences.java
46560: 4976:
46561: 4977:// "Assisted Latent Typing"
46562: 4978:import typeinfo.pets.*;
46563: 4979:import java.util.function.*;
46564: 4980:
46565: 4981:class PerformingDogA extends Dog {
46566: 4982:    public void speak() { System.out.println("Woof!"); }
46567: 4983:    public void sit() { System.out.println("Sitting"); }
46568: 4984:    public void reproduce() {}
46569: 4985:}
46570: 4986:
46571: 4987:class RobotA {
46572: 4988:    public void speak() { System.out.println("Click!"); }
46573: 4989:    public void sit() { System.out.println("Clank!"); }
46574: 4990:    public void oilChange() {}
46575: 4991:}
46576: 4992:
46577: 4993:class CommunicateA {
46578: 4994:    public static <P> void perform(P performer,
46579: 4995:      Consumer<P> action1, Consumer<P> action2) {
46580: 4996:        action1.accept(performer);
46581: 4997:        action2.accept(performer);
46582: 4998:    }
46583: 4999:}
46584: 5000:
46585: 5001:public class DogsAndRobotMethodReferences {
46586: 5002:    public static void main(String[] args) {
46587: 5003:        CommunicateA.perform(new PerformingDogA(),
46588: 5004:          PerformingDogA::speak, PerformingDogA::sit);
46589: 5005:        CommunicateA.perform(new RobotA(),
46590: 5006:          RobotA::speak, RobotA::sit);
46591: 5007:        CommunicateA.perform(new Mime(),
46592: 5008:          Mime::walkAgainstTheWind,
46593: 5009:          Mime::pushInvisibleWalls);
46594: 5010:    }
46595: 5011:}
46596: 5012:/* Output:
46597: 5013:Woof!
46598: 5014:Sitting
46599: 5015:Click!
46600: 5016:Clank!
46601: 5017:*/
46602: 5018:```
46603: 5019:
46604: 5020:**PerformingDogA** 和 **RobotA** 与 **DogsAndRobots.java** 中的相同，不同之处在于它们不继承通用接口 **Performs** ，因此它们没有通用性。
46605: 5021:
46606: 5022:`CommunicateA.perform()` 在没有约束的 **P** 上生成。 只要可以使用 `Consumer <P>`，它在这里就可以是任何东西，这些 `Consumer<P>` 代表不带参数的 **P** 方法的未绑定方法引用。当您调用 **Consumer**  的 `accept()` 方法时，它将方法引用绑定到执行者对象并调用该方法。 由于 [函数式编程](book/13-Functional-Programming.md) 一章中描述的“魔术”，我们可以将任何符合签名的未绑定方法引用传递给 `CommunicateA.perform()` 。
46607: 5023:
46608: 5024:之所以称其为“辅助”，是因为您必须显式地为 `perform()` 提供要使用的方法引用。 它不能只按名称调用方法。
46609: 5025:
46610: 5026:尽管传递未绑定的方法引用似乎要花很多力气，但潜在类型的最终目标还是可以实现的。 我们创建了一个代码片段 `CommunicateA.perform()` ，该代码可用于任何具有符合签名的方法引用的类型。 请注意，这与我们看到的其他语言中的潜在类型有所不同，因为这些语言不仅需要签名以符合规范，还需要方法名称。 因此，该技术可以说产生了更多的通用代码。
46611: 5027:
46612: 5028:为了证明这一点，我还从 **LatentReflection.java** 中引入了 **Mime**。
46613: 5029:
46614: 5030:### 使用**Suppliers**类的通用方法
46615: 5031:
46616: 5032:通过辅助潜在类型，我们可以定义本章其他部分中使用的 **Suppliers** 类。 此类包含使用生成器填充 **Collection** 的工具方法。 泛化这些操作很有意义：
46617: 5033:
46618: 5034:```java
46619: 5035:// onjava/Suppliers.java
46620: 5036:
46621: 5037:// A utility to use with Suppliers
46622: 5038:package onjava;
46623: 5039:import java.util.*;
46624: 5040:import java.util.function.*;
46625: 5041:import java.util.stream.*;
46626: 5042:
46627: 5043:public class Suppliers {
46628: 5044:    // Create a collection and fill it:
46629: 5045:    public static <T, C extends Collection<T>> C
46630: 5046:      create(Supplier<C> factory, Supplier<T> gen, int n) {
46631: 5047:        return Stream.generate(gen)
46632: 5048:            .limit(n)
46633: 5049:            .collect(factory, C::add, C::addAll);
46634: 5050:    }
46635: 5051:    
46636: 5052:    // Fill an existing collection:
46637: 5053:    public static <T, C extends Collection<T>>
46638: 5054:      C fill(C coll, Supplier<T> gen, int n) {
46639: 5055:        Stream.generate(gen)
46640: 5056:            .limit(n)
46641: 5057:            .forEach(coll::add);
46642: 5058:        return coll;
46643: 5059:    }
46644: 5060:    
46645: 5061:    // Use an unbound method reference to
46646: 5062:    // produce a more general method:
46647: 5063:    public static <H, A> H fill(H holder,
46648: 5064:      BiConsumer<H, A> adder, Supplier<A> gen, int n) {
46649: 5065:        Stream.generate(gen)
46650: 5066:            .limit(n)
46651: 5067:            .forEach(a -> adder.accept(holder, a));
46652: 5068:        return holder;
46653: 5069:    }
46654: 5070:}
46655: 5071:```
46656: 5072:
46657: 5073:`create()` 为你创建一个新的 **Collection** 子类型，而 `fill()` 的第一个版本将元素放入 **Collection** 的现有子类型中。 请注意，还会返回传入的容器的确切类型，因此不会丢失类型信息。[^6]
46658: 5074:
46659: 5075:前两种方法一般都受约束，只能与 **Collection** 子类型一起使用。`fill()` 的第二个版本适用于任何类型的 **holder** 。 它需要一个附加参数：未绑定方法引用 `adder. fill()` ，使用辅助潜在类型来使其与任何具有添加元素方法的 **holder** 类型一起使用。因为此未绑定方法 **adder** 必须带有一个参数（要添加到 **holder** 的元素），所以 **adder** 必须是 `BiConsumer <H，A>` ，其中 **H** 是要绑定到的 **holder** 对象的类型，而 **A** 是要被添加的绑定元素类型。 对 `accept()` 的调用将使用参数 a 调用对象 **holder** 上的未绑定方法 **holder**。
46660: 5076:
46661: 5077:在一个稍作模拟的测试中对 **Suppliers** 工具程序进行了测试，该仿真还使用了本章前面定义的 **RandomList** ：
46662: 5078:
46663: 5079:```java
46664: 5080:// generics/BankTeller.java
46665: 5081:
46666: 5082:// A very simple bank teller simulation
46667: 5083:import java.util.*;
46668: 5084:import onjava.*;
46669: 5085:
46670: 5086:class Customer {
46671: 5087:    private static long counter = 1;
46672: 5088:    private final long id = counter++;
46673: 5089:    @Override
46674: 5090:    public String toString() {
46675: 5091:        return "Customer " + id;
46676: 5092:    }
46677: 5093:}
46678: 5094:
46679: 5095:class Teller {
46680: 5096:    private static long counter = 1;
46681: 5097:    private final long id = counter++;
46682: 5098:    @Override
46683: 5099:    public String toString() {
46684: 5100:        return "Teller " + id;
46685: 5101:    }
46686: 5102:}
46687: 5103:
46688: 5104:class Bank {
46689: 5105:    private List<BankTeller> tellers =
46690: 5106:        new ArrayList<>();
46691: 5107:    public void put(BankTeller bt) {
46692: 5108:        tellers.add(bt);
46693: 5109:    }
46694: 5110:}
46695: 5111:
46696: 5112:public class BankTeller {
46697: 5113:    public static void serve(Teller t, Customer c) {
46698: 5114:        System.out.println(t + " serves " + c);
46699: 5115:    }
46700: 5116:    public static void main(String[] args) {
46701: 5117:        // Demonstrate create():
46702: 5118:        RandomList<Teller> tellers =
46703: 5119:            Suppliers.create(
46704: 5120:            RandomList::new, Teller::new, 4);
46705: 5121:        // Demonstrate fill():
46706: 5122:        List<Customer> customers = Suppliers.fill(
46707: 5123:            new ArrayList<>(), Customer::new, 12);
46708: 5124:        customers.forEach(c ->
46709: 5125:            serve(tellers.select(), c));
46710: 5126:        // Demonstrate assisted latent typing:
46711: 5127:        Bank bank = Suppliers.fill(
46712: 5128:            new Bank(), Bank::put, BankTeller::new, 3);
46713: 5129:        // Can also use second version of fill():
46714: 5130:        List<Customer> customers2 = Suppliers.fill(
46715: 5131:            new ArrayList<>(),
46716: 5132:            List::add, Customer::new, 12);
46717: 5133:    }
46718: 5134:}
46719: 5135:/* Output:
46720: 5136:Teller 3 serves Customer 1
46721: 5137:Teller 2 serves Customer 2
46722: 5138:Teller 3 serves Customer 3
46723: 5139:Teller 1 serves Customer 4
46724: 5140:Teller 1 serves Customer 5
46725: 5141:Teller 3 serves Customer 6
46726: 5142:Teller 1 serves Customer 7
46727: 5143:Teller 2 serves Customer 8
46728: 5144:Teller 3 serves Customer 9
46729: 5145:Teller 3 serves Customer 10
46730: 5146:Teller 2 serves Customer 11
46731: 5147:Teller 4 serves Customer 12
46732: 5148:*/
46733: 5149:```
46734: 5150:
46735: 5151:可以看到 `create()` 生成一个新的 **Collection** 对象，而 `fill()` 添加到现有 **Collection** 中。第二个版本`fill()` 显示，它不仅与无关的新类型 **Bank** 一起使用，还能与 **List** 一起使用。因此，从技术上讲，`fill()` 的第一个版本在技术上不是必需的，但在使用 **Collection** 时提供了较短的语法。
46736: 5152:
46737: 5153:<!-- Summary: Is Casting Really So Bad? -->
46738: 5154:
46739: 5155:## 总结：类型转换真的如此之糟吗？
46740: 5156:
46741: 5157:自从 C++ 模版出现以来，我就一直在致力于解释它，我可能比大多数人都更早地提出了下面的论点。直到最近，我才停下来，去思考这个论点到底在多少时间内是有效的——我将要描述的问题到底有多少次可以穿越障碍得以解决。
46742: 5158:
46743: 5159:这个论点就是：使用泛型类型机制的最吸引人的地方，就是在使用集合类的地方，这些类包括诸如各种 **List** 、各种 **Set** 、各种 **Map** 等你在 [集合](book/12-Collections.md) 和 [附录：集合主题](book/Appendix-Collection-Topics.md) 这两章所见。在 Java 5 之前，当你将一个对象放置到集合中时，这个对象就会被向上转型为 **Object** ，因此你会丢失类型信息。当你想要将这个对象从集合中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。我用的示例是持有 **Cat** 的 **List** （这个示例的一种使用苹果和桔子的变体在 [集合](book/12-Collections.md) 章节的开头展示过）。如果没有 Java 5 泛型版本的集合，你放到容集里和从集合中取回的都是 **Object** 。因此，我们很可能会将一个 **Dog** 放置到 **Cat** 的 **List** 中。
46744: 5160:
46745: 5161:但是，泛型出现之前的 Java 并不会让你误用放入到集合中的对象。如果将一个 **Dog** 扔到 **Cat** 的集合中，并且试图将这个集合中的所有东西都当作 **Cat** 处理，那么当你从这个 **Cat** 集合中取回那个 **Dog** 引用，并试图将其转型为 **Cat** 时，就会得到一个 **RuntimeException** 。你仍旧可以发现问题，但是是在运行时而非编译期发现它的。
46746: 5162:
46747: 5163:在本书以前的版本中，我曾经说过：
46748: 5164:
46749: 5165:> 这不止令人恼火，它还可能会产生难以发现的缺陷。如果这个程序的某个部分（或数个部分）向集合中插入了对象，并且通过异常，你在程序的另一个独立的部分中发现有不良对象被放置到了集合中，那么必须发现这个不良插入到底是在何处发生的。
46750: 5166:
46751: 5167:但是，随着对这个论点的进一步检查，我开始怀疑它了。首先，这会多么频繁地发生呢？我记得这类事情从未发生在我身上，并且当我在会议上询问其他人时，我也从来没有听说过有人碰上过。另一本书使用了一个称为 **files** 的 list 示例，它包含 **String** 对象。在这个示例中，向 **files** 中添加一个 **File** 对象看起来相当自然，因此这个对象的名字可能叫 **fileNames** 更好。无论 Java 提供了多少类型检查，仍旧可能会写出晦涩的程序，而编写差劲儿的程序即便可以编译，它仍旧是编写差劲儿的程序。可能大多数人都会使用命名良好的集合，例如 **cats** ，因为它们可以向试图添加非 **Cat** 对象的程序员提供可视的警告。并且即便这类事情发生了，它真正又能潜伏多久呢？只要你开始用真实数据来运行测试，就会非常快地看到异常。
46752: 5168:
46753: 5169:有一位作者甚至断言，这样的缺陷将“*潜伏数年*”。但是我不记得有任何大量的相关报告，来说明人们在查找“狗在猫列表中”这类缺陷时困难重重，或者是说明人们会非常频繁地产生这种错误。然而，你将在 [多线程编程](book/24-Concurrent-Programming.md) 章节中看到，在使用线程时，出现那些可能看起来极罕见的缺陷，是很寻常并容易发生的事，而且，对于到底出了什么错，这些缺陷只能给你一个很模糊的概念。因此，对于泛型是添加到 Java 中的非常显著和相当复杂的特性这一点，“狗在猫列表中”这个论据真的能够成为它的理由吗？
46754: 5170:我相信被称为*泛型*的通用语言特性（并非必须是其在 Java 中的特定实现）的目的在于可表达性，而不仅仅是为了创建类型安全的集合。类型安全的集合是能够创建更通用代码这一能力所带来的副作用。
46755: 5171:因此，即便“狗在猫列表中”这个论据经常被用来证明泛型是必要的，但是它仍旧是有问题的。就像我在本章开头声称的，我不相信这就是泛型这个概念真正的含义。相反，泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。正如你在本章中看到的，编写真正泛化的“持有器”类（ Java 的容器就是这种类）相当简单，但是编写出能够操作其泛型类型的泛化代码就需要额外的努力了，这些努力需要类创建者和类消费者共同付出，他们必须理解这些代码的概念和实现。这些额外的努力会增加使用这种特性的难度，并可能会因此而使其在某些场合缺乏可应用性，而在这些场合中，它可能会带来附加的价值。
46756: 5172:
46757: 5173:还要注意到，因为泛型是后来添加到 Java 中，而不是从一开始就设计到这种语言中的，所以某些容器无法达到它们应该具备的健壮性。例如，观察一下 **Map** ，在特定的方法 `containsKey(Object key) `和 `get(Object key)` 中就包含这类情况。如果这些类是使用在它们之前就存在的泛型设计的，那么这些方法将会使用参数化类型而不是 **Object** ，因此也就可以提供这些泛型假设会提供的编译期检查。例如，在 C++ 的 **map** 中，键的类型总是在编译期检查的。
46758: 5174:
46759: 5175:有一件事很明显：在一种语言已经被广泛应用之后，在其较新的版本中引入任何种类的泛型机制，都会是一项非常非常棘手的任务，并且是一项不付出艰辛就无法完成的任务。在 C++ 中，模版是在其最初的 ISO 版本中就引入的（即便如此，也引发了阵痛，因为在第一个标准 C++ 出现之前，有很多非模版版本在使用），因此实际上模版一直都是这种语言的一部分。在 Java 中，泛型是在这种语言首次发布大约 10 年之后才引入的，因此向泛型迁移的问题特别多，并且对泛型的设计产生了明显的影响。其结果就是，程序员将承受这些痛苦，而这一切都是由于 Java 设计者在设计 1.0 版本时所表现出来的短视造成的。当 Java 最初被创建时，它的设计者们当然了解 C++ 的模版，他们甚至考虑将其囊括到 Java 语言中，但是出于这样或那样的原因，他们决定将模版排除在外（其迹象就是他们过于匆忙）。因此， Java 语言和使用它的程序员都将承受这些痛苦。只有时间将会说明 Java 的泛型方式对这种语言所造成的最终影响。
46760: 5176:某些语言，已经融入了更简洁、影响更小的方式，来实现参数化类型。我们不可能不去想象这样的语言将会成为 Java 的继任者，因为它们采用的方式，与 C++ 通过 C 来实现的方式相同：按原样使用它，然后对其进行改进。
46761: 5177:
46762: 5178:## 进阶阅读
46763: 5179:
46764: 5180:泛型的入门文档是 《Generics in the Java Programming Language》，作者是 Gilad Bracha，可以从 http://java.oracle.com 获取。
46765: 5181:
46766: 5182:Angelika Langer 的《Java Generics FAQs》是一份非常有帮助的资料，可以从 http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html 获取。
46767: 5183:
46768: 5184:你可以从 《Adding Wildcards to the Java Programming Language》中学到更多关于通配符的知识，作者是 Torgerson、Ernst、Hansen、von der Ahe、Bracha 和 Gafter，地址是 http://www.jot.fm/issues/issue_2004_12/article5。
46769: 5185:
46770: 5186:Neal After 对于 Java 问题（尤其是擦除）的看法可以从这里找到：http://www.infoq.com/articles/neal-gafter-on-java。
46771: 5187:
46772: 5188:[^1]: 在编写本章期间，Angelika Langer的 Java 泛型常见问题解答以及她的其他著作（与Klaus Kreft一起）是非常宝贵的。
46773: 5189:[^2]: [http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html](http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html)
46774: 5190:[^3]: 参见本章章末引文。
46775: 5191:[^4]: 注意，一些编程环境，如 Eclipse 和 IntelliJ IDEA，将会自动生成委托代码。
46776: 5192:[^5]: 因为可以使用转型，有效地禁止了类型系统，一些人就认为 C++ 是弱类型，但这太极端了。一种可能更好的说法是 C++ 是有一道暗门的强类型语言。
46777: 5193:[^6]: 我再次从 Brian Goetz 那获得帮助。
46778: 5194:
46779: 5195:<!-- 分页 -->
46780: 5196:
46781: 5197:<div style="page-break-after: always;"></div>
46782: 
46783: 1:[TOC]
46784: 2:
46785: 3:<!-- Generics -->
46786: 4:
46787: 5:# 第二十章 泛型
46788: 6:
46789: 7:> 普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。
46790: 8:
46791: 9:多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着更大的灵活性。除了 `final` 类（或只提供私有构造函数的类）任何类型都可被扩展，所以大部分时候这种灵活性是自带的。
46792: 10:
46793: 11:拘泥于单一的继承体系太过局限，因为只有继承体系中的对象才能适用基类作为参数的方法中。如果方法以接口而不是类作为参数，限制就宽松多了，只要实现了接口就可以。这给予调用方一种选项，通过调整现有的类来实现接口，满足方法参数要求。接口可以突破继承体系的限制。
46794: 12:
46795: 13:即便是接口也还是有诸多限制。一旦指定了接口，它就要求你的代码必须使用特定的接口。而我们希望编写更通用的代码，能够适用“非特定的类型”，而不是一个具体的接口或类。
46796: 14:
46797: 15:这就是泛型的概念，是 Java 5 的重大变化之一。泛型实现了*参数化类型*，这样你编写的组件（通常是集合）可以适用于多种类型。“泛型”这个术语的含义是“适用于很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。随后你会发现 Java 中泛型的实现并没有那么“泛”，你可能会质疑“泛型”这个词是否合适用来描述这一功能。
46798: 16:
46799: 17:如果你从未接触过参数化类型机制，你会发现泛型对 Java 语言确实是个很有益的补充。在你实例化一个类型参数时，编译器会负责转型并确保类型的正确性。这是一大进步。
46800: 18:
46801: 19:然而，如果你了解其他语言（例如 C++ ）的参数化机制，你会发现，Java 泛型并不能满足所有的预期。使用别人创建好的泛型相对容易，但是创建自己的泛型时，就会遇到很多意料之外的麻烦。
46802: 20:
46803: 21:这并不是说 Java 泛型毫无用处。在很多情况下，它可以使代码更直接更优雅。不过，如果你见识过那种实现了更纯粹的泛型的编程语言，那么，Java 可能会令你失望。本章会介绍 Java 泛型的优点与局限。我会解释 Java 的泛型是如何发展成现在这样的，希望能够帮助你更有效地使用这个特性。[^1]
46804: 22:
46805: 23:### 与 C++ 的比较
46806: 24:
46807: 25:Java 的设计者曾说过，这门语言的灵感主要来自 C++ 。尽管如此，学习 Java 时基本不用参考 C++ 。
46808: 26:
46809: 27:但是，Java 中的泛型需要与 C++ 进行对比，理由有两个：首先，理解 C++ *模板*（泛型的主要灵感来源，包括基本语法）的某些特性，有助于理解泛型的基础理念。同时，非常重要的一点是，你可以了解 Java 泛型的局限是什么，以及为什么会有这些局限。最终的目标是明确 Java 泛型的边界，让你成为一个程序高手。只有知道了某个技术不能做什么，你才能更好地做到所能做的（部分原因是，不必浪费时间在死胡同里）。
46810: 28:
46811: 29:第二个原因是，在 Java 社区中，大家普遍对 C++ 模板有一种误解，而这种误解可能会令你在理解泛型的意图时产生偏差。
46812: 30:
46813: 31:因此，本章中会介绍少量 C++ 模板的例子，仅当它们确实可以加深理解时才会引入。
46814: 32:
46815: 33:<!-- Simple Generics -->
46816: 34:
46817: 35:## 简单泛型
46818: 36:
46819: 37:促成泛型出现的最主要的动机之一是为了创建*集合类*，参见 [集合](book/12-Collections.md) 章节。集合用于存放要使用到的对象。数组也是如此，不过集合比数组更加灵活，功能更丰富。几乎所有程序在运行过程中都会涉及到一组对象，因此集合是可复用性最高的类库之一。
46820: 38:
46821: 39:我们先看一个只能持有单个对象的类。这个类可以明确指定其持有的对象的类型：
46822: 40:
46823: 41:```java
46824: 42:// generics/Holder1.java
46825: 43:
46826: 44:class Automobile {}
46827: 45:
46828: 46:public class Holder1 {
46829: 47:    private Automobile a;
46830: 48:    public Holder1(Automobile a) { this.a = a; }
46831: 49:    Automobile get() { return a; }
46832: 50:}
46833: 51:```
46834: 52:
46835: 53:这个类的可复用性不高，它无法持有其他类型的对象。我们可不希望为碰到的每个类型都编写一个新的类。
46836: 54:
46837: 55:在 Java 5 之前，我们可以让这个类直接持有 `Object` 类型的对象：
46838: 56:
46839: 57:```java
46840: 58:// generics/ObjectHolder.java
46841: 59:
46842: 60:public class ObjectHolder {
46843: 61:    private Object a;
46844: 62:    public ObjectHolder(Object a) { this.a = a; }
46845: 63:    public void set(Object a) { this.a = a; }
46846: 64:    public Object get() { return a; }
46847: 65:    
46848: 66:    public static void main(String[] args) {
46849: 67:        ObjectHolder h2 = new ObjectHolder(new Automobile());
46850: 68:        Automobile a = (Automobile)h2.get();
46851: 69:        h2.set("Not an Automobile");
46852: 70:        String s = (String)h2.get();
46853: 71:        h2.set(1); // 自动装箱为 Integer
46854: 72:        Integer x = (Integer)h2.get();
46855: 73:    }
46856: 74:}
46857: 75:```
46858: 76:
46859: 77:现在，`ObjectHolder` 可以持有任何类型的对象，在上面的示例中，一个 `ObjectHolder` 先后持有了三种不同类型的对象。
46860: 78:
46861: 79:一个集合中存储多种不同类型的对象的情况很少见，通常而言，我们只会用集合存储同一种类型的对象。泛型的主要目的之一就是用来约定集合要存储什么类型的对象，并且通过编译器确保规约得以满足。
46862: 80:
46863: 81:因此，与其使用 `Object` ，我们更希望先指定一个类型占位符，稍后再决定具体使用什么类型。要达到这个目的，需要使用*类型参数*，用尖括号括住，放在类名后面。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，`T` 就是类型参数：
46864: 82:
46865: 83:```java
46866: 84:// generics/GenericHolder.java
46867: 85:
46868: 86:public class GenericHolder<T> {
46869: 87:    private T a;
46870: 88:    public GenericHolder() {}
46871: 89:    public void set(T a) { this.a = a; }
46872: 90:    public T get() { return a; }
46873: 91:    
46874: 92:    public static void main(String[] args) {
46875: 93:        GenericHolder<Automobile> h3 = new GenericHolder<Automobile>();
46876: 94:        h3.set(new Automobile()); // 此处有类型校验
46877: 95:        Automobile a = h3.get();  // 无需类型转换
46878: 96:        //- h3.set("Not an Automobile"); // 报错
46879: 97:        //- h3.set(1);  // 报错
46880: 98:    }
46881: 99:}
46882: 100:```
46883: 101:
46884: 102:创建 `GenericHolder` 对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像 `main()` 中那样使用。然后，你就只能在 `GenericHolder` 中存储该类型（或其子类，因为多态与泛型不冲突）的对象了。当你调用 `get()` 取值时，直接就是正确的类型。
46885: 103:
46886: 104:这就是 Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交给它来处理。
46887: 105:
46888: 106:你可能注意到 `h3` 的定义非常繁复。在 `=` 左边有 `GenericHolder<Automobile>`, 右边又重复了一次。在 Java 5 中，这种写法被解释成“必要的”，但在 Java 7 中设计者修正了这个问题（新的简写语法随后成为备受欢迎的特性）。以下是简写的例子：
46889: 107:
46890: 108:```java
46891: 109:// generics/Diamond.java
46892: 110:
46893: 111:class Bob {}
46894: 112:
46895: 113:public class Diamond<T> {
46896: 114:    public static void main(String[] args) {
46897: 115:        GenericHolder<Bob> h3 = new GenericHolder<>();
46898: 116:        h3.set(new Bob());
46899: 117:    }
46900: 118:}
46901: 119:```
46902: 120:
46903: 121:注意，在 `h3` 的定义处，`=` 右边的尖括号是空的（称为“钻石语法”），而不是重复左边的类型信息。在本书剩余部分都会使用这种语法。
46904: 122:
46905: 123:一般来说，你可以认为泛型和其他类型差不多，只不过它们碰巧有类型参数罢了。在使用泛型时，你只需要指定它们的名称和类型参数列表即可。
46906: 124:
46907: 125:### 一个元组类库
46908: 126:
46909: 127:有时一个方法需要能返回多个对象。而 **return** 语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得了编译时的类型安全。
46910: 128:
46911: 129:这个概念称为*元组*，它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象（这个概念也称为 *数据传输对象* 或 *信使* ）。
46912: 130:
46913: 131:通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组：
46914: 132:
46915: 133:```java
46916: 134:// onjava/Tuple2.java
46917: 135:package onjava;
46918: 136:
46919: 137:public class Tuple2<A, B> {
46920: 138:    public final A a1;
46921: 139:    public final B a2;
46922: 140:    public Tuple2(A a, B b) { a1 = a; a2 = b; }
46923: 141:    public String rep() { return a1 + ", " + a2; }
46924: 142:  
46925: 143:    @Override
46926: 144:    public String toString() {
46927: 145:        return "(" + rep() + ")";
46928: 146:    }
46929: 147:}
46930: 148:```
46931: 149:
46932: 150:构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。
46933: 151:
46934: 152:初次阅读上面的代码时，你可能认为这违反了 Java 编程的封装原则。`a1` 和 `a2` 应该声明为 **private**，然后提供 `getFirst()` 和 `getSecond()` 取值方法才对呀？考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取 `a1` 和 `a2` 然后对它们执行任何操作，但无法对 `a1` 和 `a2` 重新赋值。例子中的 `final` 可以实现同样的效果，并且更为简洁明了。
46935: 153:
46936: 154:另一种设计思路是允许元组的用户给 `a1` 和 `a2` 重新赋值。然而，采用上例中的形式无疑更加安全，如果用户想存储不同的元素，就会强制他们创建新的 `Tuple2` 对象。
46937: 155:
46938: 156:我们可以利用继承机制实现长度更长的元组。添加更多的类型参数就行了：
46939: 157:
46940: 158:```java
46941: 159:// onjava/Tuple3.java
46942: 160:package onjava;
46943: 161:
46944: 162:public class Tuple3<A, B, C> extends Tuple2<A, B> {
46945: 163:    public final C a3;
46946: 164:    public Tuple3(A a, B b, C c) {
46947: 165:        super(a, b);
46948: 166:        a3 = c;
46949: 167:    }
46950: 168:    
46951: 169:    @Override
46952: 170:    public String rep() {
46953: 171:        return super.rep() + ", " + a3;
46954: 172:    }
46955: 173:}
46956: 174:
46957: 175:// onjava/Tuple4.java
46958: 176:package onjava;
46959: 177:
46960: 178:public class Tuple4<A, B, C, D>
46961: 179:  extends Tuple3<A, B, C> {
46962: 180:    public final D a4;
46963: 181:    public Tuple4(A a, B b, C c, D d) {
46964: 182:        super(a, b, c);
46965: 183:        a4 = d;
46966: 184:    }
46967: 185:    
46968: 186:    @Override
46969: 187:    public String rep() {
46970: 188:        return super.rep() + ", " + a4;
46971: 189:    }
46972: 190:}
46973: 191:
46974: 192:// onjava/Tuple5.java
46975: 193:package onjava;
46976: 194:
46977: 195:public class Tuple5<A, B, C, D, E>
46978: 196:  extends Tuple4<A, B, C, D> {
46979: 197:    public final E a5;
46980: 198:    public Tuple5(A a, B b, C c, D d, E e) {
46981: 199:        super(a, b, c, d);
46982: 200:        a5 = e;
46983: 201:    }
46984: 202:    
46985: 203:    @Override
46986: 204:    public String rep() {
46987: 205:        return super.rep() + ", " + a5;
46988: 206:    }
46989: 207:}
46990: 208:```
46991: 209:
46992: 210:演示需要，再定义两个类：
46993: 211:
46994: 212:```java
46995: 213:// generics/Amphibian.java
46996: 214:public class Amphibian {}
46997: 215:
46998: 216:// generics/Vehicle.java
46999: 217:public class Vehicle {}
47000: 218:```
47001: 219:
47002: 220:使用元组时，你只需要定义一个长度适合的元组，将其作为返回值即可。注意下面例子中方法的返回类型：
47003: 221:
47004: 222:```java
47005: 223:// generics/TupleTest.java
47006: 224:import onjava.*;
47007: 225:
47008: 226:public class TupleTest {
47009: 227:    static Tuple2<String, Integer> f() {
47010: 228:        // 47 自动装箱为 Integer
47011: 229:        return new Tuple2<>("hi", 47);
47012: 230:    }
47013: 231:  
47014: 232:    static Tuple3<Amphibian, String, Integer> g() {
47015: 233:        return new Tuple3<>(new Amphibian(), "hi", 47);
47016: 234:    }
47017: 235:  
47018: 236:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
47019: 237:        return new Tuple4<>(new Vehicle(), new Amphibian(), "hi", 47);
47020: 238:    }
47021: 239:  
47022: 240:    static Tuple5<Vehicle, Amphibian, String, Integer, Double> k() {
47023: 241:        return new Tuple5<>(new Vehicle(), new Amphibian(), "hi", 47, 11.1);
47024: 242:    }
47025: 243:  
47026: 244:    public static void main(String[] args) {
47027: 245:        Tuple2<String, Integer> ttsi = f();
47028: 246:        System.out.println(ttsi);
47029: 247:        // ttsi.a1 = "there"; // 编译错误，因为 final 不能重新赋值
47030: 248:        System.out.println(g());
47031: 249:        System.out.println(h());
47032: 250:        System.out.println(k());
47033: 251:    }
47034: 252:}
47035: 253:
47036: 254:/* 输出：
47037: 255: (hi, 47)
47038: 256: (Amphibian@1540e19d, hi, 47)
47039: 257: (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47)
47040: 258: (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1)
47041: 259: */
47042: 260:```
47043: 261:
47044: 262:有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。
47045: 263:
47046: 264:通过 `ttsi.a1 = "there"` 语句的报错，我们可以看出，**final** 声明确实可以确保 **public** 字段在对象被构造出来之后就不能重新赋值了。
47047: 265:
47048: 266:在上面的程序中，`new` 表达式有些啰嗦。本章稍后会介绍，如何利用 *泛型方法* 简化它们。
47049: 267:
47050: 268:### 一个堆栈类
47051: 269:
47052: 270:接下来我们看一个稍微复杂一点的例子：堆栈。在 [集合](book/12-Collections.md) 一章中，我们用 `LinkedList` 实现了 `onjava.Stack` 类。在那个例子中，`LinkedList` 本身已经具备了创建堆栈所需的方法。`Stack` 是通过两个泛型类 `Stack<T>` 和 `LinkedList<T>` 的组合来创建。我们可以看出，泛型只不过是一种类型罢了（稍后我们会看到一些例外的情况）。
47053: 271:
47054: 272:这次我们不用 `LinkedList` 来实现自己的内部链式存储机制。
47055: 273:
47056: 274:```java
47057: 275:// generics/LinkedStack.java
47058: 276:// 用链式结构实现的堆栈
47059: 277:
47060: 278:public class LinkedStack<T> {
47061: 279:    private static class Node<U> {
47062: 280:        U item;
47063: 281:        Node<U> next;
47064: 282:    
47065: 283:        Node() { item = null; next = null; }
47066: 284:        
47067: 285:        Node(U item, Node<U> next) {
47068: 286:            this.item = item;
47069: 287:            this.next = next;
47070: 288:        }
47071: 289:    
47072: 290:        boolean end() {
47073: 291:            return item == null && next == null;
47074: 292:        }
47075: 293:    }
47076: 294:  
47077: 295:    private Node<T> top = new Node<>();  // 栈顶
47078: 296:  
47079: 297:    public void push(T item) {
47080: 298:        top = new Node<>(item, top);
47081: 299:    }
47082: 300:  
47083: 301:    public T pop() {
47084: 302:        T result = top.item;
47085: 303:        if (!top.end()) {
47086: 304:            top = top.next;
47087: 305:        }
47088: 306:        return result;
47089: 307:    }
47090: 308:  
47091: 309:    public static void main(String[] args) {
47092: 310:        LinkedStack<String> lss = new LinkedStack<>();
47093: 311:        for (String s : "Phasers on stun!".split(" ")) {
47094: 312:            lss.push(s);
47095: 313:        }
47096: 314:        String s;
47097: 315:        while ((s = lss.pop()) != null) {
47098: 316:            System.out.println(s);
47099: 317:        }
47100: 318:    }
47101: 319:}
47102: 320:```
47103: 321:
47104: 322:输出结果：
47105: 323:
47106: 324:```java
47107: 325:stun!
47108: 326:on
47109: 327:Phasers
47110: 328:```
47111: 329:
47112: 330:内部类 `Node` 也是一个泛型，它拥有自己的类型参数。
47113: 331:
47114: 332:这个例子使用了一个 *末端标识* (end sentinel) 来判断栈何时为空。这个末端标识是在构造 `LinkedStack` 时创建的。然后，每次调用 `push()` 就会创建一个 `Node<T>` 对象，并将其链接到前一个 `Node<T>` 对象。当你调用 `pop()` 方法时，总是返回 `top.item`，然后丢弃当前 `top` 所指向的 `Node<T>`，并将 `top` 指向下一个 `Node<T>`，除非到达末端标识，这时就不能再移动 `top` 了。如果已经到达末端，程序还继续调用 `pop()` 方法，它只能得到 `null`，说明栈已经空了。
47115: 333:
47116: 334:### RandomList
47117: 335:
47118: 336:作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它的 `select()` 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型：
47119: 337:
47120: 338:```java
47121: 339:// generics/RandomList.java
47122: 340:import java.util.*;
47123: 341:import java.util.stream.*;
47124: 342:
47125: 343:public class RandomList<T> extends ArrayList<T> {
47126: 344:    private Random rand = new Random(47);
47127: 345:  
47128: 346:    public T select() {
47129: 347:        return get(rand.nextInt(size()));
47130: 348:    }
47131: 349:  
47132: 350:    public static void main(String[] args) {
47133: 351:        RandomList<String> rs = new RandomList<>();
47134: 352:        Arrays.stream("The quick brown fox jumped over the lazy brown dog".split(" ")).forEach(rs::add);
47135: 353:        IntStream.range(0, 11).forEach(i -> 
47136: 354:            System.out.print(rs.select() + " "));
47137: 355:    }
47138: 356:}
47139: 357:```
47140: 358:
47141: 359:输出结果：
47142: 360:
47143: 361:```java
47144: 362:brown over fox quick quick dog brown The brown lazy brown
47145: 363:```
47146: 364:
47147: 365:`RandomList` 继承了 `ArrayList` 的所有方法。本例中只添加了 `select()` 这个方法。
47148: 366:
47149: 367:<!-- Generic Interfaces -->
47150: 368:
47151: 369:## 泛型接口
47152: 370:
47153: 371:泛型也可以应用于接口。例如 *生成器*，这是一种专门负责创建对象的类。实际上，这是 *工厂方法* 设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。生成器无需额外的信息就知道如何创建新对象。
47154: 372:
47155: 373:一般而言，一个生成器只定义一个方法，用于创建对象。例如 `java.util.function` 类库中的 `Supplier` 就是一个生成器，调用其 `get()` 获取对象。`get()` 是泛型方法，返回值为类型参数 `T`。
47156: 374:
47157: 375:为了演示 `Supplier`，我们需要定义几个类。下面是个咖啡相关的继承体系：
47158: 376:
47159: 377:```java
47160: 378:// generics/coffee/Coffee.java
47161: 379:package generics.coffee;
47162: 380:
47163: 381:public class Coffee {
47164: 382:    private static long counter = 0;
47165: 383:    private final long id = counter++;
47166: 384:  
47167: 385:    @Override
47168: 386:    public String toString() {
47169: 387:        return getClass().getSimpleName() + " " + id;
47170: 388:    }
47171: 389:}
47172: 390:
47173: 391:
47174: 392:// generics/coffee/Latte.java
47175: 393:package generics.coffee;
47176: 394:public class Latte extends Coffee {}
47177: 395:
47178: 396:
47179: 397:// generics/coffee/Mocha.java
47180: 398:package generics.coffee;
47181: 399:public class Mocha extends Coffee {}
47182: 400:
47183: 401:
47184: 402:// generics/coffee/Cappuccino.java
47185: 403:package generics.coffee;
47186: 404:public class Cappuccino extends Coffee {}
47187: 405:
47188: 406:
47189: 407:// generics/coffee/Americano.java
47190: 408:package generics.coffee;
47191: 409:public class Americano extends Coffee {}
47192: 410:
47193: 411:
47194: 412:// generics/coffee/Breve.java
47195: 413:package generics.coffee;
47196: 414:public class Breve extends Coffee {}
47197: 415:```
47198: 416:
47199: 417:现在，我们可以编写一个类，实现 `Supplier<Coffee>` 接口，它能够随机生成不同类型的 `Coffee` 对象：
47200: 418:
47201: 419:```java
47202: 420:// generics/coffee/CoffeeSupplier.java
47203: 421:// {java generics.coffee.CoffeeSupplier}
47204: 422:package generics.coffee;
47205: 423:import java.util.*;
47206: 424:import java.util.function.*;
47207: 425:import java.util.stream.*;
47208: 426:
47209: 427:public class CoffeeSupplier
47210: 428:implements Supplier<Coffee>, Iterable<Coffee> {
47211: 429:    private Class<?>[] types = { Latte.class, Mocha.class, 
47212: 430:        Cappuccino.class, Americano.class, Breve.class };
47213: 431:    private static Random rand = new Random(47);
47214: 432:  
47215: 433:    public CoffeeSupplier() {}
47216: 434:    // For iteration:
47217: 435:    private int size = 0;
47218: 436:    public CoffeeSupplier(int sz) { size = sz; }
47219: 437:  
47220: 438:    @Override
47221: 439:    public Coffee get() {
47222: 440:        try {
47223: 441:            return (Coffee) types[rand.nextInt(types.length)].newInstance();
47224: 442:        } catch (InstantiationException | IllegalAccessException e) {
47225: 443:            throw new RuntimeException(e);
47226: 444:        }
47227: 445:    }
47228: 446:  
47229: 447:    class CoffeeIterator implements Iterator<Coffee> {
47230: 448:        int count = size;
47231: 449:        @Override
47232: 450:        public boolean hasNext() { return count > 0; }
47233: 451:        @Override
47234: 452:        public Coffee next() {
47235: 453:            count--;
47236: 454:            return CoffeeSupplier.this.get();
47237: 455:        }
47238: 456:        @Override
47239: 457:        public void remove() {
47240: 458:            throw new UnsupportedOperationException();
47241: 459:        }
47242: 460:    }
47243: 461:  
47244: 462:    @Override
47245: 463:    public Iterator<Coffee> iterator() {
47246: 464:        return new CoffeeIterator();
47247: 465:    }
47248: 466:  
47249: 467:    public static void main(String[] args) {
47250: 468:        Stream.generate(new CoffeeSupplier())
47251: 469:              .limit(5)
47252: 470:              .forEach(System.out::println);
47253: 471:        for (Coffee c : new CoffeeSupplier(5)) {
47254: 472:            System.out.println(c);
47255: 473:        }
47256: 474:    }
47257: 475:}
47258: 476:```
47259: 477:
47260: 478:输出结果：
47261: 479:
47262: 480:```java
47263: 481:Americano 0
47264: 482:Latte 1
47265: 483:Americano 2
47266: 484:Mocha 3
47267: 485:Mocha 4
47268: 486:Breve 5
47269: 487:Americano 6
47270: 488:Latte 7
47271: 489:Cappuccino 8
47272: 490:Cappuccino 9
47273: 491:```
47274: 492:
47275: 493:参数化的 `Supplier` 接口确保 `get()` 返回值是参数的类型。`CoffeeSupplier` 同时还实现了 `Iterable` 接口，所以能用于 *for-in* 语句。不过，它还需要知道何时终止循环，这正是第二个构造函数的作用。
47276: 494:
47277: 495:下面是另一个实现 `Supplier<T>` 接口的例子，它负责生成 Fibonacci 数列：
47278: 496:
47279: 497:```java
47280: 498:// generics/Fibonacci.java
47281: 499:// Generate a Fibonacci sequence
47282: 500:import java.util.function.*;
47283: 501:import java.util.stream.*;
47284: 502:
47285: 503:public class Fibonacci implements Supplier<Integer> {
47286: 504:    private int count = 0;
47287: 505:    @Override
47288: 506:    public Integer get() { return fib(count++); }
47289: 507:  
47290: 508:    private int fib(int n) {
47291: 509:        if(n < 2) return 1;
47292: 510:        return fib(n-2) + fib(n-1);
47293: 511:    }
47294: 512:  
47295: 513:    public static void main(String[] args) {
47296: 514:        Stream.generate(new Fibonacci())
47297: 515:              .limit(18)
47298: 516:              .map(n -> n + " ")
47299: 517:              .forEach(System.out::print);
47300: 518:    }
47301: 519:}
47302: 520:```
47303: 521:
47304: 522:输出结果：
47305: 523:
47306: 524:```java
47307: 525:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
47308: 526:```
47309: 527:
47310: 528:虽然我们在 `Fibonacci` 类的里里外外使用的都是 `int` 类型，但是其参数类型却是 `Integer`。这个例子引出了 Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备自动装箱和拆箱的功能，可以很方便地在基本类型和相应的包装类之间进行转换。通过这个例子中 `Fibonacci` 类对 `int` 的使用，我们已经看到了这种效果。
47311: 529:
47312: 530:如果还想更进一步，编写一个实现了 `Iterable` 的 `Fibnoacci` 生成器。我们的一个选择是重写这个类，令其实现 `Iterable` 接口。不过，你并不是总能拥有源代码的控制权，并且，除非必须这么做，否则，我们也不愿意重写一个类。而且我们还有另一种选择，就是创建一个 *适配器* (Adapter) 来实现所需的接口，我们在前面介绍过这个设计模式。
47313: 531:
47314: 532:有多种方法可以实现适配器。例如，可以通过继承来创建适配器类：
47315: 533:
47316: 534:```java
47317: 535:// generics/IterableFibonacci.java
47318: 536:// Adapt the Fibonacci class to make it Iterable
47319: 537:import java.util.*;
47320: 538:
47321: 539:public class IterableFibonacci
47322: 540:extends Fibonacci implements Iterable<Integer> {
47323: 541:    private int n;
47324: 542:    public IterableFibonacci(int count) { n = count; }
47325: 543:  
47326: 544:    @Override
47327: 545:    public Iterator<Integer> iterator() {
47328: 546:        return new Iterator<Integer>() {
47329: 547:            @Override
47330: 548:            public boolean hasNext() { return n > 0; }
47331: 549:            @Override
47332: 550:            public Integer next() {
47333: 551:                n--;
47334: 552:                return IterableFibonacci.this.get();
47335: 553:            }
47336: 554:            @Override
47337: 555:            public void remove() { // Not implemented
47338: 556:                throw new UnsupportedOperationException();
47339: 557:            }
47340: 558:        };
47341: 559:    }
47342: 560:  
47343: 561:    public static void main(String[] args) {
47344: 562:        for(int i : new IterableFibonacci(18))
47345: 563:            System.out.print(i + " ");
47346: 564:    }
47347: 565:}
47348: 566:```
47349: 567:
47350: 568:输出结果：
47351: 569:
47352: 570:```java
47353: 571:1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
47354: 572:```
47355: 573:
47356: 574:在 *for-in* 语句中使用 `IterableFibonacci`，必须在构造函数中提供一个边界值，这样 `hasNext()` 才知道何时返回 **false**，结束循环。
47357: 575:
47358: 576:<!-- Generic Methods -->
47359: 577:
47360: 578:## 泛型方法
47361: 579:
47362: 580:到目前为止，我们已经研究了参数化整个类。其实还可以参数化类中的方法。类本身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。
47363: 581:
47364: 582:泛型方法独立于类而改变方法。作为准则，请“尽可能”使用泛型方法。通常将单个方法泛型化要比将整个类泛型化更清晰易懂。
47365: 583:
47366: 584:如果方法是 **static** 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型类型参数，则它必须是泛型方法。
47367: 585:
47368: 586:要定义泛型方法，请将泛型参数列表放置在返回值之前，如下所示：
47369: 587:
47370: 588:```java
47371: 589:// generics/GenericMethods.java
47372: 590:
47373: 591:public class GenericMethods {
47374: 592:    public <T> void f(T x) {
47375: 593:        System.out.println(x.getClass().getName());
47376: 594:    }
47377: 595:
47378: 596:    public static void main(String[] args) {
47379: 597:        GenericMethods gm = new GenericMethods();
47380: 598:        gm.f("");
47381: 599:        gm.f(1);
47382: 600:        gm.f(1.0);
47383: 601:        gm.f(1.0F);
47384: 602:        gm.f('c');
47385: 603:        gm.f(gm);
47386: 604:    }
47387: 605:}
47388: 606:/* Output:
47389: 607:java.lang.String
47390: 608:java.lang.Integer
47391: 609:java.lang.Double
47392: 610:java.lang.Float
47393: 611:java.lang.Character
47394: 612:GenericMethods
47395: 613:*/
47396: 614:```
47397: 615:
47398: 616:尽管可以同时对类及其方法进行参数化，但这里未将 **GenericMethods** 类参数化。只有方法 `f()` 具有类型参数，该参数由方法返回类型之前的参数列表指示。
47399: 617:
47400: 618:对于泛型类，必须在实例化该类时指定类型参数。使用泛型方法时，通常不需要指定参数类型，因为编译器会找出这些类型。 这称为 *类型参数推断*。因此，对 `f()` 的调用看起来像普通的方法调用，并且 `f()` 看起来像被重载了无数次一样。它甚至会接受 **GenericMethods** 类型的参数。
47401: 619:
47402: 620:如果使用基本类型调用 `f()` ，自动装箱就开始起作用，自动将基本类型包装在它们对应的包装类型中。
47403: 621:
47404: 622:<!-- Varargs and Generic Methods -->
47405: 623:
47406: 624:### 变长参数和泛型方法
47407: 625:
47408: 626:泛型方法和变长参数列表可以很好地共存：
47409: 627:
47410: 628:```java
47411: 629:// generics/GenericVarargs.java
47412: 630:
47413: 631:import java.util.ArrayList;
47414: 632:import java.util.List;
47415: 633:
47416: 634:public class GenericVarargs {
47417: 635:    @SafeVarargs
47418: 636:    public static <T> List<T> makeList(T... args) {
47419: 637:        List<T> result = new ArrayList<>();
47420: 638:        for (T item : args)
47421: 639:            result.add(item);
47422: 640:        return result;
47423: 641:    }
47424: 642:
47425: 643:    public static void main(String[] args) {
47426: 644:        List<String> ls = makeList("A");
47427: 645:        System.out.println(ls);
47428: 646:        ls = makeList("A", "B", "C");
47429: 647:        System.out.println(ls);
47430: 648:        ls = makeList(
47431: 649:                "ABCDEFFHIJKLMNOPQRSTUVWXYZ".split(""));
47432: 650:        System.out.println(ls);
47433: 651:    }
47434: 652:}
47435: 653:/* Output:
47436: 654:[A]
47437: 655:[A, B, C]
47438: 656:[A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R,
47439: 657:S, T, U, V, W, X, Y, Z]
47440: 658:*/
47441: 659:```
47442: 660:
47443: 661:此处显示的 `makeList()` 方法产生的功能与标准库的 `java.util.Arrays.asList()` 方法相同。
47444: 662:
47445: 663:`@SafeVarargs` 注解保证我们不会对变长参数列表进行任何修改，这是正确的，因为我们只从中读取。如果没有此注解，编译器将无法知道这些并会发出警告。
47446: 664:
47447: 665:<!-- A General-Purpose Supplier -->
47448: 666:
47449: 667:### 一个泛型的 Supplier
47450: 668:
47451: 669:这是一个为任意具有无参构造方法的类生成 **Supplier** 的类。为了减少键入，它还包括一个用于生成 **BasicSupplier** 的泛型方法：
47452: 670:
47453: 671:```java
47454: 672:// onjava/BasicSupplier.java
47455: 673:// Supplier from a class with a no-arg constructor
47456: 674:package onjava;
47457: 675:
47458: 676:import java.util.function.Supplier;
47459: 677:
47460: 678:public class BasicSupplier<T> implements Supplier<T> {
47461: 679:    private Class<T> type;
47462: 680:
47463: 681:    public BasicSupplier(Class<T> type) {
47464: 682:        this.type = type;
47465: 683:    }
47466: 684:
47467: 685:    @Override
47468: 686:    public T get() {
47469: 687:        try {
47470: 688:            // Assumes type is a public class:
47471: 689:            return type.newInstance();
47472: 690:        } catch (InstantiationException |
47473: 691:                IllegalAccessException e) {
47474: 692:            throw new RuntimeException(e);
47475: 693:        }
47476: 694:    }
47477: 695:
47478: 696:    // Produce a default Supplier from a type token:
47479: 697:    public static <T> Supplier<T> create(Class<T> type) {
47480: 698:        return new BasicSupplier<>(type);
47481: 699:    }
47482: 700:}
47483: 701:```
47484: 702:
47485: 703:此类提供了产生以下对象的基本实现：
47486: 704:
47487: 705:1. 是 **public** 的。 因为 **BasicSupplier** 在单独的包中，所以相关的类必须具有 **public** 权限，而不仅仅是包级访问权限。
47488: 706:
47489: 707:2. 具有无参构造方法。要创建一个这样的 **BasicSupplier** 对象，请调用 `create()` 方法，并将要生成类型的类型令牌传递给它。通用的 `create()` 方法提供了 `BasicSupplier.create(MyType.class)` 这种较简洁的语法来代替较笨拙的 `new BasicSupplier <MyType>(MyType.class)`。
47490: 708:
47491: 709:例如，这是一个具有无参构造方法的简单类：
47492: 710:
47493: 711:```java
47494: 712:// generics/CountedObject.java
47495: 713:
47496: 714:public class CountedObject {
47497: 715:    private static long counter = 0;
47498: 716:    private final long id = counter++;
47499: 717:
47500: 718:    public long id() {
47501: 719:        return id;
47502: 720:    }
47503: 721:
47504: 722:    @Override
47505: 723:    public String toString() {
47506: 724:        return "CountedObject " + id;
47507: 725:    }
47508: 726:}
47509: 727:```
47510: 728:
47511: 729:**CountedObject** 类可以跟踪自身创建了多少个实例，并通过 `toString()` 报告这些实例的数量。 **BasicSupplier** 可以轻松地为 **CountedObject** 创建 **Supplier**：
47512: 730:
47513: 731:```java
47514: 732:  // generics/BasicSupplierDemo.java
47515: 733:
47516: 734:import onjava.BasicSupplier;
47517: 735:
47518: 736:import java.util.stream.Stream;
47519: 737:
47520: 738:public class BasicSupplierDemo {
47521: 739:    public static void main(String[] args) {
47522: 740:        Stream.generate(
47523: 741:                BasicSupplier.create(CountedObject.class))
47524: 742:                .limit(5)
47525: 743:                .forEach(System.out::println);
47526: 744:    }
47527: 745:}
47528: 746:/* Output:
47529: 747:CountedObject 0
47530: 748:CountedObject 1
47531: 749:CountedObject 2
47532: 750:CountedObject 3
47533: 751:CountedObject 4
47534: 752:*/
47535: 753:```
47536: 754:
47537: 755:泛型方法减少了产生 **Supplier** 对象所需的代码量。 Java 泛型强制传递 **Class** 对象，以便在 `create()` 方法中将其用于类型推断。
47538: 756:
47539: 757:<!-- Simplifying Tuple Use -->
47540: 758:
47541: 759:### 简化元组的使用
47542: 760:
47543: 761:使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库。在这里，我们使用重载的静态方法创建元组：
47544: 762:
47545: 763:```java
47546: 764:// onjava/Tuple.java
47547: 765:// Tuple library using type argument inference
47548: 766:package onjava;
47549: 767:
47550: 768:public class Tuple {
47551: 769:    public static <A, B> Tuple2<A, B> tuple(A a, B b) {
47552: 770:        return new Tuple2<>(a, b);
47553: 771:    }
47554: 772:
47555: 773:    public static <A, B, C> Tuple3<A, B, C>
47556: 774:    tuple(A a, B b, C c) {
47557: 775:        return new Tuple3<>(a, b, c);
47558: 776:    }
47559: 777:
47560: 778:    public static <A, B, C, D> Tuple4<A, B, C, D>
47561: 779:    tuple(A a, B b, C c, D d) {
47562: 780:        return new Tuple4<>(a, b, c, d);
47563: 781:    }
47564: 782:
47565: 783:    public static <A, B, C, D, E>
47566: 784:    Tuple5<A, B, C, D, E> tuple(A a, B b, C c, D d, E e) {
47567: 785:        return new Tuple5<>(a, b, c, d, e);
47568: 786:    }
47569: 787:}
47570: 788:```
47571: 789:
47572: 790:我们修改 **TupleTest.java** 来测试 **Tuple.java** :
47573: 791:
47574: 792:```java
47575: 793:// generics/TupleTest2.java
47576: 794:
47577: 795:import onjava.Tuple2;
47578: 796:import onjava.Tuple3;
47579: 797:import onjava.Tuple4;
47580: 798:import onjava.Tuple5;
47581: 799:
47582: 800:import static onjava.Tuple.tuple;
47583: 801:
47584: 802:public class TupleTest2 {
47585: 803:    static Tuple2<String, Integer> f() {
47586: 804:        return tuple("hi", 47);
47587: 805:    }
47588: 806:
47589: 807:    static Tuple2 f2() {
47590: 808:        return tuple("hi", 47);
47591: 809:    }
47592: 810:
47593: 811:    static Tuple3<Amphibian, String, Integer> g() {
47594: 812:        return tuple(new Amphibian(), "hi", 47);
47595: 813:    }
47596: 814:
47597: 815:    static Tuple4<Vehicle, Amphibian, String, Integer> h() {
47598: 816:        return tuple(
47599: 817:                new Vehicle(), new Amphibian(), "hi", 47);
47600: 818:    }
47601: 819:
47602: 820:    static Tuple5<Vehicle, Amphibian,
47603: 821:            String, Integer, Double> k() {
47604: 822:        return tuple(new Vehicle(), new Amphibian(),
47605: 823:                "hi", 47, 11.1);
47606: 824:    }
47607: 825:
47608: 826:    public static void main(String[] args) {
47609: 827:        Tuple2<String, Integer> ttsi = f();
47610: 828:        System.out.println(ttsi);
47611: 829:        System.out.println(f2());
47612: 830:        System.out.println(g());
47613: 831:        System.out.println(h());
47614: 832:        System.out.println(k());
47615: 833:    }
47616: 834:}
47617: 835:/* Output:
47618: 836:(hi, 47)
47619: 837:(hi, 47)
47620: 838:(Amphibian@14ae5a5, hi, 47)
47621: 839:(Vehicle@135fbaa4, Amphibian@45ee12a7, hi, 47)
47622: 840:(Vehicle@4b67cf4d, Amphibian@7ea987ac, hi, 47, 11.1)
47623: 841:*/
47624: 842:```
47625: 843:
47626: 844:请注意，`f()` 返回一个参数化的 **Tuple2** 对象，而 `f2()` 返回一个未参数化的 **Tuple2** 对象。编译器不会在这里警告 `f2()` ，因为返回值未以参数化方式使用。从某种意义上说，它被“向上转型”为一个未参数化的 **Tuple2** 。 但是，如果尝试将 `f2()` 的结果放入到参数化的 **Tuple2** 中，则编译器将发出警告。
47627: 845:
47628: 846:<!-- A Set Utility -->
47629: 847:
47630: 848:### 一个 Set 工具
47631: 849:
47632: 850:对于泛型方法的另一个示例，请考虑由 **Set** 表示的数学关系。这些被方便地定义为可用于所有不同类型的泛型方法：
47633: 851:
47634: 852:```java
47635: 853:// onjava/Sets.java
47636: 854:
47637: 855:package onjava;
47638: 856:
47639: 857:import java.util.HashSet;
47640: 858:import java.util.Set;
47641: 859:
47642: 860:public class Sets {
47643: 861:    public static <T> Set<T> union(Set<T> a, Set<T> b) {
47644: 862:        Set<T> result = new HashSet<>(a);
47645: 863:        result.addAll(b);
47646: 864:        return result;
47647: 865:    }
47648: 866:
47649: 867:    public static <T>
47650: 868:    Set<T> intersection(Set<T> a, Set<T> b) {
47651: 869:        Set<T> result = new HashSet<>(a);
47652: 870:        result.retainAll(b);
47653: 871:        return result;
47654: 872:    }
47655: 873:
47656: 874:    // Subtract subset from superset:
47657: 875:    public static <T> Set<T>
47658: 876:    difference(Set<T> superset, Set<T> subset) {
47659: 877:        Set<T> result = new HashSet<>(superset);
47660: 878:        result.removeAll(subset);
47661: 879:        return result;
47662: 880:    }
47663: 881:
47664: 882:    // Reflexive--everything not in the intersection:
47665: 883:    public static <T> Set<T> complement(Set<T> a, Set<T> b) {
47666: 884:        return difference(union(a, b), intersection(a, b));
47667: 885:    }
47668: 886:}
47669: 887:```
47670: 888:
47671: 889:前三个方法通过将第一个参数的引用复制到新的 **HashSet** 对象中来复制第一个参数，因此不会直接修改参数集合。因此，返回值是一个新的 **Set** 对象。
47672: 890:
47673: 891:这四种方法代表数学集合操作： `union()` 返回一个包含两个参数并集的 **Set** ， `intersection()` 返回一个包含两个参数集合交集的 **Set** ， `difference()` 从 **superset** 中减去 **subset** 的元素 ，而 `complement()` 返回所有不在交集中的元素的 **Set**。作为显示这些方法效果的简单示例的一部分，下面是一个包含不同水彩名称的 **enum** ：
47674: 892:
47675: 893:```java
47676: 894:// generics/watercolors/Watercolors.java
47677: 895:
47678: 896:package watercolors;
47679: 897:
47680: 898:public enum Watercolors {
47681: 899:    ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW,
47682: 900:    ORANGE, BRILLIANT_RED, CRIMSON, MAGENTA,
47683: 901:    ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE,
47684: 902:    PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE,
47685: 903:    PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN,
47686: 904:    YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
47687: 905:    BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK
47688: 906:}
47689: 907:```
47690: 908:
47691: 909:为了方便起见（不必全限定所有名称），将其静态导入到以下示例中。本示例使用 **EnumSet** 轻松从 **enum** 中创建 **Set** 。（可以在[第二十二章 枚举](book/22-Enumerations.md)一章中了解有关 **EnumSet** 的更多信息。）在这里，静态方法 `EnumSet.range()` 要求提供所要在结果 **Set** 中创建的元素范围的第一个和最后一个元素：
47692: 910:
47693: 911:```java
47694: 912:// generics/WatercolorSets.java
47695: 913:
47696: 914:import watercolors.*;
47697: 915:
47698: 916:import java.util.EnumSet;
47699: 917:import java.util.Set;
47700: 918:
47701: 919:import static watercolors.Watercolors.*;
47702: 920:import static onjava.Sets.*;
47703: 921:
47704: 922:public class WatercolorSets {
47705: 923:    public static void main(String[] args) {
47706: 924:        Set<Watercolors> set1 =
47707: 925:                EnumSet.range(BRILLIANT_RED, VIRIDIAN_HUE);
47708: 926:        Set<Watercolors> set2 =
47709: 927:                EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER);
47710: 928:        System.out.println("set1: " + set1);
47711: 929:        System.out.println("set2: " + set2);
47712: 930:        System.out.println(
47713: 931:                "union(set1, set2): " + union(set1, set2));
47714: 932:        Set<Watercolors> subset = intersection(set1, set2);
47715: 933:        System.out.println(
47716: 934:                "intersection(set1, set2): " + subset);
47717: 935:        System.out.println("difference(set1, subset): " +
47718: 936:                difference(set1, subset));
47719: 937:        System.out.println("difference(set2, subset): " +
47720: 938:                difference(set2, subset));
47721: 939:        System.out.println("complement(set1, set2): " +
47722: 940:                complement(set1, set2));
47723: 941:    }
47724: 942:}
47725: 943:/* Output:
47726: 944:set1: [BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER,
47727: 945:VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
47728: 946:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE]
47729: 947:set2: [CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
47730: 948:COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE,
47731: 949:SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
47732: 950:BURNT_UMBER]
47733: 951:union(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
47734: 952:YELLOW_OCHRE, MAGENTA, SAP_GREEN, CERULEAN_BLUE_HUE,
47735: 953:ULTRAMARINE, VIRIDIAN_HUE, VIOLET, RAW_UMBER,
47736: 954:ROSE_MADDER, PERMANENT_GREEN, BURNT_UMBER,
47737: 955:PHTHALO_BLUE, CRIMSON, COBALT_BLUE_HUE]
47738: 956:intersection(set1, set2): [PERMANENT_GREEN,
47739: 957:CERULEAN_BLUE_HUE, ULTRAMARINE, VIRIDIAN_HUE,
47740: 958:PHTHALO_BLUE, COBALT_BLUE_HUE]
47741: 959:difference(set1, subset): [BRILLIANT_RED, MAGENTA,
47742: 960:VIOLET, CRIMSON, ROSE_MADDER]
47743: 961:difference(set2, subset): [BURNT_SIENNA, YELLOW_OCHRE,
47744: 962:BURNT_UMBER, SAP_GREEN, RAW_UMBER]
47745: 963:complement(set1, set2): [BURNT_SIENNA, BRILLIANT_RED,
47746: 964:YELLOW_OCHRE, MAGENTA, SAP_GREEN, VIOLET, RAW_UMBER,
47747: 965:ROSE_MADDER, BURNT_UMBER, CRIMSON]
47748: 966:*/
47749: 967:```
47750: 968:
47751: 969:接下来的例子使用 `Sets.difference()` 方法来展示 **java.util** 包中各种 **Collection** 和 **Map** 类之间的方法差异：
47752: 970:
47753: 971:```java
47754: 972:// onjava/CollectionMethodDifferences.java
47755: 973:// {java onjava.CollectionMethodDifferences}
47756: 974:
47757: 975:package onjava;
47758: 976:
47759: 977:import java.lang.reflect.Method;
47760: 978:import java.util.*;
47761: 979:import java.util.stream.Collectors;
47762: 980:
47763: 981:public class CollectionMethodDifferences {
47764: 982:    static Set<String> methodSet(Class<?> type) {
47765: 983:        return Arrays.stream(type.getMethods())
47766: 984:                .map(Method::getName)
47767: 985:                .collect(Collectors.toCollection(TreeSet::new));
47768: 986:    }
47769: 987:
47770: 988:    static void interfaces(Class<?> type) {
47771: 989:        System.out.print("Interfaces in " +
47772: 990:                type.getSimpleName() + ": ");
47773: 991:        System.out.println(
47774: 992:                Arrays.stream(type.getInterfaces())
47775: 993:                        .map(Class::getSimpleName)
47776: 994:                        .collect(Collectors.toList()));
47777: 995:    }
47778: 996:
47779: 997:    static Set<String> object = methodSet(Object.class);
47780: 998:
47781: 999:    static {
47782: 1000:        object.add("clone");
47783: 1001:    }
47784: 1002:
47785: 1003:    static void
47786: 1004:    difference(Class<?> superset, Class<?> subset) {
47787: 1005:        System.out.print(superset.getSimpleName() +
47788: 1006:                " extends " + subset.getSimpleName() +
47789: 1007:                ", adds: ");
47790: 1008:        Set<String> comp = Sets.difference(
47791: 1009:                methodSet(superset), methodSet(subset));
47792: 1010:        comp.removeAll(object); // Ignore 'Object' methods
47793: 1011:        System.out.println(comp);
47794: 1012:        interfaces(superset);
47795: 1013:    }
47796: 1014:
47797: 1015:    public static void main(String[] args) {
47798: 1016:        System.out.println("Collection: " +
47799: 1017:                methodSet(Collection.class));
47800: 1018:        interfaces(Collection.class);
47801: 1019:        difference(Set.class, Collection.class);
47802: 1020:        difference(HashSet.class, Set.class);
47803: 1021:        difference(LinkedHashSet.class, HashSet.class);
47804: 1022:        difference(TreeSet.class, Set.class);
47805: 1023:        difference(List.class, Collection.class);
47806: 1024:        difference(ArrayList.class, List.class);
47807: 1025:        difference(LinkedList.class, List.class);
47808: 1026:        difference(Queue.class, Collection.class);
47809: 1027:        difference(PriorityQueue.class, Queue.class);
47810: 1028:        System.out.println("Map: " + methodSet(Map.class));
47811: 1029:        difference(HashMap.class, Map.class);
47812: 1030:        difference(LinkedHashMap.class, HashMap.class);
47813: 1031:        difference(SortedMap.class, Map.class);
47814: 1032:        difference(TreeMap.class, Map.class);
47815: 1033:    }
47816: 1034:}
47817: 1035:/* Output:
47818: 1036:Collection: [add, addAll, clear, contains, containsAll,
47819: 1037:equals, forEach, hashCode, isEmpty, iterator,
47820: 1038:parallelStream, remove, removeAll, removeIf, retainAll,
47821: 1039:size, spliterator, stream, toArray]
47822: 1040:Interfaces in Collection: [Iterable]
47823: 1041:Set extends Collection, adds: []
47824: 1042:Interfaces in Set: [Collection]
47825: 1043:HashSet extends Set, adds: []
47826: 1044:Interfaces in HashSet: [Set, Cloneable, Serializable]
47827: 1045:LinkedHashSet extends HashSet, adds: []
47828: 1046:Interfaces in LinkedHashSet: [Set, Cloneable,
47829: 1047:Serializable]
47830: 1048:TreeSet extends Set, adds: [headSet,
47831: 1049:descendingIterator, descendingSet, pollLast, subSet,
47832: 1050:floor, tailSet, ceiling, last, lower, comparator,
47833: 1051:pollFirst, first, higher]
47834: 1052:Interfaces in TreeSet: [NavigableSet, Cloneable,
47835: 1053:Serializable]
47836: 1054:List extends Collection, adds: [replaceAll, get,
47837: 1055:indexOf, subList, set, sort, lastIndexOf, listIterator]
47838: 1056:Interfaces in List: [Collection]
47839: 1057:ArrayList extends List, adds: [trimToSize,
47840: 1058:ensureCapacity]
47841: 1059:Interfaces in ArrayList: [List, RandomAccess,
47842: 1060:Cloneable, Serializable]
47843: 1061:LinkedList extends List, adds: [offerFirst, poll,
47844: 1062:getLast, offer, getFirst, removeFirst, element,
47845: 1063:removeLastOccurrence, peekFirst, peekLast, push,
47846: 1064:pollFirst, removeFirstOccurrence, descendingIterator,
47847: 1065:pollLast, removeLast, pop, addLast, peek, offerLast,
47848: 1066:addFirst]
47849: 1067:Interfaces in LinkedList: [List, Deque, Cloneable,
47850: 1068:Serializable]
47851: 1069:Queue extends Collection, adds: [poll, peek, offer,
47852: 1070:element]
47853: 1071:Interfaces in Queue: [Collection]
47854: 1072:PriorityQueue extends Queue, adds: [comparator]
47855: 1073:Interfaces in PriorityQueue: [Serializable]
47856: 1074:Map: [clear, compute, computeIfAbsent,
47857: 1075:computeIfPresent, containsKey, containsValue, entrySet,
47858: 1076:equals, forEach, get, getOrDefault, hashCode, isEmpty,
47859: 1077:keySet, merge, put, putAll, putIfAbsent, remove,
47860: 1078:replace, replaceAll, size, values]
47861: 1079:HashMap extends Map, adds: []
47862: 1080:Interfaces in HashMap: [Map, Cloneable, Serializable]
47863: 1081:LinkedHashMap extends HashMap, adds: []
47864: 1082:Interfaces in LinkedHashMap: [Map]
47865: 1083:SortedMap extends Map, adds: [lastKey, subMap,
47866: 1084:comparator, firstKey, headMap, tailMap]
47867: 1085:Interfaces in SortedMap: [Map]
47868: 1086:TreeMap extends Map, adds: [descendingKeySet,
47869: 1087:navigableKeySet, higherEntry, higherKey, floorKey,
47870: 1088:subMap, ceilingKey, pollLastEntry, firstKey, lowerKey,
47871: 1089:headMap, tailMap, lowerEntry, ceilingEntry,
47872: 1090:descendingMap, pollFirstEntry, lastKey, firstEntry,
47873: 1091:floorEntry, comparator, lastEntry]
47874: 1092:Interfaces in TreeMap: [NavigableMap, Cloneable,
47875: 1093:Serializable]
47876: 1094:*/
47877: 1095:```
47878: 1096:
47879: 1097:在第十二章 [集合的本章小结](book/12-Collections.md#本章小结) 部分将会用到这里的输出结果。
47880: 1098:
47881: 1099:<!-- Building Complex Models -->
47882: 1100:
47883: 1101:## 构建复杂模型
47884: 1102:
47885: 1103:泛型的一个重要好处是能够简单安全地创建复杂模型。例如，我们可以轻松地创建一个元组列表：
47886: 1104:
47887: 1105:```java
47888: 1106:// generics/TupleList.java
47889: 1107:// Combining generic types to make complex generic types
47890: 1108:
47891: 1109:import onjava.Tuple4;
47892: 1110:
47893: 1111:import java.util.ArrayList;
47894: 1112:
47895: 1113:public class TupleList<A, B, C, D>
47896: 1114:        extends ArrayList<Tuple4<A, B, C, D>> {
47897: 1115:    public static void main(String[] args) {
47898: 1116:        TupleList<Vehicle, Amphibian, String, Integer> tl =
47899: 1117:                new TupleList<>();
47900: 1118:        tl.add(TupleTest2.h());
47901: 1119:        tl.add(TupleTest2.h());
47902: 1120:        tl.forEach(System.out::println);
47903: 1121:    }
47904: 1122:}
47905: 1123:/* Output:
47906: 1124:(Vehicle@7cca494b, Amphibian@7ba4f24f, hi, 47)
47907: 1125:(Vehicle@3b9a45b3, Amphibian@7699a589, hi, 47)
47908: 1126:*/
47909: 1127:```
47910: 1128:
47911: 1129:这将产生一个功能强大的数据结构，而无需太多代码。
47912: 1130:
47913: 1131:下面是第二个例子。每个类都是组成块，总体包含很多个块。在这里，该模型是一个具有过道，货架和产品的零售商店：
47914: 1132:
47915: 1133:```java
47916: 1134:// generics/Store.java
47917: 1135:// Building a complex model using generic collections
47918: 1136:
47919: 1137:import onjava.Suppliers;
47920: 1138:
47921: 1139:import java.util.ArrayList;
47922: 1140:import java.util.Random;
47923: 1141:import java.util.function.Supplier;
47924: 1142:
47925: 1143:class Product {
47926: 1144:    private final int id;
47927: 1145:    private String description;
47928: 1146:    private double price;
47929: 1147:
47930: 1148:    Product(int idNumber, String descr, double price) {
47931: 1149:        id = idNumber;
47932: 1150:        description = descr;
47933: 1151:        this.price = price;
47934: 1152:        System.out.println(toString());
47935: 1153:    }
47936: 1154:
47937: 1155:    @Override
47938: 1156:    public String toString() {
47939: 1157:        return id + ": " + description +
47940: 1158:                ", price: $" + price;
47941: 1159:    }
47942: 1160:
47943: 1161:    public void priceChange(double change) {
47944: 1162:        price += change;
47945: 1163:    }
47946: 1164:
47947: 1165:    public static Supplier<Product> generator =
47948: 1166:            new Supplier<Product>() {
47949: 1167:                private Random rand = new Random(47);
47950: 1168:
47951: 1169:                @Override
47952: 1170:                public Product get() {
47953: 1171:                    return new Product(rand.nextInt(1000), "Test",
47954: 1172:                            Math.round(
47955: 1173:                                    rand.nextDouble() * 1000.0) + 0.99);
47956: 1174:                }
47957: 1175:            };
47958: 1176:}
47959: 1177:
47960: 1178:class Shelf extends ArrayList<Product> {
47961: 1179:    Shelf(int nProducts) {
47962: 1180:        Suppliers.fill(this, Product.generator, nProducts);
47963: 1181:    }
47964: 1182:}
47965: 1183:
47966: 1184:class Aisle extends ArrayList<Shelf> {
47967: 1185:    Aisle(int nShelves, int nProducts) {
47968: 1186:        for (int i = 0; i < nShelves; i++)
47969: 1187:            add(new Shelf(nProducts));
47970: 1188:    }
47971: 1189:}
47972: 1190:
47973: 1191:class CheckoutStand {
47974: 1192:}
47975: 1193:
47976: 1194:class Office {
47977: 1195:}
47978: 1196:
47979: 1197:public class Store extends ArrayList<Aisle> {
47980: 1198:    private ArrayList<CheckoutStand> checkouts =
47981: 1199:            new ArrayList<>();
47982: 1200:    private Office office = new Office();
47983: 1201:
47984: 1202:    public Store(
47985: 1203:            int nAisles, int nShelves, int nProducts) {
47986: 1204:        for (int i = 0; i < nAisles; i++)
47987: 1205:            add(new Aisle(nShelves, nProducts));
47988: 1206:    }
47989: 1207:
47990: 1208:    @Override
47991: 1209:    public String toString() {
47992: 1210:        StringBuilder result = new StringBuilder();
47993: 1211:        for (Aisle a : this)
47994: 1212:            for (Shelf s : a)
47995: 1213:                for (Product p : s) {
47996: 1214:                    result.append(p);
47997: 1215:                    result.append("\n");
47998: 1216:                }
47999: 1217:        return result.toString();
48000: 1218:    }
48001: 1219:
48002: 1220:    public static void main(String[] args) {
48003: 1221:        System.out.println(new Store(5, 4, 3));
48004: 1222:    }
48005: 1223:}
48006: 1224:/* Output: (First 8 Lines)
48007: 1225:258: Test, price: $400.99
48008: 1226:861: Test, price: $160.99
48009: 1227:868: Test, price: $417.99
48010: 1228:207: Test, price: $268.99
48011: 1229:551: Test, price: $114.99
48012: 1230:278: Test, price: $804.99
48013: 1231:520: Test, price: $554.99
48014: 1232:140: Test, price: $530.99
48015: 1233:                  ...
48016: 1234:*/
48017: 1235:```
48018: 1236:
48019: 1237:`Store.toString()` 显示了结果：尽管有复杂的层次结构，但多层的集合仍然是类型安全的和可管理的。令人印象深刻的是，组装这样的模型并不需要耗费过多精力。
48020: 1238:
48021: 1239:**Shelf** 使用 `Suppliers.fill()` 这个实用程序，该实用程序接受 **Collection** （第一个参数），并使用 **Supplier** （第二个参数），以元素的数量为 **n** （第三个参数）来填充它。 **Suppliers** 类将会在本章末尾定义，其中的方法都是在执行某种填充操作，并在本章的其他示例中使用。
48022: 1240:
48023: 1241:<!-- The Mystery of Erasure -->
48024: 1242:
48025: 1243:## 泛型擦除
48026: 1244:
48027: 1245:当你开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的。例如，尽管可以说  `ArrayList.class`，但不能说成 `ArrayList<Integer>.class`。考虑下面的情况：
48028: 1246:
48029: 1247:```java
48030: 1248:// generics/ErasedTypeEquivalence.java
48031: 1249:
48032: 1250:import java.util.*;
48033: 1251:
48034: 1252:public class ErasedTypeEquivalence {
48035: 1253:    
48036: 1254:    public static void main(String[] args) {
48037: 1255:        Class c1 = new ArrayList<String>().getClass();
48038: 1256:        Class c2 = new ArrayList<Integer>().getClass();
48039: 1257:        System.out.println(c1 == c2);
48040: 1258:    }
48041: 1259:    
48042: 1260:}
48043: 1261:/* Output:
48044: 1262:true
48045: 1263:*/
48046: 1264:```
48047: 1265:
48048: 1266:`ArrayList<String>` 和 `ArrayList<Integer>` 应该是不同的类型。不同的类型会有不同的行为。例如，如果尝试向 `ArrayList<String>` 中放入一个 `Integer`，所得到的行为（失败）和向 `ArrayList<Integer>` 中放入一个 `Integer` 所得到的行为（成功）完全不同。然而上面的程序认为它们是相同的类型。
48049: 1267:
48050: 1268:下面的例子是对该谜题的补充：
48051: 1269:
48052: 1270:```java
48053: 1271:// generics/LostInformation.java
48054: 1272:
48055: 1273:import java.util.*;
48056: 1274:
48057: 1275:class Frob {}
48058: 1276:class Fnorkle {}
48059: 1277:class Quark<Q> {}
48060: 1278:
48061: 1279:class Particle<POSITION, MOMENTUM> {}
48062: 1280:
48063: 1281:public class LostInformation {
48064: 1282:
48065: 1283:    public static void main(String[] args) {
48066: 1284:        List<Frob> list = new ArrayList<>();
48067: 1285:        Map<Frob, Fnorkle> map = new HashMap<>();
48068: 1286:        Quark<Fnorkle> quark = new Quark<>();
48069: 1287:        Particle<Long, Double> p = new Particle<>();
48070: 1288:        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));
48071: 1289:        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));
48072: 1290:        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));
48073: 1291:        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));
48074: 1292:    }
48075: 1293:
48076: 1294:}
48077: 1295:/* Output:
48078: 1296:[E]
48079: 1297:[K,V]
48080: 1298:[Q]
48081: 1299:[POSITION,MOMENTUM]
48082: 1300:*/
48083: 1301:```
48084: 1302:
48085: 1303:根据 JDK 文档，**Class.getTypeParameters()** “返回一个 **TypeVariable** 对象数组，表示泛型声明中声明的类型参数...” 这暗示你可以发现这些参数类型。但是正如上例中输出所示，你只能看到用作参数占位符的标识符，这并非有用的信息。
48086: 1304:
48087: 1305:残酷的现实是：
48088: 1306:
48089: 1307:在泛型代码内部，无法获取任何有关泛型参数类型的信息。
48090: 1308:
48091: 1309:因此，你可以知道如类型参数标识符和泛型边界这些信息，但无法得知实际的类型参数从而用来创建特定的实例。如果你曾是 C++ 程序员，那么这个事实会让你很沮丧，在使用 Java 泛型工作时，它是必须处理的最基本的问题。
48092: 1310:
48093: 1311:Java 泛型是使用擦除实现的。这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此，`List<String>` 和 `List<Integer>` 在运行时实际上是相同的类型。它们都被擦除成原生类型 `List`。
48094: 1312:
48095: 1313:理解擦除并知道如何处理它，是你在学习 Java 泛型时面临的最大障碍之一。这也是本节将要探讨的内容。
48096: 1314:
48097: 1315:### C++ 的方式
48098: 1316:
48099: 1317:下面是使用模版的 C++ 示例。你会看到类型参数的语法十分相似，因为 Java 是受 C++ 启发的：
48100: 1318:
48101: 1319:```c++
48102: 1320:// generics/Templates.cpp
48103: 1321:
48104: 1322:#include <iostream>
48105: 1323:using namespace std;
48106: 1324:
48107: 1325:template<class T> class Manipulator {
48108: 1326:    T obj;
48109: 1327:public:
48110: 1328:    Manipulator(T x) { obj = x; }
48111: 1329:    void manipulate() { obj.f(); }
48112: 1330:};
48113: 1331:
48114: 1332:class HasF {
48115: 1333:public:
48116: 1334:    void f() { cout << "HasF::f()" << endl; }
48117: 1335:};
48118: 1336:
48119: 1337:int main() {
48120: 1338:    HasF hf;
48121: 1339:    Manipulator<HasF> manipulator(hf);
48122: 1340:    manipulator.manipulate();
48123: 1341:}
48124: 1342:/* Output:
48125: 1343:HasF::f()
48126: 1344:*/
48127: 1345:```
48128: 1346:
48129: 1347:**Manipulator** 类存储了一个 **T** 类型的对象。`manipulate()` 方法会调用 **obj** 上的 `f()` 方法。它是如何知道类型参数 **T** 中存在 `f()` 方法的呢？C++ 编译器会在你实例化模版时进行检查，所以在 `Manipulator<HasF>` 实例化的那一刻，它看到 **HasF** 中含有一个方法 `f()`。如果情况并非如此，你就会得到一个编译期错误，保持类型安全。
48130: 1348:
48131: 1349:用 C++ 编写这种代码很简单，因为当模版被实例化时，模版代码就知道模版参数的类型。Java 泛型就不同了。下面是 **HasF** 的 Java 版本：
48132: 1350:
48133: 1351:```java
48134: 1352:// generics/HasF.java
48135: 1353:
48136: 1354:public class HasF {
48137: 1355:    public void f() {
48138: 1356:        System.out.println("HasF.f()");
48139: 1357:    }
48140: 1358:}
48141: 1359:```
48142: 1360:
48143: 1361:如果我们将示例的其余代码用 Java 实现，就不会通过编译：
48144: 1362:
48145: 1363:```java
48146: 1364:// generics/Manipulation.java
48147: 1365:// {WillNotCompile}
48148: 1366:
48149: 1367:class Manipulator<T> {
48150: 1368:    private T obj;
48151: 1369:    
48152: 1370:    Manipulator(T x) {
48153: 1371:        obj = x;
48154: 1372:    }
48155: 1373:    
48156: 1374:    // Error: cannot find symbol: method f():
48157: 1375:    public void manipulate() {
48158: 1376:        obj.f();
48159: 1377:    }
48160: 1378:}
48161: 1379:
48162: 1380:public class Manipulation {
48163: 1381:	public static void main(String[] args) {
48164: 1382:        HasF hf = new HasF();
48165: 1383:        Manipulator<HasF> manipulator = new Manipulator<>(hf);
48166: 1384:        manipulator.manipulate();
48167: 1385:    }
48168: 1386:}
48169: 1387:```
48170: 1388:
48171: 1389:因为擦除，Java 编译器无法将 `manipulate()` 方法必须能调用 **obj** 的 `f()` 方法这一需求映射到 HasF 具有 `f()` 方法这个事实上。为了调用 `f()`，我们必须协助泛型类，给定泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。这里重用了 **extends** 关键字。由于有了边界，下面的代码就能通过编译：
48172: 1390:
48173: 1391:```java
48174: 1392:public class Manipulator2<T extends HasF> {
48175: 1393:    private T obj;
48176: 1394:
48177: 1395:    Manipulator2(T x) {
48178: 1396:        obj = x;
48179: 1397:    }
48180: 1398:
48181: 1399:    public void manipulate() {
48182: 1400:        obj.f();
48183: 1401:    }
48184: 1402:}
48185: 1403:```
48186: 1404:
48187: 1405:边界 `<T extends HasF>` 声明 T 必须是 HasF 类型或其子类。如果情况确实如此，就可以安全地在 **obj** 上调用 `f()` 方法。
48188: 1406:
48189: 1407:我们说泛型类型参数会擦除到它的第一个边界（可能有多个边界，稍后你将看到）。我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的示例，**T** 擦除到了 **HasF**，就像在类的声明中用 **HasF** 替换了 **T** 一样。
48190: 1408:
48191: 1409:你可能正确地观察到了泛型在 **Manipulator2.java** 中没有贡献任何事。你可以很轻松地自己去执行擦除，生成没有泛型的类：
48192: 1410:
48193: 1411:```java
48194: 1412:// generics/Manipulator3.java
48195: 1413:
48196: 1414:class Manipulator3 {
48197: 1415:    private HasF obj;
48198: 1416:    
48199: 1417:    Manipulator3(HasF x) {
48200: 1418:        obj = x;
48201: 1419:    }
48202: 1420:    
48203: 1421:    public void manipulate() {
48204: 1422:        obj.f();
48205: 1423:    }
48206: 1424:}
48207: 1425:```
48208: 1426:
48209: 1427:这提出了很重要的一点：泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用。因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换更加复杂。但是，不能因此认为使用 `<T extends HasF>` 形式就是有缺陷的。例如，如果某个类有一个返回 **T** 的方法，那么泛型就有所帮助，因为它们之后将返回确切的类型：
48210: 1428:
48211: 1429:```java
48212: 1430:// generics/ReturnGenericType.java
48213: 1431:
48214: 1432:public class ReturnGenericType<T extends HasF> {
48215: 1433:    private T obj;
48216: 1434:    
48217: 1435:    ReturnGenericType(T x) {
48218: 1436:        obj = x;
48219: 1437:    }
48220: 1438:    
48221: 1439:    public T get() {
48222: 1440:        return obj;
48223: 1441:    }
48224: 1442:}
48225: 1443:```
48226: 1444:
48227: 1445:你必须查看所有的代码，从而确定代码是否复杂到必须使用泛型的程度。
48228: 1446:
48229: 1447:我们将在本章稍后看到有关边界的更多细节。
48230: 1448:
48231: 1449:### 迁移兼容性
48232: 1450:
48233: 1451:为了减少潜在的关于擦除的困惑，你必须清楚地认识到这不是一个语言特性。它是 Java 实现泛型的一种妥协，因为泛型不是 Java 语言出现时就有的，所以就有了这种妥协。它会使你痛苦，因此你需要尽早习惯它并了解为什么它会这样。
48234: 1452:
48235: 1453:如果 Java 1.0 就含有泛型的话，那么这个特性就不会使用擦除来实现——它会使用具体化，保持参数类型为第一类实体，因此你就能在类型参数上执行基于类型的语言操作和反射操作。本章稍后你会看到，擦除减少了泛型的泛化性。泛型在 Java 中仍然是有用的，只是不如它们本来设想的那么有用，而原因就是擦除。
48236: 1454:
48237: 1455:在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文使用泛型类型。泛型类型只有在静态类型检测期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如， `List<T>` 这样的类型注解会被擦除为 **List**，普通的类型变量在未指定边界的情况下会被擦除为 **Object**。
48238: 1456:
48239: 1457:擦除的核心动机是你可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常被称为“迁移兼容性”。在理想情况下，所有事物将在指定的某天被泛化。在现实中，即使程序员只编写泛型代码，他们也必须处理 Java 5 之前编写的非泛型类库。这些类库的作者可能从没想过要泛化他们的代码，或许他们可能刚刚开始接触泛型。
48240: 1458:
48241: 1459:因此 Java 泛型不仅必须支持向后兼容性——现有的代码和类文件仍然合法，继续保持之前的含义——而且还必须支持迁移兼容性，使得类库能按照它们自己的步调变为泛型，当某个类库变为泛型时，不会破坏依赖于它的代码和应用。在确定了这个目标后，Java 设计者们和从事此问题相关工作的各个团队决策认为擦除是唯一可行的解决方案。擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。
48242: 1460:
48243: 1461:例如，假设一个应用使用了两个类库 **X** 和 **Y**，**Y** 使用了类库 **Z**。随着 Java 5 的出现，这个应用和这些类库的创建者最终可能希望迁移到泛型上。但是当进行迁移时，它们有着不同的动机和限制。为了实现迁移兼容性，每个类库与应用必须与其他所有的部分是否使用泛型无关。因此，它们不能探测其他类库是否使用了泛型。因此，某个特定的类库使用了泛型这样的证据必须被”擦除“。
48244: 1462:
48245: 1463:如果没有某种类型的迁移途径，所有已经构建了很长时间的类库就需要与希望迁移到 Java 泛型上的开发者们说再见了。类库毫无争议是编程语言的一部分，对生产效率有着极大的影响，所以这种代码无法接受。擦除是否是最佳的或唯一的迁移途径，还待时间来证明。
48246: 1464:
48247: 1465:### 擦除的问题
48248: 1466:
48249: 1467:因此，擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中。擦除允许你继续使用现有的非泛型客户端代码，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会骤然破坏所有现有的代码。
48250: 1468:
48251: 1469:擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作中，例如转型、**instanceof** 操作和 **new** 表达式。因为所有关于参数的类型信息都丢失了，当你在编写泛型代码时，必须时刻提醒自己，你只是看起来拥有有关参数的类型信息而已。
48252: 1470:
48253: 1471:考虑如下的代码段：
48254: 1472:
48255: 1473:```java
48256: 1474:class Foo<T> {
48257: 1475:    T var;
48258: 1476:}
48259: 1477:```
48260: 1478:
48261: 1479:看上去当你创建一个 **Foo** 实例时：
48262: 1480:
48263: 1481:```java
48264: 1482:Foo<Cat> f = new Foo<>();
48265: 1483:```
48266: 1484:
48267: 1485:**class** **Foo** 中的代码应该知道现在工作于 **Cat** 之上。泛型语法也在强烈暗示整个类中所有 T 出现的地方都被替换，就像在 C++ 中一样。但是事实并非如此，当你在编写这个类的代码时，必须提醒自己：“不，这只是一个 **Object**“。
48268: 1486:
48269: 1487:另外，擦除和迁移兼容性意味着，使用泛型并不是强制的，尽管你可能希望这样：
48270: 1488:
48271: 1489:```java
48272: 1490:// generics/ErasureAndInheritance.java
48273: 1491:
48274: 1492:class GenericBase<T> {
48275: 1493:    private T element;
48276: 1494:    
48277: 1495:    public void set(T arg) {
48278: 1496:        element = arg;
48279: 1497:    }
48280: 1498:    
48281: 1499:    public T get() {
48282: 1500:        return element;
48283: 1501:    }
48284: 1502:}
48285: 1503:
48286: 1504:class Derived1<T> extends GenericBase<T> {}
48287: 1505:
48288: 1506:class Derived2 extends GenericBase {} // No warning
48289: 1507:
48290: 1508:// class Derived3 extends GenericBase<?> {}
48291: 1509:// Strange error:
48292: 1510:// unexpected type
48293: 1511:// required: class or interface without bounds
48294: 1512:public class ErasureAndInteritance {
48295: 1513:    @SuppressWarnings("unchecked")
48296: 1514:    public static void main(String[] args) {
48297: 1515:        Derived2 d2 = new Derived2();
48298: 1516:        Object obj = d2.get();
48299: 1517:        d2.set(obj); // Warning here!
48300: 1518:    }
48301: 1519:}
48302: 1520:```
48303: 1521:
48304: 1522:**Derived2** 继承自 **GenericBase**，但是没有任何类型参数，编译器没有发出任何警告。直到调用 `set()` 方法时才出现警告。
48305: 1523:
48306: 1524:为了关闭警告，Java 提供了一个注解，我们可以在列表中看到它：
48307: 1525:
48308: 1526:```java
48309: 1527:@SuppressWarnings("unchecked")
48310: 1528:```
48311: 1529:
48312: 1530:这个注解放置在产生警告的方法上，而不是整个类上。当你要关闭警告时，最好尽可能地“聚焦”，这样就不会因为过于宽泛地关闭警告，而导致意外地遮蔽掉真正的问题。
48313: 1531:
48314: 1532:可以推断，**Derived3** 产生的错误意味着编译器期望得到一个原生基类。
48315: 1533:
48316: 1534:当你希望将类型参数不仅仅当作 Object 处理时，就需要付出额外努力来管理边界，并且与在 C++、Ada 和 Eiffel 这样的语言中获得参数化类型相比，你需要付出多得多的努力来获得少得多的回报。这并不是说，对于大多数的编程问题而言，这些语言通常都会比 Java 更得心应手，只是说它们的参数化类型机制相比 Java 更灵活、更强大。
48317: 1535:
48318: 1536:### 边界处的动作
48319: 1537:
48320: 1538:因为擦除，我发现了泛型最令人困惑的方面是可以表示没有任何意义的事物。例如：
48321: 1539:
48322: 1540:```java
48323: 1541:// generics/ArrayMaker.java
48324: 1542:
48325: 1543:import java.lang.reflect.*;
48326: 1544:import java.util.*;
48327: 1545:
48328: 1546:public class ArrayMaker<T> {
48329: 1547:    private Class<T> kind;
48330: 1548:
48331: 1549:    public ArrayMaker(Class<T> kind) {
48332: 1550:        this.kind = kind;
48333: 1551:    }
48334: 1552:
48335: 1553:    @SuppressWarnings("unchecked")
48336: 1554:    T[] create(int size) {
48337: 1555:        return (T[]) Array.newInstance(kind, size);
48338: 1556:    }
48339: 1557:
48340: 1558:    public static void main(String[] args) {
48341: 1559:        ArrayMaker<String> stringMaker = new ArrayMaker<>(String.class);
48342: 1560:        String[] stringArray = stringMaker.create(9);
48343: 1561:        System.out.println(Arrays.toString(stringArray));
48344: 1562:    }
48345: 1563:}
48346: 1564:/* Output
48347: 1565:[null,null,null,null,null,null,null,null,null]
48348: 1566:*/
48349: 1567:```
48350: 1568:
48351: 1569:即使 **kind** 被存储为 `Class<T>`，擦除也意味着它实际被存储为没有任何参数的 **Class**。因此，当你在使用它时，例如创建数组，`Array.newInstance()` 实际上并未拥有 **kind** 所蕴含的类型信息。所以它不会产生具体的结果，因而必须转型，这会产生一条令你无法满意的警告。
48352: 1570:
48353: 1571:注意，对于在泛型中创建数组，使用 `Array.newInstance()` 是推荐的方式。
48354: 1572:
48355: 1573:如果我们创建一个集合而不是数组，情况就不同了：
48356: 1574:
48357: 1575:```java
48358: 1576:// generics/ListMaker.java
48359: 1577:
48360: 1578:import java.util.*;
48361: 1579:
48362: 1580:public class ListMaker<T> {
48363: 1581:    List<T> create() {
48364: 1582:        return new ArrayList<>();
48365: 1583:    }
48366: 1584:    
48367: 1585:    public static void main(String[] args) {
48368: 1586:        ListMaker<String> stringMaker = new ListMaker<>();
48369: 1587:        List<String> stringList = stringMaker.create();
48370: 1588:    }
48371: 1589:}
48372: 1590:```
48373: 1591:
48374: 1592:编译器不会给出任何警告，尽管我们知道（从擦除中）在 `create()` 内部的 `new ArrayList<>()` 中的 `<T>` 被移除了——在运行时，类内部没有任何 `<T>`，因此这看起来毫无意义。但是如果你遵从这种思路，并将这个表达式改为 `new ArrayList()`，编译器就会发出警告。
48375: 1593:
48376: 1594:本例中这么做真的毫无意义吗？如果在创建 **List** 的同时向其中放入一些对象呢，像这样：
48377: 1595:
48378: 1596:```java
48379: 1597:// generics/FilledList.java
48380: 1598:
48381: 1599:import java.util.*;
48382: 1600:import java.util.function.*;
48383: 1601:import onjava.*;
48384: 1602:
48385: 1603:public class FilledList<T> extends ArrayList<T> {
48386: 1604:    FilledList(Supplier<T> gen, int size) {
48387: 1605:        Suppliers.fill(this, gen, size);
48388: 1606:    }
48389: 1607:    
48390: 1608:    public FilledList(T t, int size) {
48391: 1609:        for (int i = 0; i < size; i++) {
48392: 1610:            this.add(t);
48393: 1611:        }
48394: 1612:    }
48395: 1613:    
48396: 1614:    public static void main(String[] args) {
48397: 1615:        List<String> list = new FilledList<>("Hello", 4);
48398: 1616:        System.out.println(list);
48399: 1617:        // Supplier version:
48400: 1618:        List<Integer> ilist = new FilledList<>(() -> 47, 4);
48401: 1619:        System.out.println(ilist);
48402: 1620:    }
48403: 1621:}
48404: 1622:/* Output:
48405: 1623:[Hello,Hello,Hello,Hello]
48406: 1624:[47,47,47,47]
48407: 1625:*/
48408: 1626:```
48409: 1627:
48410: 1628:即使编译器无法得知 `add()` 中的 **T** 的任何信息，但它仍可以在编译期确保你放入 **FilledList** 中的对象是 **T** 类型。因此，即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。
48411: 1629:
48412: 1630:因为擦除移除了方法体中的类型信息，所以在运行时的问题就是*边界*：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。
48413: 1631:
48414: 1632:考虑如下这段非泛型示例：
48415: 1633:
48416: 1634:```java
48417: 1635:// generics/SimpleHolder.java
48418: 1636:
48419: 1637:public class SimpleHolder {
48420: 1638:    private Object obj;
48421: 1639:    
48422: 1640:    public void set(Object obj) {
48423: 1641:        this.obj = obj;
48424: 1642:    }
48425: 1643:    
48426: 1644:    public Object get() {
48427: 1645:        return obj;
48428: 1646:    }
48429: 1647:    
48430: 1648:    public static void main(String[] args) {
48431: 1649:        SimpleHolder holder = new SimpleHolder();
48432: 1650:        holder.set("Item");
48433: 1651:        String s = (String) holder.get();
48434: 1652:    }
48435: 1653:}
48436: 1654:```
48437: 1655:
48438: 1656:如果用 **javap -c SimpleHolder** 反编译这个类，会得到如下内容（经过编辑）：
48439: 1657:
48440: 1658:```java
48441: 1659:public void set(java.lang.Object);
48442: 1660:   0: aload_0
48443: 1661:   1: aload_1
48444: 1662:   2: putfield #2; // Field obj:Object;
48445: 1663:   5: return
48446: 1664:    
48447: 1665:public java.lang.Object get();
48448: 1666:   0: aload_0
48449: 1667:   1: getfield #2; // Field obj:Object;
48450: 1668:   4: areturn
48451: 1669:    
48452: 1670:public static void main(java.lang.String[]);
48453: 1671:   0: new #3; // class SimpleHolder
48454: 1672:   3: dup
48455: 1673:   4: invokespecial #4; // Method "<init>":()V
48456: 1674:   7: astore_1
48457: 1675:   8: aload_1
48458: 1676:   9: ldc #5; // String Item
48459: 1677:   11: invokevirtual #6; // Method set:(Object;)V
48460: 1678:   14: aload_1
48461: 1679:   15: invokevirtual #7; // Method get:()Object;
48462: 1680:   18: checkcast #8; // class java/lang/String
48463: 1681:   21: astore_2
48464: 1682:   22: return
48465: 1683:```
48466: 1684:
48467: 1685:`set()` 和 `get()` 方法存储和产生值，转型在调用 `get()` 时接受检查。
48468: 1686:
48469: 1687:现在将泛型融入上例代码中：
48470: 1688:
48471: 1689:```java
48472: 1690:// generics/GenericHolder2.java
48473: 1691:
48474: 1692:public class GenericHolder2<T> {
48475: 1693:    private T obj;
48476: 1694:
48477: 1695:    public void set(T obj) {
48478: 1696:        this.obj = obj;
48479: 1697:    }
48480: 1698:
48481: 1699:    public T get() {
48482: 1700:        return obj;
48483: 1701:    }
48484: 1702:
48485: 1703:    public static void main(String[] args) {
48486: 1704:        GenericHolder2<String> holder =  new GenericHolder2<>();
48487: 1705:        holder.set("Item");
48488: 1706:        String s = holder.get();
48489: 1707:    }
48490: 1708:}
48491: 1709:```
48492: 1710:
48493: 1711:从 `get()` 返回后的转型消失了，但是我们还知道传递给 `set()` 的值在编译期会被检查。下面是相关的字节码：
48494: 1712:
48495: 1713:```java
48496: 1714:public void set(java.lang.Object);
48497: 1715:   0: aload_0
48498: 1716:   1: aload_1
48499: 1717:   2: putfield #2; // Field obj:Object;
48500: 1718:   5: return
48501: 1719:       
48502: 1720:public java.lang.Object get();
48503: 1721:   0: aload_0
48504: 1722:   1: getfield #2; // Field obj:Object;
48505: 1723:   4: areturn
48506: 1724:       
48507: 1725:public static void main(java.lang.String[]);
48508: 1726:   0: new #3; // class GenericHolder2
48509: 1727:   3: dup
48510: 1728:   4: invokespecial #4; // Method "<init>":()V
48511: 1729:   7: astore_1
48512: 1730:   8: aload_1
48513: 1731:   9: ldc #5; // String Item
48514: 1732:   11: invokevirtual #6; // Method set:(Object;)V
48515: 1733:   14: aload_1
48516: 1734:   15: invokevirtual #7; // Method get:()Object;
48517: 1735:   18: checkcast #8; // class java/lang/String
48518: 1736:   21: astore_2
48519: 1737:   22: return
48520: 1738:```
48521: 1739:
48522: 1740:所产生的字节码是相同的。对进入 `set()` 的类型进行检查是不需要的，因为这将由编译器执行。而对 `get()` 返回的值进行转型仍然是需要的，只不过不需要你来操作，它由编译器自动插入，这样你就不用编写（阅读）杂乱的代码。
48523: 1741:
48524: 1742:`get()` 和 `set()` 产生了相同的字节码，这就告诉我们泛型的所有动作都发生在边界处——对入参的编译器检查和对返回值的转型。这有助于澄清对擦除的困惑，记住：“边界就是动作发生的地方”。
48525: 1743:
48526: 1744:<!-- Compensating for Erasure -->
48527: 1745:
48528: 1746:## 补偿擦除
48529: 1747:
48530: 1748:因为擦除，我们将失去执行泛型代码中某些操作的能力。无法在运行时知道确切类型：
48531: 1749:
48532: 1750:```java
48533: 1751:// generics/Erased.java
48534: 1752:// {WillNotCompile}
48535: 1753:
48536: 1754:public class Erased<T> {
48537: 1755:    private final int SIZE = 100;
48538: 1756:
48539: 1757:    public void f(Object arg) {
48540: 1758:        // error: illegal generic type for instanceof
48541: 1759:        if (arg instanceof T) {
48542: 1760:        }
48543: 1761:        // error: unexpected type
48544: 1762:        T var = new T();
48545: 1763:        // error: generic array creation
48546: 1764:        T[] array = new T[SIZE];
48547: 1765:        // warning: [unchecked] unchecked cast
48548: 1766:        T[] array = (T[]) new Object[SIZE];
48549: 1767:
48550: 1768:    }
48551: 1769:}
48552: 1770:```
48553: 1771:
48554: 1772:有时，我们可以对这些问题进行编程，但是有时必须通过引入类型标签来补偿擦除。这意味着为所需的类型显式传递一个 **Class** 对象，以在类型表达式中使用它。
48555: 1773:
48556: 1774:例如，由于擦除了类型信息，因此在上一个程序中尝试使用 **instanceof** 将会失败。类型标签可以使用动态 `isInstance()` ：
48557: 1775:
48558: 1776:```java
48559: 1777:// generics/ClassTypeCapture.java
48560: 1778:
48561: 1779:class Building {
48562: 1780:}
48563: 1781:
48564: 1782:class House extends Building {
48565: 1783:}
48566: 1784:
48567: 1785:public class ClassTypeCapture<T> {
48568: 1786:    Class<T> kind;
48569: 1787:
48570: 1788:    public ClassTypeCapture(Class<T> kind) {
48571: 1789:        this.kind = kind;
48572: 1790:    }
48573: 1791:
48574: 1792:    public boolean f(Object arg) {
48575: 1793:        return kind.isInstance(arg);
48576: 1794:    }
48577: 1795:
48578: 1796:    public static void main(String[] args) {
48579: 1797:        ClassTypeCapture<Building> ctt1 =
48580: 1798:                new ClassTypeCapture<>(Building.class);
48581: 1799:        System.out.println(ctt1.f(new Building()));
48582: 1800:        System.out.println(ctt1.f(new House()));
48583: 1801:        ClassTypeCapture<House> ctt2 =
48584: 1802:                new ClassTypeCapture<>(House.class);
48585: 1803:        System.out.println(ctt2.f(new Building()));
48586: 1804:        System.out.println(ctt2.f(new House()));
48587: 1805:    }
48588: 1806:}
48589: 1807:/* Output:
48590: 1808:true
48591: 1809:true
48592: 1810:false
48593: 1811:true
48594: 1812:*/
48595: 1813:```
48596: 1814:
48597: 1815:编译器来保证类型标签与泛型参数相匹配。
48598: 1816:
48599: 1817:<!-- Creating Instances of Types -->
48600: 1818:
48601: 1819:### 创建类型的实例
48602: 1820:
48603: 1821:试图在 **Erased.java** 中 `new T()` 是行不通的，部分原因是由于擦除，部分原因是编译器无法验证 **T** 是否具有默认（无参）构造函数。但是在 C++ 中，此操作自然，直接且安全（在编译时检查）：
48604: 1822:
48605: 1823:```C++
48606: 1824:// generics/InstantiateGenericType.cpp
48607: 1825:// C++, not Java!
48608: 1826:
48609: 1827:template<class T> class Foo {
48610: 1828:  T x; // Create a field of type T
48611: 1829:  T* y; // Pointer to T
48612: 1830:public:
48613: 1831:  // Initialize the pointer:
48614: 1832:  Foo() { y = new T(); }
48615: 1833:};
48616: 1834:
48617: 1835:class Bar {};
48618: 1836:
48619: 1837:int main() {
48620: 1838:  Foo<Bar> fb;
48621: 1839:  Foo<int> fi; // ... and it works with primitives
48622: 1840:}
48623: 1841:```
48624: 1842:
48625: 1843:Java 中的解决方案是传入一个工厂对象，并使用该对象创建新实例。方便的工厂对象只是 **Class** 对象，因此，如果使用类型标记，则可以使用 `newInstance()` 创建该类型的新对象：
48626: 1844:
48627: 1845:```java
48628: 1846:// generics/InstantiateGenericType.java
48629: 1847:
48630: 1848:import java.util.function.Supplier;
48631: 1849:
48632: 1850:class ClassAsFactory<T> implements Supplier<T> {
48633: 1851:    Class<T> kind;
48634: 1852:
48635: 1853:    ClassAsFactory(Class<T> kind) {
48636: 1854:        this.kind = kind;
48637: 1855:    }
48638: 1856:
48639: 1857:    @Override
48640: 1858:    public T get() {
48641: 1859:        try {
48642: 1860:            return kind.newInstance();
48643: 1861:        } catch (InstantiationException |
48644: 1862:                IllegalAccessException e) {
48645: 1863:            throw new RuntimeException(e);
48646: 1864:        }
48647: 1865:    }
48648: 1866:}
48649: 1867:
48650: 1868:class Employee {
48651: 1869:    @Override
48652: 1870:    public String toString() {
48653: 1871:        return "Employee";
48654: 1872:    }
48655: 1873:}
48656: 1874:
48657: 1875:public class InstantiateGenericType {
48658: 1876:    public static void main(String[] args) {
48659: 1877:        ClassAsFactory<Employee> fe =
48660: 1878:                new ClassAsFactory<>(Employee.class);
48661: 1879:        System.out.println(fe.get());
48662: 1880:        ClassAsFactory<Integer> fi =
48663: 1881:                new ClassAsFactory<>(Integer.class);
48664: 1882:        try {
48665: 1883:            System.out.println(fi.get());
48666: 1884:        } catch (Exception e) {
48667: 1885:            System.out.println(e.getMessage());
48668: 1886:        }
48669: 1887:    }
48670: 1888:}
48671: 1889:/* Output:
48672: 1890:Employee
48673: 1891:java.lang.InstantiationException: java.lang.Integer
48674: 1892:*/
48675: 1893:```
48676: 1894:
48677: 1895:这样可以编译，但对于 `ClassAsFactory<Integer>` 会失败，这是因为 **Integer** 没有无参构造函数。由于错误不是在编译时捕获的，因此语言创建者不赞成这种方法。他们建议使用显式工厂（**Supplier**）并约束类型，以便只有实现该工厂的类可以这样创建对象。这是创建工厂的两种不同方法：
48678: 1896:
48679: 1897:```java
48680: 1898:// generics/FactoryConstraint.java
48681: 1899:
48682: 1900:import onjava.Suppliers;
48683: 1901:
48684: 1902:import java.util.ArrayList;
48685: 1903:import java.util.List;
48686: 1904:import java.util.function.Supplier;
48687: 1905:
48688: 1906:class IntegerFactory implements Supplier<Integer> {
48689: 1907:    private int i = 0;
48690: 1908:
48691: 1909:    @Override
48692: 1910:    public Integer get() {
48693: 1911:        return ++i;
48694: 1912:    }
48695: 1913:}
48696: 1914:
48697: 1915:class Widget {
48698: 1916:    private int id;
48699: 1917:
48700: 1918:    Widget(int n) {
48701: 1919:        id = n;
48702: 1920:    }
48703: 1921:
48704: 1922:    @Override
48705: 1923:    public String toString() {
48706: 1924:        return "Widget " + id;
48707: 1925:    }
48708: 1926:
48709: 1927:    public static
48710: 1928:    class Factory implements Supplier<Widget> {
48711: 1929:        private int i = 0;
48712: 1930:
48713: 1931:        @Override
48714: 1932:        public Widget get() {
48715: 1933:            return new Widget(++i);
48716: 1934:        }
48717: 1935:    }
48718: 1936:}
48719: 1937:
48720: 1938:class Fudge {
48721: 1939:    private static int count = 1;
48722: 1940:    private int n = count++;
48723: 1941:
48724: 1942:    @Override
48725: 1943:    public String toString() {
48726: 1944:        return "Fudge " + n;
48727: 1945:    }
48728: 1946:}
48729: 1947:
48730: 1948:class Foo2<T> {
48731: 1949:    private List<T> x = new ArrayList<>();
48732: 1950:
48733: 1951:    Foo2(Supplier<T> factory) {
48734: 1952:        Suppliers.fill(x, factory, 5);
48735: 1953:    }
48736: 1954:
48737: 1955:    @Override
48738: 1956:    public String toString() {
48739: 1957:        return x.toString();
48740: 1958:    }
48741: 1959:}
48742: 1960:
48743: 1961:public class FactoryConstraint {
48744: 1962:    public static void main(String[] args) {
48745: 1963:        System.out.println(
48746: 1964:                new Foo2<>(new IntegerFactory()));
48747: 1965:        System.out.println(
48748: 1966:                new Foo2<>(new Widget.Factory()));
48749: 1967:        System.out.println(
48750: 1968:                new Foo2<>(Fudge::new));
48751: 1969:    }
48752: 1970:}
48753: 1971:/* Output:
48754: 1972:[1, 2, 3, 4, 5]
48755: 1973:[Widget 1, Widget 2, Widget 3, Widget 4, Widget 5]
48756: 1974:[Fudge 1, Fudge 2, Fudge 3, Fudge 4, Fudge 5]
48757: 1975:*/
48758: 1976:```
48759: 1977:
48760: 1978:**IntegerFactory** 本身就是通过实现 `Supplier<Integer>` 的工厂。 **Widget** 包含一个内部类，它是一个工厂。还要注意，**Fudge** 并没有做任何类似于工厂的操作，并且传递 `Fudge::new` 仍然会产生工厂行为，因为编译器将对函数方法 `::new` 的调用转换为对 `get()` 的调用。
48761: 1979:
48762: 1980:另一种方法是模板方法设计模式。在以下示例中，`create()` 是模板方法，在子类中被重写以生成该类型的对象：
48763: 1981:
48764: 1982:```java
48765: 1983:// generics/CreatorGeneric.java
48766: 1984:
48767: 1985:abstract class GenericWithCreate<T> {
48768: 1986:    final T element;
48769: 1987:
48770: 1988:    GenericWithCreate() {
48771: 1989:        element = create();
48772: 1990:    }
48773: 1991:
48774: 1992:    abstract T create();
48775: 1993:}
48776: 1994:
48777: 1995:class X {
48778: 1996:}
48779: 1997:
48780: 1998:class XCreator extends GenericWithCreate<X> {
48781: 1999:    @Override
48782: 2000:    X create() {
48783: 2001:        return new X();
48784: 2002:    }
48785: 2003:
48786: 2004:    void f() {
48787: 2005:        System.out.println(
48788: 2006:                element.getClass().getSimpleName());
48789: 2007:    }
48790: 2008:}
48791: 2009:
48792: 2010:public class CreatorGeneric {
48793: 2011:    public static void main(String[] args) {
48794: 2012:        XCreator xc = new XCreator();
48795: 2013:        xc.f();
48796: 2014:    }
48797: 2015:}
48798: 2016:/* Output:
48799: 2017:X
48800: 2018:*/
48801: 2019:```
48802: 2020:
48803: 2021:**GenericWithCreate** 包含 `element` 字段，并通过无参构造函数强制其初始化，该构造函数又调用抽象的 `create()` 方法。这种创建方式可以在子类中定义，同时建立 **T** 的类型。
48804: 2022:
48805: 2023:<!-- Arrays of Generics -->
48806: 2024:
48807: 2025:### 泛型数组
48808: 2026:
48809: 2027:正如在 **Erased.java** 中所看到的，我们无法创建泛型数组。通用解决方案是在试图创建泛型数组的时候使用 **ArrayList** ：
48810: 2028:
48811: 2029:```java
48812: 2030:// generics/ListOfGenerics.java
48813: 2031:
48814: 2032:import java.util.ArrayList;
48815: 2033:import java.util.List;
48816: 2034:
48817: 2035:public class ListOfGenerics<T> {
48818: 2036:    private List<T> array = new ArrayList<>();
48819: 2037:
48820: 2038:    public void add(T item) {
48821: 2039:        array.add(item);
48822: 2040:    }
48823: 2041:
48824: 2042:    public T get(int index) {
48825: 2043:        return array.get(index);
48826: 2044:    }
48827: 2045:}
48828: 2046:```
48829: 2047:
48830: 2048:这样做可以获得数组的行为，并且还具有泛型提供的编译时类型安全性。
48831: 2049:
48832: 2050:有时，仍然会创建泛型类型的数组（例如， **ArrayList** 在内部使用数组）。可以通过使编译器满意的方式定义对数组的通用引用：
48833: 2051:
48834: 2052:```java
48835: 2053:// generics/ArrayOfGenericReference.java
48836: 2054:
48837: 2055:class Generic<T> {
48838: 2056:}
48839: 2057:
48840: 2058:public class ArrayOfGenericReference {
48841: 2059:    static Generic<Integer>[] gia;
48842: 2060:}
48843: 2061:```
48844: 2062:
48845: 2063:编译器接受此操作而不产生警告。但是我们永远无法创建具有该确切类型（包括类型参数）的数组，因此有点令人困惑。由于所有数组，无论它们持有什么类型，都具有相同的结构（每个数组插槽的大小和数组布局），因此似乎可以创建一个 **Object** 数组并将其转换为所需的数组类型。实际上，这确实可以编译，但是会产生 **ClassCastException** ：
48846: 2064:
48847: 2065:```java
48848: 2066:// generics/ArrayOfGeneric.java
48849: 2067:
48850: 2068:public class ArrayOfGeneric {
48851: 2069:    static final int SIZE = 100;
48852: 2070:    static Generic<Integer>[] gia;
48853: 2071:
48854: 2072:    @SuppressWarnings("unchecked")
48855: 2073:    public static void main(String[] args) {
48856: 2074:        try {
48857: 2075:            gia = (Generic<Integer>[]) new Object[SIZE];
48858: 2076:        } catch (ClassCastException e) {
48859: 2077:            System.out.println(e.getMessage());
48860: 2078:        }
48861: 2079:        // Runtime type is the raw (erased) type:
48862: 2080:        gia = (Generic<Integer>[]) new Generic[SIZE];
48863: 2081:        System.out.println(gia.getClass().getSimpleName());
48864: 2082:        gia[0] = new Generic<>();
48865: 2083:        //- gia[1] = new Object(); // Compile-time error
48866: 2084:        // Discovers type mismatch at compile time:
48867: 2085:        //- gia[2] = new Generic<Double>();
48868: 2086:    }
48869: 2087:}
48870: 2088:/* Output:
48871: 2089:[Ljava.lang.Object; cannot be cast to [LGeneric;
48872: 2090:Generic[]
48873: 2091:*/
48874: 2092:```
48875: 2093:
48876: 2094:问题在于数组会跟踪其实际类型，而该类型是在创建数组时建立的。因此，即使 `gia` 被强制转换为 `Generic<Integer>[]` ，该信息也仅在编译时存在（并且没有 **@SuppressWarnings** 注解，将会收到有关该强制转换的警告）。在运行时，它仍然是一个 **Object** 数组，这会引起问题。成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换。
48877: 2095:
48878: 2096:让我们看一个更复杂的示例。考虑一个包装数组的简单泛型包装器：
48879: 2097:
48880: 2098:```java
48881: 2099:// generics/GenericArray.java
48882: 2100:
48883: 2101:public class GenericArray<T> {
48884: 2102:    private T[] array;
48885: 2103:
48886: 2104:    @SuppressWarnings("unchecked")
48887: 2105:    public GenericArray(int sz) {
48888: 2106:        array = (T[]) new Object[sz];
48889: 2107:    }
48890: 2108:
48891: 2109:    public void put(int index, T item) {
48892: 2110:        array[index] = item;
48893: 2111:    }
48894: 2112:
48895: 2113:    public T get(int index) {
48896: 2114:        return array[index];
48897: 2115:    }
48898: 2116:
48899: 2117:    // Method that exposes the underlying representation:
48900: 2118:    public T[] rep() {
48901: 2119:        return array;
48902: 2120:    }
48903: 2121:
48904: 2122:    public static void main(String[] args) {
48905: 2123:        GenericArray<Integer> gai = new GenericArray<>(10);
48906: 2124:        try {
48907: 2125:            Integer[] ia = gai.rep();
48908: 2126:        } catch (ClassCastException e) {
48909: 2127:            System.out.println(e.getMessage());
48910: 2128:        }
48911: 2129:        // This is OK:
48912: 2130:        Object[] oa = gai.rep();
48913: 2131:    }
48914: 2132:}
48915: 2133:/* Output:
48916: 2134:[Ljava.lang.Object; cannot be cast to
48917: 2135:[Ljava.lang.Integer;
48918: 2136:*/
48919: 2137:```
48920: 2138:
48921: 2139:和以前一样，我们不能说 `T[] array = new T[sz]` ，所以我们创建了一个 **Object** 数组并将其强制转换。
48922: 2140:
48923: 2141:`rep()` 方法返回一个 `T[]` ，在主方法中它应该是 `gai` 的 `Integer[]`，但是如果调用它并尝试将结果转换为 `Integer[]` 引用，则会得到 **ClassCastException** ，这再次是因为实际的运行时类型为 `Object[]` 。
48924: 2142:
48925: 2143:如果再注释掉 **@SuppressWarnings** 注解后编译 **GenericArray.java** ，则编译器会产生警告：
48926: 2144:
48927: 2145:```java
48928: 2146:GenericArray.java uses unchecked or unsafe operations.
48929: 2147:Recompile with -Xlint:unchecked for details.
48930: 2148:```
48931: 2149:
48932: 2150:在这里，我们收到了一个警告，我们认为这是有关强制转换的。
48933: 2151:
48934: 2152:但是要真正确定，请使用 `-Xlint：unchecked` 进行编译：
48935: 2153:
48936: 2154:```java
48937: 2155:GenericArray.java:7: warning: [unchecked] unchecked cast    array = (T[])new Object[sz];                 ^  required: T[]  found:    Object[]  where T is a type-variable:    T extends Object declared in class GenericArray 1 warning
48938: 2156:```
48939: 2157:
48940: 2158:确实是在抱怨那个强制转换。由于警告会变成噪音，因此，一旦我们确认预期会出现特定警告，我们可以做的最好的办法就是使用 **@SuppressWarnings** 将其关闭。这样，当警告确实出现时，我们将进行实际调查。
48941: 2159:
48942: 2160:由于擦除，数组的运行时类型只能是 `Object[]` 。 如果我们立即将其转换为 `T[]` ，则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。因此，最好在集合中使用 `Object[]` ，并在使用数组元素时向 **T** 添加强制类型转换。让我们来看看在 **GenericArray.java** 示例中会是怎么样的：
48943: 2161:
48944: 2162:```java
48945: 2163:// generics/GenericArray2.java
48946: 2164:
48947: 2165:public class GenericArray2<T> {
48948: 2166:    private Object[] array;
48949: 2167:
48950: 2168:    public GenericArray2(int sz) {
48951: 2169:        array = new Object[sz];
48952: 2170:    }
48953: 2171:
48954: 2172:    public void put(int index, T item) {
48955: 2173:        array[index] = item;
48956: 2174:    }
48957: 2175:
48958: 2176:    @SuppressWarnings("unchecked")
48959: 2177:    public T get(int index) {
48960: 2178:        return (T) array[index];
48961: 2179:    }
48962: 2180:
48963: 2181:    @SuppressWarnings("unchecked")
48964: 2182:    public T[] rep() {
48965: 2183:        return (T[]) array; // Unchecked cast
48966: 2184:    }
48967: 2185:
48968: 2186:    public static void main(String[] args) {
48969: 2187:        GenericArray2<Integer> gai =
48970: 2188:                new GenericArray2<>(10);
48971: 2189:        for (int i = 0; i < 10; i++)
48972: 2190:            gai.put(i, i);
48973: 2191:        for (int i = 0; i < 10; i++)
48974: 2192:            System.out.print(gai.get(i) + " ");
48975: 2193:        System.out.println();
48976: 2194:        try {
48977: 2195:            Integer[] ia = gai.rep();
48978: 2196:        } catch (Exception e) {
48979: 2197:            System.out.println(e);
48980: 2198:        }
48981: 2199:    }
48982: 2200:}
48983: 2201:/* Output:
48984: 2202:0 1 2 3 4 5 6 7 8 9
48985: 2203:java.lang.ClassCastException: [Ljava.lang.Object;
48986: 2204:cannot be cast to [Ljava.lang.Integer;
48987: 2205:*/
48988: 2206:```
48989: 2207:
48990: 2208:最初，看起来并没有太大不同，只是转换的位置移动了。没有 **@SuppressWarnings** 注解，仍然会收到“unchecked”警告。但是，内部表示现在是 `Object[]` 而不是 `T[]` 。 调用 `get()` 时，它将对象强制转换为 **T** ，实际上这是正确的类型，因此很安全。但是，如果调用 `rep()` ，它将再次尝试将 `Object[]` 强制转换为 `T[]` ，但仍然不正确，并在编译时生成警告，并在运行时生成异常。因此，无法破坏基础数组的类型，该基础数组只能是 `Object[]` 。在内部将数组视为 `Object[]` 而不是 `T[]` 的优点是，我们不太可能会忘记数组的运行时类型并意外地引入了bug，尽管大多数（也许是全部）此类错误会在运行时被迅速检测到。
48991: 2209:
48992: 2210:对于新代码，请传入类型标记。在这种情况下，**GenericArray** 如下所示：
48993: 2211:
48994: 2212:```java
48995: 2213:// generics/GenericArrayWithTypeToken.java
48996: 2214:
48997: 2215:import java.lang.reflect.Array;
48998: 2216:
48999: 2217:public class GenericArrayWithTypeToken<T> {
49000: 2218:    private T[] array;
49001: 2219:
49002: 2220:    @SuppressWarnings("unchecked")
49003: 2221:    public GenericArrayWithTypeToken(Class<T> type, int sz) {
49004: 2222:        array = (T[]) Array.newInstance(type, sz);
49005: 2223:    }
49006: 2224:
49007: 2225:    public void put(int index, T item) {
49008: 2226:        array[index] = item;
49009: 2227:    }
49010: 2228:
49011: 2229:    public T get(int index) {
49012: 2230:        return array[index];
49013: 2231:    }
49014: 2232:
49015: 2233:    // Expose the underlying representation:
49016: 2234:    public T[] rep() {
49017: 2235:        return array;
49018: 2236:    }
49019: 2237:
49020: 2238:    public static void main(String[] args) {
49021: 2239:        GenericArrayWithTypeToken<Integer> gai =
49022: 2240:                new GenericArrayWithTypeToken<>(
49023: 2241:                        Integer.class, 10);
49024: 2242:        // This now works:
49025: 2243:        Integer[] ia = gai.rep();
49026: 2244:    }
49027: 2245:}
49028: 2246:```
49029: 2247:
49030: 2248:类型标记 **Class\<T\>** 被传递到构造函数中以从擦除中恢复，因此尽管必须使用 **@SuppressWarnings** 关闭来自强制类型转换的警告，但我们仍可以创建所需的实际数组类型。一旦获得了实际的类型，就可以返回它并产生所需的结果，如在主方法中看到的那样。数组的运行时类型是确切的类型 `T[]` 。
49031: 2249:
49032: 2250:不幸的是，如果查看 Java 标准库中的源代码，你会发现到处都有从 **Object** 数组到参数化类型的转换。例如，这是**ArrayList** 中，复制一个 **Collection** 的构造函数，这里为了简化，去除了源码中对此不重要的代码：
49033: 2251:
49034: 2252:```java
49035: 2253:public ArrayList(Collection c) {
49036: 2254:  size = c.size();
49037: 2255:  elementData = (E[])new Object[size];
49038: 2256:  c.toArray(elementData);
49039: 2257:}
49040: 2258:```
49041: 2259:
49042: 2260:如果你浏览 **ArrayList.java** 的代码，将会发现很多此类强制转换。当我们编译它时会发生什么？
49043: 2261:
49044: 2262:```java
49045: 2263:Note: ArrayList.java uses unchecked or unsafe operations
49046: 2264:Note: Recompile with -Xlint:unchecked for details.
49047: 2265:```
49048: 2266:
49049: 2267:果然，标准库会产生很多警告。如果你使用过 C 语言，尤其是使用 ANSI C 之前的语言，你会记住警告的特殊效果：发现警告后，可以忽略它们。因此，除非程序员必须对其进行处理，否则最好不要从编译器发出任何类型的消息。
49050: 2268:
49051: 2269:Neal Gafter（Java 5 的主要开发人员之一）在他的博客中[^2]指出，他在重写 Java 库时是很随意、马虎的，我们不应该像他那样做。Neal 还指出，他在不破坏现有接口的情况下无法修复某些 Java 库代码。因此，即使在 Java 库源代码中出现了一些习惯用法，它们也不一定是正确的做法。当查看库代码时，我们不能认为这就是要在自己代码中必须遵循的示例。
49052: 2270:
49053: 2271:请注意，在 Java 文献中推荐使用类型标记技术，例如 Gilad Bracha 的论文《Generics in the Java Programming Language》[^3]，他指出：“例如，这种用法已广泛用于新的 API 中以处理注解。” 我发现此技术在人们对于舒适度的看法方面存在一些不一致之处；有些人强烈喜欢本章前面介绍的工厂方法。
49054: 2272:
49055: 2273:<!-- Bounds -->
49056: 2274:
49057: 2275:## 边界
49058: 2276:
49059: 2277:*边界*（bounds）在本章的前面进行了简要介绍。边界允许我们对泛型使用的参数类型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果是我们可以在绑定的类型中调用方法。
49060: 2278:
49061: 2279:由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 **Object** 可用的方法。但是，如果将该参数限制为某类型的子集，则可以调用该子集中的方法。为了应用约束，Java 泛型使用了 `extends` 关键字。
49062: 2280:
49063: 2281:重要的是要理解，当用于限定泛型类型时，`extends` 的含义与通常的意义截然不同。此示例展示边界的基础应用：
49064: 2282:
49065: 2283:```java
49066: 2284:// generics/BasicBounds.java
49067: 2285:
49068: 2286:interface HasColor {
49069: 2287:    java.awt.Color getColor();
49070: 2288:}
49071: 2289:
49072: 2290:class WithColor<T extends HasColor> {
49073: 2291:    T item;
49074: 2292:
49075: 2293:    WithColor(T item) {
49076: 2294:        this.item = item;
49077: 2295:    }
49078: 2296:
49079: 2297:    T getItem() {
49080: 2298:        return item;
49081: 2299:    }
49082: 2300:
49083: 2301:    // The bound allows you to call a method:
49084: 2302:    java.awt.Color color() {
49085: 2303:        return item.getColor();
49086: 2304:    }
49087: 2305:}
49088: 2306:
49089: 2307:class Coord {
49090: 2308:    public int x, y, z;
49091: 2309:}
49092: 2310:
49093: 2311:// This fails. Class must be first, then interfaces:
49094: 2312:// class WithColorCoord<T extends HasColor & Coord> {
49095: 2313:
49096: 2314:// Multiple bounds:
49097: 2315:class WithColorCoord<T extends Coord & HasColor> {
49098: 2316:    T item;
49099: 2317:
49100: 2318:    WithColorCoord(T item) {
49101: 2319:        this.item = item;
49102: 2320:    }
49103: 2321:
49104: 2322:    T getItem() {
49105: 2323:        return item;
49106: 2324:    }
49107: 2325:
49108: 2326:    java.awt.Color color() {
49109: 2327:        return item.getColor();
49110: 2328:    }
49111: 2329:
49112: 2330:    int getX() {
49113: 2331:        return item.x;
49114: 2332:    }
49115: 2333:
49116: 2334:    int getY() {
49117: 2335:        return item.y;
49118: 2336:    }
49119: 2337:
49120: 2338:    int getZ() {
49121: 2339:        return item.z;
49122: 2340:    }
49123: 2341:}
49124: 2342:
49125: 2343:interface Weight {
49126: 2344:    int weight();
49127: 2345:}
49128: 2346:
49129: 2347:// As with inheritance, you can have only one
49130: 2348:// concrete class but multiple interfaces:
49131: 2349:class Solid<T extends Coord & HasColor & Weight> {
49132: 2350:    T item;
49133: 2351:
49134: 2352:    Solid(T item) {
49135: 2353:        this.item = item;
49136: 2354:    }
49137: 2355:
49138: 2356:    T getItem() {
49139: 2357:        return item;
49140: 2358:    }
49141: 2359:
49142: 2360:    java.awt.Color color() {
49143: 2361:        return item.getColor();
49144: 2362:    }
49145: 2363:
49146: 2364:    int getX() {
49147: 2365:        return item.x;
49148: 2366:    }
49149: 2367:
49150: 2368:    int getY() {
49151: 2369:        return item.y;
49152: 2370:    }
49153: 2371:
49154: 2372:    int getZ() {
49155: 2373:        return item.z;
49156: 2374:    }
49157: 2375:
49158: 2376:    int weight() {
49159: 2377:        return item.weight();
49160: 2378:    }
49161: 2379:}
49162: 2380:
49163: 2381:class Bounded
49164: 2382:        extends Coord implements HasColor, Weight {
49165: 2383:    @Override
49166: 2384:    public java.awt.Color getColor() {
49167: 2385:        return null;
49168: 2386:    }
49169: 2387:
49170: 2388:    @Override
49171: 2389:    public int weight() {
49172: 2390:        return 0;
49173: 2391:    }
49174: 2392:}
49175: 2393:
49176: 2394:public class BasicBounds {
49177: 2395:    public static void main(String[] args) {
49178: 2396:        Solid<Bounded> solid =
49179: 2397:                new Solid<>(new Bounded());
49180: 2398:        solid.color();
49181: 2399:        solid.getY();
49182: 2400:        solid.weight();
49183: 2401:    }
49184: 2402:}
49185: 2403:```
49186: 2404:
49187: 2405:你可能会观察到 **BasicBounds.java** 中似乎包含一些冗余，它们可以通过继承来消除。在这里，每个继承级别还添加了边界约束：
49188: 2406:
49189: 2407:```java
49190: 2408:// generics/InheritBounds.java
49191: 2409:
49192: 2410:class HoldItem<T> {
49193: 2411:    T item;
49194: 2412:
49195: 2413:    HoldItem(T item) {
49196: 2414:        this.item = item;
49197: 2415:    }
49198: 2416:
49199: 2417:    T getItem() {
49200: 2418:        return item;
49201: 2419:    }
49202: 2420:}
49203: 2421:
49204: 2422:class WithColor2<T extends HasColor>
49205: 2423:        extends HoldItem<T> {
49206: 2424:    WithColor2(T item) {
49207: 2425:        super(item);
49208: 2426:    }
49209: 2427:
49210: 2428:    java.awt.Color color() {
49211: 2429:        return item.getColor();
49212: 2430:    }
49213: 2431:}
49214: 2432:
49215: 2433:class WithColorCoord2<T extends Coord & HasColor>
49216: 2434:        extends WithColor2<T> {
49217: 2435:    WithColorCoord2(T item) {
49218: 2436:        super(item);
49219: 2437:    }
49220: 2438:
49221: 2439:    int getX() {
49222: 2440:        return item.x;
49223: 2441:    }
49224: 2442:
49225: 2443:    int getY() {
49226: 2444:        return item.y;
49227: 2445:    }
49228: 2446:
49229: 2447:    int getZ() {
49230: 2448:        return item.z;
49231: 2449:    }
49232: 2450:}
49233: 2451:
49234: 2452:class Solid2<T extends Coord & HasColor & Weight>
49235: 2453:        extends WithColorCoord2<T> {
49236: 2454:    Solid2(T item) {
49237: 2455:        super(item);
49238: 2456:    }
49239: 2457:
49240: 2458:    int weight() {
49241: 2459:        return item.weight();
49242: 2460:    }
49243: 2461:}
49244: 2462:
49245: 2463:public class InheritBounds {
49246: 2464:    public static void main(String[] args) {
49247: 2465:        Solid2<Bounded> solid2 =
49248: 2466:                new Solid2<>(new Bounded());
49249: 2467:        solid2.color();
49250: 2468:        solid2.getY();
49251: 2469:        solid2.weight();
49252: 2470:    }
49253: 2471:}
49254: 2472:```
49255: 2473:
49256: 2474:**HoldItem** 拥有一个对象，因此此行为将继承到 **WithColor2** 中，这也需要其参数符合 **HasColor**。 **WithColorCoord2** 和 **Solid2** 进一步扩展了层次结构，并在每个级别添加了边界。现在，这些方法已被继承，并且在每个类中不再重复。
49257: 2475:
49258: 2476:这是一个具有更多层次的示例：
49259: 2477:
49260: 2478:```java
49261: 2479:// generics/EpicBattle.java
49262: 2480:// Bounds in Java generics
49263: 2481:
49264: 2482:import java.util.List;
49265: 2483:
49266: 2484:interface SuperPower {
49267: 2485:}
49268: 2486:
49269: 2487:interface XRayVision extends SuperPower {
49270: 2488:    void seeThroughWalls();
49271: 2489:}
49272: 2490:
49273: 2491:interface SuperHearing extends SuperPower {
49274: 2492:    void hearSubtleNoises();
49275: 2493:}
49276: 2494:
49277: 2495:interface SuperSmell extends SuperPower {
49278: 2496:    void trackBySmell();
49279: 2497:}
49280: 2498:
49281: 2499:class SuperHero<POWER extends SuperPower> {
49282: 2500:    POWER power;
49283: 2501:
49284: 2502:    SuperHero(POWER power) {
49285: 2503:        this.power = power;
49286: 2504:    }
49287: 2505:
49288: 2506:    POWER getPower() {
49289: 2507:        return power;
49290: 2508:    }
49291: 2509:}
49292: 2510:
49293: 2511:class SuperSleuth<POWER extends XRayVision>
49294: 2512:        extends SuperHero<POWER> {
49295: 2513:    SuperSleuth(POWER power) {
49296: 2514:        super(power);
49297: 2515:    }
49298: 2516:
49299: 2517:    void see() {
49300: 2518:        power.seeThroughWalls();
49301: 2519:    }
49302: 2520:}
49303: 2521:
49304: 2522:class
49305: 2523:CanineHero<POWER extends SuperHearing & SuperSmell>
49306: 2524:        extends SuperHero<POWER> {
49307: 2525:    CanineHero(POWER power) {
49308: 2526:        super(power);
49309: 2527:    }
49310: 2528:
49311: 2529:    void hear() {
49312: 2530:        power.hearSubtleNoises();
49313: 2531:    }
49314: 2532:
49315: 2533:    void smell() {
49316: 2534:        power.trackBySmell();
49317: 2535:    }
49318: 2536:}
49319: 2537:
49320: 2538:class SuperHearSmell
49321: 2539:        implements SuperHearing, SuperSmell {
49322: 2540:    @Override
49323: 2541:    public void hearSubtleNoises() {
49324: 2542:    }
49325: 2543:
49326: 2544:    @Override
49327: 2545:    public void trackBySmell() {
49328: 2546:    }
49329: 2547:}
49330: 2548:
49331: 2549:class DogPerson extends CanineHero<SuperHearSmell> {
49332: 2550:    DogPerson() {
49333: 2551:        super(new SuperHearSmell());
49334: 2552:    }
49335: 2553:}
49336: 2554:
49337: 2555:public class EpicBattle {
49338: 2556:    // Bounds in generic methods:
49339: 2557:    static <POWER extends SuperHearing>
49340: 2558:    void useSuperHearing(SuperHero<POWER> hero) {
49341: 2559:        hero.getPower().hearSubtleNoises();
49342: 2560:    }
49343: 2561:
49344: 2562:    static <POWER extends SuperHearing & SuperSmell>
49345: 2563:    void superFind(SuperHero<POWER> hero) {
49346: 2564:        hero.getPower().hearSubtleNoises();
49347: 2565:        hero.getPower().trackBySmell();
49348: 2566:    }
49349: 2567:
49350: 2568:    public static void main(String[] args) {
49351: 2569:        DogPerson dogPerson = new DogPerson();
49352: 2570:        useSuperHearing(dogPerson);
49353: 2571:        superFind(dogPerson);
49354: 2572:        // You can do this:
49355: 2573:        List<? extends SuperHearing> audioPeople;
49356: 2574:        // But you can't do this:
49357: 2575:        // List<? extends SuperHearing & SuperSmell> dogPs;
49358: 2576:    }
49359: 2577:}
49360: 2578:```
49361: 2579:
49362: 2580:接下来将要研究的通配符将会把范围限制在单个类型。
49363: 2581:
49364: 2582:<!-- Wildcards -->
49365: 2583:
49366: 2584:## 通配符
49367: 2585:
49368: 2586:你已经在 [集合](book/12-Collections.md) 章节中看到了一些简单示例使用了通配符——在泛型参数表达式中的问号，在 [类型信息](book/19-Type-Information.md) 一章中这种示例更多。本节将更深入地探讨这个特性。
49369: 2587:
49370: 2588:我们的起始示例要展示数组的一种特殊行为：你可以将派生类的数组赋值给基类的引用：
49371: 2589:
49372: 2590:```java
49373: 2591:// generics/CovariantArrays.java
49374: 2592:
49375: 2593:class Fruit {}
49376: 2594:
49377: 2595:class Apple extends Fruit {}
49378: 2596:
49379: 2597:class Jonathan extends Apple {}
49380: 2598:
49381: 2599:class Orange extends Fruit {}
49382: 2600:
49383: 2601:public class CovariantArrays {
49384: 2602:    
49385: 2603:    public static void main(String[] args) {
49386: 2604:        Fruit[] fruit = new Apple[10];
49387: 2605:        fruit[0] = new Apple(); // OK
49388: 2606:        fruit[1] = new Jonathan(); // OK
49389: 2607:        // Runtime type is Apple[], not Fruit[] or Orange[]:
49390: 2608:        try {
49391: 2609:            // Compiler allows you to add Fruit:
49392: 2610:            fruit[0] = new Fruit(); // ArrayStoreException
49393: 2611:        } catch (Exception e) {
49394: 2612:            System.out.println(e);
49395: 2613:        }
49396: 2614:        try {
49397: 2615:            // Compiler allows you to add Oranges:
49398: 2616:            fruit[0] = new Orange(); // ArrayStoreException
49399: 2617:        } catch (Exception e) {
49400: 2618:            System.out.println(e);
49401: 2619:        }
49402: 2620:    }
49403: 2621:}
49404: 2622:/* Output:
49405: 2623:java.lang.ArrayStoreException: Fruit
49406: 2624:java.lang.ArrayStoreException: Orange
49407: 2625:```
49408: 2626:
49409: 2627:`main()` 中的第一行创建了 **Apple** 数组，并赋值给一个 **Fruit** 数组引用。这是有意义的，因为 **Apple** 也是一种 **Fruit**，因此 **Apple** 数组应该也是一个 **Fruit** 数组。
49410: 2628:
49411: 2629:但是，如果实际的数组类型是 **Apple[]**，你可以在其中放置 **Apple** 或 **Apple** 的子类型，这在编译期和运行时都可以工作。但是你也可以在数组中放置 **Fruit** 对象。这对编译器来说是有意义的，因为它有一个 **Fruit[]** 引用——它有什么理由不允许将 **Fruit** 对象或任何从 **Fruit** 继承出来的对象（比如 **Orange**），放置到这个数组中呢？因此在编译期，这是允许的。然而，运行时的数组机制知道它处理的是 **Apple[]**，因此会在向数组中放置异构类型时抛出异常。
49412: 2630:
49413: 2631:向上转型用在这里不合适。你真正在做的是将一个数组赋值给另一个数组。数组的行为是持有其他对象，这里只是因为我们能够向上转型而已，所以很明显，数组对象可以保留有关它们包含的对象类型的规则。看起来就像数组对它们持有的对象是有意识的，因此在编译期检查和运行时检查之间，你不能滥用它们。
49414: 2632:
49415: 2633:数组的这种赋值并不是那么可怕，因为在运行时你可以发现插入了错误的类型。但是泛型的主要目标之一是将这种错误检测移到编译期。所以当我们试图使用泛型集合代替数组时，会发生什么呢？
49416: 2634:
49417: 2635:```java
49418: 2636:// generics/NonCovariantGenerics.java
49419: 2637:// {WillNotCompile}
49420: 2638:
49421: 2639:import java.util.*;
49422: 2640:
49423: 2641:public class NonCovariantGenerics {
49424: 2642:    // Compile Error: incompatible types:
49425: 2643:    List<Fruit> flist = new ArrayList<Apple>();
49426: 2644:}
49427: 2645:```
49428: 2646:
49429: 2647:尽管你在首次阅读这段代码时会认为“不能将一个 **Apple** 集合赋值给一个 **Fruit** 集合”。记住，泛型不仅仅是关于集合，它真正要表达的是“不能把一个涉及 **Apple** 的泛型赋值给一个涉及 **Fruit** 的泛型”。如果像在数组中的情况一样，编译器对代码的了解足够多，可以确定所涉及到的集合，那么它可能会留下一些余地。但是它不知道任何有关这方面的信息，因此它拒绝向上转型。然而实际上这也不是向上转型—— **Apple** 的 **List** 不是 **Fruit** 的 **List**。**Apple** 的 **List** 将持有 **Apple** 和 **Apple** 的子类型，**Fruit** 的 **List** 将持有任何类型的 **Fruit**。是的，这包括 **Apple**，但是它不是一个 **Apple** 的 **List**，它仍然是 **Fruit** 的 **List**。**Apple** 的 **List** 在类型上不等价于 **Fruit** 的 **List**，即使 **Apple** 是一种 **Fruit** 类型。
49430: 2648:
49431: 2649:真正的问题是我们在讨论的集合类型，而不是集合持有对象的类型。与数组不同，泛型没有内建的协变类型。这是因为数组是完全在语言中定义的，因此可以具有编译期和运行时的内建检查，但是在使用泛型时，编译器和运行时系统不知道你想用类型做什么，以及应该采用什么规则。
49432: 2650:
49433: 2651:但是，有时你想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。
49434: 2652:
49435: 2653:```java
49436: 2654:// generics/GenericsAndCovariance.java
49437: 2655:
49438: 2656:import java.util.*;
49439: 2657:
49440: 2658:public class GenericsAndCovariance {
49441: 2659:    
49442: 2660:    public static void main(String[] args) {
49443: 2661:        // Wildcards allow covariance:
49444: 2662:        List<? extends Fruit> flist = new ArrayList<>();
49445: 2663:        // Compile Error: can't add any type of object:
49446: 2664:        // flist.add(new Apple());
49447: 2665:        // flist.add(new Fruit());
49448: 2666:        // flist.add(new Object());
49449: 2667:        flist.add(null); // Legal but uninteresting
49450: 2668:        // We know it returns at least Fruit:
49451: 2669:        Fruit f = flist.get(0);
49452: 2670:    }
49453: 2671:    
49454: 2672:}
49455: 2673:```
49456: 2674:
49457: 2675:**flist** 的类型现在是 `List<? extends Fruit>`，你可以读作“一个具有任何从 **Fruit** 继承的类型的列表”。然而，这实际上并不意味着这个 **List** 将持有任何类型的 **Fruit**。通配符引用的是明确的类型，因此它意味着“某种 **flist** 引用没有指定的具体类型”。因此这个被赋值的 **List** 必须持有诸如 **Fruit** 或 **Apple** 这样的指定类型，但是为了向上转型为 **Fruit**，这个类型是什么没人在意。
49458: 2676:
49459: 2677:**List** 必须持有一种具体的 **Fruit** 或 **Fruit** 的子类型，但是如果你不关心具体的类型是什么，那么你能对这样的 **List** 做什么呢？如果不知道 **List** 中持有的对象是什么类型，你怎能保证安全地向其中添加对象呢？就像在 **CovariantArrays.java** 中向上转型一样，你不能，除非编译器而不是运行时系统可以阻止这种操作的发生。你很快就会发现这个问题。
49460: 2678:
49461: 2679:你可能认为事情开始变得有点走极端了，因为现在你甚至不能向刚刚声明过将持有 **Apple** 对象的 **List** 中放入一个 **Apple** 对象。是的，但编译器并不知道这一点。`List<? extends Fruit>` 可能合法地指向一个 `List<Orange>`。一旦执行这种类型的向上转型，你就丢失了向其中传递任何对象的能力，甚至传递 **Object** 也不行。
49462: 2680:
49463: 2681:另一方面，如果你调用了一个返回 **Fruit** 的方法，则是安全的，因为你知道这个 **List** 中的任何对象至少具有 **Fruit** 类型，因此编译器允许这么做。
49464: 2682:
49465: 2683:### 编译器有多聪明
49466: 2684:
49467: 2685:现在你可能会猜想自己不能去调用任何接受参数的方法，但是考虑下面的代码：
49468: 2686:
49469: 2687:```java
49470: 2688:// generics/CompilerIntelligence.java
49471: 2689:
49472: 2690:import java.util.*;
49473: 2691:
49474: 2692:public class CompilerIntelligence {
49475: 2693:    
49476: 2694:    public static void main(String[] args) {
49477: 2695:        List<? extends Fruit> flist = Arrays.asList(new Apple());
49478: 2696:        Apple a = (Apple) flist.get(0); // No warning
49479: 2697:        flist.contains(new Apple()); // Argument is 'Object'
49480: 2698:        flist.indexOf(new Apple()); // Argument is 'Object'
49481: 2699:    }
49482: 2700:    
49483: 2701:}
49484: 2702:```
49485: 2703:
49486: 2704:这里对 `contains()` 和 `indexOf()` 的调用接受 **Apple** 对象作为参数，执行没问题。这是否意味着编译器实际上会检查代码，以查看是否有某个特定的方法修改了它的对象？
49487: 2705:
49488: 2706:通过查看 **ArrayList** 的文档，我们发现编译器没有那么聪明。尽管 `add()` 接受一个泛型参数类型的参数，但 `contains()` 和 `indexOf()` 接受的参数类型是 **Object**。因此当你指定一个 `ArrayList<? extends Fruit>` 时，`add()` 的参数就变成了"**? extends Fruit**"。从这个描述中，编译器无法得知这里需要 **Fruit** 的哪个具体子类型，因此它不会接受任何类型的 **Fruit**。如果你先把 **Apple** 向上转型为 **Fruit**，也没有关系——编译器仅仅会拒绝调用像 `add()` 这样参数列表中涉及通配符的方法。
49489: 2707:
49490: 2708:`contains()` 和 `indexOf()` 的参数类型是 **Object**，不涉及通配符，所以编译器允许调用它们。这意味着将由泛型类的设计者来决定哪些调用是“安全的”，并使用 **Object** 类作为它们的参数类型。为了禁止对类型中使用了通配符的方法调用，需要在参数列表中使用类型参数。
49491: 2709:
49492: 2710:下面展示一个简单的 **Holder** 类：
49493: 2711:
49494: 2712:```java
49495: 2713:// generics/Holder.java
49496: 2714:
49497: 2715:public class Holder<T> {
49498: 2716:
49499: 2717:    private T value;
49500: 2718:
49501: 2719:    public Holder() {}
49502: 2720:
49503: 2721:    public Holder(T val) {
49504: 2722:        value = val;
49505: 2723:    }
49506: 2724:
49507: 2725:    public void set(T val) {
49508: 2726:        value = val;
49509: 2727:    }
49510: 2728:
49511: 2729:    public T get() {
49512: 2730:        return value;
49513: 2731:    }
49514: 2732:
49515: 2733:    @Override
49516: 2734:    public boolean equals(Object o) {
49517: 2735:        return o instanceof Holder && Objects.equals(value, ((Holder) o).value);
49518: 2736:    }
49519: 2737:
49520: 2738:    @Override
49521: 2739:    public int hashCode() {
49522: 2740:        return Objects.hashCode(value);
49523: 2741:    }
49524: 2742:
49525: 2743:    public static void main(String[] args) {
49526: 2744:        Holder<Apple> apple = new Holder<>(new Apple());
49527: 2745:        Apple d = apple.get();
49528: 2746:        apple.set(d);
49529: 2747:        // Holder<Fruit> fruit = apple; // Cannot upcast
49530: 2748:        Holder<? extends Fruit> fruit = apple; // OK
49531: 2749:        Fruit p = fruit.get();
49532: 2750:        d = (Apple) fruit.get();
49533: 2751:        try {
49534: 2752:            Orange c = (Orange) fruit.get(); // No warning
49535: 2753:        } catch (Exception e) {
49536: 2754:            System.out.println(e);
49537: 2755:        }
49538: 2756:        // fruit.set(new Apple()); // Cannot call set()
49539: 2757:        // fruit.set(new Fruit()); // Cannot call set()
49540: 2758:        System.out.println(fruit.equals(d)); // OK
49541: 2759:    }
49542: 2760:}
49543: 2761:/* Output
49544: 2762:java.lang.ClassCastException: Apple cannot be cast to Orange
49545: 2763:false
49546: 2764:*/
49547: 2765:```
49548: 2766:
49549: 2767:**Holder** 有一个接受 **T** 类型对象的 `set()` 方法，一个返回 T 对象的 `get()` 方法和一个接受 Object 对象的 `equals()` 方法。正如你所见，如果创建了一个 `Holder<Apple>`，就不能将其向上转型为 `Holder<Fruit>`，但是可以向上转型为 `Holder<? extends Fruit>`。如果调用 `get()`，只能返回一个 **Fruit**——这就是在给定“任何扩展自 **Fruit** 的对象”这一边界后，它所能知道的一切了。如果你知道更多的信息，就可以将其转型到某种具体的 **Fruit** 而不会导致任何警告，但是存在得到 **ClassCastException** 的风险。`set()` 方法不能工作在 **Apple** 和 **Fruit** 上，因为 `set()` 的参数也是"**? extends Fruit**"，意味着它可以是任何事物，编译器无法验证“任何事物”的类型安全性。
49550: 2768:
49551: 2769:但是，`equals()` 方法可以正常工作，因为它接受的参数是 **Object** 而不是 **T** 类型。因此，编译器只关注传递进来和要返回的对象类型。它不会分析代码，以查看是否执行了任何实际的写入和读取操作。
49552: 2770:
49553: 2771:Java 7 引入了 **java.util.Objects** 库，使创建 `equals()` 和 `hashCode()` 方法变得更加容易，当然还有很多其他功能。`equals()` 方法的标准形式参考 [附录：理解 equals 和 hashCode 方法](book/Appendix-Understanding-equals-and-hashCode) 一章。
49554: 2772:
49555: 2773:### 逆变
49556: 2774:
49557: 2775:还可以走另外一条路，即使用超类型通配符。这里，可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 `<？super MyClass>` ，或者甚至使用类型参数： `<？super T>`（尽管你不能对泛型参数给出一个超类型边界；即不能声明 `<T super MyClass>` ）。这使得你可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，就可以向 **Collection** 写入了：
49558: 2776:
49559: 2777:```java
49560: 2778:// generics/SuperTypeWildcards.java
49561: 2779:import java.util.*;
49562: 2780:public class SuperTypeWildcards {
49563: 2781:    static void writeTo(List<? super Apple> apples) {
49564: 2782:        apples.add(new Apple());
49565: 2783:        apples.add(new Jonathan());
49566: 2784:        // apples.add(new Fruit()); // Error
49567: 2785:    }
49568: 2786:}
49569: 2787:```
49570: 2788:
49571: 2789:参数 **apples** 是 **Apple** 的某种基类型的 **List**，这样你就知道向其中添加 **Apple** 或 **Apple** 的子类型是安全的。但是因为 **Apple** 是下界，所以你知道向这样的 **List** 中添加 **Fruit** 是不安全的，因为这将使这个 **List** 敞开口子，从而可以向其中添加非 **Apple** 类型的对象，而这是违反静态类型安全的。
49572: 2790:下面的示例复习了一下逆变和通配符的的使用：
49573: 2791:
49574: 2792:```java
49575: 2793:// generics/GenericReading.java
49576: 2794:import java.util.*;
49577: 2795:
49578: 2796:public class GenericReading {
49579: 2797:    static List<Apple> apples = Arrays.asList(new Apple());
49580: 2798:    static List<Fruit> fruit = Arrays.asList(new Fruit());
49581: 2799:    
49582: 2800:    static <T> T readExact(List<T> list) {
49583: 2801:        return list.get(0);
49584: 2802:    }
49585: 2803:    
49586: 2804:    // A static method adapts to each call:
49587: 2805:    static void f1() {
49588: 2806:        Apple a = readExact(apples);
49589: 2807:        Fruit f = readExact(fruit);
49590: 2808:        f = readExact(apples);
49591: 2809:    }
49592: 2810:    
49593: 2811:    // A class type is established
49594: 2812:    // when the class is instantiated:
49595: 2813:    static class Reader<T> {
49596: 2814:        T readExact(List<T> list) { 
49597: 2815:            return list.get(0); 
49598: 2816:        }
49599: 2817:    }
49600: 2818:    
49601: 2819:    static void f2() {
49602: 2820:        Reader<Fruit> fruitReader = new Reader<>();
49603: 2821:        Fruit f = fruitReader.readExact(fruit);
49604: 2822:        //- Fruit a = fruitReader.readExact(apples);
49605: 2823:        // error: incompatible types: List<Apple>
49606: 2824:        // cannot be converted to List<Fruit>
49607: 2825:    }
49608: 2826:    
49609: 2827:    static class CovariantReader<T> {
49610: 2828:        T readCovariant(List<? extends T> list) {
49611: 2829:            return list.get(0);
49612: 2830:        }
49613: 2831:    }
49614: 2832:    
49615: 2833:    static void f3() {
49616: 2834:        CovariantReader<Fruit> fruitReader = new CovariantReader<>();
49617: 2835:        Fruit f = fruitReader.readCovariant(fruit);
49618: 2836:        Fruit a = fruitReader.readCovariant(apples);
49619: 2837:    }
49620: 2838:    
49621: 2839:    public static void main(String[] args) {
49622: 2840:        f1(); 
49623: 2841:        f2(); 
49624: 2842:        f3();
49625: 2843:    }
49626: 2844:}
49627: 2845:```
49628: 2846:
49629: 2847:`readExact()` 方法使用了精确的类型。如果使用这个没有任何通配符的精确类型，就可以向 **List** 中写入和读取这个精确类型。另外，对于返回值，静态的泛型方法 `readExact()` 可以有效地“适应”每个方法调用，并能够从 `List<Apple>` 中返回一个 **Apple** ，从 `List<Fruit>` 中返回一个 **Fruit** ，就像在 `f1()` 中看到的那样。因此，如果可以摆脱静态泛型方法，那么在读取时就不需要协变类型了。
49630: 2848:然而对于泛型类来说，当你创建这个类的实例时，就要为这个类确定参数。就像在 `f2()` 中看到的，**fruitReader** 实例可以从 `List<Fruit>` 中读取一个 **Fruit** ，因为这就是它的确切类型。但是 `List<Apple>` 也应该产生 **Fruit** 对象，而 **fruitReader** 不允许这么做。
49631: 2849:为了修正这个问题，`CovariantReader.readCovariant()` 方法将接受 `List<？extends T>` ，因此，从这个列表中读取一个 **T** 是安全的（你知道在这个列表中的所有对象至少是一个 **T** ，并且可能是从 T 导出的某种对象）。在 `f3()` 中，你可以看到现在可以从 `List<Apple>` 中读取 **Fruit** 了。
49632: 2850:
49633: 2851:### 无界通配符
49634: 2852:
49635: 2853:无界通配符 `<?>` 看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器初看起来是支持这种判断的：
49636: 2854:
49637: 2855:```java
49638: 2856:// generics/UnboundedWildcards1.java
49639: 2857:import java.util.*;
49640: 2858:
49641: 2859:public class UnboundedWildcards1 {
49642: 2860:    static List list1;
49643: 2861:    static List<?> list2;
49644: 2862:    static List<? extends Object> list3;
49645: 2863:  
49646: 2864:    static void assign1(List list) {
49647: 2865:        list1 = list;
49648: 2866:        list2 = list;
49649: 2867:        //- list3 = list;
49650: 2868:        // warning: [unchecked] unchecked conversion
49651: 2869:        // list3 = list;
49652: 2870:        //         ^
49653: 2871:        // required: List<? extends Object>
49654: 2872:        // found:    List
49655: 2873:    }
49656: 2874:    
49657: 2875:    static void assign2(List<?> list) {
49658: 2876:        list1 = list;
49659: 2877:        list2 = list;
49660: 2878:        list3 = list;
49661: 2879:    }
49662: 2880:    
49663: 2881:    static void assign3(List<? extends Object> list) {
49664: 2882:        list1 = list;
49665: 2883:        list2 = list;
49666: 2884:        list3 = list;
49667: 2885:    }
49668: 2886:    
49669: 2887:    public static void main(String[] args) {
49670: 2888:        assign1(new ArrayList());
49671: 2889:        assign2(new ArrayList());
49672: 2890:        //- assign3(new ArrayList());
49673: 2891:        // warning: [unchecked] unchecked method invocation:
49674: 2892:        // method assign3 in class UnboundedWildcards1
49675: 2893:        // is applied to given types
49676: 2894:        // assign3(new ArrayList());
49677: 2895:        //        ^
49678: 2896:        // required: List<? extends Object>
49679: 2897:        // found: ArrayList
49680: 2898:        // warning: [unchecked] unchecked conversion
49681: 2899:        // assign3(new ArrayList());
49682: 2900:        //         ^
49683: 2901:        // required: List<? extends Object>
49684: 2902:        // found:    ArrayList
49685: 2903:        // 2 warnings
49686: 2904:        assign1(new ArrayList<>());
49687: 2905:        assign2(new ArrayList<>());
49688: 2906:        assign3(new ArrayList<>());
49689: 2907:        // Both forms are acceptable as List<?>:
49690: 2908:        List<?> wildList = new ArrayList();
49691: 2909:        wildList = new ArrayList<>();
49692: 2910:        assign1(wildList);
49693: 2911:        assign2(wildList);
49694: 2912:        assign3(wildList);
49695: 2913:    }
49696: 2914:}
49697: 2915:```
49698: 2916:
49699: 2917:有很多情况都和你在这里看到的情况类似，即编译器很少关心使用的是原生类型还是 `<?>` 。在这些情况中，`<?>` 可以被认为是一种装饰，但是它仍旧是很有价值的，因为，实际上它是在声明：“我是想用 Java 的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型。”
49700: 2918:第二个示例展示了无界通配符的一个重要应用。当你在处理多个泛型参数时，有时允许一个参数可以是任何类型，同时为其他参数确定某种特定类型的这种能力会显得很重要：
49701: 2919:
49702: 2920:```java
49703: 2921:// generics/UnboundedWildcards2.java
49704: 2922:import java.util.*;
49705: 2923:
49706: 2924:public class UnboundedWildcards2 {
49707: 2925:    static Map map1;
49708: 2926:    static Map<?,?> map2;
49709: 2927:    static Map<String,?> map3;
49710: 2928:  
49711: 2929:    static void assign1(Map map) { 
49712: 2930:        map1 = map; 
49713: 2931:    }
49714: 2932:    
49715: 2933:    static void assign2(Map<?,?> map) { 
49716: 2934:        map2 = map; 
49717: 2935:    }
49718: 2936:    
49719: 2937:    static void assign3(Map<String,?> map) { 
49720: 2938:        map3 = map; 
49721: 2939:    }
49722: 2940:    
49723: 2941:    public static void main(String[] args) {
49724: 2942:        assign1(new HashMap());
49725: 2943:        assign2(new HashMap());
49726: 2944:        //- assign3(new HashMap());
49727: 2945:        // warning: [unchecked] unchecked method invocation:
49728: 2946:        // method assign3 in class UnboundedWildcards2
49729: 2947:        // is applied to given types
49730: 2948:        //     assign3(new HashMap());
49731: 2949:        //            ^
49732: 2950:        //   required: Map<String,?>
49733: 2951:        //   found: HashMap
49734: 2952:        // warning: [unchecked] unchecked conversion
49735: 2953:        //     assign3(new HashMap());
49736: 2954:        //             ^
49737: 2955:        //   required: Map<String,?>
49738: 2956:        //   found:    HashMap
49739: 2957:        // 2 warnings
49740: 2958:        assign1(new HashMap<>());
49741: 2959:        assign2(new HashMap<>());
49742: 2960:        assign3(new HashMap<>());
49743: 2961:    }
49744: 2962:}
49745: 2963:```
49746: 2964:
49747: 2965:但是，当你拥有的全都是无界通配符时，就像在 `Map<?,?>` 中看到的那样，编译器看起来就无法将其与原生 **Map** 区分开了。另外， **UnboundedWildcards1.java** 展示了编译器处理  `List<?>` 和 `List<? extends Object>` 是不同的。
49748: 2966:令人困惑的是，编译器并非总是关注像 `List` 和 `List<?>` 之间的这种差异，因此它们看起来就像是相同的事物。事实上，因为泛型参数擦除到它的第一个边界，因此 `List<?>` 看起来等价于 `List<Object>` ，而 **List** 实际上也是 `List<Object>` ——除非这些语句都不为真。**List** 实际上表示“持有任何 **Object** 类型的原生 **List** ”，而 `List<?>` 表示“具有某种特定类型的非原生 **List** ，只是我们不知道类型是什么。”
49749: 2967:编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？下面的示例使用了前面定义的 `Holder<T>` 类，它包含接受 **Holder** 作为参数的各种方法，但是它们具有不同的形式：作为原生类型，具有具体的类型参数以及具有无界通配符参数：
49750: 2968:
49751: 2969:```java
49752: 2970:// generics/Wildcards.java
49753: 2971:// Exploring the meaning of wildcards
49754: 2972:
49755: 2973:public class Wildcards {
49756: 2974:    // Raw argument:
49757: 2975:    static void rawArgs(Holder holder, Object arg) {
49758: 2976:        //- holder.set(arg);
49759: 2977:        // warning: [unchecked] unchecked call to set(T)
49760: 2978:        // as a member of the raw type Holder
49761: 2979:        //     holder.set(arg);
49762: 2980:        //               ^
49763: 2981:        //   where T is a type-variable:
49764: 2982:        //     T extends Object declared in class Holder
49765: 2983:        // 1 warning
49766: 2984:
49767: 2985:        // Can't do this; don't have any 'T':
49768: 2986:        // T t = holder.get();
49769: 2987:
49770: 2988:        // OK, but type information is lost:
49771: 2989:        Object obj = holder.get();
49772: 2990:    }
49773: 2991:    
49774: 2992:    // Like rawArgs(), but errors instead of warnings:
49775: 2993:    static void unboundedArg(Holder<?> holder, Object arg) {
49776: 2994:        //- holder.set(arg);
49777: 2995:        // error: method set in class Holder<T>
49778: 2996:        // cannot be applied to given types;
49779: 2997:        //     holder.set(arg);
49780: 2998:        //           ^
49781: 2999:        //   required: CAP#1
49782: 3000:        //   found: Object
49783: 3001:        //   reason: argument mismatch;
49784: 3002:        //     Object cannot be converted to CAP#1
49785: 3003:        //   where T is a type-variable:
49786: 3004:        //     T extends Object declared in class Holder
49787: 3005:        //   where CAP#1 is a fresh type-variable:
49788: 3006:        //     CAP#1 extends Object from capture of ?
49789: 3007:        // 1 error
49790: 3008:
49791: 3009:        // Can't do this; don't have any 'T':
49792: 3010:        // T t = holder.get();
49793: 3011:
49794: 3012:        // OK, but type information is lost:
49795: 3013:        Object obj = holder.get();
49796: 3014:    }
49797: 3015:    
49798: 3016:    static <T> T exact1(Holder<T> holder) {
49799: 3017:        return holder.get();
49800: 3018:    }
49801: 3019:    
49802: 3020:    static <T> T exact2(Holder<T> holder, T arg) {
49803: 3021:        holder.set(arg);
49804: 3022:        return holder.get();
49805: 3023:    }
49806: 3024:    
49807: 3025:    static <T> T wildSubtype(Holder<? extends T> holder, T arg) {
49808: 3026:        //- holder.set(arg);
49809: 3027:        // error: method set in class Holder<T#2>
49810: 3028:        // cannot be applied to given types;
49811: 3029:        //     holder.set(arg);
49812: 3030:        //           ^
49813: 3031:        //   required: CAP#1
49814: 3032:        //   found: T#1
49815: 3033:        //   reason: argument mismatch;
49816: 3034:        //     T#1 cannot be converted to CAP#1
49817: 3035:        //   where T#1,T#2 are type-variables:
49818: 3036:        //     T#1 extends Object declared in method
49819: 3037:        //     <T#1>wildSubtype(Holder<? extends T#1>,T#1)
49820: 3038:        //     T#2 extends Object declared in class Holder
49821: 3039:        //   where CAP#1 is a fresh type-variable:
49822: 3040:        //     CAP#1 extends T#1 from
49823: 3041:        //       capture of ? extends T#1
49824: 3042:        // 1 error
49825: 3043:        return holder.get();
49826: 3044:    }
49827: 3045:    
49828: 3046:    static <T> void wildSupertype(Holder<? super T> holder, T arg) {
49829: 3047:        holder.set(arg);
49830: 3048:        //- T t = holder.get();
49831: 3049:        // error: incompatible types:
49832: 3050:        // CAP#1 cannot be converted to T
49833: 3051:        //     T t = holder.get();
49834: 3052:        //                     ^
49835: 3053:        //   where T is a type-variable:
49836: 3054:        //     T extends Object declared in method
49837: 3055:        //       <T>wildSupertype(Holder<? super T>,T)
49838: 3056:        //   where CAP#1 is a fresh type-variable:
49839: 3057:        //     CAP#1 extends Object super:
49840: 3058:        //       T from capture of ? super T
49841: 3059:        // 1 error
49842: 3060:
49843: 3061:        // OK, but type information is lost:
49844: 3062:        Object obj = holder.get();
49845: 3063:    }
49846: 3064:    
49847: 3065:    public static void main(String[] args) {
49848: 3066:        Holder raw = new Holder<>();
49849: 3067:        // Or:
49850: 3068:        raw = new Holder();
49851: 3069:        Holder<Long> qualified = new Holder<>();
49852: 3070:        Holder<?> unbounded = new Holder<>();
49853: 3071:        Holder<? extends Long> bounded = new Holder<>();
49854: 3072:        Long lng = 1L;
49855: 3073:
49856: 3074:        rawArgs(raw, lng);
49857: 3075:        rawArgs(qualified, lng);
49858: 3076:        rawArgs(unbounded, lng);
49859: 3077:        rawArgs(bounded, lng);
49860: 3078:
49861: 3079:        unboundedArg(raw, lng);
49862: 3080:        unboundedArg(qualified, lng);
49863: 3081:        unboundedArg(unbounded, lng);
49864: 3082:        unboundedArg(bounded, lng);
49865: 3083:
49866: 3084:        //- Object r1 = exact1(raw);
49867: 3085:        // warning: [unchecked] unchecked method invocation:
49868: 3086:        // method exact1 in class Wildcards is applied
49869: 3087:        // to given types
49870: 3088:        //      Object r1 = exact1(raw);
49871: 3089:        //                        ^
49872: 3090:        //   required: Holder<T>
49873: 3091:        //   found: Holder
49874: 3092:        //   where T is a type-variable:
49875: 3093:        //     T extends Object declared in
49876: 3094:        //     method <T>exact1(Holder<T>)
49877: 3095:        // warning: [unchecked] unchecked conversion
49878: 3096:        //      Object r1 = exact1(raw);
49879: 3097:        //                         ^
49880: 3098:        //   required: Holder<T>
49881: 3099:        //   found:    Holder
49882: 3100:        //   where T is a type-variable:
49883: 3101:        //     T extends Object declared in
49884: 3102:        //     method <T>exact1(Holder<T>)
49885: 3103:        // 2 warnings
49886: 3104:
49887: 3105:        Long r2 = exact1(qualified);
49888: 3106:        Object r3 = exact1(unbounded); // Must return Object
49889: 3107:        Long r4 = exact1(bounded);
49890: 3108:
49891: 3109:        //- Long r5 = exact2(raw, lng);
49892: 3110:        // warning: [unchecked] unchecked method invocation:
49893: 3111:        // method exact2 in class Wildcards is
49894: 3112:        // applied to given types
49895: 3113:        //     Long r5 = exact2(raw, lng);
49896: 3114:        //                     ^
49897: 3115:        //   required: Holder<T>,T
49898: 3116:        //   found: Holder,Long
49899: 3117:        //   where T is a type-variable:
49900: 3118:        //     T extends Object declared in
49901: 3119:        //       method <T>exact2(Holder<T>,T)
49902: 3120:        // warning: [unchecked] unchecked conversion
49903: 3121:        //     Long r5 = exact2(raw, lng);
49904: 3122:        //                      ^
49905: 3123:        //   required: Holder<T>
49906: 3124:        //   found:    Holder
49907: 3125:        //   where T is a type-variable:
49908: 3126:        //     T extends Object declared in
49909: 3127:        //       method <T>exact2(Holder<T>,T)
49910: 3128:        // 2 warnings
49911: 3129:
49912: 3130:        Long r6 = exact2(qualified, lng);
49913: 3131:
49914: 3132:        //- Long r7 = exact2(unbounded, lng);
49915: 3133:        // error: method exact2 in class Wildcards
49916: 3134:        // cannot be applied to given types;
49917: 3135:        //     Long r7 = exact2(unbounded, lng);
49918: 3136:        //               ^
49919: 3137:        //   required: Holder<T>,T
49920: 3138:        //   found: Holder<CAP#1>,Long
49921: 3139:        //   reason: inference variable T has
49922: 3140:        //     incompatible bounds
49923: 3141:        //     equality constraints: CAP#1
49924: 3142:        //     lower bounds: Long
49925: 3143:        //   where T is a type-variable:
49926: 3144:        //     T extends Object declared in
49927: 3145:        //       method <T>exact2(Holder<T>,T)
49928: 3146:        //   where CAP#1 is a fresh type-variable:
49929: 3147:        //     CAP#1 extends Object from capture of ?
49930: 3148:        // 1 error
49931: 3149:
49932: 3150:        //- Long r8 = exact2(bounded, lng);
49933: 3151:        // error: method exact2 in class Wildcards
49934: 3152:        // cannot be applied to given types;
49935: 3153:        //      Long r8 = exact2(bounded, lng);
49936: 3154:        //                ^
49937: 3155:        //   required: Holder<T>,T
49938: 3156:        //   found: Holder<CAP#1>,Long
49939: 3157:        //   reason: inference variable T
49940: 3158:        //     has incompatible bounds
49941: 3159:        //     equality constraints: CAP#1
49942: 3160:        //     lower bounds: Long
49943: 3161:        //   where T is a type-variable:
49944: 3162:        //     T extends Object declared in
49945: 3163:        //       method <T>exact2(Holder<T>,T)
49946: 3164:        //   where CAP#1 is a fresh type-variable:
49947: 3165:        //     CAP#1 extends Long from
49948: 3166:        //       capture of ? extends Long
49949: 3167:        // 1 error
49950: 3168:
49951: 3169:        //- Long r9 = wildSubtype(raw, lng);
49952: 3170:        // warning: [unchecked] unchecked method invocation:
49953: 3171:        // method wildSubtype in class Wildcards
49954: 3172:        // is applied to given types
49955: 3173:        //     Long r9 = wildSubtype(raw, lng);
49956: 3174:        //                          ^
49957: 3175:        //   required: Holder<? extends T>,T
49958: 3176:        //   found: Holder,Long
49959: 3177:        //   where T is a type-variable:
49960: 3178:        //     T extends Object declared in
49961: 3179:        //     method <T>wildSubtype(Holder<? extends T>,T)
49962: 3180:        // warning: [unchecked] unchecked conversion
49963: 3181:        //     Long r9 = wildSubtype(raw, lng);
49964: 3182:        //                           ^
49965: 3183:        //   required: Holder<? extends T>
49966: 3184:        //   found:    Holder
49967: 3185:        //   where T is a type-variable:
49968: 3186:        //     T extends Object declared in
49969: 3187:        //     method <T>wildSubtype(Holder<? extends T>,T)
49970: 3188:        // 2 warnings
49971: 3189:
49972: 3190:        Long r10 = wildSubtype(qualified, lng);
49973: 3191:        // OK, but can only return Object:
49974: 3192:        Object r11 = wildSubtype(unbounded, lng);
49975: 3193:        Long r12 = wildSubtype(bounded, lng);
49976: 3194:
49977: 3195:        //- wildSupertype(raw, lng);
49978: 3196:        // warning: [unchecked] unchecked method invocation:
49979: 3197:        //   method wildSupertype in class Wildcards
49980: 3198:        //   is applied to given types
49981: 3199:        //     wildSupertype(raw, lng);
49982: 3200:        //                  ^
49983: 3201:        //   required: Holder<? super T>,T
49984: 3202:        //   found: Holder,Long
49985: 3203:        //   where T is a type-variable:
49986: 3204:        //     T extends Object declared in
49987: 3205:        //     method <T>wildSupertype(Holder<? super T>,T)
49988: 3206:        // warning: [unchecked] unchecked conversion
49989: 3207:        //     wildSupertype(raw, lng);
49990: 3208:        //                   ^
49991: 3209:        //   required: Holder<? super T>
49992: 3210:        //   found:    Holder
49993: 3211:        //   where T is a type-variable:
49994: 3212:        //     T extends Object declared in
49995: 3213:        //     method <T>wildSupertype(Holder<? super T>,T)
49996: 3214:        // 2 warnings
49997: 3215:
49998: 3216:        wildSupertype(qualified, lng);
49999: 3217:
50000: 3218:        //- wildSupertype(unbounded, lng);
50001: 3219:        // error: method wildSupertype in class Wildcards
50002: 3220:        // cannot be applied to given types;
50003: 3221:        //     wildSupertype(unbounded, lng);
50004: 3222:        //     ^
50005: 3223:        //   required: Holder<? super T>,T
50006: 3224:        //   found: Holder<CAP#1>,Long
50007: 3225:        //   reason: cannot infer type-variable(s) T
50008: 3226:        //     (argument mismatch; Holder<CAP#1>
50009: 3227:        //     cannot be converted to Holder<? super T>)
50010: 3228:        //   where T is a type-variable:
50011: 3229:        //     T extends Object declared in
50012: 3230:        //     method <T>wildSupertype(Holder<? super T>,T)
50013: 3231:        //   where CAP#1 is a fresh type-variable:
50014: 3232:        //     CAP#1 extends Object from capture of ?
50015: 3233:        // 1 error
50016: 3234:
50017: 3235:        //- wildSupertype(bounded, lng);
50018: 3236:        // error: method wildSupertype in class Wildcards
50019: 3237:        // cannot be applied to given types;
50020: 3238:        //     wildSupertype(bounded, lng);
50021: 3239:        //     ^
50022: 3240:        //   required: Holder<? super T>,T
50023: 3241:        //   found: Holder<CAP#1>,Long
50024: 3242:        //   reason: cannot infer type-variable(s) T
50025: 3243:        //     (argument mismatch; Holder<CAP#1>
50026: 3244:        //     cannot be converted to Holder<? super T>)
50027: 3245:        //   where T is a type-variable:
50028: 3246:        //     T extends Object declared in
50029: 3247:        //     method <T>wildSupertype(Holder<? super T>,T)
50030: 3248:        //   where CAP#1 is a fresh type-variable:
50031: 3249:        //     CAP#1 extends Long from capture of
50032: 3250:        //     ? extends Long
50033: 3251:        // 1 error
50034: 3252:    }
50035: 3253:}
50036: 3254:```
50037: 3255:
50038: 3256:在 `rawArgs()` 中，编译器知道 `Holder` 是一个泛型类型，因此即使它在这里被表示成一个原生类型，编译器仍旧知道向 `set()` 传递一个 **Object** 是不安全的。由于它是原生类型，你可以将任何类型的对象传递给 `set()` ，而这个对象将被向上转型为 **Object** 。因此无论何时，只要使用了原生类型，都会放弃编译期检查。对 `get()` 的调用说明了相同的问题：没有任何 **T** 类型的对象，因此结果只能是一个 **Object**。
50039: 3257:人们很自然地会开始考虑原生 `Holder` 与 `Holder<?>` 是大致相同的事物。但是 `unboundedArg()` 强调它们是不同的——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，因为原生 **Holder** 将持有任何类型的组合，而 `Holder<?>` 将持有具有某种具体类型的同构集合，因此不能只是向其中传递 **Object** 。
50040: 3258:在 `exact1()` 和 `exact2()` 中，你可以看到使用了确切的泛型参数——没有任何通配符。你将看到，`exact2()`与 `exact1()` 具有不同的限制，因为它有额外的参数。
50041: 3259:在 `wildSubtype()` 中，在 **Holder** 类型上的限制被放松为包括持有任何扩展自 **T** 的对象的 **Holder** 。这还是意味着如果 T 是 **Fruit** ，那么 `holder` 可以是 `Holder<Apple>` ，这是合法的。为了防止将 **Orange** 放置到 `Holder<Apple>` 中，对 `set()` 的调用（或者对任何接受这个类型参数为参数的方法的调用）都是不允许的。但是，你仍旧知道任何来自 `Holder<？extends Fruit>` 的对象至少是 **Fruit** ，因此 `get()` （或者任何将产生具有这个类型参数的返回值的方法）都是允许的。
50042: 3260:`wildSupertype()` 展示了超类型通配符，这个方法展示了与 `wildSubtype()` 相反的行为：`holder` 可以是持有任何 T 的基类型的容器。因此， `set()` 可以接受 **T** ，因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是 **T** ）。但是，尝试着调用 `get()` 是没有用的，因为由 `holder` 持有的类型可以是任何超类型，因此唯一安全的类型就是 **Object** 。
50043: 3261:这个示例还展示了对于在 `unbounded()` 中使用无界通配符能够做什么不能做什么所做出的限制：因为你没有 **T**，所以你不能将 `set()` 或 `get()` 作用于 **T** 上。
50044: 3262:
50045: 3263:在 `main()` 方法中你看到了某些方法在接受某些类型的参数时没有报错和警告。为了迁移兼容性，`rawArgs()`  将接受所有 **Holder** 的不同变体，而不会产生警告。`unboundedArg()` 方法也可以接受相同的所有类型，尽管如前所述，它在方法体内部处理这些类型的方式并不相同。
50046: 3264:
50047: 3265:如果向接受“确切”泛型类型（没有通配符）的方法传递一个原生 **Holder** 引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息。如果向 `exact1()` 传递一个无界引用，就不会有任何可以确定返回类型的类型信息。
50048: 3266:可以看到，`exact2()` 具有最多的限制，因为它希望精确地得到一个 `Holder<T>` ，以及一个具有类型 **T** 的参数，正由于此，它将产生错误或警告，除非提供确切的参数。有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决于是否想要从泛型参数中返回类型确定的返回值（就像在 `wildSubtype()` 中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在 `wildSupertype()` 中看到的那样）。
50049: 3267:因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合你的需求的方法。
50050: 3268:
50051: 3269:### 捕获转换
50052: 3270:
50053: 3271:有一种特殊情况需要使用 `<?>` 而不是原生类型。如果向一个使用 `<?>` 的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。下面的示例演示了这种技术，它被称为捕获转换，因为未指定的通配符类型被捕获，并被转换为确切类型。这里，有关警告的注释只有在 `@SuppressWarnings` 注解被移除之后才能起作用：
50054: 3272:
50055: 3273:```java
50056: 3274:// generics/CaptureConversion.java
50057: 3275:
50058: 3276:public class CaptureConversion {
50059: 3277:    static <T> void f1(Holder<T> holder) {
50060: 3278:        T t = holder.get();
50061: 3279:        System.out.println(t.getClass().getSimpleName());
50062: 3280:    }
50063: 3281:  
50064: 3282:    static void f2(Holder<?> holder) {
50065: 3283:        f1(holder); // Call with captured type
50066: 3284:    }
50067: 3285:    
50068: 3286:    @SuppressWarnings("unchecked")
50069: 3287:    public static void main(String[] args) {
50070: 3288:        Holder raw = new Holder<>(1);
50071: 3289:        f1(raw);
50072: 3290:        // warning: [unchecked] unchecked method invocation:
50073: 3291:        // method f1 in class CaptureConversion
50074: 3292:        // is applied to given types
50075: 3293:        //     f1(raw);
50076: 3294:        //       ^
50077: 3295:        //   required: Holder<T>
50078: 3296:        //   found: Holder
50079: 3297:        //   where T is a type-variable:
50080: 3298:        //     T extends Object declared in
50081: 3299:        //     method <T>f1(Holder<T>)
50082: 3300:        // warning: [unchecked] unchecked conversion
50083: 3301:        //     f1(raw);
50084: 3302:        //        ^
50085: 3303:        //   required: Holder<T>
50086: 3304:        //   found:    Holder
50087: 3305:        //   where T is a type-variable:
50088: 3306:        //     T extends Object declared in
50089: 3307:        //     method <T>f1(Holder<T>)
50090: 3308:        // 2 warnings
50091: 3309:        f2(raw); // No warnings
50092: 3310:        
50093: 3311:        Holder rawBasic = new Holder();
50094: 3312:        rawBasic.set(new Object());
50095: 3313:        // warning: [unchecked] unchecked call to set(T)
50096: 3314:        // as a member of the raw type Holder
50097: 3315:        //     rawBasic.set(new Object());
50098: 3316:        //                 ^
50099: 3317:        //   where T is a type-variable:
50100: 3318:        //     T extends Object declared in class Holder
50101: 3319:        // 1 warning
50102: 3320:        f2(rawBasic); // No warnings
50103: 3321:        
50104: 3322:        // Upcast to Holder<?>, still figures it out:
50105: 3323:        Holder<?> wildcarded = new Holder<>(1.0);
50106: 3324:        f2(wildcarded);
50107: 3325:    }
50108: 3326:}
50109: 3327:/* Output:
50110: 3328:Integer
50111: 3329:Integer
50112: 3330:Object
50113: 3331:Double
50114: 3332:*/
50115: 3333:```
50116: 3334:
50117: 3335:`f1()` 中的类型参数都是确切的，没有通配符或边界。在 `f2()` 中，**Holder** 参数是一个无界通配符，因此它看起来是未知的。但是，在 `f2()` 中调用了 `f1()`，而 `f1()` 需要一个已知参数。这里所发生的是：在调用 `f2()` 的过程中捕获了参数类型，并在调用 `f1()` 时使用了这种类型。
50118: 3336:你可能想知道这项技术是否可以用于写入，但是这要求在传递 `Holder<?>` 时同时传递一个具体类型。捕获转换只有在这样的情况下可以工作：即在方法内部，你需要使用确切的类型。注意，不能从 `f2()` 中返回 **T**，因为 **T** 对于 `f2()` 来说是未知的。捕获转换十分有趣，但是非常受限。
50119: 3337:
50120: 3338:<!-- Issues -->
50121: 3339:
50122: 3340:## 问题
50123: 3341:
50124: 3342:本节将阐述在使用 Java 泛型时会出现的各类问题。
50125: 3343:
50126: 3344:### 任何基本类型都不能作为类型参数
50127: 3345:
50128: 3346:正如本章早先提到的，Java 泛型的限制之一是不能将基本类型用作类型参数。因此，不能创建  `ArrayList<int>` 之类的东西。
50129: 3347:解决方法是使用基本类型的包装器类以及自动装箱机制。如果创建一个 `ArrayList<Integer>`，并将基本类型 **int** 应用于这个集合，那么你将发现自动装箱机制将自动地实现 **int** 到 **Integer** 的双向转换——因此，这几乎就像是有一个 `ArrayList<int>` 一样：
50130: 3348:
50131: 3349:```java
50132: 3350:// generics/ListOfInt.java
50133: 3351:// Autoboxing compensates for the inability
50134: 3352:// to use primitives in generics
50135: 3353:import java.util.*;
50136: 3354:import java.util.stream.*;
50137: 3355:
50138: 3356:public class ListOfInt {
50139: 3357:    public static void main(String[] args) {
50140: 3358:        List<Integer> li = IntStream.range(38, 48)
50141: 3359:            .boxed() // Converts ints to Integers
50142: 3360:            .collect(Collectors.toList());
50143: 3361:        System.out.println(li);
50144: 3362:    }
50145: 3363:}
50146: 3364:/* Output:
50147: 3365:[38, 39, 40, 41, 42, 43, 44, 45, 46, 47]
50148: 3366:*/
50149: 3367:```
50150: 3368:
50151: 3369:通常，这种解决方案工作得很好——能够成功地存储和读取 **int**，自动装箱隐藏了转换的过程。但是如果性能成为问题的话，就需要使用专门为基本类型适配的特殊版本的集合；一个开源版本的实现是 **org.apache.commons.collections.primitives**。
50152: 3370:下面是另外一种方式，它可以创建持有 **Byte** 的 **Set**：
50153: 3371:
50154: 3372:```java
50155: 3373:// generics/ByteSet.java
50156: 3374:import java.util.*;
50157: 3375:
50158: 3376:public class ByteSet {
50159: 3377:    Byte[] possibles = { 1,2,3,4,5,6,7,8,9 };
50160: 3378:    Set<Byte> mySet = new HashSet<>(Arrays.asList(possibles));
50161: 3379:    // But you can't do this:
50162: 3380:    // Set<Byte> mySet2 = new HashSet<>(
50163: 3381:    // Arrays.<Byte>asList(1,2,3,4,5,6,7,8,9));
50164: 3382:}
50165: 3383:```
50166: 3384:
50167: 3385:自动装箱机制解决了一些问题，但并没有解决所有问题。
50168: 3386:
50169: 3387:在下面的示例中，**FillArray** 接口包含一些通用方法，这些方法使用 **Supplier** 来用对象填充数组（这使得类泛型在本例中无法工作，因为这个方法是静态的）。**Supplier** 实现来自 [数组](book/21-Arrays.md) 一章,并且在 `main()` 中，可以看到 `FillArray.fill()` 使用对象填充了数组：
50170: 3388:
50171: 3389:```java
50172: 3390:// generics/PrimitiveGenericTest.java
50173: 3391:import onjava.*;
50174: 3392:import java.util.*;
50175: 3393:import java.util.function.*;
50176: 3394:
50177: 3395:// Fill an array using a generator:
50178: 3396:interface FillArray {
50179: 3397:    static <T> T[] fill(T[] a, Supplier<T> gen) {
50180: 3398:        Arrays.setAll(a, n -> gen.get());
50181: 3399:        return a;
50182: 3400:    }
50183: 3401:    
50184: 3402:    static int[] fill(int[] a, IntSupplier gen) {
50185: 3403:        Arrays.setAll(a, n -> gen.getAsInt());
50186: 3404:        return a;
50187: 3405:    }
50188: 3406:    
50189: 3407:    static long[] fill(long[] a, LongSupplier gen) {
50190: 3408:        Arrays.setAll(a, n -> gen.getAsLong());
50191: 3409:        return a;
50192: 3410:    }
50193: 3411:    
50194: 3412:    static double[] fill(double[] a, DoubleSupplier gen) {
50195: 3413:        Arrays.setAll(a, n -> gen.getAsDouble());
50196: 3414:        return a;
50197: 3415:    }
50198: 3416:}
50199: 3417:
50200: 3418:public class PrimitiveGenericTest {
50201: 3419:    public static void main(String[] args) {
50202: 3420:        String[] strings = FillArray.fill(
50203: 3421:            new String[5], new Rand.String(9));
50204: 3422:        System.out.println(Arrays.toString(strings));
50205: 3423:        int[] integers = FillArray.fill(
50206: 3424:            new int[9], new Rand.Pint());
50207: 3425:        System.out.println(Arrays.toString(integers));
50208: 3426:    }
50209: 3427:}
50210: 3428:/* Output:
50211: 3429:[btpenpccu, xszgvgmei, nneeloztd, vewcippcy, gpoalkljl]
50212: 3430:[635, 8737, 3941, 4720, 6177, 8479, 6656, 3768, 4948]
50213: 3431:*/
50214: 3432:```
50215: 3433:
50216: 3434:自动装箱不适用于数组，因此我们必须创建 `FillArray.fill()` 的重载版本，或创建产生 **Wrapped** 输出的生成器。 **FillArray** 仅比 `java.util.Arrays.setAll()` 有用一点，因为它返回填充的数组。
50217: 3435:
50218: 3436:### 实现参数化接口
50219: 3437:
50220: 3438:一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。下面是产生这种冲突的情况：
50221: 3439:
50222: 3440:```java
50223: 3441:// generics/MultipleInterfaceVariants.java
50224: 3442:// {WillNotCompile}
50225: 3443:package generics;
50226: 3444:
50227: 3445:interface Payable<T> {}
50228: 3446:
50229: 3447:class Employee implements Payable<Employee> {}
50230: 3448:
50231: 3449:class Hourly extends Employee implements Payable<Hourly> {}
50232: 3450:```
50233: 3451:
50234: 3452:**Hourly** 不能编译，因为擦除会将  `Payable<Employe>` 和 `Payable<Hourly>` 简化为相同的类 **Payable**，这样，上面的代码就意味着在重复两次地实现相同的接口。十分有趣的是，如果从 **Payable** 的两种用法中都移除掉泛型参数（就像编译器在擦除阶段所做的那样）这段代码就可以编译。
50235: 3453:
50236: 3454:在使用某些更基本的 Java 接口，例如 `Comparable<T>` 时，这个问题可能会变得十分令人恼火，就像你在本节稍后看到的那样。
50237: 3455:
50238: 3456:### 转型和警告
50239: 3457:
50240: 3458:使用带有泛型类型参数的转型或 **instanceof** 不会有任何效果。下面的集合在内部将各个值存储为 **Object**，并在获取这些值时，再将它们转型回 **T**：
50241: 3459:
50242: 3460:```java
50243: 3461:// generics/GenericCast.java
50244: 3462:import java.util.*;
50245: 3463:import java.util.stream.*;
50246: 3464:
50247: 3465:class FixedSizeStack<T> {
50248: 3466:    private final int size;
50249: 3467:    private Object[] storage;
50250: 3468:    private int index = 0;
50251: 3469:    
50252: 3470:    FixedSizeStack(int size) {
50253: 3471:        this.size = size;
50254: 3472:        storage = new Object[size];
50255: 3473:    }
50256: 3474:    
50257: 3475:    public void push(T item) {
50258: 3476:        if(index < size)
50259: 3477:            storage[index++] = item;
50260: 3478:    }
50261: 3479:    
50262: 3480:    @SuppressWarnings("unchecked")
50263: 3481:    public T pop() {
50264: 3482:        return index == 0 ? null : (T)storage[--index];
50265: 3483:    }
50266: 3484:    
50267: 3485:    @SuppressWarnings("unchecked")
50268: 3486:    Stream<T> stream() {
50269: 3487:        return (Stream<T>)Arrays.stream(storage);
50270: 3488:    }
50271: 3489:}
50272: 3490:
50273: 3491:public class GenericCast {
50274: 3492:    static String[] letters = "ABCDEFGHIJKLMNOPQRS".split("");
50275: 3493:  
50276: 3494:    public static void main(String[] args) {
50277: 3495:        FixedSizeStack<String> strings =
50278: 3496:            new FixedSizeStack<>(letters.length);
50279: 3497:        Arrays.stream("ABCDEFGHIJKLMNOPQRS".split(""))
50280: 3498:            .forEach(strings::push);
50281: 3499:        System.out.println(strings.pop());
50282: 3500:        strings.stream()
50283: 3501:            .map(s -> s + " ")
50284: 3502:            .forEach(System.out::print);
50285: 3503:    }
50286: 3504:}
50287: 3505:/* Output:
50288: 3506:S
50289: 3507:A B C D E F G H I J K L M N O P Q R S
50290: 3508:*/
50291: 3509:```
50292: 3510:
50293: 3511:如果没有 **@SuppressWarnings** 注解，编译器将对 `pop()` 产生 “unchecked cast” 警告。由于擦除的原因，编译器无法知道这个转型是否是安全的，并且 `pop()` 方法实际上并没有执行任何转型。
50294: 3512:这是因为，**T** 被擦除到它的第一个边界，默认情况下是 **Object** ，因此 `pop()` 实际上只是将 **Object** 转型为 **Object**。
50295: 3513:有时，泛型没有消除对转型的需要，这就会由编译器产生警告，而这个警告是不恰当的。例如：
50296: 3514:
50297: 3515:```java
50298: 3516:// generics/NeedCasting.java
50299: 3517:import java.io.*;
50300: 3518:import java.util.*;
50301: 3519:
50302: 3520:public class NeedCasting {
50303: 3521:    @SuppressWarnings("unchecked")
50304: 3522:    public void f(String[] args) throws Exception {
50305: 3523:        ObjectInputStream in = new ObjectInputStream(
50306: 3524:            new FileInputStream(args[0]));
50307: 3525:        List<Widget> shapes = (List<Widget>)in.readObject();
50308: 3526:    }
50309: 3527:}
50310: 3528:```
50311: 3529:
50312: 3530:正如你将在 [附录：对象序列化](book/Appendix-Object-Serialization.md) 中学到的那样，`readObject()` 无法知道它正在读取的是什么，因此它返回的是必须转型的对象。但是当注释掉 **@SuppressWarnings** 注解并编译这个程序时，就会得到下面的警告。
50313: 3531:
50314: 3532:```
50315: 3533:NeedCasting.java uses unchecked or unsafe operations.
50316: 3534:Recompile with -Xlint:unchecked for details.
50317: 3535:
50318: 3536:And if you follow the instructions and recompile with  -
50319: 3537:Xlint:unchecked :(如果遵循这条指示，使用-Xlint:unchecked来重新编译：)
50320: 3538:
50321: 3539:NeedCasting.java:10: warning: [unchecked] unchecked cast
50322: 3540:    List<Widget> shapes = (List<Widget>)in.readObject();
50323: 3541:    required: List<Widget>
50324: 3542:    found: Object
50325: 3543:1 warning
50326: 3544:```
50327: 3545:
50328: 3546:你会被强制要求转型，但是又被告知不应该转型。为了解决这个问题，必须使用 Java 5 引入的新的转型形式，即通过泛型类来转型：
50329: 3547:
50330: 3548:```java
50331: 3549:// generics/ClassCasting.java
50332: 3550:import java.io.*;
50333: 3551:import java.util.*;
50334: 3552:
50335: 3553:public class ClassCasting {
50336: 3554:    @SuppressWarnings("unchecked")
50337: 3555:    public void f(String[] args) throws Exception {
50338: 3556:        ObjectInputStream in = new ObjectInputStream(
50339: 3557:            new FileInputStream(args[0]));
50340: 3558:        // Won't Compile:
50341: 3559:        //    List<Widget> lw1 =
50342: 3560:        //    List<>.class.cast(in.readObject());
50343: 3561:        List<Widget> lw2 = List.class.cast(in.readObject());
50344: 3562:    }
50345: 3563:}
50346: 3564:```
50347: 3565:
50348: 3566:但是，不能转型到实际类型（ `List<Widget>` ）。也就是说，不能声明：
50349: 3567:
50350: 3568:```
50351: 3569:List<Widget>.class.cast(in.readobject())
50352: 3570:```
50353: 3571:
50354: 3572:甚至当你添加一个像下面这样的另一个转型时：
50355: 3573:
50356: 3574:```
50357: 3575:(List<Widget>)List.class.cast(in.readobject())
50358: 3576:```
50359: 3577:
50360: 3578:仍旧会得到一个警告。
50361: 3579:
50362: 3580:### 重载
50363: 3581:
50364: 3582:下面的程序是不能编译的，即使它看起来是合理的：
50365: 3583:
50366: 3584:```java
50367: 3585:// generics/UseList.java
50368: 3586:// {WillNotCompile}
50369: 3587:import java.util.*;
50370: 3588:
50371: 3589:public class UseList<W, T> {
50372: 3590:    void f(List<T> v) {}
50373: 3591:    void f(List<W> v) {}
50374: 3592:}
50375: 3593:```
50376: 3594:
50377: 3595:因为擦除，所以重载方法产生了相同的类型签名。
50378: 3596:
50379: 3597:因而，当擦除后的参数不能产生唯一的参数列表时，你必须提供不同的方法名：
50380: 3598:
50381: 3599:```java
50382: 3600:// generics/UseList2.java
50383: 3601:
50384: 3602:import java.util.*;
50385: 3603:
50386: 3604:public class UseList2<W, T> {
50387: 3605:    void f1(List<T> v) {}
50388: 3606:    void f2(List<W> v) {}
50389: 3607:}
50390: 3608:```
50391: 3609:
50392: 3610:幸运的是，编译器可以检测到这类问题。
50393: 3611:
50394: 3612:### 基类劫持接口
50395: 3613:
50396: 3614:假设你有一个实现了 **Comparable** 接口的 **Pet** 类：
50397: 3615:
50398: 3616:```java
50399: 3617:// generics/ComparablePet.java
50400: 3618:
50401: 3619:public class ComparablePet implements Comparable<ComparablePet> {
50402: 3620:    @Override
50403: 3621:    public int compareTo(ComparablePet o) {
50404: 3622:        return 0;
50405: 3623:    }
50406: 3624:}
50407: 3625:```
50408: 3626:
50409: 3627:尝试缩小 **ComparablePet** 子类的比较类型是有意义的。例如，**Cat** 类可以与其他的 **Cat** 比较：
50410: 3628:
50411: 3629:```java
50412: 3630:// generics/HijackedInterface.java
50413: 3631:// {WillNotCompile}
50414: 3632:
50415: 3633:class Cat extends ComparablePet implements Comparable<Cat> {
50416: 3634:    // error: Comparable cannot be inherited with
50417: 3635:    // different arguments: <Cat> and <ComparablePet>
50418: 3636:    // class Cat
50419: 3637:    // ^
50420: 3638:    // 1 error
50421: 3639:    public int compareTo(Cat arg) {
50422: 3640:        return 0;
50423: 3641:    }
50424: 3642:}
50425: 3643:```
50426: 3644:
50427: 3645:不幸的是，这不能工作。一旦 **Comparable** 的类型参数设置为 **ComparablePet**，其他的实现类只能比较 **ComparablePet**：
50428: 3646:
50429: 3647:```java
50430: 3648:// generics/RestrictedComparablePets.java
50431: 3649:
50432: 3650:public class Hamster extends ComparablePet implements Comparable<ComparablePet> {
50433: 3651:
50434: 3652:    @Override
50435: 3653:    public int compareTo(ComparablePet arg) {
50436: 3654:        return 0;
50437: 3655:    }
50438: 3656:}
50439: 3657:// Or just:
50440: 3658:class Gecko extends ComparablePet {
50441: 3659:    public int compareTo(ComparablePet arg) {
50442: 3660:        return 0;
50443: 3661:    }
50444: 3662:}
50445: 3663:```
50446: 3664:
50447: 3665:**Hamster** 显示了重新实现 **ComparablePet** 中相同的接口是可能的，只要接口完全相同，包括参数类型。然而正如 **Gecko** 中所示，这与直接覆写基类的方法完全相同。
50448: 3666:
50449: 3667:<!-- Self-Bounded Types -->
50450: 3668:
50451: 3669:## 自限定的类型
50452: 3670:
50453: 3671:在 Java 泛型中，有一个似乎经常性出现的惯用法，它相当令人费解：
50454: 3672:
50455: 3673:```java
50456: 3674:class SelfBounded<T extends SelfBounded<T>> { // ...
50457: 3675:```
50458: 3676:
50459: 3677:这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。**SelfBounded** 类接受泛型参数 **T**，而 **T** 由一个边界类限定，这个边界就是拥有 **T** 作为其参数的 **SelfBounded**。
50460: 3678:
50461: 3679:当你首次看到它时，很难去解析它，它强调的是当 **extends** 关键字用于边界与用来创建子类明显是不同的。
50462: 3680:
50463: 3681:### 古怪的循环泛型
50464: 3682:
50465: 3683:为了理解自限定类型的含义，我们从这个惯用法的一个简单版本入手，它没有自限定的边界。
50466: 3684:
50467: 3685:不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数的类。也就是说，可以声明：
50468: 3686:
50469: 3687:```java
50470: 3688:// generics/CuriouslyRecurringGeneric.java
50471: 3689:
50472: 3690:class GenericType<T> {}
50473: 3691:
50474: 3692:public class CuriouslyRecurringGeneric
50475: 3693:  extends GenericType<CuriouslyRecurringGeneric> {}
50476: 3694:```
50477: 3695:
50478: 3696:这可以按照 Jim Coplien 在 C++ 中的*古怪的循环模版模式*的命名方式，称为古怪的循环泛型（CRG）。“古怪的循环”是指类相当古怪地出现在它自己的基类中这一事实。
50479: 3697:为了理解其含义，努力大声说：“我在创建一个新类，它继承自一个泛型类型，这个泛型类型接受我的类的名字作为其参数。”当给出导出类的名字时，这个泛型基类能够实现什么呢？好吧，Java 中的泛型关乎参数和返回类型，因此它能够产生使用导出类作为其参数和返回类型的基类。它还能将导出类型用作其域类型，尽管这些将被擦除为 **Object** 的类型。下面是表示了这种情况的一个泛型类：
50480: 3698:
50481: 3699:```java
50482: 3700:// generics/BasicHolder.java
50483: 3701:
50484: 3702:public class BasicHolder<T> {
50485: 3703:    T element;
50486: 3704:    void set(T arg) { element = arg; }
50487: 3705:    T get() { return element; }
50488: 3706:    void f() {
50489: 3707:        System.out.println(element.getClass().getSimpleName());
50490: 3708:    }
50491: 3709:}
50492: 3710:```
50493: 3711:
50494: 3712:这是一个普通的泛型类型，它的一些方法将接受和产生具有其参数类型的对象，还有一个方法在其存储的域上执行操作（尽管只是在这个域上执行 **Object** 操作）。
50495: 3713:我们可以在一个古怪的循环泛型中使用 **BasicHolder**：
50496: 3714:
50497: 3715:```java
50498: 3716:// generics/CRGWithBasicHolder.java
50499: 3717:
50500: 3718:class Subtype extends BasicHolder<Subtype> {}
50501: 3719:
50502: 3720:public class CRGWithBasicHolder {
50503: 3721:    public static void main(String[] args) {
50504: 3722:        Subtype st1 = new Subtype(), st2 = new Subtype();
50505: 3723:        st1.set(st2);
50506: 3724:        Subtype st3 = st1.get();
50507: 3725:        st1.f();
50508: 3726:    }
50509: 3727:}
50510: 3728:/* Output:
50511: 3729:Subtype
50512: 3730:*/
50513: 3731:```
50514: 3732:
50515: 3733:注意，这里有些东西很重要：新类 **Subtype** 接受的参数和返回的值具有 **Subtype** 类型而不仅仅是基类 **BasicHolder** 类型。这就是 CRG 的本质：基类用导出类替代其参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对于其所有参数和返回值，将使用导出类型。也就是说，在所产生的类中将使用确切类型而不是基类型。因此，在**Subtype** 中，传递给 `set()` 的参数和从 `get()` 返回的类型都是确切的 **Subtype**。
50516: 3734:
50517: 3735:### 自限定
50518: 3736:
50519: 3737:**BasicHolder** 可以使用任何类型作为其泛型参数，就像下面看到的那样：
50520: 3738:
50521: 3739:```java
50522: 3740:// generics/Unconstrained.java
50523: 3741:// (c)2017 MindView LLC: see Copyright.txt
50524: 3742:// We make no guarantees that this code is fit for any purpose.
50525: 3743:// Visit http://OnJava8.com for more book information.
50526: 3744:
50527: 3745:class Other {}
50528: 3746:class BasicOther extends BasicHolder<Other> {}
50529: 3747:
50530: 3748:public class Unconstrained {
50531: 3749:    public static void main(String[] args) {
50532: 3750:        BasicOther b = new BasicOther();
50533: 3751:        BasicOther b2 = new BasicOther();
50534: 3752:        b.set(new Other());
50535: 3753:        Other other = b.get();
50536: 3754:        b.f();
50537: 3755:    }
50538: 3756:}
50539: 3757:/* Output:
50540: 3758:Other
50541: 3759:*/
50542: 3760:```
50543: 3761:
50544: 3762:限定将采取额外的步骤，强制泛型当作其自身的边界参数来使用。观察所产生的类可以如何使用以及不可以如何使用：
50545: 3763:
50546: 3764:```java
50547: 3765:// generics/SelfBounding.java
50548: 3766:
50549: 3767:class SelfBounded<T extends SelfBounded<T>> {
50550: 3768:    T element;
50551: 3769:    SelfBounded<T> set(T arg) {
50552: 3770:        element = arg;
50553: 3771:        return this;
50554: 3772:    }
50555: 3773:    T get() { return element; }
50556: 3774:}
50557: 3775:
50558: 3776:class A extends SelfBounded<A> {}
50559: 3777:class B extends SelfBounded<A> {} // Also OK
50560: 3778:
50561: 3779:class C extends SelfBounded<C> {
50562: 3780:    C setAndGet(C arg) { 
50563: 3781:        set(arg); 
50564: 3782:        return get();
50565: 3783:    }
50566: 3784:}
50567: 3785:
50568: 3786:class D {}
50569: 3787:// Can't do this:
50570: 3788:// class E extends SelfBounded<D> {}
50571: 3789:// Compile error:
50572: 3790://   Type parameter D is not within its bound
50573: 3791:
50574: 3792:// Alas, you can do this, so you cannot force the idiom:
50575: 3793:class F extends SelfBounded {}
50576: 3794:
50577: 3795:public class SelfBounding {
50578: 3796:    public static void main(String[] args) {
50579: 3797:        A a = new A();
50580: 3798:        a.set(new A());
50581: 3799:        a = a.set(new A()).get();
50582: 3800:        a = a.get();
50583: 3801:        C c = new C();
50584: 3802:        c = c.setAndGet(new C());
50585: 3803:    }
50586: 3804:}
50587: 3805:```
50588: 3806:
50589: 3807:自限定所做的，就是要求在继承关系中，像下面这样使用这个类：
50590: 3808:
50591: 3809:```java
50592: 3810:class A extends SelfBounded<A>{}
50593: 3811:```
50594: 3812:
50595: 3813:这会强制要求将正在定义的类当作参数传递给基类。
50596: 3814:
50597: 3815:自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。正如你在 B 类的定义中所看到的，还可以从使用了另一个 **SelfBounded** 参数的 **SelfBounded** 中导出，尽管在 **A** 类看到的用法看起来是主要的用法。对定义 **E** 的尝试说明不能使用不是 **SelfBounded** 的类型参数。
50598: 3816:遗憾的是， **F** 可以编译，不会有任何警告，因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型。
50599: 3817:注意，可以移除自限定这个限制，这样所有的类仍旧是可以编译的，但是 **E** 也会因此而变得可编译：
50600: 3818:
50601: 3819:```java
50602: 3820:// generics/NotSelfBounded.java
50603: 3821:
50604: 3822:public class NotSelfBounded<T> {
50605: 3823:    T element;
50606: 3824:    NotSelfBounded<T> set(T arg) {
50607: 3825:        element = arg;
50608: 3826:        return this;
50609: 3827:    }
50610: 3828:    T get() { return element; }
50611: 3829:} 
50612: 3830:
50613: 3831:class A2 extends NotSelfBounded<A2> {}
50614: 3832:class B2 extends NotSelfBounded<A2> {}
50615: 3833:
50616: 3834:class C2 extends NotSelfBounded<C2> {
50617: 3835:    C2 setAndGet(C2 arg) { 
50618: 3836:        set(arg); 
50619: 3837:        return get(); 
50620: 3838:    }
50621: 3839:}
50622: 3840:
50623: 3841:class D2 {}
50624: 3842:// Now this is OK:
50625: 3843:class E2 extends NotSelfBounded<D2> {}
50626: 3844:```
50627: 3845:
50628: 3846:因此很明显，自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。这会强制要求使用这个类的每个人都要遵循这种形式。
50629: 3847:还可以将自限定用于泛型方法：
50630: 3848:
50631: 3849:```java
50632: 3850:// generics/SelfBoundingMethods.java
50633: 3851:// (c)2017 MindView LLC: see Copyright.txt
50634: 3852:// We make no guarantees that this code is fit for any purpose.
50635: 3853:// Visit http://OnJava8.com for more book information.
50636: 3854:
50637: 3855:public class SelfBoundingMethods {
50638: 3856:    static <T extends SelfBounded<T>> T f(T arg) {
50639: 3857:        return arg.set(arg).get();
50640: 3858:    }
50641: 3859:    
50642: 3860:    public static void main(String[] args) {
50643: 3861:        A a = f(new A());
50644: 3862:    }
50645: 3863:}
50646: 3864:```
50647: 3865:
50648: 3866:这可以防止这个方法被应用于除上述形式的自限定参数之外的任何事物上。
50649: 3867:
50650: 3868:### 参数协变
50651: 3869:
50652: 3870:自限定类型的价值在于它们可以产生*协变参数类型*——方法参数类型会随子类而变化。
50653: 3871:
50654: 3872:尽管自限定类型还可以产生与子类类型相同的返回类型，但是这并不十分重要，因为*协变返回类型*是在 Java 5 引入：
50655: 3873:
50656: 3874:```java
50657: 3875:// generics/CovariantReturnTypes.java
50658: 3876:
50659: 3877:class Base {}
50660: 3878:class Derived extends Base {}
50661: 3879:
50662: 3880:interface OrdinaryGetter {
50663: 3881:    Base get();
50664: 3882:}
50665: 3883:
50666: 3884:interface DerivedGetter extends OrdinaryGetter {
50667: 3885:    // Overridden method return type can vary:
50668: 3886:    @Override
50669: 3887:    Derived get();
50670: 3888:}
50671: 3889:
50672: 3890:public class CovariantReturnTypes {
50673: 3891:    void test(DerivedGetter d) {
50674: 3892:        Derived d2 = d.get();
50675: 3893:    }
50676: 3894:}
50677: 3895:```
50678: 3896:
50679: 3897:**DerivedGetter** 中的 `get()` 方法覆盖了 **OrdinaryGetter** 中的 `get()` ，并返回了一个从 `OrdinaryGetter.get()` 的返回类型中导出的类型。尽管这是完全合乎逻辑的事情（导出类方法应该能够返回比它覆盖的基类方法更具体的类型）但是这在早先的 Java 版本中是不合法的。
50680: 3898:
50681: 3899:自限定泛型事实上将产生确切的导出类型作为其返回值，就像在 `get()` 中所看到的一样：
50682: 3900:
50683: 3901:```java
50684: 3902:// generics/GenericsAndReturnTypes.java
50685: 3903:
50686: 3904:interface GenericGetter<T extends GenericGetter<T>> {
50687: 3905:    T get();
50688: 3906:}
50689: 3907:
50690: 3908:interface Getter extends GenericGetter<Getter> {}
50691: 3909:
50692: 3910:public class GenericsAndReturnTypes {
50693: 3911:    void test(Getter g) {
50694: 3912:        Getter result = g.get();
50695: 3913:        GenericGetter gg = g.get(); // Also the base type
50696: 3914:    }
50697: 3915:}
50698: 3916:```
50699: 3917:
50700: 3918:注意，这段代码不能编译，除非是使用囊括了协变返回类型的 Java 5。
50701: 3919:
50702: 3920:然而，在非泛型代码中，参数类型不能随子类型发生变化：
50703: 3921:
50704: 3922:```java
50705: 3923:// generics/OrdinaryArguments.java
50706: 3924:
50707: 3925:class OrdinarySetter {
50708: 3926:    void set(Base base) {
50709: 3927:        System.out.println("OrdinarySetter.set(Base)");
50710: 3928:    }
50711: 3929:}
50712: 3930:
50713: 3931:class DerivedSetter extends OrdinarySetter {
50714: 3932:    void set(Derived derived) {
50715: 3933:        System.out.println("DerivedSetter.set(Derived)");
50716: 3934:    }
50717: 3935:}
50718: 3936:
50719: 3937:public class OrdinaryArguments {
50720: 3938:    public static void main(String[] args) {
50721: 3939:        Base base = new Base();
50722: 3940:        Derived derived = new Derived();
50723: 3941:        DerivedSetter ds = new DerivedSetter();
50724: 3942:        ds.set(derived);
50725: 3943:        // Compiles--overloaded, not overridden!:
50726: 3944:        ds.set(base);
50727: 3945:    }
50728: 3946:}
50729: 3947:/* Output:
50730: 3948:DerivedSetter.set(Derived)
50731: 3949:OrdinarySetter.set(Base)
50732: 3950:*/
50733: 3951:```
50734: 3952:
50735: 3953:`set(derived)` 和 `set(base)` 都是合法的，因此 `DerivedSetter.set()` 没有覆盖 `OrdinarySetter.set()` ，而是重载了这个方法。从输出中可以看到，在 **DerivedSetter** 中有两个方法，因此基类版本仍旧是可用的，因此可以证明它被重载过。
50736: 3954:但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类型而不是基类型为参数：
50737: 3955:
50738: 3956:```java
50739: 3957:// generics/SelfBoundingAndCovariantArguments.java
50740: 3958:
50741: 3959:interface SelfBoundSetter<T extends SelfBoundSetter<T>> {
50742: 3960:    void set(T arg);
50743: 3961:}
50744: 3962:
50745: 3963:interface Setter extends SelfBoundSetter<Setter> {}
50746: 3964:
50747: 3965:public class SelfBoundingAndCovariantArguments {
50748: 3966:    void
50749: 3967:    testA(Setter s1, Setter s2, SelfBoundSetter sbs) {
50750: 3968:        s1.set(s2);
50751: 3969:        //- s1.set(sbs);
50752: 3970:        // error: method set in interface SelfBoundSetter<T>
50753: 3971:        // cannot be applied to given types;
50754: 3972:        //     s1.set(sbs);
50755: 3973:        //       ^
50756: 3974:        //   required: Setter
50757: 3975:        //   found: SelfBoundSetter
50758: 3976:        //   reason: argument mismatch;
50759: 3977:        // SelfBoundSetter cannot be converted to Setter
50760: 3978:        //   where T is a type-variable:
50761: 3979:        //     T extends SelfBoundSetter<T> declared in
50762: 3980:        //     interface SelfBoundSetter
50763: 3981:        // 1 error
50764: 3982:    }
50765: 3983:}
50766: 3984:```
50767: 3985:
50768: 3986:编译器不能识别将基类型当作参数传递给 `set()` 的尝试，因为没有任何方法具有这样的签名。实际上，这个参数已经被覆盖。
50769: 3987:如果不使用自限定类型，普通的继承机制就会介入，而你将能够重载，就像在非泛型的情况下一样：
50770: 3988:
50771: 3989:```java
50772: 3990:// generics/PlainGenericInheritance.java
50773: 3991:
50774: 3992:class GenericSetter<T> { // Not self-bounded
50775: 3993:    void set(T arg) {
50776: 3994:        System.out.println("GenericSetter.set(Base)");
50777: 3995:    }
50778: 3996:}
50779: 3997:
50780: 3998:class DerivedGS extends GenericSetter<Base> {
50781: 3999:    void set(Derived derived) {
50782: 4000:        System.out.println("DerivedGS.set(Derived)");
50783: 4001:    }
50784: 4002:}
50785: 4003:
50786: 4004:public class PlainGenericInheritance {
50787: 4005:    public static void main(String[] args) {
50788: 4006:        Base base = new Base();
50789: 4007:        Derived derived = new Derived();
50790: 4008:        DerivedGS dgs = new DerivedGS();
50791: 4009:        dgs.set(derived);
50792: 4010:        dgs.set(base); // Overloaded, not overridden!
50793: 4011:    }
50794: 4012:}
50795: 4013:/* Output:
50796: 4014:DerivedGS.set(Derived)
50797: 4015:GenericSetter.set(Base)
50798: 4016:*/
50799: 4017:```
50800: 4018:
50801: 4019:这段代码在模仿 **OrdinaryArguments.java**；在那个示例中，**DerivedSetter** 继承自包含一个 `set(Base)` 的**OrdinarySetter** 。而这里，**DerivedGS** 继承自泛型创建的也包含有一个 `set(Base)`的 `GenericSetter<Base>`。就像 **OrdinaryArguments.java** 一样，你可以从输出中看到， **DerivedGS** 包含两个  `set()` 的重载版本。如果不使用自限定，将重载参数类型。如果使用了自限定，只能获得方法的一个版本，它将接受确切的参数类型。
50802: 4020:
50803: 4021:<!-- Dynamic Type Safety -->
50804: 4022:
50805: 4023:## 动态类型安全
50806: 4024:
50807: 4025:因为可以向 Java 5 之前的代码传递泛型集合，所以旧式代码仍旧有可能会破坏你的集合。Java 5 的 **java.util.Collections** 中有一组便利工具，可以解决在这种情况下的类型检查问题，它们是：静态方法 `checkedCollection()` 、`checkedList()`、 `checkedMap()` 、 `checkedSet()` 、`checkedSortedMap()`和 `checkedSortedSet()`。这些方法每一个都会将你希望动态检查的集合当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。
50808: 4026:
50809: 4027:受检查的集合在你试图插入类型不正确的对象时抛出 **ClassCastException** ，这与泛型之前的（原生）集合形成了对比，对于后者来说，当你将对象从集合中取出时，才会通知你出现了问题。在后一种情况中，你知道存在问题，但是不知道罪魁祸首在哪里，如果使用受检查的集合，就可以发现谁在试图插入不良对象。
50810: 4028:让我们用受检查的集合来看看“将猫插入到狗列表中”这个问题。这里，`oldStyleMethod()` 表示遗留代码，因为它接受的是原生的 **List** ，而 **@SuppressWarnings（“unchecked”）** 注解对于压制所产生的警告是必需的：
50811: 4029:
50812: 4030:```java
50813: 4031:// generics/CheckedList.java
50814: 4032:// Using Collection.checkedList()
50815: 4033:import typeinfo.pets.*;
50816: 4034:import java.util.*;
50817: 4035:
50818: 4036:public class CheckedList {
50819: 4037:    @SuppressWarnings("unchecked")
50820: 4038:    static void oldStyleMethod(List probablyDogs) {
50821: 4039:        probablyDogs.add(new Cat());
50822: 4040:    }
50823: 4041:    
50824: 4042:    public static void main(String[] args) {
50825: 4043:        List<Dog> dogs1 = new ArrayList<>();
50826: 4044:        oldStyleMethod(dogs1); // Quietly accepts a Cat
50827: 4045:        List<Dog> dogs2 = Collections.checkedList(
50828: 4046:            new ArrayList<>(), Dog.class);
50829: 4047:        try {
50830: 4048:            oldStyleMethod(dogs2); // Throws an exception
50831: 4049:        } catch(Exception e) {
50832: 4050:            System.out.println("Expected: " + e);
50833: 4051:        }
50834: 4052:        // Derived types work fine:
50835: 4053:        List<Pet> pets = Collections.checkedList(
50836: 4054:            new ArrayList<>(), Pet.class);
50837: 4055:        pets.add(new Dog());
50838: 4056:        pets.add(new Cat());
50839: 4057:    }
50840: 4058:}
50841: 4059:/* Output:
50842: 4060:Expected: java.lang.ClassCastException: Attempt to
50843: 4061:insert class typeinfo.pets.Cat element into collection
50844: 4062:with element type class typeinfo.pets.Dog
50845: 4063:*/
50846: 4064:```
50847: 4065:
50848: 4066:运行这个程序时，你会发现插入一个 **Cat** 对于 **dogs1** 来说没有任何问题，而 **dogs2** 立即会在这个错误类型的插入操作上抛出一个异常。还可以看到，将导出类型的对象放置到将要检查基类型的受检查容器中是没有问题的。
50849: 4067:
50850: 4068:<!-- Exceptions -->
50851: 4069:
50852: 4070:## 泛型异常
50853: 4071:
50854: 4072:由于擦除的原因，**catch** 语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承自 **Throwable**（这将进一步阻止你去定义不能捕获的泛型异常）。
50855: 4073:但是，类型参数可能会在一个方法的 **throws** 子句中用到。这使得你可以编写随检查型异常类型变化的泛型代码：
50856: 4074:
50857: 4075:```java
50858: 4076:// generics/ThrowGenericException.java
50859: 4077:
50860: 4078:import java.util.*;
50861: 4079:
50862: 4080:interface Processor<T, E extends Exception> {
50863: 4081:    void process(List<T> resultCollector) throws E;
50864: 4082:}
50865: 4083:
50866: 4084:class ProcessRunner<T, E extends Exception>
50867: 4085:extends ArrayList<Processor<T, E>> {
50868: 4086:    List<T> processAll() throws E {
50869: 4087:        List<T> resultCollector = new ArrayList<>();
50870: 4088:        for(Processor<T, E> processor : this)
50871: 4089:            processor.process(resultCollector);
50872: 4090:        return resultCollector;
50873: 4091:    }
50874: 4092:}
50875: 4093:
50876: 4094:class Failure1 extends Exception {}
50877: 4095:
50878: 4096:class Processor1
50879: 4097:implements Processor<String, Failure1> {
50880: 4098:    static int count = 3;
50881: 4099:    @Override
50882: 4100:    public void process(List<String> resultCollector)
50883: 4101:    throws Failure1 {
50884: 4102:        if(count-- > 1)
50885: 4103:            resultCollector.add("Hep!");
50886: 4104:        else
50887: 4105:            resultCollector.add("Ho!");
50888: 4106:        if(count < 0)
50889: 4107:            throw new Failure1();
50890: 4108:    }
50891: 4109:}
50892: 4110:
50893: 4111:class Failure2 extends Exception {}
50894: 4112:
50895: 4113:class Processor2
50896: 4114:implements Processor<Integer, Failure2> {
50897: 4115:    static int count = 2;
50898: 4116:    @Override
50899: 4117:    public void process(List<Integer> resultCollector)
50900: 4118:    throws Failure2 {
50901: 4119:        if(count-- == 0)
50902: 4120:            resultCollector.add(47);
50903: 4121:        else {
50904: 4122:            resultCollector.add(11);
50905: 4123:        }
50906: 4124:        if(count < 0)
50907: 4125:            throw new Failure2();
50908: 4126:    }
50909: 4127:}
50910: 4128:
50911: 4129:public class ThrowGenericException {
50912: 4130:    public static void main(String[] args) {
50913: 4131:        ProcessRunner<String, Failure1> runner =
50914: 4132:            new ProcessRunner<>();
50915: 4133:        for(int i = 0; i < 3; i++)
50916: 4134:            runner.add(new Processor1());
50917: 4135:        try {
50918: 4136:            System.out.println(runner.processAll());
50919: 4137:        } catch(Failure1 e) {
50920: 4138:            System.out.println(e);
50921: 4139:        }
50922: 4140:
50923: 4141:        ProcessRunner<Integer, Failure2> runner2 =
50924: 4142:            new ProcessRunner<>();
50925: 4143:        for(int i = 0; i < 3; i++)
50926: 4144:            runner2.add(new Processor2());
50927: 4145:        try {
50928: 4146:            System.out.println(runner2.processAll());
50929: 4147:        } catch(Failure2 e) {
50930: 4148:            System.out.println(e);
50931: 4149:        }
50932: 4150:    }
50933: 4151:}
50934: 4152:/* Output:
50935: 4153:[Hep!, Hep!, Ho!]
50936: 4154:Failure2
50937: 4155:*/
50938: 4156:```
50939: 4157:
50940: 4158:**Processor** 执行 `process()` 方法，并且可能会抛出具有类型 **E** 的异常。`process()` 的结果存储在 `List<T>resultCollector` 中（这被称为*收集参数*）。**ProcessRunner** 有一个 `processAll()` 方法，它会在所持有的每个 **Process** 对象执行，并返回 **resultCollector** 。
50941: 4159:如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出这种泛化的代码。
50942: 4160:
50943: 4161:<!-- Mixins -->
50944: 4162:
50945: 4163:## 混型
50946: 4164:
50947: 4165:术语*混型*随时间的推移好像拥有了无数的含义，但是其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。这往往是你最后的手段，它将使组装多个类变得简单易行。
50948: 4166:混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。如果想在混型类中修改某些东西，作为一种意外的好处，这些修改将会应用于混型所应用的所有类型之上。正由于此，混型有一点*面向切面编程* （AOP） 的味道，而切面经常被建议用来解决混型问题。
50949: 4167:
50950: 4168:### C++ 中的混型
50951: 4169:
50952: 4170:在 C++ 中，使用多重继承的最大理由，就是为了使用混型。但是，对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为混型就是继承自其类型参数的类。在 C++ 中，可以很容易地创建混型，因为 C++ 能够记住其模版参数的类型。
50953: 4171:下面是一个 C++ 示例，它有两个混型类型：一个使得你可以在每个对象中混入拥有一个时间戳这样的属性，而另一个可以混入一个序列号。
50954: 4172:
50955: 4173:```c++
50956: 4174:// generics/Mixins.cpp
50957: 4175:
50958: 4176:#include <string>
50959: 4177:#include <ctime>
50960: 4178:#include <iostream>
50961: 4179:using namespace std;
50962: 4180:
50963: 4181:template<class T> class TimeStamped : public T {
50964: 4182:    long timeStamp;
50965: 4183:public:
50966: 4184:    TimeStamped() { timeStamp = time(0); }
50967: 4185:    long getStamp() { return timeStamp; }
50968: 4186:};
50969: 4187:
50970: 4188:template<class T> class SerialNumbered : public T {
50971: 4189:    long serialNumber;
50972: 4190:    static long counter;
50973: 4191:public:
50974: 4192:    SerialNumbered() { serialNumber = counter++; }
50975: 4193:    long getSerialNumber() { return serialNumber; }
50976: 4194:};
50977: 4195:
50978: 4196:// Define and initialize the static storage:
50979: 4197:template<class T> long SerialNumbered<T>::counter = 1;
50980: 4198:
50981: 4199:class Basic {
50982: 4200:    string value;
50983: 4201:public:
50984: 4202:    void set(string val) { value = val; }
50985: 4203:    string get() { return value; }
50986: 4204:};
50987: 4205:
50988: 4206:int main() {
50989: 4207:    TimeStamped<SerialNumbered<Basic>> mixin1, mixin2;
50990: 4208:    mixin1.set("test string 1");
50991: 4209:    mixin2.set("test string 2");
50992: 4210:    cout << mixin1.get() << " " << mixin1.getStamp() <<
50993: 4211:      " " << mixin1.getSerialNumber() << endl;
50994: 4212:    cout << mixin2.get() << " " << mixin2.getStamp() <<
50995: 4213:      " " << mixin2.getSerialNumber() << endl;
50996: 4214:}
50997: 4215:/* Output:
50998: 4216:test string 1 1452987605 1
50999: 4217:test string 2 1452987605 2
51000: 4218:*/
51001: 4219:```
51002: 4220:
51003: 4221:在 `main()` 中， **mixin1** 和 **mixin2** 所产生的类型拥有所混入类型的所有方法。可以将混型看作是一种功能，它可以将现有类映射到新的子类上。注意，使用这种技术来创建一个混型是多么的轻而易举。基本上，只需要声明“这就是我想要的”，紧跟着它就发生了：
51004: 4222:
51005: 4223:```c++
51006: 4224:TimeStamped<SerialNumbered<Basic>> mixin1，mixin2；
51007: 4225:```
51008: 4226:
51009: 4227:遗憾的是，Java 泛型不允许这样。擦除会忘记基类类型，因此
51010: 4228:
51011: 4229:>  泛型类不能直接继承自一个泛型参数
51012: 4230:
51013: 4231:这突显了许多我在 Java 语言设计决策（以及与这些功能一起发布）中遇到的一大问题：处理一件事很有希望，但是当您实际尝试做一些有趣的事情时，您会发现自己做不到。
51014: 4232:
51015: 4233:### 与接口混合
51016: 4234:
51017: 4235:一种更常见的推荐解决方案是使用接口来产生混型效果，就像下面这样：
51018: 4236:
51019: 4237:```java
51020: 4238:// generics/Mixins.java
51021: 4239:
51022: 4240:import java.util.*;
51023: 4241:
51024: 4242:interface TimeStamped { long getStamp(); }
51025: 4243:
51026: 4244:class TimeStampedImp implements TimeStamped {
51027: 4245:    private final long timeStamp;
51028: 4246:    TimeStampedImp() {
51029: 4247:        timeStamp = new Date().getTime();
51030: 4248:    }
51031: 4249:    @Override
51032: 4250:    public long getStamp() { return timeStamp; }
51033: 4251:}
51034: 4252:
51035: 4253:interface SerialNumbered { long getSerialNumber(); }
51036: 4254:
51037: 4255:class SerialNumberedImp implements SerialNumbered {
51038: 4256:    private static long counter = 1;
51039: 4257:    private final long serialNumber = counter++;
51040: 4258:    @Override
51041: 4259:    public long getSerialNumber() { return serialNumber; }
51042: 4260:}
51043: 4261:
51044: 4262:interface Basic {
51045: 4263:    void set(String val);
51046: 4264:    String get();
51047: 4265:}
51048: 4266:
51049: 4267:class BasicImp implements Basic {
51050: 4268:    private String value;
51051: 4269:    @Override
51052: 4270:    public void set(String val) { value = val; }
51053: 4271:    @Override
51054: 4272:    public String get() { return value; }
51055: 4273:}
51056: 4274:
51057: 4275:class Mixin extends BasicImp
51058: 4276:implements TimeStamped, SerialNumbered {
51059: 4277:    private TimeStamped timeStamp = new TimeStampedImp();
51060: 4278:    private SerialNumbered serialNumber =
51061: 4279:        new SerialNumberedImp();
51062: 4280:    @Override
51063: 4281:    public long getStamp() {
51064: 4282:        return timeStamp.getStamp();
51065: 4283:    }
51066: 4284:    @Override
51067: 4285:    public long getSerialNumber() {
51068: 4286:        return serialNumber.getSerialNumber();
51069: 4287:    }
51070: 4288:}
51071: 4289:
51072: 4290:public class Mixins {
51073: 4291:    public static void main(String[] args) {
51074: 4292:        Mixin mixin1 = new Mixin(), mixin2 = new Mixin();
51075: 4293:        mixin1.set("test string 1");
51076: 4294:        mixin2.set("test string 2");
51077: 4295:        System.out.println(mixin1.get() + " " +
51078: 4296:            mixin1.getStamp() +  " " + mixin1.getSerialNumber());
51079: 4297:        System.out.println(mixin2.get() + " " +
51080: 4298:            mixin2.getStamp() +  " " + mixin2.getSerialNumber());
51081: 4299:    }
51082: 4300:}
51083: 4301:/* Output:
51084: 4302:test string 1 1494331663026 1
51085: 4303:test string 2 1494331663027 2
51086: 4304:*/
51087: 4305:```
51088: 4306:
51089: 4307:**Mixin** 类基本上是在使用*委托*，因此每个混入类型都要求在 **Mixin** 中有一个相应的域，而你必须在 **Mixin** 中编写所有必需的方法，将方法调用转发给恰当的对象。这个示例使用了非常简单的类，但是当使用更复杂的混型时，代码数量会急速增加。[^4]
51090: 4308:
51091: 4309:### 使用装饰器模式
51092: 4310:
51093: 4311:当你观察混型的使用方式时，就会发现混型概念好像与*装饰器*设计模式关系很近。装饰器经常用于满足各种可能的组合，而直接子类化会产生过多的类，因此是不实际的。
51094: 4312:装饰器模式使用分层对象来动态透明地向单个对象中添加责任。装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。某些事物是可装饰的，可以通过将其他类包装在这个可装饰对象的四周，来将功能分层。这使得对装饰器的使用是透明的——无论对象是否被装饰，你都拥有一个可以向对象发送的公共消息集。装饰类也可以添加新方法，但是正如你所见，这将是受限的。
51095: 4313:装饰器是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。
51096: 4314:前面的示例可以被改写为使用装饰器：
51097: 4315:
51098: 4316:```java
51099: 4317:// generics/decorator/Decoration.java
51100: 4318:
51101: 4319:// {java generics.decorator.Decoration}
51102: 4320:package generics.decorator;
51103: 4321:import java.util.*;
51104: 4322:
51105: 4323:class Basic {
51106: 4324:    private String value;
51107: 4325:    public void set(String val) { value = val; }
51108: 4326:    public String get() { return value; }
51109: 4327:}
51110: 4328:
51111: 4329:class Decorator extends Basic {
51112: 4330:    protected Basic basic;
51113: 4331:    Decorator(Basic basic) { this.basic = basic; }
51114: 4332:    @Override
51115: 4333:    public void set(String val) { basic.set(val); }
51116: 4334:    @Override
51117: 4335:    public String get() { return basic.get(); }
51118: 4336:}
51119: 4337:
51120: 4338:class TimeStamped extends Decorator {
51121: 4339:    private final long timeStamp;
51122: 4340:    TimeStamped(Basic basic) {
51123: 4341:        super(basic);
51124: 4342:        timeStamp = new Date().getTime();
51125: 4343:    }
51126: 4344:    public long getStamp() { return timeStamp; }
51127: 4345:}
51128: 4346:
51129: 4347:class SerialNumbered extends Decorator {
51130: 4348:    private static long counter = 1;
51131: 4349:    private final long serialNumber = counter++;
51132: 4350:    SerialNumbered(Basic basic) { super(basic); }
51133: 4351:    public long getSerialNumber() { return serialNumber; }
51134: 4352:}
51135: 4353:
51136: 4354:public class Decoration {
51137: 4355:    public static void main(String[] args) {
51138: 4356:        TimeStamped t = new TimeStamped(new Basic());
51139: 4357:        TimeStamped t2 = new TimeStamped(
51140: 4358:            new SerialNumbered(new Basic()));
51141: 4359:        //- t2.getSerialNumber(); // Not available
51142: 4360:        SerialNumbered s = new SerialNumbered(new Basic());
51143: 4361:        SerialNumbered s2 = new SerialNumbered(
51144: 4362:            new TimeStamped(new Basic()));
51145: 4363:        //- s2.getStamp(); // Not available
51146: 4364:  }
51147: 4365:}
51148: 4366:```
51149: 4367:
51150: 4368:产生自泛型的类包含所有感兴趣的方法，但是由使用装饰器所产生的对象类型是最后被装饰的类型。也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。因此，装饰器只是对由混型提出的问题的一种局限的解决方案。
51151: 4369:
51152: 4370:### 与动态代理混合
51153: 4371:
51154: 4372:可以使用动态代理来创建一种比装饰器更贴近混型模型的机制（查看 [类型信息](book/19-Type-Information.md) 一章中关于 Java 的动态代理如何工作的解释）。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。
51155: 4373:由于动态代理的限制，每个被混入的类都必须是某个接口的实现：
51156: 4374:
51157: 4375:```java
51158: 4376:// generics/DynamicProxyMixin.java
51159: 4377:
51160: 4378:import java.lang.reflect.*;
51161: 4379:import java.util.*;
51162: 4380:import onjava.*;
51163: 4381:import static onjava.Tuple.*;
51164: 4382:
51165: 4383:class MixinProxy implements InvocationHandler {
51166: 4384:    Map<String, Object> delegatesByMethod;
51167: 4385:    @SuppressWarnings("unchecked")
51168: 4386:    MixinProxy(Tuple2<Object, Class<?>>... pairs) {
51169: 4387:        delegatesByMethod = new HashMap<>();
51170: 4388:        for(Tuple2<Object, Class<?>> pair : pairs) {
51171: 4389:            for(Method method : pair.a2.getMethods()) {
51172: 4390:                String methodName = method.getName();
51173: 4391:                // The first interface in the map
51174: 4392:                // implements the method.
51175: 4393:                if(!delegatesByMethod.containsKey(methodName))
51176: 4394:                    delegatesByMethod.put(methodName, pair.a1);
51177: 4395:            }
51178: 4396:        }
51179: 4397:    }
51180: 4398:    @Override
51181: 4399:    public Object invoke(Object proxy, Method method,
51182: 4400:      Object[] args) throws Throwable {
51183: 4401:        String methodName = method.getName();
51184: 4402:        Object delegate = delegatesByMethod.get(methodName);
51185: 4403:        return method.invoke(delegate, args);
51186: 4404:    }
51187: 4405:    
51188: 4406:    @SuppressWarnings("unchecked")
51189: 4407:    public static Object newInstance(Tuple2... pairs) {
51190: 4408:        Class[] interfaces = new Class[pairs.length];
51191: 4409:        for(int i = 0; i < pairs.length; i++) {
51192: 4410:            interfaces[i] = (Class)pairs[i].a2;
51193: 4411:        }
51194: 4412:        ClassLoader cl = pairs[0].a1.getClass().getClassLoader();
51195: 4413:        return Proxy.newProxyInstance(cl, interfaces, new MixinProxy(pairs));
51196: 4414:    }
51197: 4415:}
51198: 4416:
51199: 4417:public class DynamicProxyMixin {
51200: 4418:    public static void main(String[] args) {
51201: 4419:        Object mixin = MixinProxy.newInstance(
51202: 4420:          tuple(new BasicImp(), Basic.class),
51203: 4421:          tuple(new TimeStampedImp(), TimeStamped.class),
51204: 4422:          tuple(new SerialNumberedImp(), SerialNumbered.class));
51205: 4423:        Basic b = (Basic)mixin;
51206: 4424:        TimeStamped t = (TimeStamped)mixin;
51207: 4425:        SerialNumbered s = (SerialNumbered)mixin;
51208: 4426:        b.set("Hello");
51209: 4427:        System.out.println(b.get());
51210: 4428:        System.out.println(t.getStamp());
51211: 4429:        System.out.println(s.getSerialNumber());
51212: 4430:    }
51213: 4431:}
51214: 4432:/* Output:
51215: 4433:Hello
51216: 4434:1494331653339
51217: 4435:1
51218: 4436:*/
51219: 4437:```
51220: 4438:
51221: 4439:因为只有动态类型而不是静态类型才包含所有的混入类型，因此这仍旧不如 C++ 的方式好，因为可以在具有这些类型的对象上调用方法之前，你被强制要求必须先将这些对象向下转型到恰当的类型。但是，它明显地更接近于真正的混型。
51222: 4440:为了让 Java 支持混型，人们已经做了大量的工作朝着这个目标努力，包括创建了至少一种附加语言（ Jam 语言），它是专门用来支持混型的。
51223: 4441:
51224: 4442:<!-- Latent Typing -->
51225: 4443:
51226: 4444:## 潜在类型机制
51227: 4445:
51228: 4446:在本章的开头介绍过这样的思想，即要编写能够尽可能广泛地应用的代码。为了实现这一点，我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处。然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码。
51229: 4447:
51230: 4448:Java 泛型看起来是向这一方向迈进了一步。当你在编写或使用只是持有对象的泛型时，这些代码将可以工作于任何类型（除了基本类型，尽管正如你所见到的，自动装箱机制可以克服这一点）。或者，换个角度讲，“持有器”泛型能够声明：“我不关心你是什么类型”。如果代码不关心它将要作用的类型，那么这种代码就可以真正地应用于任何地方，并因此而相当泛化。
51231: 4449:
51232: 4450:还是正如你所见到的，当要在泛型类型上执行操作（即调用 **Object** 方法之外的方法）时，就会产生问题。擦除强制要求指定可能会用到的泛型类型的边界，以安全地调用代码中的泛型对象上的具体方法。这是对“泛化”概念的一种明显的限制，因为必须限制你的泛型类型，使它们继承自特定的类，或者实现特定的接口。在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类或接口没有任何区别。
51233: 4451:
51234: 4452:某些编程语言提供的一种解决方案称为*潜在类型机制*或*结构化类型机制*，而更古怪的术语称为*鸭子类型机制*，即“如果它走起来像鸭子，并且叫起来也像鸭子，那么你就可以将它当作鸭子对待。”鸭子类型机制变成了一种相当流行的术语，可能是因为它不像其他的术语那样承载着历史的包袱。
51235: 4453:
51236: 4454:泛型代码典型地只能在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得你可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以 `speak()` 和 `sit()` 即可。”由于不要求具体类型，因此代码就可以更加泛化。
51237: 4455:
51238: 4456:潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方。
51239: 4457:
51240: 4458:支持潜在类型机制的语言包括 Python（可以从 www.Python.org 免费下载）、C++、Ruby、SmallTalk 和 Go。Python 是动态类型语言（几乎所有的类型检查都发生在运行时），而 C++ 和 Go 是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查。
51241: 4459:
51242: 4460:### pyhton 中的潜在类型
51243: 4461:
51244: 4462:如果我们将上面的描述用 Python 来表示，如下所示：
51245: 4463:
51246: 4464:```python
51247: 4465:# generics/DogsAndRobots.py
51248: 4466:
51249: 4467:class Dog:
51250: 4468:    def speak(self):
51251: 4469:        print("Arf!")
51252: 4470:    def sit(self):
51253: 4471:        print("Sitting")
51254: 4472:    def reproduce(self):
51255: 4473:        pass
51256: 4474:
51257: 4475:class Robot:
51258: 4476:    def speak(self):
51259: 4477:        print("Click!")
51260: 4478:    def sit(self):
51261: 4479:        print("Clank!")
51262: 4480:    def oilChange(self):
51263: 4481:        pass
51264: 4482:
51265: 4483:def perform(anything):
51266: 4484:    anything.speak()
51267: 4485:    anything.sit()
51268: 4486:
51269: 4487:a = Dog()
51270: 4488:b = Robot()
51271: 4489:perform(a)
51272: 4490:perform(b)
51273: 4491:
51274: 4492:output = """
51275: 4493:Arf!
51276: 4494:Sitting
51277: 4495:Click!
51278: 4496:Clank!
51279: 4497:"""
51280: 4498:```
51281: 4499:
51282: 4500:Python 使用缩进来确定作用域（因此不需要任何花括号），而冒号将表示新的作用域的开始。“**#**” 表示注释到行尾，就像Java中的 “ **//** ”。类的方法需要显式地指定 **this** 引用的等价物作为第一个参数，按惯例成为 **self** 。构造器调用不要求任何类型的“ **new** ”关键字，并且 Python 允许普通（非成员）函数，就像 `perform()` 所表明的那样。注意，在 `perform(anything)` 中，没有任何针对 **anything** 的类型，**anything** 只是一个标识符，它必须能够执行 `perform()` 期望它执行的操作，因此这里隐含着一个接口。但是你从来都不必显式地写出这个接口——它是潜在的。`perform()` 不关心其参数的类型，因此我可以向它传递任何对象，只要该对象支持  `speak()` 和 `sit()` 方法。如果传递给 `perform()` 的对象不支持这些操作，那么将会得到运行时异常。
51283: 4501:
51284: 4502:输出规定使用三重引号创建带有内嵌换行符的字符串。
51285: 4503:
51286: 4504:### C++ 中的潜在类型
51287: 4505:
51288: 4506:我们可以用 C++ 产生相同的效果：
51289: 4507:
51290: 4508:```c++
51291: 4509:// generics/DogsAndRobots.cpp
51292: 4510:
51293: 4511:#include <iostream>
51294: 4512:using namespace std;
51295: 4513:
51296: 4514:class Dog {
51297: 4515:public:
51298: 4516:    void speak() { cout << "Arf!" << endl; }
51299: 4517:    void sit() { cout << "Sitting" << endl; }
51300: 4518:    void reproduce() {}
51301: 4519:};
51302: 4520:
51303: 4521:class Robot {
51304: 4522:public:
51305: 4523:    void speak() { cout << "Click!" << endl; }
51306: 4524:    void sit() { cout << "Clank!" << endl; }
51307: 4525:    void oilChange() {}
51308: 4526:};
51309: 4527:
51310: 4528:template<class T> void perform(T anything) {
51311: 4529:    anything.speak();
51312: 4530:    anything.sit();
51313: 4531:}
51314: 4532:
51315: 4533:int main() {
51316: 4534:    Dog d;
51317: 4535:    Robot r;
51318: 4536:    perform(d);
51319: 4537:    perform(r);
51320: 4538:}
51321: 4539:/* Output:
51322: 4540:Arf!
51323: 4541:Sitting
51324: 4542:Click!
51325: 4543:Clank!
51326: 4544:*/
51327: 4545:```
51328: 4546:
51329: 4547:在 Python 和 C++ 中，**Dog** 和 **Robot** 没有任何共同的东西，只是碰巧有两个方法具有相同的签名。从类型的观点看，它们是完全不同的类型。但是，`perform()` 不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。
51330: 4548:C++ 确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给你一个错误消息（这些错误消息从历史上看是相当可怕和冗长的，是 C++ 的模版名声欠佳的主要原因）。尽管它们是在不同时期实现这一点的，C++ 在编译期，而 Python 在运行时，但是这两种语言都可以确保类型不会被误用，因此被认为是强类型的。[^5]潜在类型机制没有损害强类型机制。
51331: 4549:
51332: 4550:### Go 中的潜在类型
51333: 4551:
51334: 4552:这里用 Go 语言编写相同的程序：
51335: 4553:
51336: 4554:```go
51337: 4555:// generics/dogsandrobots.go
51338: 4556:
51339: 4557:package main
51340: 4558:import "fmt"
51341: 4559:
51342: 4560:type Dog struct {}
51343: 4561:func (this Dog) speak() { fmt.Printf("Arf!\n")}
51344: 4562:func (this Dog) sit() { fmt.Printf("Sitting\n")}
51345: 4563:func (this Dog) reproduce() {}
51346: 4564:
51347: 4565:type Robot struct {}
51348: 4566:func (this Robot) speak() { fmt.Printf("Click!\n") }
51349: 4567:func (this Robot) sit() { fmt.Printf("Clank!\n") }
51350: 4568:func (this Robot) oilChange() {}
51351: 4569:
51352: 4570:func perform(speaker interface { speak(); sit() }) {
51353: 4571:  speaker.speak();
51354: 4572:  speaker.sit();
51355: 4573:}
51356: 4574:
51357: 4575:func main() {
51358: 4576:  perform(Dog{})
51359: 4577:  perform(Robot{})
51360: 4578:}
51361: 4579:/* Output:
51362: 4580:Arf!
51363: 4581:Sitting
51364: 4582:Click!
51365: 4583:Clank!
51366: 4584:*/
51367: 4585:```
51368: 4586:
51369: 4587:Go 没有 **class** 关键字，但是可以使用上述形式创建等效的基本类：它通常不定义为类，而是定义为 **struct** ，在其中定义数据字段（此处不存在）。 对于每种方法，都以 **func** 关键字开头，然后（为了将该方法附加到您的类上）放在括号中，该括号包含对象引用，该对象引用可以是任何标识符，但是我在这里使用 **this** 来提醒您，就像在 C ++ 或 Java 中的 **this** 一样。 然后，在Go中像这样定义其余的函数。
51370: 4588:
51371: 4589:Go也没有继承关系，因此这种“面向对象的目标”形式是相对原始的，并且可能是我无法花更多的时间来学习该语言的主要原因。 但是，Go 的组成很简单。
51372: 4590:
51373: 4591:`perform()` 函数使用潜在类型：参数的确切类型并不重要，只要它包含了 `speak()` 和  `sit()` 方法即可。 该接口在此处匿名定义，内联，如 `perform()` 的参数列表所示。
51374: 4592:
51375: 4593:`main()` 证明 `perform()` 确实对其参数的确切类型不在乎，只要可以在该参数上调用 `talk()` 和 `sit()` 即可。 但是，就像 C ++ 模板函数一样，在编译时检查类型。
51376: 4594:
51377: 4595:语法 **Dog {}** 和 **Robot {}** 创建匿名的 **Dog** 和 **Robot** 结构。
51378: 4596:
51379: 4597:### java中的直接潜在类型
51380: 4598:
51381: 4599:因为泛型是在这场竞赛的后期才添加到 Java 中，因此没有任何机会可以去实现任何类型的潜在类型机制，因此 Java 没有对这种特性的支持。所以，初看起来，Java 的泛型机制比支持潜在类型机制的语言更“缺乏泛化性”。（使用擦除来实现 Java 泛型的实现有时称为第二类泛型类型）例如，在 Java 8  之前如果我们试图用 Java 实现上面 dogs-and-robots 的示例，那么就会被强制要求使用一个类或接口，并在边界表达式中指定它：
51382: 4600:
51383: 4601:```java
51384: 4602:// generics/Performs.java
51385: 4603:
51386: 4604:public interface Performs {
51387: 4605:    void speak();
51388: 4606:    void sit();
51389: 4607:}
51390: 4608:```
51391: 4609:
51392: 4610:```java
51393: 4611:// generics/DogsAndRobots.java
51394: 4612:// No (direct) latent typing in Java
51395: 4613:import typeinfo.pets.*;
51396: 4614:
51397: 4615:class PerformingDog extends Dog implements Performs {
51398: 4616:    @Override
51399: 4617:    public void speak() { System.out.println("Woof!"); }
51400: 4618:    @Override
51401: 4619:    public void sit() { System.out.println("Sitting"); }
51402: 4620:    public void reproduce() {}
51403: 4621:}
51404: 4622:
51405: 4623:class Robot implements Performs {
51406: 4624:    public void speak() { System.out.println("Click!"); }
51407: 4625:    public void sit() { System.out.println("Clank!"); }
51408: 4626:    public void oilChange() {}
51409: 4627:}
51410: 4628:
51411: 4629:class Communicate {
51412: 4630:    public static <T extends Performs>
51413: 4631:      void perform(T performer) {
51414: 4632:        performer.speak();
51415: 4633:        performer.sit();
51416: 4634:    }
51417: 4635:}
51418: 4636:
51419: 4637:public class DogsAndRobots {
51420: 4638:    public static void main(String[] args) {
51421: 4639:        Communicate.perform(new PerformingDog());
51422: 4640:        Communicate.perform(new Robot());
51423: 4641:    }
51424: 4642:}
51425: 4643:/* Output:
51426: 4644:Woof!
51427: 4645:Sitting
51428: 4646:Click!
51429: 4647:Clank!
51430: 4648:*/
51431: 4649:```
51432: 4650:
51433: 4651:但是要注意，`perform()` 不需要使用泛型来工作，它可以被简单地指定为接受一个 **Performs** 对象：
51434: 4652:
51435: 4653:```java
51436: 4654:// generics/SimpleDogsAndRobots.java
51437: 4655:// Removing the generic; code still works
51438: 4656:
51439: 4657:class CommunicateSimply {
51440: 4658:    static void perform(Performs performer) {
51441: 4659:        performer.speak();
51442: 4660:        performer.sit();
51443: 4661:    }
51444: 4662:}
51445: 4663:
51446: 4664:public class SimpleDogsAndRobots {
51447: 4665:    public static void main(String[] args) {
51448: 4666:        CommunicateSimply.perform(new PerformingDog());
51449: 4667:        CommunicateSimply.perform(new Robot());
51450: 4668:    }
51451: 4669:}
51452: 4670:/* Output:
51453: 4671:Woof!
51454: 4672:Sitting
51455: 4673:Click!
51456: 4674:Clank!
51457: 4675:*/
51458: 4676:```
51459: 4677:
51460: 4678:在本例中，泛型不是必需的，因为这些类已经被强制要求实现 **Performs** 接口。
51461: 4679:
51462: 4680:<!-- Compensating for the Lack of (Direct) Latent -->
51463: 4681:
51464: 4682:## 对缺乏潜在类型机制的补偿
51465: 4683:
51466: 4684:尽管 Java 不直接支持潜在类型机制，但是这并不意味着泛型代码不能在不同的类型层次结构之间应用。也就是说，我们仍旧可以创建真正的泛型代码，但是这需要付出一些额外的努力。
51467: 4685:
51468: 4686:### 反射
51469: 4687:
51470: 4688:可以使用的一种方式是反射，下面的 `perform()` 方法就是用了潜在类型机制：
51471: 4689:
51472: 4690:```java
51473: 4691:// generics/LatentReflection.java
51474: 4692:// Using reflection for latent typing
51475: 4693:import java.lang.reflect.*;
51476: 4694:
51477: 4695:// Does not implement Performs:
51478: 4696:class Mime {
51479: 4697:    public void walkAgainstTheWind() {}
51480: 4698:    public void sit() {
51481: 4699:        System.out.println("Pretending to sit");
51482: 4700:    }
51483: 4701:    public void pushInvisibleWalls() {}
51484: 4702:    @Override
51485: 4703:    public String toString() { return "Mime"; }
51486: 4704:}
51487: 4705:
51488: 4706:// Does not implement Performs:
51489: 4707:class SmartDog {
51490: 4708:    public void speak() { System.out.println("Woof!"); }
51491: 4709:    public void sit() { System.out.println("Sitting"); }
51492: 4710:    public void reproduce() {}
51493: 4711:}
51494: 4712:
51495: 4713:class CommunicateReflectively {
51496: 4714:    public static void perform(Object speaker) {
51497: 4715:        Class<?> spkr = speaker.getClass();
51498: 4716:        try {
51499: 4717:            try {
51500: 4718:                Method speak = spkr.getMethod("speak");
51501: 4719:                speak.invoke(speaker);
51502: 4720:            } catch(NoSuchMethodException e) {
51503: 4721:                System.out.println(speaker + " cannot speak");
51504: 4722:            }
51505: 4723:            try {
51506: 4724:                Method sit = spkr.getMethod("sit");
51507: 4725:                sit.invoke(speaker);
51508: 4726:            } catch(NoSuchMethodException e) {
51509: 4727:                System.out.println(speaker + " cannot sit");
51510: 4728:            }
51511: 4729:        } catch(SecurityException |
51512: 4730:            IllegalAccessException |
51513: 4731:            IllegalArgumentException |
51514: 4732:            InvocationTargetException e) {
51515: 4733:            throw new RuntimeException(speaker.toString(), e);
51516: 4734:        }
51517: 4735:    }
51518: 4736:}
51519: 4737:
51520: 4738:public class LatentReflection {
51521: 4739:    public static void main(String[] args) {
51522: 4740:        CommunicateReflectively.perform(new SmartDog());
51523: 4741:        CommunicateReflectively.perform(new Robot());
51524: 4742:        CommunicateReflectively.perform(new Mime());
51525: 4743:    }
51526: 4744:}
51527: 4745:/* Output:
51528: 4746:Woof!
51529: 4747:Sitting
51530: 4748:Click!
51531: 4749:Clank!
51532: 4750:Mime cannot speak
51533: 4751:Pretending to sit
51534: 4752:*/
51535: 4753:```
51536: 4754:
51537: 4755:上例中，这些类完全是彼此分离的，没有任何公共基类（除了 **Object** ）或接口。通过反射, `CommunicateReflectively.perform()` 能够动态地确定所需要的方法是否可用并调用它们。它甚至能够处理 **Mime** 只具有一个必需的方法这一事实，并能够部分实现其目标。
51538: 4756:
51539: 4757:### 将一个方法应用于序列
51540: 4758:
51541: 4759:反射提供了一些有用的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。但是有可能实现编译期类型检查和潜在类型机制吗？
51542: 4760:
51543: 4761:让我们看一个说明这个问题的示例。假设想要创建一个 `apply()` 方法，它能够将任何方法应用于某个序列中的所有对象。这种情况下使用接口不适合，因为你想要将任何方法应用于一个对象集合，而接口不可能描述任何方法。如何用 Java 来实现这个需求呢？
51544: 4762:
51545: 4763:最初，我们可以用反射来解决这个问题，由于有了 Java 的可变参数，这种方式被证明是相当优雅的：
51546: 4764:
51547: 4765:```java
51548: 4766:// generics/Apply.java
51549: 4767:
51550: 4768:import java.lang.reflect.*;
51551: 4769:import java.util.*;
51552: 4770:
51553: 4771:public class Apply {
51554: 4772:    public static <T, S extends Iterable<T>>
51555: 4773:      void apply(S seq, Method f, Object... args) {
51556: 4774:        try {
51557: 4775:            for(T t: seq)
51558: 4776:                f.invoke(t, args);
51559: 4777:        } catch(IllegalAccessException |
51560: 4778:            IllegalArgumentException |
51561: 4779:            InvocationTargetException e) {
51562: 4780:            // Failures are programmer errors
51563: 4781:            throw new RuntimeException(e);
51564: 4782:        }
51565: 4783:    }
51566: 4784:}
51567: 4785:```
51568: 4786:
51569: 4787:在 **Apply.java** 中，异常被转换为 **RuntimeException** ，因为没有多少办法可以从这种异常中恢复——在这种情况下，它们实际上代表着程序员的错误。
51570: 4788:
51571: 4789:为什么我们不只使用 Java 8 方法参考（稍后显示）而不是反射方法 **f** ？ 注意，`invoke()` 和 `apply()` 的优点是它们可以接受任意数量的参数。 在某些情况下，灵活性可能至关重要。
51572: 4790:
51573: 4791:为了测试 **Apply** ，我们首先创建一个 **Shape** 类：
51574: 4792:
51575: 4793:```java
51576: 4794:// generics/Shape.java
51577: 4795:
51578: 4796:public class Shape {
51579: 4797:    private static long counter = 0;
51580: 4798:    private final long id = counter++;
51581: 4799:    @Override
51582: 4800:    public String toString() {
51583: 4801:        return getClass().getSimpleName() + " " + id;
51584: 4802:    }
51585: 4803:    public void rotate() {
51586: 4804:        System.out.println(this + " rotate");
51587: 4805:    }
51588: 4806:    public void resize(int newSize) {
51589: 4807:        System.out.println(this + " resize " + newSize);
51590: 4808:    }
51591: 4809:}
51592: 4810:```
51593: 4811:
51594: 4812:被一个子类 **Square** 继承：
51595: 4813:
51596: 4814:```java
51597: 4815:// generics/Square.java
51598: 4816:
51599: 4817:public class Square extends Shape {}
51600: 4818:```
51601: 4819:
51602: 4820:通过这些，我们可以测试 **Apply**：
51603: 4821:
51604: 4822:```java
51605: 4823:// generics/ApplyTest.java
51606: 4824:
51607: 4825:import java.util.*;
51608: 4826:import java.util.function.*;
51609: 4827:import onjava.*;
51610: 4828:
51611: 4829:public class ApplyTest {
51612: 4830:    public static
51613: 4831:    void main(String[] args) throws Exception {
51614: 4832:        List<Shape> shapes =
51615: 4833:          Suppliers.create(ArrayList::new, Shape::new, 3);
51616: 4834:        Apply.apply(shapes, Shape.class.getMethod("rotate"));
51617: 4835:        Apply.apply(shapes, Shape.class.getMethod("resize", int.class), 7);
51618: 4836:
51619: 4837:        List<Square> squares =
51620: 4838:          Suppliers.create(ArrayList::new, Square::new, 3);
51621: 4839:        Apply.apply(squares, Shape.class.getMethod("rotate"));
51622: 4840:        Apply.apply(squares, Shape.class.getMethod("resize", int.class), 7);
51623: 4841:
51624: 4842:        Apply.apply(new FilledList<>(Shape::new, 3),
51625: 4843:          Shape.class.getMethod("rotate"));
51626: 4844:        Apply.apply(new FilledList<>(Square::new, 3),
51627: 4845:          Shape.class.getMethod("rotate"));
51628: 4846:
51629: 4847:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
51630: 4848:          new SimpleQueue<>(), SimpleQueue::add,
51631: 4849:          Shape::new, 3);
51632: 4850:        Suppliers.fill(shapeQ, SimpleQueue::add,
51633: 4851:          Square::new, 3);
51634: 4852:        Apply.apply(shapeQ, Shape.class.getMethod("rotate"));
51635: 4853:    }
51636: 4854:}
51637: 4855:/* Output:
51638: 4856:Shape 0 rotate
51639: 4857:Shape 1 rotate
51640: 4858:Shape 2 rotate
51641: 4859:Shape 0 resize 7
51642: 4860:Shape 1 resize 7
51643: 4861:Shape 2 resize 7
51644: 4862:Square 3 rotate
51645: 4863:Square 4 rotate
51646: 4864:Square 5 rotate
51647: 4865:Square 3 resize 7
51648: 4866:Square 4 resize 7
51649: 4867:Square 5 resize 7
51650: 4868:Shape 6 rotate
51651: 4869:Shape 7 rotate
51652: 4870:Shape 8 rotate
51653: 4871:Square 9 rotate
51654: 4872:Square 10 rotate
51655: 4873:Square 11 rotate
51656: 4874:Shape 12 rotate
51657: 4875:Shape 13 rotate
51658: 4876:Shape 14 rotate
51659: 4877:Square 15 rotate
51660: 4878:Square 16 rotate
51661: 4879:Square 17 rotate
51662: 4880:*/
51663: 4881:```
51664: 4882:
51665: 4883:在 **Apply** 中，我们运气很好，因为碰巧在 Java 中内建了一个由 Java 集合类库使用的 **Iterable** 接口。正由于此， `apply()` 方法可以接受任何实现了 **Iterable** 接口的事物，包括诸如 **List** 这样的所有 **Collection** 类。但是它还可以接受其他任何事物，只要能够使这些事物是 **Iterable** 的——例如，在 `main()` 中使用下面定义的 **SimpleQueue** 类：
51666: 4884:
51667: 4885:```java
51668: 4886:// generics/SimpleQueue.java
51669: 4887:
51670: 4888:// A different kind of Iterable collection
51671: 4889:import java.util.*;
51672: 4890:
51673: 4891:public class SimpleQueue<T> implements Iterable<T> {
51674: 4892:    private LinkedList<T> storage = new LinkedList<>();
51675: 4893:    public void add(T t) { storage.offer(t); }
51676: 4894:    public T get() { return storage.poll(); }
51677: 4895:    @Override
51678: 4896:    public Iterator<T> iterator() {
51679: 4897:        return storage.iterator();
51680: 4898:    }
51681: 4899:}
51682: 4900:```
51683: 4901:
51684: 4902:正如反射解决方案看起来那样优雅，我们必须观察到反射（尽管在 Java 的最新版本中得到了显着改进）通常比非反射实现要慢，因为在运行时发生了很多事情。 但它不应阻止您尝试这种解决方案，这依然是值得考虑的一点。
51685: 4903:
51686: 4904:几乎可以肯定，你会首先使用 Java 8 的函数式方法，并且只有在解决了特殊需求时才诉诸反射。 这里对 **ApplyTest.java** 进行了重写，以利用 Java 8 的流和函数工具：
51687: 4905:
51688: 4906:```java
51689: 4907:// generics/ApplyFunctional.java
51690: 4908:
51691: 4909:import java.util.*;
51692: 4910:import java.util.stream.*;
51693: 4911:import java.util.function.*;
51694: 4912:import onjava.*;
51695: 4913:
51696: 4914:public class ApplyFunctional {
51697: 4915:    public static void main(String[] args) {
51698: 4916:        Stream.of(
51699: 4917:          Stream.generate(Shape::new).limit(2),
51700: 4918:          Stream.generate(Square::new).limit(2))
51701: 4919:        .flatMap(c -> c) // flatten into one stream
51702: 4920:        .peek(Shape::rotate)
51703: 4921:        .forEach(s -> s.resize(7));
51704: 4922:
51705: 4923:        new FilledList<>(Shape::new, 2)
51706: 4924:          .forEach(Shape::rotate);
51707: 4925:        new FilledList<>(Square::new, 2)
51708: 4926:          .forEach(Shape::rotate);
51709: 4927:
51710: 4928:        SimpleQueue<Shape> shapeQ = Suppliers.fill(
51711: 4929:          new SimpleQueue<>(), SimpleQueue::add,
51712: 4930:          Shape::new, 2);
51713: 4931:        Suppliers.fill(shapeQ, SimpleQueue::add,
51714: 4932:          Square::new, 2);
51715: 4933:        shapeQ.forEach(Shape::rotate);
51716: 4934:    }
51717: 4935:}
51718: 4936:/* Output:
51719: 4937:Shape 0 rotate
51720: 4938:Shape 0 resize 7
51721: 4939:Shape 1 rotate
51722: 4940:Shape 1 resize 7
51723: 4941:Square 2 rotate
51724: 4942:Square 2 resize 7
51725: 4943:Square 3 rotate
51726: 4944:Square 3 resize 7
51727: 4945:Shape 4 rotate
51728: 4946:Shape 5 rotate
51729: 4947:Square 6 rotate
51730: 4948:Square 7 rotate
51731: 4949:Shape 8 rotate
51732: 4950:Shape 9 rotate
51733: 4951:Square 10 rotate
51734: 4952:Square 11 rotate
51735: 4953:*/
51736: 4954:```
51737: 4955:
51738: 4956:由于使用 Java 8，因此不需要 `Apply.apply()` 。
51739: 4957:
51740: 4958:我们首先生成两个 **Stream** ： 一个是 **Shape** ，一个是 **Square** ，并将它们展平为单个流。 尽管 Java 缺少功能语言中经常出现的 `flatten()` ，但是我们可以使用 `flatMap(c-> c)` 产生相同的结果，后者使用身份映射将操作简化为“  **flatten** ”。
51741: 4959:
51742: 4960:我们使用 `peek()` 当做对 `rotate()` 的调用，因为 `peek()` 执行一个操作（此处是出于副作用），并在未更改的情况下传递对象。
51743: 4961:
51744: 4962:注意，使用 **FilledList** 和 **shapeQ** 调用 `forEach()` 比 `Apply.apply()` 代码整洁得多。 在代码简单性和可读性方面，结果比以前的方法好得多。 并且，现在也不可能从  `main()` 引发异常。
51745: 4963:
51746: 4964:<!-- Assisted Latent Typing in Java 8 -->
51747: 4965:
51748: 4966:## Java8 中的辅助潜在类型
51749: 4967:
51750: 4968:先前声明关于 Java 缺乏对潜在类型的支持在 Java 8 之前是完全正确的。但是，Java 8 中的非绑定方法引用使我们能够产生一种潜在类型的形式，以满足创建一段可工作在不相干类型上的代码。因为 Java 最初并不是如此设计，所以结果可想而知，比其他语言中要尴尬一些。但是，至少现在成为了可能，只是缺乏令人惊艳之处。
51751: 4969:
51752: 4970:我在其他地方从没遇过这种技术，因此我将其称为辅助潜在类型。
51753: 4971:
51754: 4972:我们将重写 **DogsAndRobots.java** 来演示该技术。 为使外观看起来与原始示例尽可能相似，我仅向每个原始类名添加了 **A**：
51755: 4973:
51756: 4974:```java
51757: 4975:// generics/DogsAndRobotMethodReferences.java
51758: 4976:
51759: 4977:// "Assisted Latent Typing"
51760: 4978:import typeinfo.pets.*;
51761: 4979:import java.util.function.*;
51762: 4980:
51763: 4981:class PerformingDogA extends Dog {
51764: 4982:    public void speak() { System.out.println("Woof!"); }
51765: 4983:    public void sit() { System.out.println("Sitting"); }
51766: 4984:    public void reproduce() {}
51767: 4985:}
51768: 4986:
51769: 4987:class RobotA {
51770: 4988:    public void speak() { System.out.println("Click!"); }
51771: 4989:    public void sit() { System.out.println("Clank!"); }
51772: 4990:    public void oilChange() {}
51773: 4991:}
51774: 4992:
51775: 4993:class CommunicateA {
51776: 4994:    public static <P> void perform(P performer,
51777: 4995:      Consumer<P> action1, Consumer<P> action2) {
51778: 4996:        action1.accept(performer);
51779: 4997:        action2.accept(performer);
51780: 4998:    }
51781: 4999:}
51782: 5000:
51783: 5001:public class DogsAndRobotMethodReferences {
51784: 5002:    public static void main(String[] args) {
51785: 5003:        CommunicateA.perform(new PerformingDogA(),
51786: 5004:          PerformingDogA::speak, PerformingDogA::sit);
51787: 5005:        CommunicateA.perform(new RobotA(),
51788: 5006:          RobotA::speak, RobotA::sit);
51789: 5007:        CommunicateA.perform(new Mime(),
51790: 5008:          Mime::walkAgainstTheWind,
51791: 5009:          Mime::pushInvisibleWalls);
51792: 5010:    }
51793: 5011:}
51794: 5012:/* Output:
51795: 5013:Woof!
51796: 5014:Sitting
51797: 5015:Click!
51798: 5016:Clank!
51799: 5017:*/
51800: 5018:```
51801: 5019:
51802: 5020:**PerformingDogA** 和 **RobotA** 与 **DogsAndRobots.java** 中的相同，不同之处在于它们不继承通用接口 **Performs** ，因此它们没有通用性。
51803: 5021:
51804: 5022:`CommunicateA.perform()` 在没有约束的 **P** 上生成。 只要可以使用 `Consumer <P>`，它在这里就可以是任何东西，这些 `Consumer<P>` 代表不带参数的 **P** 方法的未绑定方法引用。当您调用 **Consumer**  的 `accept()` 方法时，它将方法引用绑定到执行者对象并调用该方法。 由于 [函数式编程](book/13-Functional-Programming.md) 一章中描述的“魔术”，我们可以将任何符合签名的未绑定方法引用传递给 `CommunicateA.perform()` 。
51805: 5023:
51806: 5024:之所以称其为“辅助”，是因为您必须显式地为 `perform()` 提供要使用的方法引用。 它不能只按名称调用方法。
51807: 5025:
51808: 5026:尽管传递未绑定的方法引用似乎要花很多力气，但潜在类型的最终目标还是可以实现的。 我们创建了一个代码片段 `CommunicateA.perform()` ，该代码可用于任何具有符合签名的方法引用的类型。 请注意，这与我们看到的其他语言中的潜在类型有所不同，因为这些语言不仅需要签名以符合规范，还需要方法名称。 因此，该技术可以说产生了更多的通用代码。
51809: 5027:
51810: 5028:为了证明这一点，我还从 **LatentReflection.java** 中引入了 **Mime**。
51811: 5029:
51812: 5030:### 使用**Suppliers**类的通用方法
51813: 5031:
51814: 5032:通过辅助潜在类型，我们可以定义本章其他部分中使用的 **Suppliers** 类。 此类包含使用生成器填充 **Collection** 的工具方法。 泛化这些操作很有意义：
51815: 5033:
51816: 5034:```java
51817: 5035:// onjava/Suppliers.java
51818: 5036:
51819: 5037:// A utility to use with Suppliers
51820: 5038:package onjava;
51821: 5039:import java.util.*;
51822: 5040:import java.util.function.*;
51823: 5041:import java.util.stream.*;
51824: 5042:
51825: 5043:public class Suppliers {
51826: 5044:    // Create a collection and fill it:
51827: 5045:    public static <T, C extends Collection<T>> C
51828: 5046:      create(Supplier<C> factory, Supplier<T> gen, int n) {
51829: 5047:        return Stream.generate(gen)
51830: 5048:            .limit(n)
51831: 5049:            .collect(factory, C::add, C::addAll);
51832: 5050:    }
51833: 5051:    
51834: 5052:    // Fill an existing collection:
51835: 5053:    public static <T, C extends Collection<T>>
51836: 5054:      C fill(C coll, Supplier<T> gen, int n) {
51837: 5055:        Stream.generate(gen)
51838: 5056:            .limit(n)
51839: 5057:            .forEach(coll::add);
51840: 5058:        return coll;
51841: 5059:    }
51842: 5060:    
51843: 5061:    // Use an unbound method reference to
51844: 5062:    // produce a more general method:
51845: 5063:    public static <H, A> H fill(H holder,
51846: 5064:      BiConsumer<H, A> adder, Supplier<A> gen, int n) {
51847: 5065:        Stream.generate(gen)
51848: 5066:            .limit(n)
51849: 5067:            .forEach(a -> adder.accept(holder, a));
51850: 5068:        return holder;
51851: 5069:    }
51852: 5070:}
51853: 5071:```
51854: 5072:
51855: 5073:`create()` 为你创建一个新的 **Collection** 子类型，而 `fill()` 的第一个版本将元素放入 **Collection** 的现有子类型中。 请注意，还会返回传入的容器的确切类型，因此不会丢失类型信息。[^6]
51856: 5074:
51857: 5075:前两种方法一般都受约束，只能与 **Collection** 子类型一起使用。`fill()` 的第二个版本适用于任何类型的 **holder** 。 它需要一个附加参数：未绑定方法引用 `adder. fill()` ，使用辅助潜在类型来使其与任何具有添加元素方法的 **holder** 类型一起使用。因为此未绑定方法 **adder** 必须带有一个参数（要添加到 **holder** 的元素），所以 **adder** 必须是 `BiConsumer <H，A>` ，其中 **H** 是要绑定到的 **holder** 对象的类型，而 **A** 是要被添加的绑定元素类型。 对 `accept()` 的调用将使用参数 a 调用对象 **holder** 上的未绑定方法 **holder**。
51858: 5076:
51859: 5077:在一个稍作模拟的测试中对 **Suppliers** 工具程序进行了测试，该仿真还使用了本章前面定义的 **RandomList** ：
51860: 5078:
51861: 5079:```java
51862: 5080:// generics/BankTeller.java
51863: 5081:
51864: 5082:// A very simple bank teller simulation
51865: 5083:import java.util.*;
51866: 5084:import onjava.*;
51867: 5085:
51868: 5086:class Customer {
51869: 5087:    private static long counter = 1;
51870: 5088:    private final long id = counter++;
51871: 5089:    @Override
51872: 5090:    public String toString() {
51873: 5091:        return "Customer " + id;
51874: 5092:    }
51875: 5093:}
51876: 5094:
51877: 5095:class Teller {
51878: 5096:    private static long counter = 1;
51879: 5097:    private final long id = counter++;
51880: 5098:    @Override
51881: 5099:    public String toString() {
51882: 5100:        return "Teller " + id;
51883: 5101:    }
51884: 5102:}
51885: 5103:
51886: 5104:class Bank {
51887: 5105:    private List<BankTeller> tellers =
51888: 5106:        new ArrayList<>();
51889: 5107:    public void put(BankTeller bt) {
51890: 5108:        tellers.add(bt);
51891: 5109:    }
51892: 5110:}
51893: 5111:
51894: 5112:public class BankTeller {
51895: 5113:    public static void serve(Teller t, Customer c) {
51896: 5114:        System.out.println(t + " serves " + c);
51897: 5115:    }
51898: 5116:    public static void main(String[] args) {
51899: 5117:        // Demonstrate create():
51900: 5118:        RandomList<Teller> tellers =
51901: 5119:            Suppliers.create(
51902: 5120:            RandomList::new, Teller::new, 4);
51903: 5121:        // Demonstrate fill():
51904: 5122:        List<Customer> customers = Suppliers.fill(
51905: 5123:            new ArrayList<>(), Customer::new, 12);
51906: 5124:        customers.forEach(c ->
51907: 5125:            serve(tellers.select(), c));
51908: 5126:        // Demonstrate assisted latent typing:
51909: 5127:        Bank bank = Suppliers.fill(
51910: 5128:            new Bank(), Bank::put, BankTeller::new, 3);
51911: 5129:        // Can also use second version of fill():
51912: 5130:        List<Customer> customers2 = Suppliers.fill(
51913: 5131:            new ArrayList<>(),
51914: 5132:            List::add, Customer::new, 12);
51915: 5133:    }
51916: 5134:}
51917: 5135:/* Output:
51918: 5136:Teller 3 serves Customer 1
51919: 5137:Teller 2 serves Customer 2
51920: 5138:Teller 3 serves Customer 3
51921: 5139:Teller 1 serves Customer 4
51922: 5140:Teller 1 serves Customer 5
51923: 5141:Teller 3 serves Customer 6
51924: 5142:Teller 1 serves Customer 7
51925: 5143:Teller 2 serves Customer 8
51926: 5144:Teller 3 serves Customer 9
51927: 5145:Teller 3 serves Customer 10
51928: 5146:Teller 2 serves Customer 11
51929: 5147:Teller 4 serves Customer 12
51930: 5148:*/
51931: 5149:```
51932: 5150:
51933: 5151:可以看到 `create()` 生成一个新的 **Collection** 对象，而 `fill()` 添加到现有 **Collection** 中。第二个版本`fill()` 显示，它不仅与无关的新类型 **Bank** 一起使用，还能与 **List** 一起使用。因此，从技术上讲，`fill()` 的第一个版本在技术上不是必需的，但在使用 **Collection** 时提供了较短的语法。
51934: 5152:
51935: 5153:<!-- Summary: Is Casting Really So Bad? -->
51936: 5154:
51937: 5155:## 总结：类型转换真的如此之糟吗？
51938: 5156:
51939: 5157:自从 C++ 模版出现以来，我就一直在致力于解释它，我可能比大多数人都更早地提出了下面的论点。直到最近，我才停下来，去思考这个论点到底在多少时间内是有效的——我将要描述的问题到底有多少次可以穿越障碍得以解决。
51940: 5158:
51941: 5159:这个论点就是：使用泛型类型机制的最吸引人的地方，就是在使用集合类的地方，这些类包括诸如各种 **List** 、各种 **Set** 、各种 **Map** 等你在 [集合](book/12-Collections.md) 和 [附录：集合主题](book/Appendix-Collection-Topics.md) 这两章所见。在 Java 5 之前，当你将一个对象放置到集合中时，这个对象就会被向上转型为 **Object** ，因此你会丢失类型信息。当你想要将这个对象从集合中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。我用的示例是持有 **Cat** 的 **List** （这个示例的一种使用苹果和桔子的变体在 [集合](book/12-Collections.md) 章节的开头展示过）。如果没有 Java 5 泛型版本的集合，你放到容集里和从集合中取回的都是 **Object** 。因此，我们很可能会将一个 **Dog** 放置到 **Cat** 的 **List** 中。
51942: 5160:
51943: 5161:但是，泛型出现之前的 Java 并不会让你误用放入到集合中的对象。如果将一个 **Dog** 扔到 **Cat** 的集合中，并且试图将这个集合中的所有东西都当作 **Cat** 处理，那么当你从这个 **Cat** 集合中取回那个 **Dog** 引用，并试图将其转型为 **Cat** 时，就会得到一个 **RuntimeException** 。你仍旧可以发现问题，但是是在运行时而非编译期发现它的。
51944: 5162:
51945: 5163:在本书以前的版本中，我曾经说过：
51946: 5164:
51947: 5165:> 这不止令人恼火，它还可能会产生难以发现的缺陷。如果这个程序的某个部分（或数个部分）向集合中插入了对象，并且通过异常，你在程序的另一个独立的部分中发现有不良对象被放置到了集合中，那么必须发现这个不良插入到底是在何处发生的。
51948: 5166:
51949: 5167:但是，随着对这个论点的进一步检查，我开始怀疑它了。首先，这会多么频繁地发生呢？我记得这类事情从未发生在我身上，并且当我在会议上询问其他人时，我也从来没有听说过有人碰上过。另一本书使用了一个称为 **files** 的 list 示例，它包含 **String** 对象。在这个示例中，向 **files** 中添加一个 **File** 对象看起来相当自然，因此这个对象的名字可能叫 **fileNames** 更好。无论 Java 提供了多少类型检查，仍旧可能会写出晦涩的程序，而编写差劲儿的程序即便可以编译，它仍旧是编写差劲儿的程序。可能大多数人都会使用命名良好的集合，例如 **cats** ，因为它们可以向试图添加非 **Cat** 对象的程序员提供可视的警告。并且即便这类事情发生了，它真正又能潜伏多久呢？只要你开始用真实数据来运行测试，就会非常快地看到异常。
51950: 5168:
51951: 5169:有一位作者甚至断言，这样的缺陷将“*潜伏数年*”。但是我不记得有任何大量的相关报告，来说明人们在查找“狗在猫列表中”这类缺陷时困难重重，或者是说明人们会非常频繁地产生这种错误。然而，你将在 [多线程编程](book/24-Concurrent-Programming.md) 章节中看到，在使用线程时，出现那些可能看起来极罕见的缺陷，是很寻常并容易发生的事，而且，对于到底出了什么错，这些缺陷只能给你一个很模糊的概念。因此，对于泛型是添加到 Java 中的非常显著和相当复杂的特性这一点，“狗在猫列表中”这个论据真的能够成为它的理由吗？
51952: 5170:我相信被称为*泛型*的通用语言特性（并非必须是其在 Java 中的特定实现）的目的在于可表达性，而不仅仅是为了创建类型安全的集合。类型安全的集合是能够创建更通用代码这一能力所带来的副作用。
51953: 5171:因此，即便“狗在猫列表中”这个论据经常被用来证明泛型是必要的，但是它仍旧是有问题的。就像我在本章开头声称的，我不相信这就是泛型这个概念真正的含义。相反，泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。正如你在本章中看到的，编写真正泛化的“持有器”类（ Java 的容器就是这种类）相当简单，但是编写出能够操作其泛型类型的泛化代码就需要额外的努力了，这些努力需要类创建者和类消费者共同付出，他们必须理解这些代码的概念和实现。这些额外的努力会增加使用这种特性的难度，并可能会因此而使其在某些场合缺乏可应用性，而在这些场合中，它可能会带来附加的价值。
51954: 5172:
51955: 5173:还要注意到，因为泛型是后来添加到 Java 中，而不是从一开始就设计到这种语言中的，所以某些容器无法达到它们应该具备的健壮性。例如，观察一下 **Map** ，在特定的方法 `containsKey(Object key) `和 `get(Object key)` 中就包含这类情况。如果这些类是使用在它们之前就存在的泛型设计的，那么这些方法将会使用参数化类型而不是 **Object** ，因此也就可以提供这些泛型假设会提供的编译期检查。例如，在 C++ 的 **map** 中，键的类型总是在编译期检查的。
51956: 5174:
51957: 5175:有一件事很明显：在一种语言已经被广泛应用之后，在其较新的版本中引入任何种类的泛型机制，都会是一项非常非常棘手的任务，并且是一项不付出艰辛就无法完成的任务。在 C++ 中，模版是在其最初的 ISO 版本中就引入的（即便如此，也引发了阵痛，因为在第一个标准 C++ 出现之前，有很多非模版版本在使用），因此实际上模版一直都是这种语言的一部分。在 Java 中，泛型是在这种语言首次发布大约 10 年之后才引入的，因此向泛型迁移的问题特别多，并且对泛型的设计产生了明显的影响。其结果就是，程序员将承受这些痛苦，而这一切都是由于 Java 设计者在设计 1.0 版本时所表现出来的短视造成的。当 Java 最初被创建时，它的设计者们当然了解 C++ 的模版，他们甚至考虑将其囊括到 Java 语言中，但是出于这样或那样的原因，他们决定将模版排除在外（其迹象就是他们过于匆忙）。因此， Java 语言和使用它的程序员都将承受这些痛苦。只有时间将会说明 Java 的泛型方式对这种语言所造成的最终影响。
51958: 5176:某些语言，已经融入了更简洁、影响更小的方式，来实现参数化类型。我们不可能不去想象这样的语言将会成为 Java 的继任者，因为它们采用的方式，与 C++ 通过 C 来实现的方式相同：按原样使用它，然后对其进行改进。
51959: 5177:
51960: 5178:## 进阶阅读
51961: 5179:
51962: 5180:泛型的入门文档是 《Generics in the Java Programming Language》，作者是 Gilad Bracha，可以从 http://java.oracle.com 获取。
51963: 5181:
51964: 5182:Angelika Langer 的《Java Generics FAQs》是一份非常有帮助的资料，可以从 http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html 获取。
51965: 5183:
51966: 5184:你可以从 《Adding Wildcards to the Java Programming Language》中学到更多关于通配符的知识，作者是 Torgerson、Ernst、Hansen、von der Ahe、Bracha 和 Gafter，地址是 http://www.jot.fm/issues/issue_2004_12/article5。
51967: 5185:
51968: 5186:Neal After 对于 Java 问题（尤其是擦除）的看法可以从这里找到：http://www.infoq.com/articles/neal-gafter-on-java。
51969: 5187:
51970: 5188:[^1]: 在编写本章期间，Angelika Langer的 Java 泛型常见问题解答以及她的其他著作（与Klaus Kreft一起）是非常宝贵的。
51971: 5189:[^2]: [http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html](http://gafter.blogspot.com/2004/09/puzzling-through-erasureanswer.html)
51972: 5190:[^3]: 参见本章章末引文。
51973: 5191:[^4]: 注意，一些编程环境，如 Eclipse 和 IntelliJ IDEA，将会自动生成委托代码。
51974: 5192:[^5]: 因为可以使用转型，有效地禁止了类型系统，一些人就认为 C++ 是弱类型，但这太极端了。一种可能更好的说法是 C++ 是有一道暗门的强类型语言。
51975: 5193:[^6]: 我再次从 Brian Goetz 那获得帮助。
51976: 5194:
51977: 5195:<!-- 分页 -->
51978: 5196:
51979: 5197:<div style="page-break-after: always;"></div>
51980: 
Wed Feb 17 00:26:40 CST 2021
